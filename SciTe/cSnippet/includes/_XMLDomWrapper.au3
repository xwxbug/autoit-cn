#include-once
#include <Array.au3>
;#include <_debug.au3> Added func to end of this udf.
; ------------------------------------------------------------------------------
;
; AutoIt Version: 	3.0
; Language: 		English
; Description: 		Functions that assist with using xml files
;					Stephen Podhajecki <gehossafats@netmdc.com>
; Dec 15, 2005, Update Jan10,2006, Update Feb 5,8,14-15, 2006
; ------------------------------------------------------------------------------


;===============================================================================
; XML DOM Wrapper functions
;
; These funtions require BETA as they need support for COM
;
;===============================================================================
#cs defs to add to au3.api
	_XMLCreateCDATA($sNode, $sCDATA) Create a CDATA SECTION node directly under root. (Requires: #include <_XMLDomWrapper.au3>)
	_XMLCreateChildNode($XPath, $sNode, [$sData = ""],[$sNamespace=""]) Create a child node under the specified XPath Node.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLCreateChildNodeWAttr($sXPath, $sNode, $avAttr, $avVal,[$sData =""],[$sNamespace=""]) Create a child node under the specified XPath Node with Attributes. (Requires: #include <_XMLDomWrapper.au3>)
	_XMLCreateComment($sNode, $sComment)Create a COMMENT node at specified path.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLCreateFile($sPath, $sRootNode, [$bOverwrite = False]) Creates an XML file with the given name and root.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLCreateRootChild($sNode,[$sData = ""],[$sNamespace=""]) Create node directly under root.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLCreateRootNodeWAttr($sNode, $avAttr, $avVal,[$sData=""],[$sNamespace=""]) Create a child node under root node with attributes.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLDeleteAttr($sXPath, $sAttrib) Delete attribute for specified XPath(Requires: #include <_XMLDomWrapper.au3>)
	_XMLDeleteAttrNode($sXPath, $sAttrib) Delete attribute node for specified XPath(Requires: #include <_XMLDomWrapper.au3>)
	_XMLDeleteNode($sXPath) Delete specified XPath node.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLError($sError = "") Sets or Gets XML error message generated by XML functions.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLFileOpen($sXMLFile)Creates an instance of an XML file.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLGetAllAttrib($sXPath,byRef $aNames,byRef $aValues,[$sQuery = ""]) Get all XML Field(s) attributes based on XPath input from root node.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLGetAttrib($sXPath, $sAttrib, $sQuery = "") Get XML attribute based on XPath input from root node.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLGetAllAttribIndex($path,$aNames,$aValues,[$sQuery="",$iNode=0]])Get all XML Field(s) attributes based on Xpathn and specific index.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLGetField($sPath) Get XML Field(s) based on XPath input from root node.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLGetNodeCount($sPath,[sQuery="",$iType=$NODE_ELEMENT]]) Get node count for specified path and type. (Requires: #include <_XMLDomWrapper.au3>)
	_XMLSetAttrib($sPath, $sAttrib, $sValue = "") Set XML Field(s) attributes based on XPath input from root node.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLUpdateField_XMLUpdateField($sXPath, $sData) Update existing node(s) based on XPath specs.(Requires: #include <_XMLDomWrapper.au3>)
	_XMLSelectNodes($sXPath) Selects XML Node(s) based on XPath input from root node. (Requires: #include <_XMLDomWrapper.au3>)
	_XMLUDFVersion() Returns the UDF Version number. (Requires: #include <_XMLDomWrapper.au3>)
#ce
;===============================================================================
;Global variables
Global Const $_XMLUDFVER = "1.0.3.19"; udf version
Global Const $NODE_ELEMENT = 1;
Global Const $NODE_ATTRIBUTE = 2;
Global Const $NODE_TEXT = 3;
Global Const $NODE_CDATA_SECTION = 4;
Global Const $NODE_ENTITY_REFERENCE = 5;
Global Const $NODE_ENTITY = 6;
Global Const $NODE_PROCESSING_INSTRUCTION = 7;
Global Const $NODE_COMMENT = 8;
Global Const $NODE_DOCUMENT = 9;
Global Const $NODE_DOCUMENT_TYPE = 10;
Global Const $NODE_DOCUMENT_FRAGMENT = 11;
Global Const $NODE_NOTATION = 12;


Global $strFile;the current xml file name
Global $objDoc;then current XML object
;Global $objSel;Selection object
;Global $objXMLex    ;Exception handler object
;Global $COMErr_Silent = False ; Flag to display error msg or to allow calling function to handle it
Global $oMyError ;COM error handler OBJ ; Initialize SvenP 's  error handler
Global $sXML_error;Error message variable for XML errors
Global $debugging;flag for debug messages
;===============================================================================

;UDF functions

;===============================================================================
; Function Name:	 _XMLFileOpen
; Description:		Creates an instance of an XML file.
; Parameters:		$filename
; Syntax:			 _XMLFileOpen($strFile)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			1 on success -1 on failure set error 2 = no obj or
;													error= parse error
;===============================================================================
Func _XMLFileOpen($strXMLFile, $strNameSpc = "")
	;==== pick your poison
;~ 	$objDoc = ObjCreate("Microsoft.XMLDOM")
	$objDoc = ObjCreate("Msxml2.DOMDocument.3.0")
;~ 	$objDoc = ObjCreate("Msxml2.DOMDocument.4.0")
	If Not IsObj($objDoc) Then
		_XMLError( "Error: MSXML not found. This object is required to use this program.")
		;		msgBox(0,"Error","MSXML not found. This object is required to use this program.")
		SetError(2)
		Return -1
	EndIf
	
	$oMyError = ObjEvent("AutoIt.Error", "_COMerr") ; ; Initialize SvenP 's  error handler
	$objDoc.async = False
	$strFile = $strXMLFile
	$objDoc.Load ($strFile)
	$objDoc.setProperty ("SelectionNamespaces", $strNameSpc); "xmlns:ms='urn:schemas-microsoft-com:xslt'"
	$objDoc.setProperty ("SelectionLanguage", "XPath")
	If $objDoc.parseError.errorCode <> 0 Then
		_XMLError( "Error opening specified file: " & $strXMLFile & @CRLF & $objDoc.parseError.reason)
		SetError($objDoc.parseError.errorCode)
		Return -1
	EndIf
	Return 1
EndFunc   ;==>_XMLFileOpen

;===============================================================================
; Function Name:	_XMLCreateFile
; Description:		Create a new blank metafile with header.
; Parameters:		$filename	The xml filename with full path to create
;					$root		The root of the xml file to create
;					[overwrite] boolean flag to auto overwrite existing
;								xml file of same name. Defaults to false and
;								will prompt to overwrite.
;								Overwrite copies the file with the ext .old
;								Then deletes the original file.
; Syntax:			_XMLCreateFile($filename,$root,[flag])  flag is boolean
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			-1 on failure
;===============================================================================
Func _XMLCreateFile($strPath, $strRoot, $bOverwrite = False)
	Local $retval, $fe, $objPI, $objDoc, $rootElement
	$fe = FileExists($strPath)
	If $fe And Not $bOverwrite Then
		$retval = (MsgBox(4097, "File Exists:", "The specified file exits." & @CRLF & "Click OK to overwrite file or cancel to exit."))
		If $retval = 1 Then
			FileCopy($strPath, $strPath & @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN & "-" & @SEC & ".bak", 1)
			FileDelete($strPath)
			$fe = False
		Else
			_XMLError( "Error failed to create file: " & $strPath & @CRLF & "File exists.")
			SetError(1)
			Return -1
		EndIf
	Else
		FileCopy($strPath, $strPath & ".old", 1)
		FileDelete($strPath)
		$fe = False
	EndIf
	
	If $fe = False Then
		;==== pick your poison
		;	$objDoc = ObjCreate("Microsoft.XMLDOM")
		$objDoc = ObjCreate("Msxml2.DOMDocument.3.0")
		;	$objDoc = ObjCreate("Msxml2.DOMDocument.4.0")
		$objPI = $objDoc.createProcessingInstruction ("xml", "version=""1.0""")
		$objDoc.appendChild ($objPI)
		$rootElement = $objDoc.createElement ($strRoot)
		$objDoc.documentElement = $rootElement
		$objDoc.save ($strPath)
		If $objDoc.parseError.errorCode <> 0 Then
			;			_XMLError( "Error Creating specified file: " & $strPath & @CRLF & $oMyError.windescription)
			_XMLError( "Error Creating specified file: " & $strPath)
			SetError($objDoc.parseError.errorCode)
			Return -1
		EndIf
		Return
	Else
		_XMLError( "Error! Failed to create file: " & $strPath)
		SetError(1)
		Return -1
	EndIf
EndFunc   ;==>_XMLCreateFile
;===============================================================================
; Function Name:	_XMLSelectNodes
; Description:		Selects XML Node(s) based on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
; Syntax:			_XMLDeleteNode($path)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of Nodes or -1 on failure
;===============================================================================
Func _XMLSelectNodes($strXPath)
	Local $objNode, $objNodeList, $arrResponse[1], $xmlerr
	$objNodeList = $objDoc.selectNodes ($strXPath)
	While @error = 0
		If Not IsObj($objNode) Then $xmlerr = @CRLF & "No Matching Nodes found"
		For $objNode In $objNodeList
			_ArrayAdd($arrResponse, $objNode.nodeName)
			
		Next
		$arrResponse[0] = $objNodeList.length
		Return $arrResponse
	WEnd
	;	_XMLError( "Error Selecting Node(s): " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Selecting Node(s): " & $strXPath & $xmlerr)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLSelectNodes

;===============================================================================
; Function Name:	_XMLGetField
; Description:		Get XML Field(s) based on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
; Syntax:			_XMLGetField($path)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of fields text values -1 on failure
;===============================================================================
Func _XMLGetField($strXPath)
	Local $objNodeList, $arrResponse[1], $xmlerr
	While @error = 0
		$objNodeList = $objDoc.selectNodes ($strXPath)
		If $objNodeList.length > 0 Then
			_DebugWrite("GetField list length:" & $objNodeList.length)
			For $objNode In $objNodeList
				_ArrayAdd($arrResponse, $objNode.Text)
				_DebugWrite("GetField:" & $objNode.Text)
			Next
			$arrResponse[0] = $objNodeList.length
			Return $arrResponse
		Else
			$xmlerr = @CRLF & "No matching node(s)found!"
			ExitLoop
		EndIf
		
	WEnd
	;	_XMLError( "Error Retrieving: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Retrieving: " & $strXPath & $xmlerr)
	;			_XMLError( "No matching node(s)found for: " & $strXPath & @CRLF & $oMyError.windescription)
	SetError(1)
	Return -1
	
EndFunc   ;==>_XMLGetField
;===============================================================================
; Function Name:    _XMLGetValue
; Description:        Get XML Fieldbased on XPath input from root node.
; Parameters:        $path    xml tree path from root node (root/child/child..)
; Syntax:            _XMLGetValue($path)
; Author(s):        Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:            array of fields text values -1 on failure
;===============================================================================
Func _XMLGetValue($strXPath)
    Local $objNodeList, $arrResponse[1], $objNodeChild, $xmlerr
    While @error = 0
    $objNodeList = $objDoc.selectNodes($strXPath)
;    $objNodeList = $objDoc.selectNodes ($strXPath)
        If $objNodeList.length > 0 Then
            _DebugWrite("GetValue list length:" & $objNodeList.length)
            For $objNode In $objNodeList
            if $objNode.hasChildNodes() = False Then
                _ArrayAdd($arrResponse, $objNode.Text)
            Else
                $objNodeChild = $objNode.childNodes(0)
                if $objNodeChild.nodeType = $NODE_CDATA_SECTION Then
                    _ArrayAdd($arrResponse, $objNodeChild.data)
                Else
                    _ArrayAdd($arrResponse, $objNode.Text)
                EndIf
            EndIf
            
            _DebugWrite("GetValue:" & $objNode.nodeValue)
        Next
        Return $arrResponse
;            Return $objNode.nodeValue
           ;            Return $arrResponse
        Else
            $xmlerr = @CRLF & "No matching node(s)found!"
            Return -1
            ExitLoop
        EndIf
        
    WEnd
   ;    _XMLError( "Error Retrieving: " & $strXPath & @CRLF & $oMyError.windescription)
    _XMLError( "Error Retrieving: " & $strXPath & $xmlerr)
   ;            _XMLError( "No matching node(s)found for: " & $strXPath & @CRLF & $oMyError.windescription)
    SetError(1)
    Return -1
    
 EndFunc  ;==>_XMLGetValue

;===============================================================================
; Function Name:	_XMLDeleteNode
; Description:		Deletes XML Node based on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
; Syntax:			_XMLDeleteNode($path)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of fields text values   -1 on failure
;===============================================================================
Func _XMLDeleteNode($strXPath)
	Local $objNode, $xmlerr
	$objNode = $objDoc.selectSingleNode ($strXPath)
	If Not IsObj($objNode) Then $xmlerr = @CRLF & "Node Not found"
	While @error = 0 ;And $objNode.length > 0
		$objNode.parentNode.removeChild ($objNode)
		$objDoc.save ($strFile)
		Return
	WEnd
	;	_XMLError( "Error Deleting Node: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Deleting Node: " & $strXPath & $xmlerr)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLDeleteNode

;===============================================================================
; Function Name:	_XMLDeleteAttr
; Description:		Delete XML Attribute based on XPath input from root node.
; Parameters:		$path xml tree path from root node (root/child/child..)
;					$attribute The attribute node to delete
; Syntax:			_XMLDeleteAttr($path,$attribute)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			-1 on error and set error to 1
;===============================================================================
Func _XMLDeleteAttr($strXPath, $strAttrib)
	Local $objNode, $objAttr, $xmlerr
	$objNode = $objDoc.selectSingleNode ($strXPath)
	While @error = 0 And IsObj($objNode)
		$objAttr = $objNode.getAttributeNode ($strAttrib)
		If not (IsObj($objAttr)) Then
			$xmlerr = "Attribute " & $strAttrib & " does not exist!"
			ExitLoop
		EndIf
		$objAttr = $objNode.removeAttribute ($strAttrib)
		$objDoc.save ($strFile)
		Return
	WEnd
	;	_XMLError( "Error Deleting Node: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Removing Attribute: " & $strXPath & " - " & $strAttrib & @CRLF & $xmlerr)
	$xmlerr = ""
	SetError(1)
	Return -1
EndFunc   ;==>_XMLDeleteAttr

;===============================================================================
; Function Name:	_XMLDeleteAttrNode
; Description:		Delete XML Attribute node based on XPath input from root node.
; Parameters:		$path xml tree path from root node (root/child/child..)
;					$attribute The attribute node to delete
; Syntax:			_XMLDeleteAttrNode($path,$attribute)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			-1 on error and set error to 1
;===============================================================================
Func _XMLDeleteAttrNode($strXPath, $strAttrib)
	Local $objNode, $objAttr, $xmlerr
	$objNode = $objDoc.selectSingleNode ($strXPath)
	If Not IsObj($objNode) Then
		$xmlerr = @CRLF & "Specified node not found!"
	Else
		While @error = 0 ;and IsObj($objNode) ;getAttributeNode($strAttrib)
			$objAttr = $objNode.removeAttributeNode ($objNode.getAttributeNode ($strAttrib))
			$objDoc.save ($strFile)
			If not (IsObj($objAttr)) Then
				$xmlerr = @CRLF & "Unspecified error:!"
				ExitLoop
			EndIf
			Return
		WEnd
	EndIf
	;	_XMLError( "Error Deleting Node: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Removing Attribute Node: " & $strXPath & " - " & $strAttrib & $xmlerr)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLDeleteAttrNode

;===============================================================================
; Function Name:	_XMLGetAttrib
; Description:		Get XML Field(s) based on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
; Syntax:			_XMLGetAttrib($path,$attrib)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of fields text values
;					on error set error to 1 and returns -1
;===============================================================================
Func _XMLGetAttrib($strXPath, $strAttrib, $strQuery = "")
	Local $objNodeList, $arrResponse[1], $i, $xmlerr, $objAttr
	$objNodeList = $objDoc.selectNodes ($strXPath & $strQuery)
	_DebugWrite("Get Attrib length= " & $objNodeList.length)
	;	If @error = 0 Then
	While @error = 0
		
		If $objNodeList.length > 0 Then
			;			_DebugWrite ("Length:" & $objNodeList.length)
			ReDim $arrResponse[$objNodeList.length]
			For $i = 0 To $objNodeList.length - 1
				$objAttr = $objNodeList.item ($i).getAttribute ($strAttrib)
				;				$arrResponse[$i] = $objAttr.text
				;				$arrResponse[$i] = $objAttr
				$arrResponse = $objAttr
				_DebugWrite("RET>>" & $objAttr)
				_DebugWrite("Text>>" & $objAttr.text)
			Next
			Return $arrResponse
		Else
			$xmlerr = @CRLF & "No qualified items found"
			ExitLoop
		EndIf
	WEnd
	
	;EndIf
;~ 	_XMLError( "Attribute " & $strAttrib & " not found for: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Attribute " & $strAttrib & " not found for: " & $strXPath & $xmlerr)
	SetError(1)
	Return -1
	;	EndIf
EndFunc   ;==>_XMLGetAttrib

;===============================================================================
; Function Name:	_XMLSetAttrib
; Description:		Set XML Field(s) based on XPath input from root node.
; Parameters:		$path xml tree path from root node (root/child/child..)
;					$attrib  the attribute to set.
;					$value the value to give the attribute defaults to ""
; Syntax:			_XMLSetAttrib($path,$attrib,$value)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of fields text values
;					on error returns -1 and sets error to 1
;===============================================================================
Func _XMLSetAttrib($strXPath, $strAttrib, $strValue = "")
	Local $objNodeList, $arrResponse[1], $i
	
	$objNodeList = $objDoc.getElementsByTagName ($strXPath)
	_DebugWrite(" Node list Length: " & $objNodeList.length)
	;		If @error = 0 Then
	While @error = 0 And $objNodeList.length > 0
		;		If $objNodeList.length <> 0 Then
		ReDim $arrResponse[$objNodeList.length]
		For $i = 0 To $objNodeList.length - 1
			$arrResponse[$i] = $objNodeList.item ($i).SetAttribute ($strAttrib, $strValue)
		Next
		$objDoc.save ($strFile)
		Return $arrResponse
		;			Else
	WEnd
	;	_XMLError( "Failed to set attribute for: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error failed to set attribute for: " & $strXPath & @CRLF)
	SetError(1)
	Return -1
	;		EndIf
EndFunc   ;==>_XMLSetAttrib

;===============================================================================
; Function Name:	_XMLGetAllAttrib
; Description:		Get all XML Field(s) attributes based on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
;					$query the query string in xml format
;					$names the array to return the attrib names
;					$value the array to return the attrib values
;					[$query] DOM compliant query string  (not really necessary as it becomes
;part of the path
; Syntax:			_XMLGetAllAttrib($path,$query)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of fields text values
;					on error set error to 1 and returns -1
;===============================================================================
Func _XMLGetAllAttrib($strXPath, ByRef $aName, ByRef $aValue, $strQry = "")
	Local $objNodeList, $objQueryNodes, $objNode, $arrResponse[2][1], $i
	
	$objQueryNodes = $objDoc.selectNodes ($strXPath & $strQry)
	While @error = 0 And $objQueryNodes.length > 0
		For $objNode In $objQueryNodes
			;			$objNodeList = $objDoc.documentElement.selectSingleNode ($strXPath & $strQry).attributes
			$objNodeList = $objNode.attributes
			if ($objNodeList.length) Then
				_DebugWrite("Get all attrib " & $objNodeList.length)
				ReDim $arrResponse[2][$objNodeList.length + 1]
				ReDim $aName[$objNodeList.length]
				ReDim $aValue[$objNodeList.length]
				For $i = 0 To $objNodeList.length - 1
					;					$arrResponse[0,$i] = $objNodeList.item ($i).nodeName & "," & $objNodeList.item ($i).Text
					$arrResponse[0][$i] = $objNodeList.item ($i).nodeName
					$arrResponse[1][$i] = $objNodeList.item ($i).Value
					$aName[$i] = $objNodeList.item ($i).nodeName
					$aValue[$i] = $objNodeList.item ($i).Value
				Next
				;				Return $arrResponse
			Else
				SetError(1)
				ExitLoop
			EndIf
		Next
		Return $arrResponse
	WEnd
	;	_XMLError( "Error retrieving attributes for: " & $strXPath & @CRLF & $oMyError.windescription & @CRLF & $oMyError.scriptline)
	_XMLError( "Error retrieving attributes for: " & $strXPath & @CRLF)
	SetError(1)
	Return -1
	;	EndIf
EndFunc   ;==>_XMLGetAllAttrib

;===============================================================================
; Function Name:	_XMLUpdateField
; Description:		Update existing node(s) based on XPath specs.
; Parameters:		$path	Path from root node
;					$new_data	Data to update node with
; Syntax:			_XMLUpdateField($path,$new_data)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			on error set error to 1 and returns -1
;===============================================================================
Func _XMLUpdateField($strXPath, $strData)
	Local $objField, $objNodeList
	#forceref $objField
	While @error = 0
		$objNodeList = $objDoc.selectNodes ($strXPath)
		If IsObj($objNodeList) And $objNodeList.length > 0 Then
			;	If $objDoc.documentElement.selectNodes ($strXPath) Then
			For $objField In $objNodeList
				$objField.Text = $strData
			Next
			$objDoc.Save ($strFile)
			$objField = ""
			Return
		Else
			ExitLoop
		EndIf
	WEnd
	
	;	Else
	;		_XMLError( "Failed to update field for: " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Failed to update field for: " & $strXPath & @CRLF)
	SetError(1)
	Return -1
	;	EndIf
EndFunc   ;==>_XMLUpdateField

;===============================================================================
; Function Name:    _XMLCreateCDATA
; Description:        Create a CDATA SECTION node directly under root.
; Parameters:        $node name of node to create
;                    $data CDATA value
; Syntax:            _XMLCreateCDATA($node,$data)
; Author(s):        Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:            on error set error to 1 and returns -1
; fixme, won't append to exisiting node. must create new node.
;===============================================================================
Func _XMLCreateCDATA($strNode, $strCDATA,$strNameSpc="")
    Local $objChild, $objNode
    While @error = 0
        $objNode = $objDoc.createNode (1, $strNode, $strNameSpc)
        $objChild = $objDoc.createCDATASection ($strCDATA)
        $objNode.appendChild($objChild)
        $objDoc.documentElement.appendChild ($objNode)
        $objDoc.Save ($strFile)
        $objChild = ""
        Return
    WEnd
   ;    _XMLError( "Failed to create CDATA Section: " & $strNode & @CRLF & $oMyError.windescription)
    _XMLError( "Failed to create CDATA Section: " & $strNode & @CRLF)
    SetError(1)
    Return -1
 EndFunc  ;==>_XMLCreateCDATA

;===============================================================================
; Function Name:	_XMLCreateComment
; Description:		Create a COMMENT node at specified path.
; Parameters:		$node	name of node to create
;					$comment the comment to add the to the xml file
; Syntax:			_XMLCreateComment($node,$comment)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			on error set error to 1 and returns -1
;===============================================================================
Func _XMLCreateComment($strNode, $strComment)
	Local $objChild, $objNode
	While @error = 0
		$objNode = $objDoc.selectSingleNode ($strNode)
		;$objNode = $objDoc.selectSingleNode($strNode)
		$objChild = $objDoc.createComment ($strComment)
		$objNode.insertBefore ($objChild, $objNode.childNodes (0))
		;		$objNode.appendChild($objChild)
		$objDoc.Save ($strFile)
		$objChild = ""
		Return
	WEnd
	;	_XMLError( "Failed to root child: " & $strNode & @CRLF & $oMyError.windescription)
	_XMLError( "Failed to root child: " & $strNode & @CRLF)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLCreateComment

;===============================================================================
; Function Name:	_XMLCreateRootChild
; Description:		Create node directly under root.
; Parameters:		$node	name of node to create
;					$value optional value to create
; Syntax:			_XMLCreateRootChild($node,[$value])
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			on error set error to 1 and returns -1
;===============================================================================
Func _XMLCreateRootChild($strNode, $strData = "", $strNameSpc = "")
	Local $objChild
	$objChild = $objDoc.createNode (1, $strNode, $strNameSpc)
	If $strData <> "" Then $objChild.text = $strData
	While @error = 0
		$objDoc.documentElement.appendChild ($objChild)
		
		$objDoc.Save ($strFile)
		$objChild = ""
		Return
	WEnd
	;	_XMLError( "Failed to root child: " & $strNode & @CRLF & $oMyError.windescription)
	_XMLError( "Failed to root child: " & $strNode & @CRLF)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLCreateRootChild

;===============================================================================
; Function Name:	_XMLCreateRootNodeWAttr
; Description:		Create a child node under root node with attributes.
; Parameters:		$node  node to add with attibute(s)
;					$[array]attrib  attribute name(s) -- can be array
;					$[array]value	attribute value(s) -- can be array
;					$data 	optional value to give the node.
; Requirements		This function requires that each attribute name has
;					a corresponding value.
; Syntax:			_XMLCreateRootNodeWAttr($node,$array_attribs,$array_value)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			on error set error to 1 or 2 and returns -1
;===============================================================================
Func _XMLCreateRootNodeWAttr($strNode, $aAttr, $aVal, $strData = "", $strNameSpc = "")
	Local $objChild, $objAttr, $objAttrVal
	$objChild = $objDoc.createNode (1, $strNode, $strNameSpc)
	If $strData <> "" Then $objChild.text = $strData
	;	If @error = 0 Then
	While @error = 0
		If IsArray($aAttr) And IsArray($aVal) Then
			;If UBound($aAttr)-LBound($aAttr) <> UBound($aVal)-LBound($aVal) Then  ; no lbound support??
			If UBound($aAttr) <> UBound($aVal) Then
				_XMLError( "Attribute and value mismatch" & @CRLF & "Please make sure each attribute has a matching value.")
				SetError(2)
				Return -1
			Else
				Local $i
				;For $i = LBound($aAttr) To UBound($aAttr); no lbound support??
				For $i = 0 To UBound($aAttr) - 1
					If $aAttr[$i] = "" Then
						_XMLError( "Error creating child node: " & $strNode & @CRLF & " Attribute Name Cannot be NULL." & @CRLF)
						SetError(1)
						Return -1
					EndIf
;~ 						if $aVal[$i] = chr(0) Then
;~ 							_XMLError( "Error creating child node: " & $strNode & @CRLF &" Attribute Value Cannot be NULL." & @CRLF)
;~ 							Seterror(1)
;~ 							Return -1
;~ 						EndIf
					
					$objAttr = $objDoc.createAttribute ($aAttr[$i], $strNameSpc)
					$objAttrVal = $objDoc.createTextNode ($aVal[$i])
					$objAttr.appendChild ($objAttrVal)
					$objChild.SetAttribute ($aAttr[$i], $aVal[$i])
				Next
			EndIf
		Else
			$objAttr = $objDoc.createAttribute ($aAttr, $strNameSpc)
			$objAttrVal = $objDoc.createTextNode ($aVal)
			$objAttr.appendChild ($objAttrVal)
			$objChild.SetAttribute ($aAttr, $aVal)
		EndIf
		$objDoc.documentElement.appendChild ($objChild)
		$objDoc.Save ($strFile)
		$objChild = ""
		Return
		;	Else
	WEnd
	;	_XMLError( "Failed to create root child with attributes: " & $strNode & @CRLF & $oMyError.windescription)
	_XMLError( "Failed to create root child with attributes: " & $strNode & @CRLF)
	SetError(1)
	Return -1
	;	EndIf
EndFunc   ;==>_XMLCreateRootNodeWAttr

;===============================================================================
; Function Name:	_XMLCreateChildNode
; Description:		Create a child node under the specified XPath Node.
; Parameters:		$path	Path from root
;					$node	Node to add
; Syntax:			_XMLCreateChildNode($path,$node)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			on error set error to 1 and returns -1
;===============================================================================
Func _XMLCreateChildNode($strXPath, $strNode, $strData = "", $strNameSpc = "")
	Local $objParent, $objChild, $objNodeList
	While @error = 0
		$objNodeList = $objDoc.selectNodes ($strXPath)
		If IsObj($objNodeList) And $objNodeList.length <> 0 Then;.length <> 0 Then
			;			For $objParent In $objNodeList.documentElement.selectNodes ($strXPath)
			For $objParent In $objNodeList
				$objChild = $objDoc.createNode (1, $strNode, $strNameSpc)
				If $strData <> "" Then $objChild.text = $strData
				$objParent.appendChild ($objChild)
			Next
			$objDoc.Save ($strFile)
			$objParent = ""
			$objChild = ""
			Return
		Else
			ExitLoop
		EndIf
	WEnd
	;	_XMLError( "Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF & $oMyError.windescription)
	_XMLError( "Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLCreateChildNode

;===============================================================================
; Function Name:	_XMLCreateChildNodeWAttr
; Description:		Create a child node(s) under the specified XPath Node with attributes.
; Parameters:		$sPath Path from root
; 					$sNode  node to add with attibute(s)
;					$[array]attrib  attribute name(s) -- can be array
;					$[array]value	attribute value(s) -- can be array
;					$data 			Optional value to give the child node.
; Requirements		This function requires that each attribute name has
;					a corresponding value.
; Syntax:			_XMLCreateChildNodeWAttr($path,$node,$[array]attrib,$]array]value)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			0 on error and set error 1 or 2
;===============================================================================
Func _XMLCreateChildNodeWAttr($strXPath, $strNode, $aAttr, $aVal, $strData = "", $strNameSpc = "")
	Local $objParent, $objChild, $objAttr, $objAttrVal, $objNodeList
	While @error = 0
		$objNodeList = $objDoc.selectNodes ($strXPath)
		_DebugWrite("Node Selected")
		If IsObj($objNodeList) And $objNodeList.length <> 0 Then
			_DebugWrite("Entering if")
			;		For $objParent In $objDoc.documentElement.selectNodes ($strXPath)
			For $objParent In $objNodeList
				_DebugWrite("Entering for")
				$objChild = $objDoc.createNode (1, $strNode, $strNameSpc)
				If @error Then Return -1
				If $strData <> "" Then $objChild.text = $strData
				If IsArray($aAttr) And IsArray($aVal) Then
					If UBound($aAttr) <> UBound($aVal) Then
						_XMLError( "Attribute and value mismatch" & @CRLF & "Please make sure each attribute has a matching value.")
						SetError(2)
						Return -1
					Else
						Local $i
						For $i = 0 To UBound($aAttr) - 1
							_DebugWrite("Entering inside for")
							If $aAttr[$i] = "" Then
								_XMLError( "Error creating child node: " & $strNode & @CRLF & " Attribute Name Cannot be NULL." & @CRLF)
								SetError(1)
								Return -1
							EndIf
							$objAttr = $objDoc.createAttribute ($aAttr[$i], $strNameSpc)
							If @error Then ExitLoop
							$objAttrVal = $objDoc.createTextNode ($aVal[$i])
							$objAttr.appendChild ($objAttrVal)
							$objChild.SetAttribute ($aAttr[$i], $aVal[$i])
							If @error <> 0 Then
								_XMLError( "Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF)
								SetError(1)
								Return -1
							EndIf
							_DebugWrite("Looping inside for")
						Next
					EndIf
				Else
					$objAttr = $objDoc.createAttribute ($aAttr, $strNameSpc)
					$objAttrVal = $objDoc.createTextNode ($aVal)
					$objAttr.appendChild ($objAttrVal)
					$objChild.SetAttribute ($aAttr, $aVal)
				EndIf
				$objParent.appendChild ($objChild)
				_DebugWrite("Looping for")
			Next
			$objDoc.Save ($strFile)
			_DebugWrite("Saved")
			$objParent = ""
			$objChild = ""
			_DebugWrite("Returning")
			Return
		Else
			_DebugWrite("Exitloop")
			ExitLoop
		EndIf
	WEnd
	;	_XMLError( "Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF & $oMyError.windescription)
	_XMLError( "Error creating child node: " & $strNode & @CRLF & $strXPath & " does not exist." & @CRLF)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLCreateChildNodeWAttr

;===============================================================================
; Function Name:	_XMLGetChildText
; Description:		Selects XML child Node(s) of an element based on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
; Syntax:			_XMLGetChildText($path)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of Nodes or -1 on failure
;===============================================================================
Func _XMLGetChildText($strXPath)
	Local $objNodeList, $arrResponse[1], $xmlerr
	While @error = 0
		;	$objNodeList = $objDoc.getElementsByTagName($strXPath)
		$objNodeList = $objDoc.selectSingleNode ($strXPath)
		If Not IsObj($objNodeList) Then
			$xmlerr = @CRLF & "No Matching Nodes found"
			$arrResponse[0] = 0
			ExitLoop
		EndIf
		If $objNodeList.hasChildNodes () Then
			For $objChild In $objNodeList.childNodes ()
				If $objChild.nodeType = $NODE_ELEMENT Then
					_ArrayAdd($arrResponse, $objChild.baseName)
;~ ;					_DebugWrite($objChild.baseName)
				ElseIf $objChild.nodeType = $NODE_TEXT Then
					_ArrayAdd($arrResponse, $objChild.text)
					;					_ArrayAdd($arrResponse, $objChild.nodeTypedValue)
;~ 				Else
;~ 					_ArrayAdd($arrResponse, $objChild.baseName & "," & Chr(0))
;~ 					_ArrayAdd($arrResponse,  Chr(0))
;~ 					;					$tag =$objNodeList.selectSingleNode($objChild.basename)&"/self::text()"
;~ 					;					_DebugWrite($objChild.text)
;~ 					;ConsoleWrite($objChild.nodeValue&@crlf)
				EndIf
			Next
			$arrResponse[0] = UBound($arrResponse) - 1
			Return $arrResponse
		Else
			$arrResponse[0] = 0
			$xmlerr = @CRLF & "No Child Text Nodes found"
			SetError(1)
			ExitLoop
		EndIf
		Return $arrResponse
	WEnd
	;	_XMLError( "Error Selecting Node(s): " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Selecting Node(s): " & $strXPath & $xmlerr)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLGetChildText
;===============================================================================
; Function Name:	_XMLGetChildNodes
; Description:		Selects XML child Node(s) of an element based on XPath input from root node.
; Parameters:		$path	xml tree path from root node (root/child/child..)
; Syntax:			_XMLGetChildNodes($path)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of Nodes or -1 on failure
;===============================================================================
Func _XMLGetChildNodes($strXPath)
	Local $objNodeList, $arrResponse[1], $xmlerr
	While @error = 0
		$objNodeList = $objDoc.selectSingleNode ($strXPath)
		If Not IsObj($objNodeList) Then
			$xmlerr = @LF & "No Matching Nodes found"
			$arrResponse[0] = 0
			ExitLoop
		EndIf
		If $objNodeList.hasChildNodes () Then
			;				$child=1
			For $objChild In $objNodeList.childNodes ()
				;					ConsoleWrite("made it here")
				If $objChild.nodeType () = $NODE_ELEMENT Then
					_ArrayAdd($arrResponse, $objChild.baseName)
					;					ConsoleWrite($objChild.baseName
;~ 					ElseIf $objChild.nodeType = $NODE_TEXT Then
;~ 					_ArrayAdd($arrResponse, $objChild.text)
;~ ;					$tag =$objNodeList.selectSingleNode($objChild.basename)&"/self::text()"
;~ 					_DebugWrite($objChild.text)
;~  					;ConsoleWrite($objChild.nodeValue&@crlf)
				EndIf
			Next
			$arrResponse[0] = UBound($arrResponse) - 1
			Return $arrResponse
		Else
			$arrResponse[0] = 0
			$xmlerr = @LF & "No Child Nodes found"
			SetError(1)
			ExitLoop
		EndIf
		Return $arrResponse
	WEnd
	;	_XMLError( "Error Selecting Node(s): " & $strXPath & @CRLF & $oMyError.windescription)
	_XMLError( "Error Selecting Node(s): " & $strXPath & $xmlerr)
	SetError(1)
	Return -1
EndFunc   ;==>_XMLGetChildNodes

;===============================================================================
; Function Name:    _XMLGetNodeCount
; Description:        Get Node Count based on XPath input from root node.
; Parameters:        $path    xml tree path from root node (root/child/child..)
;                    [$query] DOM compliant query string  (not really necessary as it becomes part of the path
;					$iNodeType  The type of node to count. (element, attrib, comment etc.)
; Syntax:            _XMLGetNodeCount($path,$query)
; Author(s):        Stephen Podhajecki <gehossafats@netmdc.com> & DickB
; Returns:          0 or Number of Nodes found
;                    on error set error to 1 and returns -1
;===============================================================================
Func _XMLGetNodeCount($strXPath, $strQry = "", $iNodeType = 1)
	Local $objQueryNodes, $objNode, $nodeCount = 0
	;   $objQueryNodes = $objDoc.documentElement.selectNodes ($strXPath & $strQry)
	$objQueryNodes = $objDoc.selectNodes ($strXPath & $strQry)
	If @error = 0 And $objQueryNodes.length > 0 Then
		For $objNode In $objQueryNodes
			If $objNode.type = $iNodeType Then $nodeCount = $nodeCount + 1
		Next
		Return $nodeCount
	EndIf
	;    _XMLError( "Error retrieving node count for: " & $strXPath & @CRLF & $oMyError.windescription & @CRLF & $oMyError.scriptline)
	_XMLError( "Error retrieving node count for: " & $strXPath & @CRLF)
	SetError(1)
	Return -1
	;    EndIf
EndFunc   ;==>_XMLGetNodeCount
;===============================================================================
; Function Name:	_XMLGetAllAttribIndex
; Description:		Get all XML Field(s) attributes based on Xpathn and specific index.
; Parameters:		$sXpath	xml tree path from root node (root/child/child..)
;					$aNames the array to return the attrib names
;					$aValue the array to return the attrib values
;					[$sQuery] DOM compliant query string  (not really necessary as it becomes
;					[$iNode] node index.
;part of the path
; Syntax:			_XMLGetAllAttribIndex($path,$aNames,$aValues,[$sQuery="",$iNode=0]])
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			array of attrib node names, array of attrib values
;					on error set error to 1 and returns -1
;===============================================================================
Func _XMLGetAllAttribIndex($strXPath, ByRef $aName, ByRef $aValue, $strQry = "", $NodeIndex = 0)
	Local $objNodeList, $objQueryNodes, $arrResponse[2][1], $i
	
	;    $objQueryNodes = $objDoc.documentElement.selectNodes ($strXPath & $strQry)
	$objQueryNodes = $objDoc.selectNodes ($strXPath & $strQry)
	While @error = 0 And $objQueryNodes.length > 0
		$objNodeList = $objQueryNodes.item ($NodeIndex).attributes
		_DebugWrite("GetAllAttribIndex " & $objNodeList.length)
		ReDim $arrResponse[2][$objNodeList.length + 1]
		ReDim $aName[$objNodeList.length]
		ReDim $aValue[$objNodeList.length]
		For $i = 0 To $objNodeList.length - 1
			$arrResponse[0][$i] = $objNodeList.item ($i).nodeName
			$arrResponse[1][$i] = $objNodeList.item ($i).Value
			$aName[$i] = $objNodeList.item ($i).nodeName
			$aValue[$i] = $objNodeList.item ($i).Value
		Next
		Return $arrResponse
	WEnd
	;    _XMLError( "Error retrieving attributes for: " & $strXPath & @CRLF & $oMyError.windescription & @CRLF & $oMyError.scriptline)
	_XMLError( "Error retrieving attributes for: " & $strXPath & @CRLF)
	SetError(1)
	Return -1
	;    EndIf
EndFunc   ;==>_XMLGetAllAttribIndex

;===============================================================================
; Function Name:	_XMLError
; Description:		Sets error message generated by XML functs.
;					or Gets the message that was Set.
; Parameters:		$sError Node from root to delete
; Syntax:			_XMLError([$sError)
; Author(s):		Stephen Podhajecki <gehossafats@netmdc.com>
; Returns:			Nothing or Error message
;===============================================================================
Func _XMLError($sError = "")
	If $sError = "" Then
		$sError = $sXML_error
		$sXML_error = ""
		Return $sError
	Else
		$sXML_error = $sError
	EndIf
	_DebugWrite($sXML_error)
EndFunc   ;==>_XMLError

;===============================================================================
; Function Name:	_COMerr
; Description:		Displays a message box with the COM Error.
; Parameters:		none
; Syntax:			_COMerr()
; Author(s):		SvenP 's  error handler
; Returns:
; From the forum this came.
;===============================================================================
Func _COMerr($quiet = "")
	Local $COMErr_Silent, $HexNumber
	;===============================================================================
	;added silent switch to allow the func returned to the option to display custom
	;error messages
	If $quiet = True Or $quiet = False Then
		$COMErr_Silent = $quiet
		$quiet = ""
		Return
	EndIf
	;===============================================================================
	If $COMErr_Silent <> True Then
		
		;	ConsoleWrite("COM Error")
		$HexNumber = Hex($oMyError.number, 8)
		
		MsgBox(0, @AutoItExe, "COM Error with DOM!" & @CRLF & @CRLF & _
				"err.description is: " & @TAB & $oMyError.description & @CRLF & _
				"err.windescription:" & @TAB & $oMyError.windescription & @CRLF & _
				"err.number is: " & @TAB & $HexNumber & @CRLF & _
				"err.lastdllerror is: " & @TAB & $oMyError.lastdllerror & @CRLF & _
				"err.scriptline is: " & @TAB & $oMyError.scriptline & @CRLF & _
				"err.source is: " & @TAB & $oMyError.source & @CRLF & _
				"err.helpfile is: " & @TAB & $oMyError.helpfile & @CRLF & _
				"err.helpcontext is: " & @TAB & $oMyError.helpcontext _
				)
		SetError(1) ; to check for after this function returns
		;	MsgBox(4096, "COM Error", "There is a COM Error")
	EndIf
EndFunc   ;==>_COMerr

; simple helper functions
;===============================================================================
; Function Name:	- 	_DebugWrite($message)
; Description:		-  Writes a message to console with a crlf on the end
; Parameters:		- $message   the message to display
; Syntax:			- _DebugWrite($message)
; Author(s):		-
; Returns:			-
;===============================================================================
Func _DebugWrite($message, $flag =@LF)
    If $debugging Then
        If $flag <> "" Then
            ConsoleWrite($message & $flag )
        Else
            ConsoleWrite($message)
        EndIf
    EndIf
EndFunc   ;==>_DebugWrite
;===============================================================================
; Function Name:	_Notifier($Notifier_msg)
; Description:		displays a simple "ok" messagebox
; Parameters:		$Notifier_Msg   The message to display
; Syntax:			_Notifier($Notifier_msg)
; Author(s):		-
; Returns:			-
;===============================================================================
Func _Notifier($Notifier_msg)
	Return	msgbox (4096, @ScriptName, $Notifier_msg)
EndFunc   ;==>_Notifier
;===============================================================================
; Function Name:	- 	_SetDebug($flag =False)
; Description:		-  Writes a message to console with a crlf on the end
; Parameters:		- $message   the message to display
; Syntax:			- _DebugWrite($message)
; Author(s):		-
; Returns:			-
;===============================================================================
Func _SetDebug($debug_flag = True)
	$debugging = $debug_flag
EndFunc   ;==>_SetDebug
;===============================================================================
; Function Name:	- 	_XMLUDFVersion()
; Description:		-  Returns UDF version number
; Parameters:		- none
; Syntax:			- _XMLUDFVersion()
; Author(s):		-
; Returns:			-
;===============================================================================
Func _XMLUDFVersion()
	Return $_XMLUDFVER
EndFunc   ;==>_XMLUDFVersion
