# Define SciTE settings for C++, C, C#, Ch, Java, IDL, JavaScript, Flash (ActionScript 2) files.

# sma files are Small script (C-like)
file.patterns.cpp=*.c;*.cc;*.cpp;*.cxx;*.h;*.hh;*.hpp;*.hxx;*.ipp;*.sma
file.patterns.cplusplus=*.cc;*.cpp;*.cxx
# pln, inc and t are SilkTest (4Test) files.
file.patterns.test=*.pln;*.inc;*.t
file.patterns.cs=*.cs
file.patterns.rc=*.rc;*.rc2;*.dlg
file.patterns.idl=*.idl;*.odl
file.patterns.flash=*.as;*.asc;*.jsfl
file.patterns.ch=*.ch;*.chf;*.chs
file.patterns.wsh=*.js;*.wsf
file.patterns.c.like=$(file.patterns.cpp);$(file.patterns.cs);$(file.patterns.idl);*.java;$(file.patterns.flash);$(file.patterns.ch);$(file.patterns.wsh)

shbang.tcc=cpp
shbang.tinycc=cpp

filter.cpp=C/C++ (c cc cpp cxx cs h hh hxx hpp ipp dlg rc rc2 mak)|\
$(file.patterns.cpp);$(file.patterns.cs);$(file.patterns.rc);*.mak;make*|
filter.java=Java (java)|*.java|
filter.js=JavaScript (js)|*.js|
filter.idl=IDL (idl odl)|$(file.patterns.idl)|
filter.test=SilkTest (pln inc t)|$(file.patterns.test)|
filter.flash=Flash (as asc jsfl)|$(file.patterns.flash)|
filter.ch=Ch (ch chf chs)|$(file.patterns.ch)|

lexer.*.java=cpp
lexer.$(file.patterns.cpp)=cpp
lexer.$(file.patterns.rc)=cpp
lexer.$(file.patterns.idl)=cpp
lexer.$(file.patterns.cs)=cpp
lexer.$(file.patterns.wsh)=cpp
lexer.$(file.patterns.test)=cpp
lexer.$(file.patterns.flash)=cpp
lexer.$(file.patterns.ch)=cpp

keyword.logicoperations.cpp=and and_eq not not_eq or or_eq xor xor_eq
keywordclass.cpp=asm auto bitand bitor bool break \
case catch char class compl const const_cast continue \
default delete do double dynamic_cast else enum explicit export extern false float for \
friend goto if inline int long mutable namespace new \
operator private protected public \
register reinterpret_cast return short signed sizeof static static_cast struct switch \
template this throw true try typedef typeid typename union unsigned using \
virtual void volatile wchar_t while 
keywords.$(file.patterns.cpp)=$(keywordclass.cpp)
# keywords2 is for highlighting user defined keywords or function calls or similar
keywords2.$(file.patterns.cpp)=$(keyword.logicoperations.cpp)
# keywords3 is for doc comment keywords, highlighted in style 17
#CPP doxygen
keywords3.$(file.patterns.cpp)=a addindex addtogroup anchor arg attention \
author b brief bug c class code date def defgroup deprecated dontinclude \
e em endcode endhtmlonly endif endlatexonly endlink endverbatim enum example exception \
f$ f[ f] file fn hideinitializer htmlinclude htmlonly \
if image include ingroup internal invariant interface latexonly li line link \
mainpage name namespace nosubgrouping note overload \
p page par param param[in] param[out] \
post pre ref relates remarks return retval \
sa section see showinitializer since skip skipline struct subsection \
test throw todo typedef union until \
var verbatim verbinclude version warning weakgroup $ @ \ & < > # { }

word.chars.cxx=$(chars.alpha)$(chars.numeric)_#
word.characters.$(file.patterns.cpp)=$(word.chars.cxx)
word.characters.$(file.patterns.cs)=$(word.chars.cxx)
calltip.cpp.word.characters=$(chars.alpha)$(chars.numeric)_

comment.block.cpp=//
#comment.block.at.line.start.cpp=1

comment.stream.start.cpp=/*
comment.stream.end.cpp=*/
comment.box.start.cpp=/*
comment.box.middle.cpp= *
comment.box.end.cpp= */
#fold.at.else=1

file.patterns.c.except.cpp=$(file.patterns.cs);$(file.patterns.idl);*.java;$(file.patterns.flash);$(file.patterns.ch)
statement.indent.$(file.patterns.c.except.cpp)=5 case default do else for if while
statement.indent.$(file.patterns.cpp)=5 case default do else for if private protected public while
statement.end.$(file.patterns.c.like)=10 ;
statement.lookback.$(file.patterns.c.like)=20
block.start.$(file.patterns.c.like)=10 {
block.end.$(file.patterns.c.like)=10 }

#autocomplete.cpp.fillups=(

#styling.within.preprocessor=1
preprocessor.symbol.$(file.patterns.cpp)=#
preprocessor.start.$(file.patterns.cpp)=if ifdef ifndef
preprocessor.middle.$(file.patterns.cpp)=else elif
preprocessor.end.$(file.patterns.cpp)=endif

preprocessor.symbol.$(file.patterns.cs)=#
preprocessor.start.$(file.patterns.cs)=if region
preprocessor.middle.$(file.patterns.cs)=else elif
preprocessor.end.$(file.patterns.cs)=endif endregion

keywordclass.ch=\
auto array bool break case char class complex ComplexInf ComplexNaN \
const continue default delete \
do double else enum export extern float for foreach goto if Inf inline int \
long namespace NaN new NULL private public register restrict return short \
signed sizeof static string_t struct switch this typedef union unsigned \
using void volatile wchar_t while __declspec
keywords.$(file.patterns.ch)=$(keywordclass.ch)
word.chars.ch=$(chars.alpha)$(chars.numeric)_#
word.characters.$(file.patterns.ch)=$(word.chars.cxx)
comment.block.ch=//
#comment.block.at.line.start.ch=1
comment.stream.start.ch=/*
comment.stream.end.ch=*/
comment.box.start.ch=/*
comment.box.middle.ch= *
comment.box.end.ch= */
preprocessor.symbol.$(file.patterns.ch)=#
preprocessor.start.$(file.patterns.ch)=if ifdef ifndef
preprocessor.middle.$(file.patterns.ch)=else elif
preprocessor.end.$(file.patterns.ch)=endif

keywordclass.cs=abstract as base bool break byte case catch char checked class \
const continue decimal default delegate do double else enum \
event explicit extern false finally fixed float for foreach goto if \
implicit in int interface internal is lock long namespace new null \
object operator out override params private protected public \
readonly ref return sbyte sealed short sizeof stackalloc static \
string struct switch this throw true try typeof uint ulong \
unchecked unsafe ushort using virtual void while
keywords.$(file.patterns.cs)=$(keywordclass.cs)
word.characters.$(file.patterns.cs)=$(word.chars.cxx)

keywordclass.rc=\
ACCELERATORS ALT AUTO3STATE AUTOCHECKBOX AUTORADIOBUTTON \
BEGIN BITMAP BLOCK BUTTON CAPTION CHARACTERISTICS CHECKBOX CLASS \
COMBOBOX CONTROL CTEXT CURSOR DEFPUSHBUTTON DIALOG DIALOGEX DISCARDABLE \
EDITTEXT END EXSTYLE FONT GROUPBOX ICON LANGUAGE LISTBOX LTEXT \
MENU MENUEX MENUITEM MESSAGETABLE POPUP \
PUSHBUTTON RADIOBUTTON RCDATA RTEXT SCROLLBAR SEPARATOR SHIFT STATE3 \
STRINGTABLE STYLE TEXTINCLUDE VALUE VERSION VERSIONINFO VIRTKEY
keywords.$(file.patterns.rc)=$(keywordclass.rc)

keywordclass.idl=\
aggregatable allocate appobject arrays async async_uuid \
auto_handle \
bindable boolean broadcast byte byte_count \
call_as callback char coclass code comm_status \
const context_handle context_handle_noserialize \
context_handle_serialize control cpp_quote custom \
decode default defaultbind defaultcollelem \
defaultvalue defaultvtable dispinterface displaybind dllname \
double dual \
enable_allocate encode endpoint entry enum error_status_t \
explicit_handle \
fault_status first_is float \
handle_t heap helpcontext helpfile helpstring \
helpstringcontext helpstringdll hidden hyper \
id idempotent ignore iid_as iid_is immediatebind implicit_handle \
import importlib in include in_line int __int64 __int3264 interface \
last_is lcid length_is library licensed local long \
max_is maybe message methods midl_pragma \
midl_user_allocate midl_user_free min_is module ms_union \
ncacn_at_dsp ncacn_dnet_nsp ncacn_http ncacn_ip_tcp \
ncacn_nb_ipx ncacn_nb_nb ncacn_nb_tcp ncacn_np \
ncacn_spx ncacn_vns_spp ncadg_ip_udp ncadg_ipx ncadg_mq \
ncalrpc nocode nonbrowsable noncreatable nonextensible notify \
object odl oleautomation optimize optional out out_of_line \
pipe pointer_default pragma properties propget propput propputref \
ptr public \
range readonly ref represent_as requestedit restricted retval \
shape short signed size_is small source strict_context_handle \
string struct switch switch_is switch_type \
transmit_as typedef \
uidefault union unique unsigned user_marshal usesgetlasterror uuid \
v1_enum vararg version void wchar_t wire_marshal

keywordclass.msidl=handle
keywordclass.xpidl=attribute native noscript scriptable shared wstring inout
keywords.$(file.patterns.idl)=$(keywordclass.idl) $(keywordclass.xpidl)

keywordclass.java=abstract assert boolean break byte case catch char class \
const continue default do double else extends false final finally float for future \
generic goto if implements import inner instanceof int interface long \
native new null outer package private protected public rest \
return short static super switch synchronized this throw throws \
transient true try var void volatile while
keywords.*.java=$(keywordclass.java)

keywordclass.javascript=abstract assert boolean break byte case catch char \
class const continue debugger default delete do double else enum export extends \
false final finally float for function future generic goto if implements import \
in inner instanceof int interface long native new null outer package private \
protected public rest return short static super switch synchronized this throw \
throws transient true try typeof undefined var void volatile while with
keywords.$(file.patterns.wsh)=$(keywordclass.javascript)

keywordclass.flash=add and break case catch class continue default delete do \
dynamic else eq extends false finally for function ge get gt if implements import in \
instanceof interface intrinsic le lt ne new not null or private public return \
set static super switch this throw true try typeof undefined var void while with

keywordclass2.flash=Array Arguments Accessibility Boolean Button Camera Color \
ContextMenu ContextMenuItem Date Error Function Key LoadVars LocalConnection Math \
Microphone Mouse MovieClip MovieClipLoader NetConnection NetStream Number Object \
PrintJob Selection SharedObject Sound Stage String StyleSheet System TextField \
TextFormat TextSnapshot Video Void XML XMLNode XMLSocket \
_accProps _focusrect _global _highquality _parent _quality _root _soundbuftime \
arguments asfunction call capabilities chr clearInterval duplicateMovieClip \
escape eval fscommand getProperty getTimer getURL getVersion gotoAndPlay gotoAndStop \
ifFrameLoaded Infinity -Infinity int isFinite isNaN length loadMovie loadMovieNum \
loadVariables loadVariablesNum maxscroll mbchr mblength mbord mbsubstring MMExecute \
NaN newline nextFrame nextScene on onClipEvent onUpdate ord parseFloat parseInt play \
prevFrame prevScene print printAsBitmap printAsBitmapNum printNum random removeMovieClip \
scroll set setInterval setProperty startDrag stop stopAllSounds stopDrag substring \
targetPath tellTarget toggleHighQuality trace unescape unloadMovie unLoadMovieNum updateAfterEvent

keywords.$(file.patterns.flash)=$(keywordclass.flash)
keywords2.$(file.patterns.flash)=$(keywordclass2.flash)

# C++ styles

# Default
style.cpp.32=
# White space
style.cpp.0=$(colour.whitespace)
# Comment: /* */.
style.cpp.1=$(colour.comment),$(font.comment)
# Line Comment: //.
style.cpp.2=$(colour.comment),$(font.comment)
# Doc comment: block comments beginning with /** or /*!
style.cpp.3=$(colour.code.comment.doc),$(font.comment)
# Number
style.cpp.4=$(colour.number)
# Keyword
style.cpp.5=$(colour.keyword),bold
# Double quoted string
style.cpp.6=$(colour.string)
# Single quoted string
style.cpp.7=$(colour.char)
# UUIDs (only in IDL)
style.cpp.8=fore:#804080
# Preprocessor
style.cpp.9=$(colour.preproc)
# Operators
style.cpp.10=$(colour.operator),bold
# Identifiers
style.cpp.11=
# End of line where string is not closed
style.cpp.12=back:#E0C0E0,eolfilled
# Verbatim strings for C#
style.cpp.13=fore:#007F00,back:#E0FFE0,eolfilled
# Regular expressions for JavaScript
style.cpp.14=fore:#3F7F3F,back:#E0F0FF,eolfilled
# Doc Comment Line: line comments beginning with /// or //!.
style.cpp.15=$(colour.code.comment.doc),$(font.comment)
# Keywords2
style.cpp.16=$(colour.keyword),fore:#B00040
# Comment keyword
style.cpp.17=$(colour.keyword),$(font.comment),bold,back:#FEFEFE
# Comment keyword error
style.cpp.18=fore:#800000,$(font.comment),bold
# Braces are only matched in operator style
braces.cpp.style=10

ccopts=-pedantic -Os
cc=g++ $(ccopts) -c $(FileNameExt) -o $(FileName).o
ccc=gcc $(ccopts) -c $(FileNameExt) -o $(FileName).o

make.command=make
command.compile.*.c=$(ccc) -std=c99
command.build.*.c=$(make.command)
command.go.*.c=./$(FileName)
# To make the Go command both compile (if needed) and execute, use this setting:
#command.go.needs.*.c=gcc $(ccopts) -std=c99 $(FileNameExt) -o $(FileName)

command.compile.$(file.patterns.cplusplus)=$(cc)
command.build.$(file.patterns.cplusplus)=$(make.command)
command.go.$(file.patterns.cplusplus)=./$(FileName)
command.go.needs.$(file.patterns.cplusplus)=g++ $(ccopts) $(FileNameExt) -o $(FileName)

command.build.*.h=$(make.command)

#~ command.name.0.$(file.patterns.cpp)=Indent
#~ command.0.$(file.patterns.cpp)=astyle -tapOK -M8 $(FileNameExt)
#~ command.is.filter.0.$(file.patterns.cpp)=1

#~ command.name.1.$(file.patterns.cplusplus)=Lint
#~ command.1.$(file.patterns.cplusplus)=g++ -W -Wall -Wshadow -Wwrite-strings -Wold-style-cast -Woverloaded-virtual -pedantic -Os -fno-exceptions -c $(FileNameExt)
#~ 	-Woverloaded-virtual -pedantic -Os -fno-exceptions -c $(FileNameExt)

if PLAT_WIN
	command.compile.*.rc=windres $(FileNameExt) $(FileName).o
	command.build.*.rc=$(make.command)
	command.help.$(file.patterns.cpp)=$(CurrentWord)!G:\Program Files\Microsoft Visual Studio\MSDN98\98VSa\1033\MSDNVS6A.COL
	command.help.subsystem.$(file.patterns.cpp)=4
# When maintaining old Win16 programs...
#	command.help.$(file.patterns.cpp)=$(CurrentWord)!I:\msvc\help\win31wh.hlp
#	command.help.subsystem.$(file.patterns.cpp)=5

if PLAT_GTK
	command.help.$(file.patterns.cpp)=man $(CurrentWord) | col -b

if PLAT_WIN
	command.build.*.cs=csc /t:winexe $(FileNameExt) /r:system.dll,system.drawing.dll
	command.go.*.cs=$(FileName)
	command.go.subsystem.*.cs=1
if PLAT_GTK
	command.build.*.cs=mcs /t:winexe $(FileNameExt) /r:System,System.Drawing
	command.go.*.cs=mono $(FileName).exe
	command.go.subsystem.*.cs=1

command.compile.*.java=javac $(FileNameExt)
command.build.*.java=javac *.java
command.go.*.java=java $(FileName)

command.compile.*.ch=ch -n $(FileNameExt)
command.build.*.ch=ch -n  $(FileNameExt)
command.go.*.ch=ch -u $(FileNameExt)

command.compile.*.as=mtasc -strict $(FileNameExt)
command.build.*.as=mtasc -strict *.as

# =========================================================
if PLAT_WIN
# §¬§à§Þ§Ñ§ß§Õ§Ñ §Þ§Ö§ß§ð - §£§í§á§à§Ý§ß§Ú§ä§î (F5)
	command.go.$(file.patterns.wsh)=wscript "$(FileNameExt)" $(1) $(2) $(3) $(4)
# §¬§à§Þ§Ñ§ß§Õ§Ñ §Þ§Ö§ß§ð - §³§à§Ò§â§Ñ§ä§î (F7)
	command.build.$(file.patterns.wsh)=cscript /nologo "$(FileNameExt)" $(1) $(2) $(3) $(4)

	command.help.$(file.patterns.wsh)=$(CurrentWord)!$(SciteDefaultHome)\help\script56.chm
	command.help.subsystem.$(file.patterns.wsh)=4

c.ext=*.c;*.c++;*.cpp;*.cxx
h.ext=*.h;*.h++;*.hpp;*.hxx

command.name.3.$(c.ext)=Open $(FileName).h*
command.3.$(c.ext)=dostring \
					for ext in props['h.ext']:gmatch('[^;*]+') do \
						local file = props['FileName']..ext \
						if os.rename(file,file) then \
							scite.Open(file) \
						end \
					end
command.mode.3.$(c.ext)=subsystem:lua,savebefore:no

command.name.3.$(h.ext)=Open $(FileName).c*
command.3.$(h.ext)=dostring \
					for ext in props['c.ext']:gmatch('[^;*]+') do \
						local file = props['FileName']..ext \
						if os.rename(file,file) then \
							scite.Open(file) \
						end \
					end
command.mode.3.$(h.ext)=subsystem:lua,savebefore:no

# §¥§Ú§ß§Ñ§Þ§Ú§é§Ö§ã§Ü§Ñ§ñ §ã§Þ§Ö§ß§Ñ §ã§ä§Ú§Ý§ñ §à§æ§à§â§Þ§Ý§Ö§ß§Ú§ñ
command.name.5.$(file.patterns.cpp)=Style Classic C
command.5.$(file.patterns.cpp)=dofile $(SciteDefaultHome)\tools\style_changer.lua
command.mode.5.$(file.patterns.cpp)=subsystem:lua,savebefore:no

# §±§à§Õ§Ü§Ý§ð§é§Ö§ß§Ú§Ö §æ§Ñ§Û§Ý§à§Ó §ã§à§Ü§â§Ñ§ë§Ö§ß§Ú§Û
abbreviations.$(file.patterns.wsh)=$(SciteDefaultHome)\abbrev\jscript.abbrev
abbreviations.$(file.patterns.cpp)=$(SciteDefaultHome)\abbrev\cpp.abbrev

# Min §Õ§Ý§Ú§ß§Ñ §Ó§Ó§Ö§Õ§Ö§ß§à§Û §ã§ä§â§à§Ü§Ú §á§â§Ú §Ü§à§ä§à§â§à§Û §Ò§å§Õ§Ö§ä §Ñ§Ó§ä§à§Þ§Ñ§ä§Ú§é§Ö§ã§Ü§Ú §à§ä§Ü§â§í§Ó§Ñ§ä§î§ã§ñ §ã§á§Ú§ã§à§Ü §ã §Ó§Ñ§â§Ú§Ñ§ß§ä§Ñ§Þ§Ú §â§Ñ§ã§ê§Ú§æ§â§à§Ó§Ü§Ú §Ñ§Ò§Ò§â§Ö§Ó§Ú§Ñ§ä§å§â§í (abbrevlist.lua)
abbrev.cpp.auto=2

# §±§à§Õ§Ü§Ý§ð§é§Ö§ß§Ú§Ö §æ§Ñ§Û§Ý§Ñ §Ñ§Ó§ä§à§Õ§à§á§à§Ý§ß§Ö§ß§Ú§ñ §Ú §Ó§ã§á§Ý§í§Ó§Ñ§ð§ë§Ú§ç §á§à§Õ§ã§Ü§Ñ§Ù§à§Ü §á§à §ã§Ú§ß§ä§Ñ§Ü§ã§Ú§ã§å
api.$(file.patterns.wsh)=$(SciteDefaultHome)\api\JavaScript.api;$(SciteDefaultHome)\api\ActiveX.api
api.$(file.patterns.cpp)=$(SciteDefaultHome)\api\cpp.api

# §³§Ú§Þ§Ó§à§Ý§í, §á§à§ã§Ý§Ö §Ó§Ó§à§Õ§Ñ §Ü§à§ä§à§â§í§ç, §Ó§à§Ù§ß§Ú§Ü§Ñ§Ö§ä §ã§á§Ú§ã§à§Ü §Ñ§Ó§ä§à§Õ§à§á§à§Ý§ß§Ö§ß§Ú§ñ
autocomplete.cpp.start.characters=.

# §³§Ú§Þ§Ó§à§Ý§í, §á§à§ã§Ý§Ö §Ó§Ó§à§Õ§Ñ §Ü§à§ä§à§â§í§ç §Ó§à§Ù§ß§Ú§Ü§Ñ§Ö§ä §á§à§Õ§ã§Ü§Ñ§Ù§Ü§Ñ
calltip.cpp.parameters.start=( 
# §³§Ú§Þ§Ó§à§Ý§í - §â§Ñ§Ù§Õ§Ö§Ý§Ú§ä§Ö§Ý§Ú §á§Ñ§â§Ñ§Þ§Ö§ä§â§à§Ó
calltip.cpp.parameters.separators=,

# C++ classic colors
# mimir <http://forum.ru-board.com/topic.cgi?forum=5&topic=3215&start=780#11>
#import languages\cpp_style_classic
