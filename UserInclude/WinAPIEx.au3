#Region Header

#cs
	
	Title:          WinAPI Extended UDF Library for AutoIt3
	Filename:       WinAPIEx.au3
	Description:    Additional variables, constants and functions for the WinAPI.au3
	Author:         Yashied
	Version:        3.5 / 3.3.6.1
	Requirements:   AutoIt v3.3 +, Developed/Tested on Windows XP Pro Service Pack 2 and Windows Vista/7
	Uses:           WinAPI.au3
	Note:           The library uses the following system DLLs:
	
	advapi32.dll
	comctl32.dll
	dwmapi.dll (Windows Vista or above)
	gdi32.dll
	kernel32.dll
	ntdll.dll
	ole32.dll
	psapi.dll
	sensapi.dll
	shell32.dll
	shlwapi.dll
	user32.dll
	userenv.dll
	uxtheme.dll
	version.dll
	winmm.dll
	winspool.drv
	
	Available functions:
	
	_WinAPI_AboutDlg
	_WinAPI_ActivateKeyboardLayout
	_WinAPI_AddFontResourceEx
	_WinAPI_AddIconOverlay
	_WinAPI_AddMRUString
	_WinAPI_AdjustTokenPrivileges
	_WinAPI_AdjustWindowRectEx
	_WinAPI_AlphaBlend
	_WinAPI_AnimateWindow
	_WinAPI_ArrayToStruct
	_WinAPI_AssignProcessToJobObject
	_WinAPI_AssocGetPerceivedType
	_WinAPI_AssocQueryString
	_WinAPI_BeginDeferWindowPos
	_WinAPI_BeginPaint
	_WinAPI_BringWindowToTop
	_WinAPI_BroadcastSystemMessage
	_WinAPI_BrowseForFolderDlg
	****_WinAPI_CalculatePopupWindowPosition
	_WinAPI_CharToOem
	_WinAPI_ChildWindowFromPointEx
	_WinAPI_CloseEnhMetaFile
	_WinAPI_CloseThemeData
	_WinAPI_CloseWindow
	_WinAPI_CoInitialize
	_WinAPI_ColorHLSToRGB
	_WinAPI_ColorRGBToHLS
	_WinAPI_CommandLineToArgv
	_WinAPI_CopyBitmap
	_WinAPI_CopyCursor
	_WinAPI_CopyEnhMetaFile
	_WinAPI_CopyFileEx
	_WinAPI_CopyImage
	_WinAPI_CopyRect
	_WinAPI_CopyStruct
	_WinAPI_CoTaskMemAlloc
	_WinAPI_CoTaskMemFree
	_WinAPI_CoTaskMemRealloc
	_WinAPI_CoUninitialize
	_WinAPI_CreateBrushIndirect
	_WinAPI_CreateCaret
	_WinAPI_CreateCompatibleBitmapEx
	_WinAPI_CreateDIBSection
	_WinAPI_CreateEllipticRgn
	_WinAPI_CreateEnhMetaFile
	_WinAPI_CreateFileEx
	_WinAPI_CreateGUID
	_WinAPI_CreateIconIndirect
	_WinAPI_CreateJobObject
	_WinAPI_CreateMRUList
	_WinAPI_CreatePolygonRgn
	_WinAPI_CreateRect
	_WinAPI_CreateRectEx
	_WinAPI_CreateRectRgnIndirect
	_WinAPI_CreateSemaphore
	_WinAPI_CreateStreamOnHGlobal
	_WinAPI_DeferWindowPos
	_WinAPI_DefineDosDevice
	_WinAPI_DeleteEnhMetaFile
	_WinAPI_DeleteFile
	_WinAPI_DeleteVolumeMountPoint
	_WinAPI_DeregisterShellHookWindow
	_WinAPI_DestroyCaret
	_WinAPI_DestroyCursor
	_WinAPI_DeviceIoControl
	_WinAPI_DllInstall
	_WinAPI_DllUninstall
	_WinAPI_DragAcceptFiles
	_WinAPI_DragFinish
	_WinAPI_DragQueryFileEx
	_WinAPI_DragQueryPoint
	_WinAPI_DrawAnimatedRects
	_WinAPI_DrawBitmap
	_WinAPI_DrawShadowText
	_WinAPI_DrawThemeBackground
	_WinAPI_DrawThemeParentBackground
	_WinAPI_DrawThemeText
	***_WinAPI_DrawThemeTextEx
	***_WinAPI_DwmEnableBlurBehindWindow
	***_WinAPI_DwmEnableComposition
	***_WinAPI_DwmGetColorizationColor
	***_WinAPI_DwmGetWindowAttribute
	***_WinAPI_DwmExtendFrameIntoClientArea
	***_WinAPI_DwmIsCompositionEnabled
	***_WinAPI_DwmQueryThumbnailSourceSize
	***_WinAPI_DwmRegisterThumbnail
	***_WinAPI_DwmSetWindowAttribute
	***_WinAPI_DwmUnregisterThumbnail
	***_WinAPI_DwmUpdateThumbnailProperties
	_WinAPI_DWordToInt
	_WinAPI_DWordToFloat
	_WinAPI_EjectMedia
	_WinAPI_Ellipse
	_WinAPI_EmptyWorkingSet
	_WinAPI_EndDeferWindowPos
	_WinAPI_EndPaint
	_WinAPI_EnumChildProcess
	_WinAPI_EnumChildWindows
	_WinAPI_EnumDeviceDrivers
	_WinAPI_EnumDisplaySettings
	_WinAPI_EnumMRUList
	_WinAPI_EnumProcessThreads
	_WinAPI_EnumProcessWindows
	_WinAPI_EnumResourceLanguages
	_WinAPI_EnumResourceNames
	_WinAPI_EnumResourceTypes
	_WinAPI_EnumSystemLocales
	_WinAPI_EqualMemory
	_WinAPI_EqualRect
	_WinAPI_EqualRgn
	_WinAPI_EqualStruct
	_WinAPI_ExtFloodFill
	_WinAPI_ExtSelectClipRgn
	_WinAPI_FatalExit
	_WinAPI_FileTimeToLocalFileTime
	_WinAPI_FileTimeToSystemTime
	*_WinAPI_FillRect
	_WinAPI_FillRgn
	_WinAPI_FillStruct
	_WinAPI_FindResource
	_WinAPI_FindResourceEx
	_WinAPI_FormatDriveDlg
	*_WinAPI_FrameRect
	_WinAPI_FrameRgn
	_WinAPI_FreeMRUList
	_WinAPI_FreeResource
	_WinAPI_GetActiveWindow
	*_WinAPI_GetAsyncKeyState
	_WinAPI_GetBinaryType
	_WinAPI_GetBitmapDimension
	_WinAPI_GetBkColor
	_WinAPI_GetBValue
	_WinAPI_GetCaretBlinkTime
	_WinAPI_GetCaretPos
	_WinAPI_GetClassLongEx
	_WinAPI_GetCompression
	_WinAPI_GetComputerNameEx
	_WinAPI_GetCurrentDirectory
	_WinAPI_GetCurrentHwProfile
	_WinAPI_GetCurrentThemeName
	_WinAPI_GetCursor
	_WinAPI_GetDateFormat
	_WinAPI_GetDefaultPrinter
	_WinAPI_GetDeviceDriverBaseName
	_WinAPI_GetDeviceDriverFileName
	_WinAPI_GetDiskFreeSpaceEx
	_WinAPI_GetDriveBusType
	_WinAPI_GetDriveGeometryEx
	_WinAPI_GetDriveNumber
	_WinAPI_GetDriveType
	_WinAPI_GetErrorMode
	_WinAPI_GetFileAttributes
	_WinAPI_GetFileVersionInfo
	_WinAPI_GetFontResourceInfo
	*_WinAPI_GetForegroundWindow
	_WinAPI_GetEnhMetaFile
	_WinAPI_GetEnhMetaFileBits
	_WinAPI_GetEnhMetaFileDescription
	_WinAPI_GetEnhMetaFileDimension
	_WinAPI_GetEnhMetaFileHeader
	_WinAPI_GetGValue
	_WinAPI_GetHandleInformation
	_WinAPI_GetHGlobalFromStream
	_WinAPI_GetIconBitmap
	_WinAPI_GetIconDimension
	_WinAPI_GetIconMask
	_WinAPI_GetIdleTime
	_WinAPI_GetKeyboardLayout
	_WinAPI_GetKeyboardLayoutList
	_WinAPI_GetKeyboardState
	_WinAPI_GetKeyboardType
	_WinAPI_GetKeyNameText
	_WinAPI_GetKeyState
	*_WinAPI_GetLayeredWindowAttributes
	_WinAPI_GetLocaleInfo
	_WinAPI_GetModuleFileName
	_WinAPI_GetModuleFileNameEx
	_WinAPI_GetModuleHandleEx
	_WinAPI_GetObjectEx
	_WinAPI_GetObjectType
	_WinAPI_GetParentProcess
	_WinAPI_GetPerformanceInfo
	_WinAPI_GetPixel
	_WinAPI_GetPosFromRect
	_WinAPI_GetProcAddress
	_WinAPI_GetProcessCommandLine
	_WinAPI_GetProcessCreationTime
	_WinAPI_GetProcessIoCounters
	_WinAPI_GetProcessMemoryInfo
	_WinAPI_GetProcessName
	_WinAPI_GetProfilesDirectory
	_WinAPI_GetRgnBox
	_WinAPI_GetROP2
	_WinAPI_GetRValue
	_WinAPI_GetSystemDefaultLCID
	_WinAPI_GetSystemInfo
	_WinAPI_GetSystemPowerStatus
	_WinAPI_GetSystemWow64Directory
	_WinAPI_GetTempFileName
	_WinAPI_GetTextColor
	_WinAPI_GetTextFace
	_WinAPI_GetTextMetrics
	_WinAPI_GetThemeAppProperties
	_WinAPI_GetThemeColor
	_WinAPI_GetThemeDocumentationProperty
	_WinAPI_GetThemeFont
	_WinAPI_GetThemeInt
	_WinAPI_GetThemeMargins
	_WinAPI_GetThemePartSize
	_WinAPI_GetThemePosition
	_WinAPI_GetThemeRect
	_WinAPI_GetTickCount
	***_WinAPI_GetTickCount64
	_WinAPI_GetTimeFormat
	_WinAPI_GetTopWindow
	_WinAPI_GetUDFColorMode
	_WinAPI_GetUDFVersion
	_WinAPI_GetUpdateRect
	_WinAPI_GetUpdateRgn
	_WinAPI_GetUserDefaultLCID
	_WinAPI_GetVersion
	_WinAPI_GetVersionEx
	_WinAPI_GetVolumeNameForVolumeMountPoint
	_WinAPI_GetWindowInfo
	_WinAPI_GetWindowLongEx
	_WinAPI_GetWindowModuleFileName
	_WinAPI_GetWorkArea
	_WinAPI_GradientFill
	_WinAPI_HideCaret
	_WinAPI_HiDWord
	_WinAPI_InflateRect
	_WinAPI_IntersectRect
	_WinAPI_IntToDWord
	*_WinAPI_InvalidateRect
	_WinAPI_InvalidateRgn
	_WinAPI_InvertRect
	_WinAPI_InvertRgn
	_WinAPI_IOCTL
	_WinAPI_IsChild
	_WinAPI_IsDoorOpen
	_WinAPI_IsHungAppWindow
	_WinAPI_IsIconic
	_WinAPI_IsLoadKBLayout
	_WinAPI_IsNetworkAlive
	_WinAPI_IsPressed
	_WinAPI_IsProcessInJob
	_WinAPI_IsProcessorFeaturePresent
	_WinAPI_IsRectEmpty
	_WinAPI_IsThemeActive
	_WinAPI_IsThemeBackgroundPartiallyTransparent
	_WinAPI_IsThemePartDefined
	_WinAPI_IsValidLocale
	_WinAPI_IsWindowEnabled
	_WinAPI_IsWindowUnicode
	_WinAPI_IsWow64Process
	_WinAPI_IsWritable
	_WinAPI_IsZoomed
	_WinAPI_Keybd_Event
	_WinAPI_KillTimer
	_WinAPI_LoadCursor
	_WinAPI_LoadCursorFromFile
	***_WinAPI_LoadIconWithScaleDown
	_WinAPI_LoadKeyboardLayout
	_WinAPI_LoadMedia
	_WinAPI_LoadResource
	_WinAPI_LockDevice
	_WinAPI_LockFile
	_WinAPI_LockResource
	_WinAPI_LockWorkStation
	_WinAPI_LoDWord
	_WinAPI_LookupPrivilegeName
	_WinAPI_LookupPrivilegeValue
	_WinAPI_MessageBoxCheck
	_WinAPI_MoveFileEx
	_WinAPI_MoveToEx
	_WinAPI_OemToChar
	_WinAPI_OffsetPoints
	_WinAPI_OffsetClipRgn
	_WinAPI_OffsetRect
	_WinAPI_OffsetRgn
	_WinAPI_OpenIcon
	_WinAPI_OpenJobObject
	_WinAPI_OpenProcessToken
	_WinAPI_OpenSemaphore
	_WinAPI_OpenThemeData
	_WinAPI_PaintRgn
	_WinAPI_PatBlt
	_WinAPI_PathCompactPath
	_WinAPI_PathFindExtension
	_WinAPI_PathFindFileName
	_WinAPI_PathFindNextComponent
	*_WinAPI_PathFindOnPath
	_WinAPI_PathGetArgs
	_WinAPI_PathGetCharType
	_WinAPI_PathGetDriveNumber
	_WinAPI_PathIsExe
	_WinAPI_PathIsDirectory
	_WinAPI_PathIsDirectoryEmpty
	_WinAPI_PathIsFileSpec
	_WinAPI_PathIsLFNFileSpec
	_WinAPI_PathIsRelative
	_WinAPI_PathIsSameRoot
	_WinAPI_PathMatchSpec
	_WinAPI_PathRenameExtension
	_WinAPI_PathSearchAndQualify
	_WinAPI_PathUnExpandEnvStrings
	_WinAPI_PathYetAnotherMakeUniqueName
	_WinAPI_PickIconDlg
	_WinAPI_PlayEnhMetaFile
	_WinAPI_PlaySound
	_WinAPI_PolyBezier
	_WinAPI_PolyBezierTo
	_WinAPI_PolyDraw
	_WinAPI_Polygon
	_WinAPI_PrintWindow
	_WinAPI_PrivateExtractIcon
	_WinAPI_PtInRectEx
	_WinAPI_PtInRegion
	_WinAPI_QueryDosDevice
	_WinAPI_QueryInformationJobObject
	_WinAPI_QueryPerformanceCounter
	_WinAPI_QueryPerformanceFrequency
	_WinAPI_RadialGradientFill
	_WinAPI_Rectangle
	_WinAPI_RegCloseKey
	_WinAPI_RegConnectRegistry
	_WinAPI_RegCopyTree
	***_WinAPI_RegCopyTreeEx
	_WinAPI_RegCreateKey
	_WinAPI_RegDeleteEmptyKey
	_WinAPI_RegDeleteKey
	***_WinAPI_RegDeleteKeyValue
	_WinAPI_RegDeleteTree
	***_WinAPI_RegDeleteTreeEx
	_WinAPI_RegDeleteValue
	_WinAPI_RegDuplicateHKey
	_WinAPI_RegEnumKey
	_WinAPI_RegEnumValue
	_WinAPI_RegFlushKey
	_WinAPI_RegisterHotKey
	_WinAPI_RegisterShellHookWindow
	***_WinAPI_RegLoadMUIString
	_WinAPI_RegOpenKey
	_WinAPI_RegQueryInfoKey
	_WinAPI_RegQueryLastWriteTime
	_WinAPI_RegQueryValue
	_WinAPI_RegRestoreKey
	_WinAPI_RegSaveKey
	_WinAPI_RegSetValue
	_WinAPI_ReleaseSemaphore
	_WinAPI_RemoveFontResourceEx
	***_WinAPI_ReOpenFile
	_WinAPI_ResizeBitmap
	_WinAPI_RestartDlg
	_WinAPI_RestoreDC
	_WinAPI_RGB
	_WinAPI_RotatePoints
	_WinAPI_RoundRect
	_WinAPI_SaveDC
	_WinAPI_SendMessageTimeout
	_WinAPI_SetActiveWindow
	_WinAPI_SetClassLongEx
	_WinAPI_SetCompression
	_WinAPI_SetCaretBlinkTime
	_WinAPI_SetCaretPos
	_WinAPI_SetCurrentDirectory
	*_WinAPI_SetDefaultPrinter
	_WinAPI_SetDCBrushColor
	_WinAPI_SetDCPenColor
	_WinAPI_SetEnhMetaFileBits
	_WinAPI_SetErrorMode
	_WinAPI_SetFileAttributes
	_WinAPI_SetFilePointerEx
	_WinAPI_SetForegroundWindow
	*_WinAPI_SetHandleInformation
	_WinAPI_SetInformationJobObject
	_WinAPI_SetKeyboardLayout
	_WinAPI_SetKeyboardState
	*_WinAPI_SetLayeredWindowAttributes
	_WinAPI_SetLocaleInfo
	*_WinAPI_SetParent
	_WinAPI_SetPixel
	_WinAPI_SetROP2
	_WinAPI_SetStretchBltMode
	_WinAPI_SetSystemCursor
	_WinAPI_SetThemeAppProperties
	_WinAPI_SetTimer
	_WinAPI_SetUDFColorMode
	_WinAPI_SetVolumeMountPoint
	_WinAPI_SetWindowLongEx
	_WinAPI_ShellAddToRecentDocs
	_WinAPI_ShellChangeNotify
	_WinAPI_ShellChangeNotifyDeregister
	_WinAPI_ShellChangeNotifyRegister
	_WinAPI_ShellEmptyRecycleBin
	_WinAPI_ShellExtractAssociatedIcon
	_WinAPI_ShellExtractIcon
	_WinAPI_ShellFileOperation
	_WinAPI_ShellGetFileInfo
	***_WinAPI_ShellGetKnownFolderPath
	_WinAPI_ShellGetPathFromIDList
	_WinAPI_ShellGetSetFolderCustomSettings
	_WinAPI_ShellGetSettings
	_WinAPI_ShellGetSpecialFolderLocation
	_WinAPI_ShellGetSpecialFolderPath
	***_WinAPI_ShellGetStockIconInfo
	_WinAPI_ShellILCreateFromPath
	_WinAPI_ShellNotifyIcon
	_WinAPI_ShellObjectProperties
	_WinAPI_ShellOpenFolderAndSelectItems
	***_WinAPI_ShellOpenWithDlg
	_WinAPI_ShellQueryRecycleBin
	_WinAPI_ShellQueryUserNotificationState
	_WinAPI_ShellSetSettings
	_WinAPI_ShowCaret
	_WinAPI_ShowLastError
	_WinAPI_ShowOwnedPopups
	_WinAPI_SizeofResource
	_WinAPI_StretchBlt
	_WinAPI_StrLen
	_WinAPI_StructToArray
	_WinAPI_SubtractRect
	_WinAPI_SwapDWord
	_WinAPI_SwitchColor
	**_WinAPI_SwitchToThisWindow
	_WinAPI_TransparentBlt
	_WinAPI_TextOut
	_WinAPI_UnionRect
	_WinAPI_UnionStruct
	_WinAPI_UniqueHardwareID
	_WinAPI_UnloadKeyboardLayout
	_WinAPI_UnlockFile
	_WinAPI_UnregisterHotKey
	_WinAPI_UpdateLayeredWindowEx
	_WinAPI_ValidateRect
	_WinAPI_ValidateRgn
	_WinAPI_VerQueryRoot
	_WinAPI_VerQueryValue
	_WinAPI_WindowFromDC
	_WinAPI_Wow64EnableWow64FsRedirection
	
	* Available in native AutoIt library
	** Deprecated
	*** Required Windows Vista or above
	**** Required Windows 7 or above
	
#ce

#include-once

#include <WinAPI.au3>
#Include <BorderConstants.au3>
#Include <Constants.au3>
#Include <FileConstants.au3>
#Include <FontConstants.au3>
#Include <FrameConstants.au3>
#Include <MemoryConstants.au3>
#Include <MenuConstants.au3>
#Include <ProcessConstants.au3>
#Include <SecurityConstants.au3>
#Include <WindowsConstants.au3>


#cs

    Title:          API Constants UDF Library for AutoIt3
    Filename:       APIConstants.au3
    Description:    Constants to be used with WinAPIEx UDF library.
    Author:         Yashied
    Version:        3.3 / 3.3.6.1
    Requirements:   AutoIt v3.3 +, Developed/Tested on Windows XP Pro Service Pack 2 and Windows Vista/7
    Uses:           WindowsConstants.au3
    Note:           -

#ce
Global Const $__WINVER = __Ver()
Global $__Data, $__Ver = '3.3', $__RGB = True

#Region Global Variables and Constants
; ===============================================================================================================================
;_WinAPI_GetComputerNameEx()
; ===============================================================================================================================
Global Const $ComputerNameNetBIOS = 0
Global Const $ComputerNameDnsHostname = 1
Global Const $ComputerNameDnsDomain = 2
Global Const $ComputerNameDnsFullyQualified = 3
Global Const $ComputerNamePhysicalNetBIOS = 4
Global Const $ComputerNamePhysicalDnsHostname = 5
Global Const $ComputerNamePhysicalDnsDomain = 6
Global Const $ComputerNamePhysicalDnsFullyQualified = 7

; ===============================================================================================================================
; _WinAPI_GetArcDirection(), _WinAPI_SetArcDirection()
; ===============================================================================================================================

Global Const $AD_COUNTERCLOCKWISE = 1
Global Const $AD_CLOCKWISE = 2

; ===================================================================================================
; _WinAPI_DevicePowerSetDeviceState
; ===================================================================================================
Global Const $DEVICEPOWER_SET_WAKEENABLED = 0x00000001
Global Const $DEVICEPOWER_CLEAR_WAKEENABLED = 0x00000002
; ===============================================================================================================================
; _WinAPI_ActivateKeyboardLayout(), _WinAPI_LoadKeyboardLayout()
; ===============================================================================================================================

Global Const $KLF_ACTIVATE = 0x00000001
Global Const $KLF_NOTELLSHELL = 0x00000080
Global Const $KLF_REORDER = 0x00000008
Global Const $KLF_REPLACELANG = 0x00000010
Global Const $KLF_RESET = 0x40000000
Global Const $KLF_SETFORPROCESS = 0x00000100
Global Const $KLF_SHIFTLOCK = 0x00010000
Global Const $KLF_SUBSTITUTE_OK = 0x00000002

Global Const $HKL_NEXT = 1
Global Const $HKL_PREV = 0

; ===============================================================================================================================
; _WinAPI_AddFontResourceEx(), _WinAPI_RemoveFontResourceEx()
; ===============================================================================================================================

Global Const $FR_PRIVATE = 0x10
Global Const $FR_NOT_ENUM = 0x20

; ===============================================================================================================================
; _WinAPI_AnimateWindow()
; ===============================================================================================================================

Global Const $AW_SLIDE = 0x00040000
Global Const $AW_ACTIVATE = 0x00020000
Global Const $AW_BLEND = 0x00080000
Global Const $AW_HIDE = 0x00010000
Global Const $AW_CENTER = 0x00000010
Global Const $AW_HOR_POSITIVE = 0x00000001
Global Const $AW_HOR_NEGATIVE = 0x00000002
Global Const $AW_VER_POSITIVE = 0x00000004
Global Const $AW_VER_NEGATIVE = 0x00000008
Global Const $AW_FADE_IN = 0x00080000 ;fade-in
Global Const $AW_FADE_OUT = 0x00090000;fade-out
Global Const $AW_SLIDE_IN_LEFT = 0x00040001 ;slide in from left
Global Const $AW_SLIDE_OUT_LEFT = 0x00050002 ;slide out to left
Global Const $AW_SLIDE_IN_RIGHT = 0x00040002 ;slide in from right
Global Const $AW_SLIDE_OUT_RIGHT = 0x00050001 ;slide out to right
Global Const $AW_SLIDE_IN_TOP = 0x00040004 ;slide-in from top
Global Const $AW_SLIDE_OUT_TOP = 0x00050008 ;slide-out to top
Global Const $AW_SLIDE_IN_BOTTOM = 0x00040008 ;slide-in from bottom
Global Const $AW_SLIDE_OUT_BOTTOM = 0x00050004 ;slide-out to bottom
Global Const $AW_DIAG_SLIDE_IN_TOPLEFT = 0x00040005 ;diag slide-in from Top-left
Global Const $AW_DIAG_SLIDE_OUT_TOPLEFT = 0x0005000a ;diag slide-out to Top-left
Global Const $AW_DIAG_SLIDE_IN_TOPRIGHT = 0x00040006 ;diag slide-in from Top-Right
Global Const $AW_DIAG_SLIDE_OUT_TOPRIGHT = 0x00050009 ;diag slide-out to Top-Right
Global Const $AW_DIAG_SLIDE_IN_BOTTOMLEFT = 0x00040009 ;diag slide-in from Bottom-left
Global Const $AW_DIAG_SLIDE_OUT_BOTTOMLEFT = 0x00050006 ;diag slide-out to Bottom-left
Global Const $AW_DIAG_SLIDE_IN_BOTTOMRIGHT = 0x0004000a ;diag slide-in from Bottom-right
Global Const $AW_DIAG_SLIDE_OUT_BOTTOMRIGHT = 0x00050005 ;diag slide-out to Bottom-right
Global Const $AW_EXPLODE = 0x00040010 ;explode
Global Const $AW_IMPLODE = 0x00050010 ;implode

; ===============================================================================================================================
; _WinAPI_AssocGetPerceivedType()
; ===============================================================================================================================

Global Const $PERCEIVED_TYPE_CUSTOM = -3
Global Const $PERCEIVED_TYPE_UNSPECIFIED = -2
Global Const $PERCEIVED_TYPE_FOLDER = -1
Global Const $PERCEIVED_TYPE_UNKNOWN = 0
Global Const $PERCEIVED_TYPE_TEXT = 1
Global Const $PERCEIVED_TYPE_IMAGE = 2
Global Const $PERCEIVED_TYPE_AUDIO = 3
Global Const $PERCEIVED_TYPE_VIDEO = 4
Global Const $PERCEIVED_TYPE_COMPRESSED = 5
Global Const $PERCEIVED_TYPE_DOCUMENT = 6
Global Const $PERCEIVED_TYPE_SYSTEM = 7
Global Const $PERCEIVED_TYPE_APPLICATION = 8
Global Const $PERCEIVED_TYPE_GAMEMEDIA = 9
Global Const $PERCEIVED_TYPE_CONTACTS = 10

Global Const $PERCEIVEDFLAG_UNDEFINED = 0x0000
Global Const $PERCEIVEDFLAG_SOFTCODED = 0x0001
Global Const $PERCEIVEDFLAG_HARDCODED = 0x0002
Global Const $PERCEIVEDFLAG_NATIVESUPPORT = 0x0004
Global Const $PERCEIVEDFLAG_GDIPLUS = 0x0010
Global Const $PERCEIVEDFLAG_WMSDK = 0x0020
Global Const $PERCEIVEDFLAG_ZIPFOLDER = 0x0040

; ===============================================================================================================================
; _WinAPI_AssocQueryString()
; ===============================================================================================================================

Global Const $ASSOCSTR_COMMAND = 1
Global Const $ASSOCSTR_EXECUTABLE = 2
Global Const $ASSOCSTR_FRIENDLYDOCNAME = 3
Global Const $ASSOCSTR_FRIENDLYAPPNAME = 4
Global Const $ASSOCSTR_NOOPEN = 5
Global Const $ASSOCSTR_SHELLNEWVALUE = 6
Global Const $ASSOCSTR_DDECOMMAND = 7
Global Const $ASSOCSTR_DDEIFEXEC = 8
Global Const $ASSOCSTR_DDEAPPLICATION = 9
Global Const $ASSOCSTR_DDETOPIC = 10
Global Const $ASSOCSTR_INFOTIP = 11
Global Const $ASSOCSTR_QUICKTIP = 12
Global Const $ASSOCSTR_TILEINFO = 13
Global Const $ASSOCSTR_CONTENTTYPE = 14
Global Const $ASSOCSTR_DEFAULTICON = 15
Global Const $ASSOCSTR_SHELLEXTENSION = 16

Global Const $ASSOCF_INIT_NOREMAPCLSID = 0x00000001
Global Const $ASSOCF_INIT_BYEXENAME = 0x00000002
Global Const $ASSOCF_OPEN_BYEXENAME = 0x00000002
Global Const $ASSOCF_INIT_DEFAULTTOSTAR = 0x00000004
Global Const $ASSOCF_INIT_DEFAULTTOFOLDER = 0x00000008
Global Const $ASSOCF_NOUSERSETTINGS = 0x00000010
Global Const $ASSOCF_NOTRUNCATE = 0x00000020
Global Const $ASSOCF_VERIFY = 0x00000040
Global Const $ASSOCF_REMAPRUNDLL = 0x00000080
Global Const $ASSOCF_NOFIXUPS = 0x00000100
Global Const $ASSOCF_IGNOREBASECLASS = 0x00000200
Global Const $ASSOCF_INIT_IGNOREUNKNOWN = 0x00000400


; ===============================================================================================================================
; _WinAPI_BeginBufferedPaint()
; ===============================================================================================================================

Global Const $BPBF_COMPATIBLEBITMAP = 0
Global Const $BPBF_DIB = 1
Global Const $BPBF_TOPDOWNDIB = 2
Global Const $BPBF_TOPDOWNMONODIB = 3

Global Const $BPPF_ERASE = 0x01
Global Const $BPPF_NOCLIP = 0x02
Global Const $BPPF_NONCLIENT = 0x04

; ===============================================================================================================================
; _WinAPI_BroadcastSystemMessage()
; ===============================================================================================================================

Global Const $BSF_ALLOWSFW = 0x0080
Global Const $BSF_FLUSHDISK = 0x0004
Global Const $BSF_FORCEIFHUNG = 0x0020
Global Const $BSF_IGNORECURRENTTASK = 0x0002
Global Const $BSF_NOHANG = 0x0008
Global Const $BSF_NOTIMEOUTIFNOTHUNG = 0x0040
Global Const $BSF_POSTMESSAGE = 0x0010
Global Const $BSF_QUERY = 0x0001
Global Const $BSF_SENDNOTIFYMESSAGE = 0x0100

Global Const $BSM_ALLCOMPONENTS = 0x00
Global Const $BSM_ALLDESKTOPS = 0x08
Global Const $BSM_APPLICATIONS = 0x10
Global Const $BSM_INSTALLABLEDRIVERS = 0x04
Global Const $BSM_NETDRIVER = 0x02
Global Const $BSM_VXDS = 0x01

; ===============================================================================================================================
; _WinAPI_BrowseForFolderDlg()
; ===============================================================================================================================

Global Const $BIF_RETURNONLYFSDIRS = 0x00000001
Global Const $BIF_DONTGOBELOWDOMAIN = 0x00000002
Global Const $BIF_STATUSTEXT = 0x00000004
Global Const $BIF_RETURNFSANCESTORS = 0x00000008
Global Const $BIF_EDITBOX = 0x00000010
Global Const $BIF_VALIDATE = 0x00000020
Global Const $BIF_NEWDIALOGSTYLE = 0x00000040
Global Const $BIF_BROWSEINCLUDEURLS = 0x00000080
Global Const $BIF_USENEWUI = BitOR($BIF_EDITBOX, $BIF_NEWDIALOGSTYLE)
Global Const $BIF_UAHINT = 0x00000100
Global Const $BIF_NONEWFOLDERBUTTON = 0x00000200
Global Const $BIF_NOTRANSLATETARGETS = 0x00000400
Global Const $BIF_BROWSEFORCOMPUTER = 0x00001000
Global Const $BIF_BROWSEFORPRINTER = 0x00002000
Global Const $BIF_BROWSEINCLUDEFILES = 0x00004000
Global Const $BIF_SHAREABLE = 0x00008000

; *Windows 7 and later
Global Const $BIF_BROWSEFILEJUNCTIONS = 0x00010000

Global Const $BFFM_INITIALIZED = 1
Global Const $BFFM_IUNKNOWN = 5
Global Const $BFFM_SELCHANGED = 2
Global Const $BFFM_VALIDATEFAILED = 4

Global Const $BFFM_ENABLEOK = 0x0465 ; $WM_USER + 101
Global Const $BFFM_SETOKTEXT = 0x0469 ; $WM_USER + 105
Global Const $BFFM_SETSELECTION = 0x0467 ; $WM_USER + 103
Global Const $BFFM_SETEXPANDED = 0x046A ; $WM_USER + 106
Global Const $BFFM_SETSTATUSTEXT = 0x0468 ; $WM_USER + 104

; ===============================================================================================================================
; _WinAPI_ChangeScreenResEx()
; ===============================================================================================================================
Global Const $DM_PELSWIDTH = 0x00080000
Global Const $DM_PELSHEIGHT = 0x00100000
Global Const $DM_BITSPERPEL = 0x00040000
Global Const $DM_DISPLAYFREQUENCY = 0x00400000
Global Const $CDS_TEST = 0x00000002
Global Const $CDS_UPDATEREGISTRY = 0x00000001
Global Const $DISP_CHANGE_RESTART = 1
Global Const $DISP_CHANGE_SUCCESSFUL = 0
Global Const $HWND_BROADCAST = 0xffff


; ===============================================================================================================================
; _WinAPI_CalculatePopupWindowPosition()
; ===============================================================================================================================

;Global Const $TPM_CENTERALIGN = 0x00000004
;Global Const $TPM_LEFTALIGN = 0x00000000
;Global Const $TPM_RIGHTALIGN = 0x00000008

;Global Const $TPM_BOTTOMALIGN = 0x00000020
;Global Const $TPM_TOPALIGN = 0x00000000
;Global Const $TPM_VCENTERALIGN = 0x00000010

;Global Const $TPM_HORIZONTAL = 0x00000000
;Global Const $TPM_VERTICAL = 0x00000040

Global Const $TPM_WORKAREA = 0x00010000

; ===============================================================================================================================
; _WinAPI_CascadeWindows(), _WinAPI_TileWindows()
; ===============================================================================================================================

Global Const $MDITILE_HORIZONTAL = 0x01
Global Const $MDITILE_SKIPDISABLED = 0x02
Global Const $MDITILE_VERTICAL = 0x00
Global Const $MDITILE_ZORDER = 0x04

; ===============================================================================================================================
; _WinAPI_ChildWindowFromPointEx()
; ===============================================================================================================================

Global Const $CWP_ALL = 0x00
Global Const $CWP_SKIPINVISIBLE = 0x01
Global Const $CWP_SKIPDISABLED = 0x02
Global Const $CWP_SKIPTRANSPARENT = 0x04

; ===============================================================================================================================
; _WinAPI_CreateDesktop(), _WinAPI_OpenDesktop(), _WinAPI_OpenInputDesktop()
; ===============================================================================================================================

Global Const $DESKTOP_CREATEMENU = 0x0004
Global Const $DESKTOP_CREATEWINDOW = 0x0002
Global Const $DESKTOP_ENUMERATE = 0x0040
Global Const $DESKTOP_HOOKCONTROL = 0x0008
Global Const $DESKTOP_JOURNALPLAYBACK = 0x0020
Global Const $DESKTOP_JOURNALRECORD = 0x0010
Global Const $DESKTOP_READOBJECTS = 0x0001
Global Const $DESKTOP_SWITCHDESKTOP = 0x0100
Global Const $DESKTOP_WRITEOBJECTS = 0x0080
Global Const $DESKTOP_ALL_ACCESS = BitOR($DESKTOP_CREATEMENU, $DESKTOP_CREATEWINDOW, $DESKTOP_ENUMERATE, $DESKTOP_HOOKCONTROL, $DESKTOP_JOURNALPLAYBACK, $DESKTOP_JOURNALRECORD, $DESKTOP_READOBJECTS, $DESKTOP_SWITCHDESKTOP, $DESKTOP_WRITEOBJECTS)

; ===============================================================================================================================
; _WinAPI_CreateDIBSection()
; ===============================================================================================================================

Global Const $BI_RGB = 0
Global Const $BI_RLE8 = 1
Global Const $BI_RLE4 = 2
Global Const $BI_BITFIELDS = 3
Global Const $BI_JPEG = 4
Global Const $BI_PNG = 5

; ===============================================================================================================================
; _WinAPI_CreateMRUList()
; ===============================================================================================================================

Global Const $MRU_BINARY = 0x0001
Global Const $MRU_CACHEWRITE = 0x0002

; ===============================================================================================================================
; _WinAPI_CoInitialize()
; ===============================================================================================================================

Global Const $COINIT_APARTMENTTHREADED = 0x02
Global Const $COINIT_DISABLE_OLE1DDE = 0x04
Global Const $COINIT_MULTITHREADED = 0x00
Global Const $COINIT_SPEED_OVER_MEMORY = 0x08

; ===============================================================================================================================
; _WinAPI_CommDlgExtendedErrorEx()
; ===============================================================================================================================

Global Const $CDERR_DIALOGFAILURE = 0xFFFF
Global Const $CDERR_FINDRESFAILURE = 0x0006
Global Const $CDERR_INITIALIZATION = 0x0002
Global Const $CDERR_LOADRESFAILURE = 0x0007
Global Const $CDERR_LOADSTRFAILURE = 0x0005
Global Const $CDERR_LOCKRESFAILURE = 0x0008
Global Const $CDERR_MEMALLOCFAILURE = 0x0009
Global Const $CDERR_MEMLOCKFAILURE = 0x000A
Global Const $CDERR_NOHINSTANCE = 0x0004
Global Const $CDERR_NOHOOK = 0x000B
Global Const $CDERR_NOTEMPLATE = 0x0003
Global Const $CDERR_REGISTERMSGFAIL = 0x000C
Global Const $CDERR_STRUCTSIZE = 0x0001

Global Const $PDERR_CREATEICFAILURE = 0x100A
Global Const $PDERR_DEFAULTDIFFERENT = 0x100C
Global Const $PDERR_DNDMMISMATCH = 0x1009
Global Const $PDERR_GETDEVMODEFAIL = 0x1005
Global Const $PDERR_INITFAILURE = 0x1006
Global Const $PDERR_LOADDRVFAILURE = 0x1004
Global Const $PDERR_NODEFAULTPRN = 0x1008
Global Const $PDERR_NODEVICES = 0x1007
Global Const $PDERR_PARSEFAILURE = 0x1002
Global Const $PDERR_PRINTERNOTFOUND = 0x100B
Global Const $PDERR_RETDEFFAILURE = 0x1003
Global Const $PDERR_SETUPFAILURE = 0x1001

Global Const $CFERR_MAXLESSTHANMIN = 0x2002
Global Const $CFERR_NOFONTS = 0x2001

Global Const $FNERR_BUFFERTOOSMALL = 0x3003
Global Const $FNERR_INVALIDFILENAME = 0x3002
Global Const $FNERR_SUBCLASSFAILURE = 0x3001

Global Const $FRERR_BUFFERLENGTHZERO = 0x4001

; ===============================================================================================================================
; _WinAPI_CopyFileEx(), _WinAPI_MoveFileEx()
; ===============================================================================================================================

Global Const $COPY_FILE_ALLOW_DECRYPTED_DESTINATION = 0x0008
Global Const $COPY_FILE_COPY_SYMLINK = 0x0800
Global Const $COPY_FILE_FAIL_IF_EXISTS = 0x0001
Global Const $COPY_FILE_NO_BUFFERING = 0x1000
Global Const $COPY_FILE_OPEN_SOURCE_FOR_WRITE = 0x0004
Global Const $COPY_FILE_RESTARTABLE = 0x0002

Global Const $MOVE_FILE_COPY_ALLOWED = 0x0002
Global Const $MOVE_FILE_CREATE_HARDLINK = 0x0010
Global Const $MOVE_FILE_DELAY_UNTIL_REBOOT = 0x0004
Global Const $MOVE_FILE_FAIL_IF_NOT_TRACKABLE = 0x0020
Global Const $MOVE_FILE_REPLACE_EXISTING = 0x0001
Global Const $MOVE_FILE_WRITE_THROUGH = 0x0008

Global Const $PROGRESS_CONTINUE = 0
Global Const $PROGRESS_CANCEL = 1
Global Const $PROGRESS_STOP = 2
Global Const $PROGRESS_QUIET = 3

; ===============================================================================================================================
; _WinAPI_CopyImage()
; ===============================================================================================================================

#cs
	
	Global Const $LR_DEFAULTCOLOR = 0x0000
	Global Const $LR_DEFAULTSIZE = 0x0040
	Global Const $LR_COLOR = 0x0002
	Global Const $LR_COPYDELETEORG = 0x0008
	Global Const $LR_COPYFROMRESOURCE = 0x4000
	Global Const $LR_COPYRETURNORG = 0x0004
	Global Const $LR_CREATEDIBSECTION = 0x2000
	Global Const $LR_LOADFROMFILE = 0x0010
	Global Const $LR_LOADMAP3DCOLORS = 0x1000
	Global Const $LR_LOADTRANSPARENT = 0x0020
	Global Const $LR_MONOCHROME = 0x0001
	Global Const $LR_SHARED = 0x8000
	Global Const $LR_VGACOLOR = 0x0080
	
#ce

; ===============================================================================================================================
; _WinAPI_CreateBrushIndirect()
; ===============================================================================================================================

Global Const $BS_DIBPATTERN = 5
Global Const $BS_DIBPATTERN8X8 = 8
Global Const $BS_DIBPATTERNPT = 6
Global Const $BS_HATCHED = 2
Global Const $BS_HOLLOW = 1
Global Const $BS_NULL = 1
Global Const $BS_PATTERN = 3
Global Const $BS_PATTERN8X8 = 7
Global Const $BS_SOLID = 0

Global Const $HS_BDIAGONAL = 3
Global Const $HS_CROSS = 4
Global Const $HS_DIAGCROSS = 5
Global Const $HS_FDIAGONAL = 2
Global Const $HS_HORIZONTAL = 0
Global Const $HS_VERTICAL = 1

Global Const $DIB_PAL_COLORS = 1
Global Const $DIB_RGB_COLORS = 0

; ===============================================================================================================================
; _WinAPI_CreateFileEx()
; ===============================================================================================================================

#cs
	
	Global Const $CREATE_NEW = 1
	Global Const $CREATE_ALWAYS = 2
	Global Const $OPEN_EXISTING = 3
	Global Const $OPEN_ALWAYS = 4
	Global Const $TRUNCATE_EXISTING = 5
	
	Global Const $GENERIC_ALL = 0x10000000
	Global Const $GENERIC_EXECUTE = 0x20000000
	Global Const $GENERIC_WRITE = 0x40000000
	Global Const $GENERIC_READ = 0x80000000
	
	Global Const $FILE_SHARE_READ = 0x01
	Global Const $FILE_SHARE_WRITE = 0x02
	Global Const $FILE_SHARE_DELETE = 0x04
	
	Global Const $FILE_ATTRIBUTE_READONLY = 0x00000001
	Global Const $FILE_ATTRIBUTE_HIDDEN = 0x00000002
	Global Const $FILE_ATTRIBUTE_SYSTEM = 0x00000004
	Global Const $FILE_ATTRIBUTE_DIRECTORY = 0x00000010
	Global Const $FILE_ATTRIBUTE_ARCHIVE = 0x00000020
	Global Const $FILE_ATTRIBUTE_DEVICE = 0x00000040
	Global Const $FILE_ATTRIBUTE_NORMAL = 0x00000080
	Global Const $FILE_ATTRIBUTE_TEMPORARY = 0x00000100
	Global Const $FILE_ATTRIBUTE_SPARSE_FILE = 0x00000200
	Global Const $FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400
	Global Const $FILE_ATTRIBUTE_COMPRESSED = 0x00000800
	Global Const $FILE_ATTRIBUTE_OFFLINE = 0x00001000
	Global Const $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x00002000
	Global Const $FILE_ATTRIBUTE_ENCRYPTED = 0x00004000
	
#ce

Global Const $FILE_FLAG_BACKUP_SEMANTICS = 0x02000000
Global Const $FILE_FLAG_DELETE_ON_CLOSE = 0x04000000
Global Const $FILE_FLAG_NO_BUFFERING = 0x20000000
Global Const $FILE_FLAG_OPEN_NO_RECALL = 0x00100000
Global Const $FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000
Global Const $FILE_FLAG_OVERLAPPED = 0x40000000
Global Const $FILE_FLAG_POSIX_SEMANTICS = 0x0100000
Global Const $FILE_FLAG_RANDOM_ACCESS = 0x10000000
Global Const $FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000
Global Const $FILE_FLAG_WRITE_THROUGH = 0x80000000

Global Const $SECURITY_ANONYMOUS = 0x00000000
Global Const $SECURITY_IDENTIFICATION = 0x00010000
Global Const $SECURITY_IMPERSONATION = 0x00020000
Global Const $SECURITY_DELEGATION = 0x00030000
Global Const $SECURITY_CONTEXT_TRACKING = 0x00040000
Global Const $SECURITY_EFFECTIVE_ONLY = 0x00080000

; ===============================================================================================================================
; _WinAPI_CreatePolygonRgn()
; ===============================================================================================================================

Global Const $ALTERNATE = 1
Global Const $WINDING = 2

; ===============================================================================================================================
; _WinAPI_CreateProcess()
; ===============================================================================================================================

Global Const $CREATE_BREAKAWAY_FROM_JOB = 0x01000000
Global Const $CREATE_DEFAULT_ERROR_MODE = 0x04000000
Global Const $CREATE_NEW_CONSOLE = 0x00000010
Global Const $CREATE_NEW_PROCESS_GROUP = 0x00000200
Global Const $CREATE_NO_WINDOW = 0x08000000
Global Const $CREATE_PROTECTED_PROCESS = 0x00040000
Global Const $CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000
Global Const $CREATE_SEPARATE_WOW_VDM = 0x00000800
Global Const $CREATE_SHARED_WOW_VDM = 0x00001000
Global Const $CREATE_SUSPENDED = 0x00000004
Global Const $CREATE_UNICODE_ENVIRONMENT = 0x00000400

; ===============================================================================================================================
; _WinAPI_DeferWindowPos()
; ===============================================================================================================================

#cs
	
	Global Const $HWND_BOTTOM = 1
	Global Const $HWND_NOTOPMOST = -2
	Global Const $HWND_TOP = 0
	Global Const $HWND_TOPMOST = -1
	
	Global Const $SWP_DRAWFRAME = 0x0020
	Global Const $SWP_FRAMECHANGED = 0x0020
	Global Const $SWP_HIDEWINDOW = 0x0080
	Global Const $SWP_NOACTIVATE = 0x0010
	Global Const $SWP_NOCOPYBITS = 0x0100
	Global Const $SWP_NOMOVE = 0x0002
	Global Const $SWP_NOOWNERZORDER = 0x0200
	Global Const $SWP_NOREDRAW = 0x0008
	Global Const $SWP_NOREPOSITION = 0x0200
	Global Const $SWP_NOSENDCHANGING = 0x0400
	Global Const $SWP_NOSIZE = 0x0001
	Global Const $SWP_NOZORDER = 0x0004
	Global Const $SWP_SHOWWINDOW = 0x0040
	
#ce

; ===============================================================================================================================
; _WinAPI_DeviceIoControl()
; ===============================================================================================================================

Global Const $FSCTL_ALLOW_EXTENDED_DASD_IO = 0x00090083
Global Const $FSCTL_CREATE_OR_GET_OBJECT_ID = 0x000900C0
Global Const $FSCTL_CREATE_USN_JOURNAL = 0x000900E7
Global Const $FSCTL_DELETE_OBJECT_ID = 0x000900A0
Global Const $FSCTL_DELETE_REPARSE_POINT = 0x000900AC
Global Const $FSCTL_DELETE_USN_JOURNAL = 0x000900F8
Global Const $FSCTL_DISMOUNT_VOLUME = 0x00090020
Global Const $FSCTL_DUMP_PROPERTY_DATA = 0x00090097
Global Const $FSCTL_ENABLE_UPGRADE = 0x000980D0
Global Const $FSCTL_ENCRYPTION_FSCTL_IO = 0x000900DB
Global Const $FSCTL_ENUM_USN_DATA = 0x000900B3
Global Const $FSCTL_EXTEND_VOLUME = 0x000900F0
Global Const $FSCTL_FILESYSTEM_GET_STATISTICS = 0x00090060
Global Const $FSCTL_FIND_FILES_BY_SID = 0x0009008F
Global Const $FSCTL_GET_COMPRESSION = 0x0009003C
Global Const $FSCTL_GET_NTFS_FILE_RECORD = 0x00090068
Global Const $FSCTL_GET_NTFS_VOLUME_DATA = 0x00090064
Global Const $FSCTL_GET_OBJECT_ID = 0x0009009C
Global Const $FSCTL_GET_REPARSE_POINT = 0x000900A8
Global Const $FSCTL_GET_RETRIEVAL_POINTERS = 0x00090073
Global Const $FSCTL_GET_VOLUME_BITMAP = 0x0009006F
Global Const $FSCTL_HSM_DATA = 0x0009C113
Global Const $FSCTL_HSM_MSG = 0x0009C108
Global Const $FSCTL_INVALIDATE_VOLUMES = 0x00090054
Global Const $FSCTL_IS_PATHNAME_VALID = 0x0009002C
Global Const $FSCTL_IS_VOLUME_DIRTY = 0x00090078
Global Const $FSCTL_IS_VOLUME_MOUNTED = 0x00090028
Global Const $FSCTL_LOCK_VOLUME = 0x00090018
Global Const $FSCTL_MARK_AS_SYSTEM_HIVE = 0x0009004F
Global Const $FSCTL_MARK_HANDLE = 0x000900FC
Global Const $FSCTL_MARK_VOLUME_DIRTY = 0x00090030
Global Const $FSCTL_MOVE_FILE = 0x00090074
Global Const $FSCTL_OPBATCH_ACK_CLOSE_PENDING = 0x00090010
Global Const $FSCTL_OPLOCK_BREAK_ACK_NO_2 = 0x00090050
Global Const $FSCTL_OPLOCK_BREAK_ACKNOWLEDGE = 0x0009000C
Global Const $FSCTL_OPLOCK_BREAK_NOTIFY = 0x00090014
Global Const $FSCTL_QUERY_ALLOCATED_RANGES = 0x000940CF
Global Const $FSCTL_QUERY_FAT_BPB = 0x00090058
Global Const $FSCTL_QUERY_RETRIEVAL_POINTERS = 0x0009003B
Global Const $FSCTL_QUERY_USN_JOURNAL = 0x000900F4
Global Const $FSCTL_READ_FILE_USN_DATA = 0x000900EB
Global Const $FSCTL_READ_PROPERTY_DATA = 0x00090087
Global Const $FSCTL_READ_RAW_ENCRYPTED = 0x000900E3
Global Const $FSCTL_READ_USN_JOURNAL = 0x000900BB
Global Const $FSCTL_RECALL_FILE = 0x00090117
Global Const $FSCTL_REQUEST_BATCH_OPLOCK = 0x00090008
Global Const $FSCTL_REQUEST_FILTER_OPLOCK = 0x0009005C
Global Const $FSCTL_REQUEST_OPLOCK_LEVEL_1 = 0x00090000
Global Const $FSCTL_REQUEST_OPLOCK_LEVEL_2 = 0x00090004
Global Const $FSCTL_SECURITY_ID_CHECK = 0x000940B7
Global Const $FSCTL_SET_COMPRESSION = 0x0009C040
Global Const $FSCTL_SET_ENCRYPTION = 0x000900D7
Global Const $FSCTL_SET_OBJECT_ID = 0x00090098
Global Const $FSCTL_SET_OBJECT_ID_EXTENDED = 0x000900BC
Global Const $FSCTL_SET_REPARSE_POINT = 0x000900A4
Global Const $FSCTL_SET_SPARSE = 0x000900C4
Global Const $FSCTL_SET_ZERO_DATA = 0x000980C8
Global Const $FSCTL_SIS_COPYFILE = 0x00090100
Global Const $FSCTL_SIS_LINK_FILES = 0x0009C104
Global Const $FSCTL_UNLOCK_VOLUME = 0x0009001C
Global Const $FSCTL_WRITE_PROPERTY_DATA = 0x0009008B
Global Const $FSCTL_WRITE_RAW_ENCRYPTED = 0x000900DF
Global Const $FSCTL_WRITE_USN_CLOSE_RECORD = 0x000900EF

Global Const $IOCTL_AACS_END_SESSION = 0x003350CC
Global Const $IOCTL_AACS_GENERATE_BINDING_NONCE = 0x0033D0F0
Global Const $IOCTL_AACS_GET_CERTIFICATE = 0x003350D4
Global Const $IOCTL_AACS_GET_CHALLENGE_KEY = 0x003350D8
Global Const $IOCTL_AACS_READ_BINDING_NONCE = 0x003350EC
Global Const $IOCTL_AACS_READ_MEDIA_ID = 0x003350E8
Global Const $IOCTL_AACS_READ_MEDIA_KEY_BLOCK = 0x003350C4
Global Const $IOCTL_AACS_READ_MEDIA_KEY_BLOCK_SIZE = 0x003350C0
Global Const $IOCTL_AACS_READ_SERIAL_NUMBER = 0x003350E4
Global Const $IOCTL_AACS_READ_VOLUME_ID = 0x003350E0
Global Const $IOCTL_AACS_SEND_CERTIFICATE = 0x003350D0
Global Const $IOCTL_AACS_SEND_CHALLENGE_KEY = 0x003350DC
Global Const $IOCTL_AACS_START_SESSION = 0x003350C8

Global Const $IOCTL_ATA_PASS_THROUGH = 0x0004D02C
Global Const $IOCTL_ATA_PASS_THROUGH_DIRECT = 0x0004D030

Global Const $IOCTL_CDROM_CHECK_VERIFY = 0x00024800
Global Const $IOCTL_CDROM_DISK_TYPE = 0x00020040
Global Const $IOCTL_CDROM_EJECT_MEDIA = 0x00024808
Global Const $IOCTL_CDROM_FIND_NEW_DEVICES = 0x00024818
Global Const $IOCTL_CDROM_GET_CONFIGURATION = 0x00024058
Global Const $IOCTL_CDROM_GET_CONTROL = 0x00024034
Global Const $IOCTL_CDROM_GET_DRIVE_GEOMETRY = 0x0002404C
Global Const $IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX = 0x00024050
Global Const $IOCTL_CDROM_GET_LAST_SESSION = 0x00024038
Global Const $IOCTL_CDROM_GET_VOLUME = 0x00024014
Global Const $IOCTL_CDROM_LOAD_MEDIA = 0x0002480C
Global Const $IOCTL_CDROM_MEDIA_REMOVAL = 0x00024804
Global Const $IOCTL_CDROM_PAUSE_AUDIO = 0x0002400C
Global Const $IOCTL_CDROM_PLAY_AUDIO_MSF = 0x00024018
Global Const $IOCTL_CDROM_RAW_READ = 0x0002403E
Global Const $IOCTL_CDROM_READ_Q_CHANNEL = 0x0002402C
Global Const $IOCTL_CDROM_READ_TOC = 0x00024000
Global Const $IOCTL_CDROM_READ_TOC_EX = 0x00024054
Global Const $IOCTL_CDROM_RELEASE = 0x00024814
Global Const $IOCTL_CDROM_RESERVE = 0x00024810
Global Const $IOCTL_CDROM_RESUME_AUDIO = 0x00024010
Global Const $IOCTL_CDROM_SEEK_AUDIO_MSF = 0x00024004
Global Const $IOCTL_CDROM_SET_VOLUME = 0x00024028
Global Const $IOCTL_CDROM_STOP_AUDIO = 0x00024008
Global Const $IOCTL_CDROM_UNLOAD_DRIVER = 0x00025008

Global Const $IOCTL_DISK_CHECK_VERIFY = 0x00074800
Global Const $IOCTL_DISK_CONTROLLER_NUMBER = 0x00070044
Global Const $IOCTL_DISK_CREATE_DISK = 0x0007C058
Global Const $IOCTL_DISK_DELETE_DRIVE_LAYOUT = 0x0007C100
Global Const $IOCTL_DISK_EJECT_MEDIA = 0x00074808
Global Const $IOCTL_DISK_FIND_NEW_DEVICES = 0x00074818
Global Const $IOCTL_DISK_FORMAT_TRACKS = 0x0007C018
Global Const $IOCTL_DISK_FORMAT_TRACKS_EX = 0x0007C02C
Global Const $IOCTL_DISK_GET_CACHE_INFORMATION = 0x000740D4
Global Const $IOCTL_DISK_GET_DRIVE_GEOMETRY = 0x00070000
Global Const $IOCTL_DISK_GET_DRIVE_GEOMETRY_EX = 0x000700A0
Global Const $IOCTL_DISK_GET_DRIVE_LAYOUT = 0x0007400C
Global Const $IOCTL_DISK_GET_DRIVE_LAYOUT_EX = 0x00070050
Global Const $IOCTL_DISK_GET_LENGTH_INFO = 0x0007405C
Global Const $IOCTL_DISK_GET_MEDIA_TYPES = 0x00070C00
Global Const $IOCTL_DISK_GET_PARTITION_INFO = 0x00074004
Global Const $IOCTL_DISK_GET_PARTITION_INFO_EX = 0x00070048
Global Const $IOCTL_DISK_GET_WRITE_CACHE_STATE = 0x000740DC
Global Const $IOCTL_DISK_GROW_PARTITION = 0x0007C0D0
Global Const $IOCTL_DISK_HISTOGRAM_DATA = 0x00070034
Global Const $IOCTL_DISK_HISTOGRAM_RESET = 0x00070038
Global Const $IOCTL_DISK_HISTOGRAM_STRUCTURE = 0x00070030
Global Const $IOCTL_DISK_INTERNAL_CLEAR_VERIFY = 0x00070407
Global Const $IOCTL_DISK_INTERNAL_SET_NOTIFY = 0x00070408
Global Const $IOCTL_DISK_INTERNAL_SET_VERIFY = 0x00070403
Global Const $IOCTL_DISK_IS_WRITABLE = 0x00070024
Global Const $IOCTL_DISK_LOAD_MEDIA = 0x0007480C
Global Const $IOCTL_DISK_LOGGING = 0x00070028
Global Const $IOCTL_DISK_MEDIA_REMOVAL = 0x00074804
Global Const $IOCTL_DISK_PERFORMANCE = 0x00070020
Global Const $IOCTL_DISK_PERFORMANCE_OFF = 0x00070060
Global Const $IOCTL_DISK_REASSIGN_BLOCKS = 0x0007C01C
Global Const $IOCTL_DISK_RELEASE = 0x00074814
Global Const $IOCTL_DISK_REQUEST_DATA = 0x00070040
Global Const $IOCTL_DISK_REQUEST_STRUCTURE = 0x0007003C
Global Const $IOCTL_DISK_RESERVE = 0x00074810
Global Const $IOCTL_DISK_SET_CACHE_INFORMATION = 0x0007C0D8
Global Const $IOCTL_DISK_SET_DRIVE_LAYOUT = 0x0007C010
Global Const $IOCTL_DISK_SET_DRIVE_LAYOUT_EX = 0x0007C054
Global Const $IOCTL_DISK_SET_PARTITION_INFO = 0x0007C008
Global Const $IOCTL_DISK_SET_PARTITION_INFO_EX = 0x0007C04C
Global Const $IOCTL_DISK_UPDATE_DRIVE_SIZE = 0x0007C0C8
Global Const $IOCTL_DISK_UPDATE_PROPERTIES = 0x00070140
Global Const $IOCTL_DISK_VERIFY = 0x00070014

Global Const $IOCTL_DVD_END_SESSION = 0x0033500C
Global Const $IOCTL_DVD_GET_REGION = 0x00335014
Global Const $IOCTL_DVD_READ_KEY = 0x00335004
Global Const $IOCTL_DVD_READ_STRUCTURE = 0x00335140
Global Const $IOCTL_DVD_SEND_KEY = 0x00335008
Global Const $IOCTL_DVD_SEND_KEY2 = 0x0033D018
Global Const $IOCTL_DVD_SET_READ_AHEAD = 0x00335010
Global Const $IOCTL_DVD_START_SESSION = 0x00335000

Global Const $IOCTL_MOUNTDEV_LINK_CREATED = 0x004D0010
Global Const $IOCTL_MOUNTDEV_LINK_DELETED = 0x004D0014
Global Const $IOCTL_MOUNTDEV_QUERY_STABLE_GUID = 0x004D0018
Global Const $IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME = 0x004D000C
Global Const $IOCTL_MOUNTDEV_QUERY_UNIQUE_ID = 0x004D0000
Global Const $IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY = 0x004D0004

Global Const $IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS = 0x006DC014
Global Const $IOCTL_MOUNTMGR_CHANGE_NOTIFY = 0x006D4020
Global Const $IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES = 0x006D4028
Global Const $IOCTL_MOUNTMGR_CREATE_POINT = 0x006DC000
Global Const $IOCTL_MOUNTMGR_DELETE_POINTS = 0x006DC004
Global Const $IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY = 0x006DC00C
Global Const $IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE = 0x006DC024
Global Const $IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER = 0x006DC010
Global Const $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH = 0x006D0030
Global Const $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS = 0x006D0034
Global Const $IOCTL_MOUNTMGR_QUERY_POINTS = 0x006D0008
Global Const $IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION = 0x006D402C
Global Const $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED = 0x006DC018
Global Const $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED = 0x006DC01C

Global Const $IOCTL_SCSI_GET_INQUIRY_DATA = 0x0004100C
Global Const $IOCTL_SCSI_GET_CAPABILITIES = 0x00041010
Global Const $IOCTL_SCSI_GET_ADDRESS = 0x00041018
Global Const $IOCTL_SCSI_MINIPORT = 0x0004D008
Global Const $IOCTL_SCSI_PASS_THROUGH = 0x0004D004
Global Const $IOCTL_SCSI_PASS_THROUGH_DIRECT = 0x0004D014
Global Const $IOCTL_SCSI_RESCAN_BUS = 0x0004101C

Global Const $IOCTL_STORAGE_BREAK_RESERVATION = 0x002D5014
Global Const $IOCTL_STORAGE_CHECK_VERIFY = 0x002D4800
Global Const $IOCTL_STORAGE_CHECK_VERIFY2 = 0x002D0800
Global Const $IOCTL_STORAGE_EJECT_MEDIA = 0x002D4808
Global Const $IOCTL_STORAGE_EJECTION_CONTROL = 0x002D0940
Global Const $IOCTL_STORAGE_FIND_NEW_DEVICES = 0x002D4818
Global Const $IOCTL_STORAGE_GET_DEVICE_NUMBER = 0x002D1080
Global Const $IOCTL_STORAGE_GET_HOTPLUG_INFO = 0x002D0C14
Global Const $IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER = 0x002D0C10
Global Const $IOCTL_STORAGE_GET_MEDIA_TYPES = 0x002D0C00
Global Const $IOCTL_STORAGE_GET_MEDIA_TYPES_EX = 0x002D0C04
Global Const $IOCTL_STORAGE_LOAD_MEDIA = 0x002D480C
Global Const $IOCTL_STORAGE_LOAD_MEDIA2 = 0x002D080C
Global Const $IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES = 0x002D9404
Global Const $IOCTL_STORAGE_MCN_CONTROL = 0x002D0944
Global Const $IOCTL_STORAGE_MEDIA_REMOVAL = 0x002D4804
Global Const $IOCTL_STORAGE_PERSISTENT_RESERVE_IN = 0x002D5018
Global Const $IOCTL_STORAGE_PERSISTENT_RESERVE_OUT = 0x002D501C
Global Const $IOCTL_STORAGE_PREDICT_FAILURE = 0x002D1100
Global Const $IOCTL_STORAGE_QUERY_PROPERTY = 0x002D1400
Global Const $IOCTL_STORAGE_RELEASE = 0x002D4814
Global Const $IOCTL_STORAGE_RESERVE = 0x002D4810
Global Const $IOCTL_STORAGE_RESET_BUS = 0x002D5000
Global Const $IOCTL_STORAGE_RESET_DEVICE = 0x002D5004
Global Const $IOCTL_STORAGE_SET_HOTPLUG_INFO = 0x002DCC18
Global Const $IOCTL_STORAGE_SET_READ_AHEAD = 0x002D4400

Global Const $IOCTL_VOLUME_GET_GPT_ATTRIBUTES = 0x00560038
Global Const $IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS = 0x00560000
Global Const $IOCTL_VOLUME_IS_CLUSTERED = 0x00560030
Global Const $IOCTL_VOLUME_IS_IO_CAPABLE = 0x00560014
Global Const $IOCTL_VOLUME_IS_OFFLINE = 0x00560010
Global Const $IOCTL_VOLUME_IS_PARTITION = 0x00560028
Global Const $IOCTL_VOLUME_LOGICAL_TO_PHYSICAL = 0x00560020
Global Const $IOCTL_VOLUME_OFFLINE = 0x0056C00C
Global Const $IOCTL_VOLUME_ONLINE = 0x0056C008
Global Const $IOCTL_VOLUME_PHYSICAL_TO_LOGICAL = 0x00560024
Global Const $IOCTL_VOLUME_QUERY_FAILOVER_SET = 0x00560018
Global Const $IOCTL_VOLUME_QUERY_VOLUME_NUMBER = 0x0056001C
Global Const $IOCTL_VOLUME_READ_PLEX = 0x0056402E
Global Const $IOCTL_VOLUME_SET_GPT_ATTRIBUTES = 0x00560034
Global Const $IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE = 0x00560004

Global Const $SMART_GET_VERSION = 0x00074080
Global Const $SMART_RCV_DRIVE_DATA = 0x0007C088
Global Const $SMART_SEND_DRIVE_COMMAND = 0x0007C084

; ===============================================================================================================================
; _WinAPI_GetCurrentHwProfile()
; ===============================================================================================================================

Global Const $DOCKINFO_DOCKED = 0x02
Global Const $DOCKINFO_UNDOCKED = 0x01
Global Const $DOCKINFO_USER_SUPPLIED = 0x04
Global Const $DOCKINFO_USER_DOCKED = 0x05
Global Const $DOCKINFO_USER_UNDOCKED = 0x06

; ===============================================================================================================================
; _WinAPI_GetErrorMode(), _WinAPI_SetErrorMode()
; ===============================================================================================================================

Global Const $SEM_FAILCRITICALERRORS = 0x0001
Global Const $SEM_NOALIGNMENTFAULTEXCEPT = 0x0004
Global Const $SEM_NOGPFAULTERRORBOX = 0x0002
Global Const $SEM_NOOPENFILEERRORBOX = 0x8000

; ===============================================================================================================================
; _WinAPI_GetFileType()
; ===============================================================================================================================

Global Const $FILE_TYPE_CHAR = 0x0002
Global Const $FILE_TYPE_DISK = 0x0001
Global Const $FILE_TYPE_PIPE = 0x0003
Global Const $FILE_TYPE_REMOTE = 0x8000
Global Const $FILE_TYPE_UNKNOWN = 0x0000

; ===============================================================================================================================
; _WinAPI_DefineDosDevice()
; ===============================================================================================================================

Global Const $DDD_EXACT_MATCH_ON_REMOVE = 0x04
Global Const $DDD_NO_BROADCAST_SYSTEM = 0x08
Global Const $DDD_RAW_TARGET_PATH = 0x01
Global Const $DDD_REMOVE_DEFINITION = 0x02
; ===============================================================================================================================
; _WinAPI_DllGetVersion()
; ===============================================================================================================================

Global Const $DLLVER_PLATFORM_WINDOWS = 0x01
Global Const $DLLVER_PLATFORM_NT = 0x02

; ===============================================================================================================================
; _WinAPI_DrawShadowText()
; ===============================================================================================================================

#cs
	
	Global Const $DT_BOTTOM = 0x00000008
	Global Const $DT_CALCRECT = 0x00000400
	Global Const $DT_CENTER = 0x00000001
	Global Const $DT_EDITCONTROL = 0x00002000
	Global Const $DT_END_ELLIPSIS = 0x00008000
	Global Const $DT_EXPANDTABS = 0x00000040
	Global Const $DT_EXTERNALLEADING = 0x00000200
	Global Const $DT_HIDEPREFIX = 0x00100000
	Global Const $DT_INTERNAL = 0x00001000
	Global Const $DT_LEFT = 0x00000000
	Global Const $DT_MODIFYSTRING = 0x00010000
	Global Const $DT_NOCLIP = 0x00000100
	Global Const $DT_NOFULLWIDTHCHARBREAK = 0x00080000
	Global Const $DT_NOPREFIX = 0x00000800
	Global Const $DT_PATH_ELLIPSIS = 0x00004000
	Global Const $DT_PREFIXONLY = 0x00200000
	Global Const $DT_RIGHT = 0x00000002
	Global Const $DT_RTLREADING = 0x00020000
	Global Const $DT_SINGLELINE = 0x00000020
	Global Const $DT_TABSTOP = 0x00000080
	Global Const $DT_TOP = 0x00000000
	Global Const $DT_VCENTER = 0x00000004
	Global Const $DT_WORDBREAK = 0x00000010
	Global Const $DT_WORD_ELLIPSIS = 0x00040000
	
#ce

; ===============================================================================================================================
; _WinAPI_DrawThemeTextEx()
; ===============================================================================================================================

Global Const $DTT_TEXTCOLOR = 0x00000001
Global Const $DTT_BORDERCOLOR = 0x00000002
Global Const $DTT_SHADOWCOLOR = 0x00000004
Global Const $DTT_SHADOWTYPE = 0x00000008
Global Const $DTT_SHADOWOFFSET = 0x00000010
Global Const $DTT_BORDERSIZE = 0x00000020
Global Const $DTT_FONTPROP = 0x00000040
Global Const $DTT_COLORPROP = 0x00000080
Global Const $DTT_STATEID = 0x00000100
Global Const $DTT_CALCRECT = 0x00000200
Global Const $DTT_APPLYOVERLAY = 0x00000400
Global Const $DTT_GLOWSIZE = 0x00000800
Global Const $DTT_CALLBACK = 0x00001000
Global Const $DTT_COMPOSITED = 0x00002000
Global Const $DTT_VALIDBITS = BitOR($DTT_TEXTCOLOR, $DTT_BORDERCOLOR, $DTT_SHADOWCOLOR, $DTT_SHADOWTYPE, $DTT_SHADOWOFFSET, $DTT_BORDERSIZE, $DTT_FONTPROP, $DTT_COLORPROP, $DTT_STATEID, $DTT_CALCRECT, $DTT_APPLYOVERLAY, $DTT_GLOWSIZE, $DTT_COMPOSITED)

Global Const $TST_NONE = 0
Global Const $TST_SINGLE = 1
Global Const $TST_CONTINUOUS = 2

; ===============================================================================================================================
; _WinAPI_DwmGetWindowAttribute(), _WinAPI_DwmSetWindowAttribute()
; ===============================================================================================================================

Global Const $DWMWA_NCRENDERING_ENABLED = 1
Global Const $DWMWA_NCRENDERING_POLICY = 2
Global Const $DWMWA_TRANSITIONS_FORCEDISABLED = 3
Global Const $DWMWA_ALLOW_NCPAINT = 4
Global Const $DWMWA_CAPTION_BUTTON_BOUNDS = 5
Global Const $DWMWA_NONCLIENT_RTL_LAYOUT = 6
Global Const $DWMWA_FORCE_ICONIC_REPRESENTATION = 7
Global Const $DWMWA_FLIP3D_POLICY = 8
Global Const $DWMWA_EXTENDED_FRAME_BOUNDS = 9

; *Windows 7 or above
Global Const $DWMWA_HAS_ICONIC_BITMAP = 10
Global Const $DWMWA_DISALLOW_PEEK = 11
Global Const $DWMWA_EXCLUDED_FROM_PEEK = 12

Global Const $DWMNCRP_USEWINDOWSTYLE = 0
Global Const $DWMNCRP_DISABLED = 1
Global Const $DWMNCRP_ENABLED = 2

Global Const $DWMFLIP3D_DEFAULT = 0
Global Const $DWMFLIP3D_EXCLUDEBELOW = 1
Global Const $DWMFLIP3D_EXCLUDEABOVE = 2

; ===============================================================================================================================
; _WinAPI_EnumDisplaySettings()
; ===============================================================================================================================

Global Const $ENUM_CURRENT_SETTINGS = -1
Global Const $ENUM_REGISTRY_SETTINGS = -2

Global Const $DM_GRAYSCALE = 0x01
Global Const $DM_INTERLACED = 0x02

; ===============================================================================================================================
; _WinAPI_EnumDllProc()
; ===============================================================================================================================

Global Const $SYMOPT_ALLOW_ABSOLUTE_SYMBOLS = 0x00000800
Global Const $SYMOPT_ALLOW_ZERO_ADDRESS = 0x01000000
Global Const $SYMOPT_AUTO_PUBLICS = 0x00010000
Global Const $SYMOPT_CASE_INSENSITIVE = 0x00000001
Global Const $SYMOPT_DEBUG = 0x80000000
Global Const $SYMOPT_DEFERRED_LOADS = 0x00000004
Global Const $SYMOPT_DISABLE_SYMSRV_AUTODETECT = 0x02000000
Global Const $SYMOPT_EXACT_SYMBOLS = 0x00000400
Global Const $SYMOPT_FAIL_CRITICAL_ERRORS = 0x00000200
Global Const $SYMOPT_FAVOR_COMPRESSED = 0x00800000
Global Const $SYMOPT_FLAT_DIRECTORY = 0x00400000
Global Const $SYMOPT_IGNORE_CVREC = 0x00000080
Global Const $SYMOPT_IGNORE_IMAGEDIR = 0x00200000
Global Const $SYMOPT_IGNORE_NT_SYMPATH = 0x00001000
Global Const $SYMOPT_INCLUDE_32BIT_MODULES = 0x00002000
Global Const $SYMOPT_LOAD_ANYTHING = 0x00000040
Global Const $SYMOPT_LOAD_LINES = 0x00000010
Global Const $SYMOPT_NO_CPP = 0x00000008
Global Const $SYMOPT_NO_IMAGE_SEARCH = 0x00020000
Global Const $SYMOPT_NO_PROMPTS = 0x00080000
Global Const $SYMOPT_NO_PUBLICS = 0x00008000
Global Const $SYMOPT_NO_UNQUALIFIED_LOADS = 0x00000100
Global Const $SYMOPT_OVERWRITE = 0x00100000
Global Const $SYMOPT_PUBLICS_ONLY = 0x00004000
Global Const $SYMOPT_SECURE = 0x00040000
Global Const $SYMOPT_UNDNAME = 0x00000002

; ===============================================================================================================================
; _WinAPI_ExtFloodFill()
; ===============================================================================================================================

Global Const $FLOODFILLBORDER = 0
Global Const $FLOODFILLSURFACE = 1
; ===============================================================================================================================
; _WinAPI_ExtSelectClipRgn()
; ===============================================================================================================================

#cs
	
	Global Const $RGN_AND = 1
	Global Const $RGN_OR = 2
	Global Const $RGN_XOR = 3
	Global Const $RGN_DIFF = 4
	Global Const $RGN_COPY = 5
	
#ce

; ===============================================================================================================================
; _WinAPI_FindResource(), _WinAPI_FindResourceEx()
; ===============================================================================================================================

Global Const $RT_ACCELERATOR = 9
Global Const $RT_ANICURSOR = 21
Global Const $RT_ANIICON = 22
Global Const $RT_BITMAP = 2
Global Const $RT_CURSOR = 1
Global Const $RT_DIALOG = 5
Global Const $RT_DLGINCLUDE = 17
Global Const $RT_FONT = 8
Global Const $RT_FONTDIR = 7
Global Const $RT_GROUP_CURSOR = 12
Global Const $RT_GROUP_ICON = 14
Global Const $RT_HTML = 23
Global Const $RT_ICON = 3
Global Const $RT_MANIFEST = 24
Global Const $RT_MENU = 4
Global Const $RT_MESSAGETABLE = 11
Global Const $RT_PLUGPLAY = 19
Global Const $RT_RCDATA = 10
Global Const $RT_STRING = 6
Global Const $RT_VERSION = 16
Global Const $RT_VXD = 20

; ===============================================================================================================================
; _WinAPI_ReplaceFile()
; ===============================================================================================================================

Global Const $REPLACEFILE_WRITE_THROUGH = 0x01
Global Const $REPLACEFILE_IGNORE_MERGE_ERRORS = 0x02
Global Const $REPLACEFILE_IGNORE_ACL_ERRORS = 0x04

; ===============================================================================================================================
; _WinAPI_ResizeBitmap(), _WinAPI_SetStretchBltMode()
; ===============================================================================================================================

Global Const $BLACKONWHITE = 1
Global Const $COLORONCOLOR = 3
Global Const $HALFTONE = 4
Global Const $WHITEONBLACK = 2
Global Const $STRETCH_ANDSCANS = $BLACKONWHITE
Global Const $STRETCH_DELETESCANS = $COLORONCOLOR
Global Const $STRETCH_HALFTONE = $HALFTONE
Global Const $STRETCH_ORSCANS = $WHITEONBLACK

; ===============================================================================================================================
; _WinAPI_FormatDriveDlg()
; ===============================================================================================================================

Global Const $SHFMT_ID_DEFAULT = 0xFFFF

Global Const $SHFMT_OPT_FULL = 0x00
Global Const $SHFMT_OPT_QUICKFORMAT = 0x01
Global Const $SHFMT_OPT_SYSONLY = 0x02

Global Const $SHFMT_ERROR = -1
Global Const $SHFMT_CANCEL = -2
Global Const $SHFMT_NOFORMAT = -3

; ===============================================================================================================================
; _WinAPI_GetBinaryType()
; ===============================================================================================================================

Global Const $SCS_32BIT_BINARY = 0
Global Const $SCS_64BIT_BINARY = 6
Global Const $SCS_DOS_BINARY = 1
Global Const $SCS_OS216_BINARY = 5
Global Const $SCS_PIF_BINARY = 3
Global Const $SCS_POSIX_BINARY = 4
Global Const $SCS_WOW_BINARY = 2

; ===============================================================================================================================
; _WinAPI_GetClassLongEx(), _WinAPI_SetClassLongEx()
; ===============================================================================================================================

Global Const $GCL_CBCLSEXTRA = -20
Global Const $GCL_CBWNDEXTRA = -18
Global Const $GCL_HBRBACKGROUND = -10
Global Const $GCL_HCURSOR = -12
Global Const $GCL_HICON = -14
Global Const $GCL_HICONSM = -34
Global Const $GCL_HMODULE = -16
Global Const $GCL_MENUNAME = -8
Global Const $GCL_STYLE = -26
Global Const $GCL_WNDPROC = -24

; ===============================================================================================================================
; _WinAPI_GetCompression(), _WinAPI_SetCompression()
; ===============================================================================================================================

Global Const $COMPRESSION_FORMAT_NONE = 0
Global Const $COMPRESSION_FORMAT_DEFAULT = 1
Global Const $COMPRESSION_FORMAT_LZNT1 = 2

; ===============================================================================================================================
; _WinAPI_GetDateFormat()
; ===============================================================================================================================

Global Const $DATE_LONGDATE = 0x02
Global Const $DATE_SHORTDATE = 0x01
Global Const $DATE_USE_ALT_CALENDAR = 0x04

; *Windows Vista
Global Const $DATE_LTRREADING = 0x10
Global Const $DATE_RTLREADING = 0x20
Global Const $DATE_YEARMONTH = 0x08

; *Windows 7 and later
Global Const $DATE_AUTOLAYOUT = 0x40

; ===============================================================================================================================
; _WinAPI_GetDCEx()
; ===============================================================================================================================

Global Const $DCX_WINDOW = 0x00000001
Global Const $DCX_CACHE = 0x00000002
Global Const $DCX_PARENTCLIP = 0x00000020
Global Const $DCX_CLIPSIBLINGS = 0x00000010
Global Const $DCX_CLIPCHILDREN = 0x00000008
Global Const $DCX_NORESETATTRS = 0x00000004
Global Const $DCX_LOCKWINDOWUPDATE = 0x00000400
Global Const $DCX_EXCLUDERGN = 0x00000040
Global Const $DCX_INTERSECTRGN = 0x00000080
Global Const $DCX_INTERSECTUPDATE = 0x00000200
Global Const $DCX_VALIDATE = 0x00200000

; ===============================================================================================================================
; _WinAPI_GetDriveBusType()
; ===============================================================================================================================

Global Const $DRIVE_BUS_TYPE_UNKNOWN = 0x00
Global Const $DRIVE_BUS_TYPE_SCSI = 0x01
Global Const $DRIVE_BUS_TYPE_ATAPI = 0x02
Global Const $DRIVE_BUS_TYPE_ATA = 0x03
Global Const $DRIVE_BUS_TYPE_1394 = 0x04
Global Const $DRIVE_BUS_TYPE_SSA = 0x05
Global Const $DRIVE_BUS_TYPE_FIBRE = 0x06
Global Const $DRIVE_BUS_TYPE_USB = 0x07
Global Const $DRIVE_BUS_TYPE_RAID = 0x08
Global Const $DRIVE_BUS_TYPE_ISCSI = 0x09
Global Const $DRIVE_BUS_TYPE_SAS = 0x0A
Global Const $DRIVE_BUS_TYPE_SATA = 0x0B
Global Const $DRIVE_BUS_TYPE_SD = 0x0C
Global Const $DRIVE_BUS_TYPE_MMC = 0x0D

; ===============================================================================================================================
; _WinAPI_GetDriveNumber()
; ===============================================================================================================================

Global Const $FILE_DEVICE_8042_PORT = 0x27
Global Const $FILE_DEVICE_ACPI = 0x32
Global Const $FILE_DEVICE_BATTERY = 0x29
Global Const $FILE_DEVICE_BEEP = 0x01
Global Const $FILE_DEVICE_BUS_EXTENDER = 0x2A
Global Const $FILE_DEVICE_CD_ROM = 0x02
Global Const $FILE_DEVICE_CD_ROM_FILE_SYSTEM = 0x03
Global Const $FILE_DEVICE_CHANGER = 0x30
Global Const $FILE_DEVICE_CONTROLLER = 0x04
Global Const $FILE_DEVICE_DATALINK = 0x05
Global Const $FILE_DEVICE_DFS = 0x06
Global Const $FILE_DEVICE_DFS_FILE_SYSTEM = 0x35
Global Const $FILE_DEVICE_DFS_VOLUME = 0x36
Global Const $FILE_DEVICE_DISK = 0x07
Global Const $FILE_DEVICE_DISK_FILE_SYSTEM = 0x08
Global Const $FILE_DEVICE_DVD = 0x33
Global Const $FILE_DEVICE_FILE_SYSTEM = 0x09
Global Const $FILE_DEVICE_FIPS = 0x3A
Global Const $FILE_DEVICE_FULLSCREEN_VIDEO = 0x34
Global Const $FILE_DEVICE_INPORT_PORT = 0x0A
Global Const $FILE_DEVICE_KEYBOARD = 0x0B
Global Const $FILE_DEVICE_KS = 0x2F
Global Const $FILE_DEVICE_KSEC = 0x39
Global Const $FILE_DEVICE_MAILSLOT = 0x0C
Global Const $FILE_DEVICE_MASS_STORAGE = 0x2D
Global Const $FILE_DEVICE_MIDI_IN = 0x0D
Global Const $FILE_DEVICE_MIDI_OUT = 0x0E
Global Const $FILE_DEVICE_MODEM = 0x2B
Global Const $FILE_DEVICE_MOUSE = 0x0F
Global Const $FILE_DEVICE_MULTI_UNC_PROVIDER = 0x10
Global Const $FILE_DEVICE_NAMED_PIPE = 0x11
Global Const $FILE_DEVICE_NETWORK = 0x12
Global Const $FILE_DEVICE_NETWORK_BROWSER = 0x13
Global Const $FILE_DEVICE_NETWORK_FILE_SYSTEM = 0x14
Global Const $FILE_DEVICE_NETWORK_REDIRECTOR = 0x28
Global Const $FILE_DEVICE_NULL = 0x15
Global Const $FILE_DEVICE_PARALLEL_PORT = 0x16
Global Const $FILE_DEVICE_PHYSICAL_NETCARD = 0x17
Global Const $FILE_DEVICE_PRINTER = 0x18
Global Const $FILE_DEVICE_SCANNER = 0x19
Global Const $FILE_DEVICE_SCREEN = 0x1C
Global Const $FILE_DEVICE_SERENUM = 0x37
Global Const $FILE_DEVICE_SERIAL_MOUSE_PORT = 0x1A
Global Const $FILE_DEVICE_SERIAL_PORT = 0x1B
Global Const $FILE_DEVICE_SMARTCARD = 0x31
Global Const $FILE_DEVICE_SMB = 0x2E
Global Const $FILE_DEVICE_SOUND = 0x1D
Global Const $FILE_DEVICE_STREAMS = 0x1E
Global Const $FILE_DEVICE_TAPE = 0x1F
Global Const $FILE_DEVICE_TAPE_FILE_SYSTEM = 0x20
Global Const $FILE_DEVICE_TERMSRV = 0x38
Global Const $FILE_DEVICE_TRANSPORT = 0x21
Global Const $FILE_DEVICE_UNKNOWN = 0x22
Global Const $FILE_DEVICE_VDM = 0x2C
Global Const $FILE_DEVICE_VIDEO = 0x23
Global Const $FILE_DEVICE_VIRTUAL_DISK = 0x24
Global Const $FILE_DEVICE_WAVE_IN = 0x25
Global Const $FILE_DEVICE_WAVE_OUT = 0x26

; ===============================================================================================================================
; _WinAPI_GetDriveType()
; ===============================================================================================================================

Global Const $DRIVE_UNKNOWN = 0
Global Const $DRIVE_NO_ROOT_DIR = 1
Global Const $DRIVE_REMOVABLE = 2
Global Const $DRIVE_FIXED = 3
Global Const $DRIVE_REMOTE = 4
Global Const $DRIVE_CDROM = 5
Global Const $DRIVE_RAMDISK = 6

; ===============================================================================================================================
; _WinAPI_GetHandleInformation(), _WinAPI_SetHandleInformation()
; ===============================================================================================================================

Global Const $HANDLE_FLAG_INHERIT = 0x00000001
Global Const $HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x00000002

; ===============================================================================================================================
; _WinAPI_GetLayeredWindowAttributes(), _WinAPI_SetLayeredWindowAttributes()
; ===============================================================================================================================

#cs
	
	Global Const $LWA_COLORKEY = 0x01
	Global Const $LWA_ALPHA = 0x02
	
#ce

; ===============================================================================================================================
; _WinAPI_GetLocaleInfo(), _WinAPI_SetLocaleInfo()
; ===============================================================================================================================

Global Const $LOCALE_ILANGUAGE = 0x00000001 ; Language ID
Global Const $LOCALE_SLANGUAGE = 0x00000002 ; Localized name of language
Global Const $LOCALE_SENGLANGUAGE = 0x00001001 ; English name of language
Global Const $LOCALE_SABBREVLANGNAME = 0x00000003 ; Abbreviated language name
Global Const $LOCALE_SNATIVELANGNAME = 0x00000004 ; Native name of language

Global Const $LOCALE_ICOUNTRY = 0x00000005 ; Country code
Global Const $LOCALE_SCOUNTRY = 0x00000006 ; Localized name of country
Global Const $LOCALE_SENGCOUNTRY = 0x00001002 ; English name of country
Global Const $LOCALE_SABBREVCTRYNAME = 0x00000007 ; Abbreviated country name
Global Const $LOCALE_SNATIVECTRYNAME = 0x00000008 ; Native name of country

Global Const $LOCALE_IDEFAULTLANGUAGE = 0x00000009 ; Default language id
Global Const $LOCALE_IDEFAULTCOUNTRY = 0x0000000A ; Default country code
Global Const $LOCALE_IDEFAULTCODEPAGE = 0x0000000B ; Default oem code page
Global Const $LOCALE_IDEFAULTANSICODEPAGE = 0x00001004 ; Default ansi code page
Global Const $LOCALE_IDEFAULTMACCODEPAGE = 0x00001011 ; Default mac code page

Global Const $LOCALE_SLIST = 0x0000000C ; List item separator
Global Const $LOCALE_IMEASURE = 0x0000000D ; 0 = Metric, 1 = US

Global Const $LOCALE_SDECIMAL = 0x0000000E ; Decimal separator
Global Const $LOCALE_STHOUSAND = 0x0000000F ; Thousand separator
Global Const $LOCALE_SGROUPING = 0x00000010 ; Digit grouping
Global Const $LOCALE_IDIGITS = 0x00000011 ; Number of fractional digits
Global Const $LOCALE_ILZERO = 0x00000012 ; Leading zeros for decimal
Global Const $LOCALE_INEGNUMBER = 0x00001010 ; Negative number mode
Global Const $LOCALE_SNATIVEDIGITS = 0x00000013 ; Native ASCII 0-9

Global Const $LOCALE_SCURRENCY = 0x00000014 ; Local monetary symbol
Global Const $LOCALE_SINTLSYMBOL = 0x00000015 ; Intl monetary symbol
Global Const $LOCALE_SMONDECIMALSEP = 0x00000016 ; Monetary decimal separator
Global Const $LOCALE_SMONTHOUSANDSEP = 0x00000017 ; Monetary thousand separator
Global Const $LOCALE_SMONGROUPING = 0x00000018 ; Monetary grouping
Global Const $LOCALE_ICURRDIGITS = 0x00000019 ; # local monetary digits
Global Const $LOCALE_IINTLCURRDIGITS = 0x0000001A ; # intl monetary digits
Global Const $LOCALE_ICURRENCY = 0x0000001B ; Positive currency mode
Global Const $LOCALE_INEGCURR = 0x0000001C ; Negative currency mode

Global Const $LOCALE_SDATE = 0x0000001D ; Date separator
Global Const $LOCALE_STIME = 0x0000001E ; Time separator
Global Const $LOCALE_SSHORTDATE = 0x0000001F ; Short date format string
Global Const $LOCALE_SLONGDATE = 0x00000020 ; Long date format string
Global Const $LOCALE_STIMEFORMAT = 0x00001003 ; Time format string
Global Const $LOCALE_IDATE = 0x00000021 ; Short date format ordering
Global Const $LOCALE_ILDATE = 0x00000022 ; Long date format ordering
Global Const $LOCALE_ITIME = 0x00000023 ; Time format specifier
Global Const $LOCALE_ITIMEMARKPOSN = 0x00001005 ; Time marker position
Global Const $LOCALE_ICENTURY = 0x00000024 ; Century format specifier (short date)
Global Const $LOCALE_ITLZERO = 0x00000025 ; Leading zeros in time field
Global Const $LOCALE_IDAYLZERO = 0x00000026 ; Leading zeros in day field (short date)
Global Const $LOCALE_IMONLZERO = 0x00000027 ; Leading zeros in month field (short date)
Global Const $LOCALE_S1159 = 0x00000028 ; AM designator
Global Const $LOCALE_S2359 = 0x00000029 ; PM designator

Global Const $LOCALE_ICALENDARTYPE = 0x00001009 ; Type of calendar specifier
Global Const $LOCALE_IOPTIONALCALENDAR = 0x0000100B ; Additional calendar types specifier
Global Const $LOCALE_IFIRSTDAYOFWEEK = 0x0000100C ; First day of week specifier
Global Const $LOCALE_IFIRSTWEEKOFYEAR = 0x0000100D ; First week of year specifier

Global Const $LOCALE_SDAYNAME1 = 0x0000002A ; Long name for Monday
Global Const $LOCALE_SDAYNAME2 = 0x0000002B ; Long name for Tuesday
Global Const $LOCALE_SDAYNAME3 = 0x0000002C ; Long name for Wednesday
Global Const $LOCALE_SDAYNAME4 = 0x0000002D ; Long name for Thursday
Global Const $LOCALE_SDAYNAME5 = 0x0000002E ; Long name for Friday
Global Const $LOCALE_SDAYNAME6 = 0x0000002F ; Long name for Saturday
Global Const $LOCALE_SDAYNAME7 = 0x00000030 ; Long name for Sunday
Global Const $LOCALE_SABBREVDAYNAME1 = 0x00000031 ; Abbreviated name for Monday
Global Const $LOCALE_SABBREVDAYNAME2 = 0x00000032 ; Abbreviated name for Tuesday
Global Const $LOCALE_SABBREVDAYNAME3 = 0x00000033 ; Abbreviated name for Wednesday
Global Const $LOCALE_SABBREVDAYNAME4 = 0x00000034 ; Abbreviated name for Thursday
Global Const $LOCALE_SABBREVDAYNAME5 = 0x00000035 ; Abbreviated name for Friday
Global Const $LOCALE_SABBREVDAYNAME6 = 0x00000036 ; Abbreviated name for Saturday
Global Const $LOCALE_SABBREVDAYNAME7 = 0x00000037 ; Abbreviated name for Sunday
Global Const $LOCALE_SMONTHNAME1 = 0x00000038 ; Long name for January
Global Const $LOCALE_SMONTHNAME2 = 0x00000039 ; Long name for February
Global Const $LOCALE_SMONTHNAME3 = 0x0000003A ; Long name for March
Global Const $LOCALE_SMONTHNAME4 = 0x0000003B ; Long name for April
Global Const $LOCALE_SMONTHNAME5 = 0x0000003C ; Long name for May
Global Const $LOCALE_SMONTHNAME6 = 0x0000003D ; Long name for June
Global Const $LOCALE_SMONTHNAME7 = 0x0000003E ; Long name for July
Global Const $LOCALE_SMONTHNAME8 = 0x0000003F ; Long name for August
Global Const $LOCALE_SMONTHNAME9 = 0x00000040 ; Long name for September
Global Const $LOCALE_SMONTHNAME10 = 0x00000041 ; Long name for October
Global Const $LOCALE_SMONTHNAME11 = 0x00000042 ; Long name for November
Global Const $LOCALE_SMONTHNAME12 = 0x00000043 ; Long name for December
Global Const $LOCALE_SMONTHNAME13 = 0x0000100E ; long name for 13th month (if exists)
Global Const $LOCALE_SABBREVMONTHNAME1 = 0x00000044 ; Abbreviated name for January
Global Const $LOCALE_SABBREVMONTHNAME2 = 0x00000045 ; Abbreviated name for February
Global Const $LOCALE_SABBREVMONTHNAME3 = 0x00000046 ; Abbreviated name for March
Global Const $LOCALE_SABBREVMONTHNAME4 = 0x00000047 ; Abbreviated name for April
Global Const $LOCALE_SABBREVMONTHNAME5 = 0x00000048 ; Abbreviated name for May
Global Const $LOCALE_SABBREVMONTHNAME6 = 0x00000049 ; Abbreviated name for June
Global Const $LOCALE_SABBREVMONTHNAME7 = 0x0000004A ; Abbreviated name for July
Global Const $LOCALE_SABBREVMONTHNAME8 = 0x0000004B ; Abbreviated name for August
Global Const $LOCALE_SABBREVMONTHNAME9 = 0x0000004C ; Abbreviated name for September
Global Const $LOCALE_SABBREVMONTHNAME10 = 0x0000004D ; Abbreviated name for October
Global Const $LOCALE_SABBREVMONTHNAME11 = 0x0000004E ; Abbreviated name for November
Global Const $LOCALE_SABBREVMONTHNAME12 = 0x0000004F ; Abbreviated name for December
Global Const $LOCALE_SABBREVMONTHNAME13 = 0x0000100F ; Abbreviated name for 13th month (if exists)

Global Const $LOCALE_SPOSITIVESIGN = 0x00000050 ; Positive sign
Global Const $LOCALE_SNEGATIVESIGN = 0x00000051 ; Negative sign
Global Const $LOCALE_IPOSSIGNPOSN = 0x00000052 ; Positive sign position
Global Const $LOCALE_INEGSIGNPOSN = 0x00000053 ; Negative sign position
Global Const $LOCALE_IPOSSYMPRECEDES = 0x00000054 ; Mon sym precedes pos amt
Global Const $LOCALE_IPOSSEPBYSPACE = 0x00000055 ; Mon sym sep by space from pos amt
Global Const $LOCALE_INEGSYMPRECEDES = 0x00000056 ; Mon sym precedes neg amt
Global Const $LOCALE_INEGSEPBYSPACE = 0x00000057 ; Mon sym sep by space from neg amt

Global Const $LOCALE_FONTSIGNATURE = 0x00000058 ; Font signature
Global Const $LOCALE_SISO639LANGNAME = 0x00000059 ; ISO abbreviated language name
Global Const $LOCALE_SISO3166CTRYNAME = 0x0000005A ; ISO abbreviated country name

Global Const $LOCALE_IDEFAULTEBCDICCODEPAGE = 0x00001012 ; Default ebcdic code page
Global Const $LOCALE_IPAPERSIZE = 0x0000100A ; 0 = Letter, 1 = A4, 2 = Legal, 3 = A3
Global Const $LOCALE_SENGCURRNAME = 0x00001007 ; English name of currency
Global Const $LOCALE_SNATIVECURRNAME = 0x00001008 ; Native name of currency
Global Const $LOCALE_SYEARMONTH = 0x00001006 ; Year month format string
Global Const $LOCALE_SSORTNAME = 0x00001013 ; Sort name
Global Const $LOCALE_IDIGITSUBSTITUTION = 0x00001014 ; 0 = None, 1 = Context, 2 = Native digit

Global Const $LOCALE_CUSTOM_DEFAULT = 0x0C00
Global Const $LOCALE_CUSTOM_UI_DEFAULT = 0x1400
Global Const $LOCALE_CUSTOM_UNSPECIFIED = 0x1000

Global Const $LOCALE_INVARIANT = 0x007F
Global Const $LOCALE_SYSTEM_DEFAULT = 0x0800
Global Const $LOCALE_USER_DEFAULT = 0x0400

; ===============================================================================================================================
; _WinAPI_GetModuleHandleEx()
; ===============================================================================================================================

Global Const $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = 0x00000004
Global Const $GET_MODULE_HANDLE_EX_FLAG_PIN = 0x00000001
Global Const $GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = 0x00000002
Global Const $GET_MODULE_HANDLE_EX_FLAG_DEFAULT = 0x00000000

; ===============================================================================================================================
; _WinAPI_GetObjectType()
; ===============================================================================================================================

Global Const $OBJ_BITMAP = 7
Global Const $OBJ_BRUSH = 2
Global Const $OBJ_COLORSPACE = 14
Global Const $OBJ_DC = 3
Global Const $OBJ_ENHMETADC = 12
Global Const $OBJ_ENHMETAFILE = 13
Global Const $OBJ_EXTPEN = 11
Global Const $OBJ_FONT = 6
Global Const $OBJ_MEMDC = 10
Global Const $OBJ_METADC = 4
Global Const $OBJ_METAFILE = 9
Global Const $OBJ_PAL = 5
Global Const $OBJ_PEN = 1
Global Const $OBJ_REGION = 8

; ===============================================================================================================================
; _WinAPI_GetROP2(), _WinAPI_SetROP2()
; ===============================================================================================================================

Global Const $R2_BLACK = 1
Global Const $R2_COPYPEN = 13
Global Const $R2_LAST = 16
Global Const $R2_MASKNOTPEN = 3
Global Const $R2_MASKPEN = 9
Global Const $R2_MASKPENNOT = 5
Global Const $R2_MERGENOTPEN = 12
Global Const $R2_MERGEPEN = 15
Global Const $R2_MERGEPENNOT = 14
Global Const $R2_NOP = 11
Global Const $R2_NOT = 6
Global Const $R2_NOTCOPYPEN = 4
Global Const $R2_NOTMASKPEN = 8
Global Const $R2_NOTMERGEPEN = 2
Global Const $R2_NOTXORPEN = 10
Global Const $R2_WHITE = 16
Global Const $R2_XORPEN = 7

; ===============================================================================================================================
; _WinAPI_GetStartupInfo()
; ===============================================================================================================================

;Global Const $STARTF_FORCEONFEEDBACK = 0x00000040
;Global Const $STARTF_FORCEOFFFEEDBACK = 0x00000080
Global Const $STARTF_PREVENTPINNING = 0x00002000
;Global Const $STARTF_RUNFULLSCREEN = 0x00000020
Global Const $STARTF_TITLEISAPPID = 0x00001000
Global Const $STARTF_TITLEISLINKNAME = 0x00000800
;Global Const $STARTF_USECOUNTCHARS = 0x00000008
;Global Const $STARTF_USEFILLATTRIBUTE = 0x00000010
;Global Const $STARTF_USEHOTKEY = 0x00000200
;Global Const $STARTF_USEPOSITION = 0x00000004
;Global Const $STARTF_USESHOWWINDOW = 0x00000001
;Global Const $STARTF_USESIZE = 0x00000002
;Global Const $STARTF_USESTDHANDLES = 0x00000100

; ===============================================================================================================================
; _WinAPI_GetSystemInfo()
; ===============================================================================================================================

Global Const $PROCESSOR_ARCHITECTURE_AMD64 = 9
Global Const $PROCESSOR_ARCHITECTURE_IA64 = 6
Global Const $PROCESSOR_ARCHITECTURE_INTEL = 0
Global Const $PROCESSOR_ARCHITECTURE_UNKNOWN = 0xFFFF

Global Const $PROCESSOR_INTEL_386 = 386
Global Const $PROCESSOR_INTEL_486 = 486
Global Const $PROCESSOR_INTEL_PENTIUM = 586
Global Const $PROCESSOR_INTEL_IA64 = 2200
Global Const $PROCESSOR_AMD_X8664 = 8664

; ===============================================================================================================================
; _WinAPI_GetTextAlign(), _WinAPI_SetTextAlign()
; ===============================================================================================================================

Global Const $TA_BASELINE = 0x0018
Global Const $TA_BOTTOM = 0x0008
Global Const $TA_TOP = 0x0000
Global Const $TA_CENTER = 0x0006
Global Const $TA_LEFT = 0x0000
Global Const $TA_RIGHT = 0x0002
Global Const $TA_NOUPDATECP = 0x0000
Global Const $TA_RTLREADING = 0x0100
Global Const $TA_UPDATECP = 0x0001

Global Const $VTA_BASELINE = $TA_BASELINE
Global Const $VTA_BOTTOM = $TA_RIGHT
Global Const $VTA_TOP = $TA_LEFT
Global Const $VTA_CENTER = $TA_CENTER
Global Const $VTA_LEFT = $TA_BOTTOM
#cs
; ===============================================================================================================================
; _WinAPI_GetTextMetrics()
; ===============================================================================================================================

Global Const $TMPF_FIXED_PITCH = 0x01
Global Const $TMPF_VECTOR = 0x02
Global Const $TMPF_TRUETYPE = 0x04
Global Const $TMPF_DEVICE = 0x08
Global Const $VTA_RIGHT = $TA_TOP
#ce
; ===============================================================================================================================
; _WinAPI_GetThemeAppProperties(), _WinAPI_SetThemeAppProperties()
; ===============================================================================================================================

Global Const $STAP_ALLOW_NONCLIENT = 0x01
Global Const $STAP_ALLOW_CONTROLS = 0x02
Global Const $STAP_ALLOW_WEBCONTENT = 0x04

; ===============================================================================================================================
; _WinAPI_GetThemeDocumentationProperty()
; ===============================================================================================================================

Global Const $SZ_THDOCPROP_AUTHOR = 'Author'
Global Const $SZ_THDOCPROP_CANONICALNAME = 'ThemeName'
Global Const $SZ_THDOCPROP_DISPLAYNAME = 'DisplayName'
Global Const $SZ_THDOCPROP_TOOLTIP = 'ToolTip'

; ===============================================================================================================================
; _WinAPI_GetThemePartSize()
; ===============================================================================================================================

Global Const $TS_MIN = 0
Global Const $TS_TRUE = 1
Global Const $TS_DRAW = 2

; ===============================================================================================================================
; _WinAPI_GetTimeFormat()
; ===============================================================================================================================

Global Const $TIME_FORCE24HOURFORMAT = 0x08
Global Const $TIME_NOMINUTESORSECONDS = 0x01
Global Const $TIME_NOSECONDS = 0x02
Global Const $TIME_NOTIMEMARKER = 0x04

; ===============================================================================================================================
; _WinAPI_GetUserObjectInformation(), _WinAPI_SetUserObjectInformation()
; ===============================================================================================================================

Global Const $UOI_FLAGS = 1
Global Const $UOI_HEAPSIZE = 5
Global Const $UOI_IO = 6
Global Const $UOI_NAME = 2
Global Const $UOI_TYPE = 3
Global Const $UOI_USER_SID = 4

Global Const $DF_ALLOWOTHERACCOUNTHOOK = 0x01
Global Const $WSF_VISIBLE = 0x01

; ===============================================================================================================================
; _WinAPI_GetVersionEx()
; ===============================================================================================================================

Global Const $VER_SUITE_BACKOFFICE = 0x00000004
Global Const $VER_SUITE_BLADE = 0x00000400
Global Const $VER_SUITE_COMPUTE_SERVER = 0x00004000
Global Const $VER_SUITE_DATACENTER = 0x00000080
Global Const $VER_SUITE_ENTERPRISE = 0x00000002
Global Const $VER_SUITE_EMBEDDEDNT = 0x00000040
Global Const $VER_SUITE_PERSONAL = 0x00000200
Global Const $VER_SUITE_SINGLEUSERTS = 0x00000100
Global Const $VER_SUITE_SMALLBUSINESS = 0x00000001
Global Const $VER_SUITE_SMALLBUSINESS_RESTRICTED = 0x00000020
Global Const $VER_SUITE_STORAGE_SERVER = 0x00002000
Global Const $VER_SUITE_TERMINAL = 0x00000010
Global Const $VER_SUITE_WH_SERVER = 0x00008000

Global Const $VER_NT_DOMAIN_CONTROLLER = 0x0000002
Global Const $VER_NT_SERVER = 0x0000003
Global Const $VER_NT_WORKSTATION = 0x0000001

; ===============================================================================================================================
; _WinAPI_GetWindowDisplayAffinity(), _WinAPI_SetWindowDisplayAffinity()
; ===============================================================================================================================

Global Const $WDA_MONITOR = 0x01

; ===============================================================================================================================
; _WinAPI_GetWorldTransform(), _WinAPI_SetWorldTransform()
; ===============================================================================================================================

Global Const $MWT_IDENTITY = 0x01
Global Const $MWT_LEFTMULTIPLY = 0x02
Global Const $MWT_RIGHTMULTIPLY = 0x03
Global Const $MWT_SET = 0x04

; ===============================================================================================================================
; _WinAPI_IsNetworkAlive()
; ===============================================================================================================================

Global Const $NETWORK_ALIVE_LAN = 0x01
Global Const $NETWORK_ALIVE_WAN = 0x02
Global Const $NETWORK_ALIVE_AOL = 0x04

; ===============================================================================================================================
; _WinAPI_IsProcessorFeaturePresent()
; ===============================================================================================================================

Global Const $PF_3DNOW_INSTRUCTIONS_AVAILABLE = 7
Global Const $PF_CHANNELS_ENABLED = 16
Global Const $PF_COMPARE_EXCHANGE_DOUBLE = 2
Global Const $PF_COMPARE_EXCHANGE128 = 14
Global Const $PF_COMPARE64_EXCHANGE128 = 15
Global Const $PF_FLOATING_POINT_EMULATED = 1
Global Const $PF_FLOATING_POINT_PRECISION_ERRATA = 0
Global Const $PF_MMX_INSTRUCTIONS_AVAILABLE = 3
Global Const $PF_NX_ENABLED = 12
Global Const $PF_PAE_ENABLED = 9
Global Const $PF_RDTSC_INSTRUCTION_AVAILABLE = 8
Global Const $PF_SSE3_INSTRUCTIONS_AVAILABLE = 13
Global Const $PF_XMMI_INSTRUCTIONS_AVAILABLE = 6
Global Const $PF_XMMI64_INSTRUCTIONS_AVAILABLE = 10
Global Const $PF_XSAVE_ENABLED = 17

; ===============================================================================================================================
; _WinAPI_IsValidLocale()
; ===============================================================================================================================

Global Const $LCID_INSTALLED = 1
Global Const $LCID_SUPPORTED = 2

; ===============================================================================================================================
; _WinAPI_Keybd_Event()
; ===============================================================================================================================

Global Const $KEYEVENTF_EXTENDEDKEY = 0x01
Global Const $KEYEVENTF_KEYUP = 0x02

; ===============================================================================================================================
; _WinAPI_Keybd_Event() and similar
; ===============================================================================================================================

;Global Const $VK_LBUTTON = 0x01
;Global Const $VK_RBUTTON = 0x02
Global Const $VK_CANCEL = 0x03
;Global Const $VK_MBUTTON = 0x04
Global Const $VK_XBUTTON1 = 0x05
Global Const $VK_XBUTTON2 = 0x06
Global Const $VK_BACK = 0x08
Global Const $VK_TAB = 0x09
Global Const $VK_SHIFT = 0x10
Global Const $VK_CLEAR = 0x0C
Global Const $VK_RETURN = 0x0D
Global Const $VK_CONTROL = 0x11
Global Const $VK_MENU = 0x12
Global Const $VK_PAUSE = 0x13
Global Const $VK_CAPITAL = 0x14
Global Const $VK_ESCAPE = 0x1B
Global Const $VK_SPACE = 0x20
;Global Const $VK_PRIOR = 0x21
;Global Const $VK_NEXT = 0x22
;Global Const $VK_END = 0x23
;Global Const $VK_HOME = 0x24
;Global Const $VK_LEFT = 0x25
;Global Const $VK_UP = 0x26
;Global Const $VK_RIGHT = 0x27
;Global Const $VK_DOWN = 0x28
Global Const $VK_SELECT = 0x29
Global Const $VK_PRINT = 0x2A
Global Const $VK_EXECUTE = 0x2B
Global Const $VK_SNAPSHOT = 0x2C
Global Const $VK_INSERT = 0x2D
Global Const $VK_DELETE = 0x2E
Global Const $VK_HELP = 0x2F
Global Const $VK_0 = 0x30
Global Const $VK_1 = 0x31
Global Const $VK_2 = 0x32
Global Const $VK_3 = 0x33
Global Const $VK_4 = 0x34
Global Const $VK_5 = 0x35
Global Const $VK_6 = 0x36
Global Const $VK_7 = 0x37
Global Const $VK_8 = 0x38
Global Const $VK_9 = 0x39
Global Const $VK_A = 0x41
Global Const $VK_B = 0x42
Global Const $VK_C = 0x43
Global Const $VK_D = 0x44
Global Const $VK_E = 0x45
Global Const $VK_F = 0x46
Global Const $VK_G = 0x47
Global Const $VK_H = 0x48
Global Const $VK_I = 0x49
Global Const $VK_J = 0x4A
Global Const $VK_K = 0x4B
Global Const $VK_L = 0x4C
Global Const $VK_M = 0x4D
Global Const $VK_N = 0x4E
Global Const $VK_O = 0x4F
Global Const $VK_P = 0x50
Global Const $VK_Q = 0x51
Global Const $VK_R = 0x52
Global Const $VK_S = 0x53
Global Const $VK_T = 0x54
Global Const $VK_U = 0x55
Global Const $VK_V = 0x56
Global Const $VK_W = 0x57
Global Const $VK_X = 0x58
Global Const $VK_Y = 0x59
Global Const $VK_Z = 0x5A
Global Const $VK_LWIN = 0x5B
Global Const $VK_RWIN = 0x5C
Global Const $VK_APPS = 0x5D
Global Const $VK_SLEEP = 0x5F
Global Const $VK_NUMPAD0 = 0x60
Global Const $VK_NUMPAD1 = 0x61
Global Const $VK_NUMPAD2 = 0x62
Global Const $VK_NUMPAD3 = 0x63
Global Const $VK_NUMPAD4 = 0x64
Global Const $VK_NUMPAD5 = 0x65
Global Const $VK_NUMPAD6 = 0x66
Global Const $VK_NUMPAD7 = 0x67
Global Const $VK_NUMPAD8 = 0x68
Global Const $VK_NUMPAD9 = 0x69
Global Const $VK_MULTIPLY = 0x6A
Global Const $VK_ADD = 0x6B
Global Const $VK_SEPARATOR = 0x6C
Global Const $VK_SUBTRACT = 0x6D
Global Const $VK_DECIMAL = 0x6E
Global Const $VK_DIVIDE = 0x6F
Global Const $VK_F1 = 0x70
Global Const $VK_F2 = 0x71
Global Const $VK_F3 = 0x72
Global Const $VK_F4 = 0x73
Global Const $VK_F5 = 0x74
Global Const $VK_F6 = 0x75
Global Const $VK_F7 = 0x76
Global Const $VK_F8 = 0x77
Global Const $VK_F9 = 0x78
Global Const $VK_F10 = 0x79
Global Const $VK_F11 = 0x7A
Global Const $VK_F12 = 0x7B
Global Const $VK_F13 = 0x7C
Global Const $VK_F14 = 0x7D
Global Const $VK_F15 = 0x7E
Global Const $VK_F16 = 0x7F
Global Const $VK_F17 = 0x80
Global Const $VK_F18 = 0x81
Global Const $VK_F19 = 0x82
Global Const $VK_F20 = 0x83
Global Const $VK_F21 = 0x84
Global Const $VK_F22 = 0x85
Global Const $VK_F23 = 0x86
Global Const $VK_F24 = 0x87
Global Const $VK_NUMLOCK = 0x90
Global Const $VK_SCROLL = 0x91
Global Const $VK_LSHIFT = 0xA0
Global Const $VK_RSHIFT = 0xA1
Global Const $VK_LCONTROL = 0xA2
Global Const $VK_RCONTROL = 0xA3
Global Const $VK_LMENU = 0xA4
Global Const $VK_RMENU = 0xA5
Global Const $VK_BROWSER_BACK = 0xA6
Global Const $VK_BROWSER_FORWARD = 0xA7
Global Const $VK_BROWSER_REFRESH = 0xA8
Global Const $VK_BROWSER_STOP = 0xA9
Global Const $VK_BROWSER_SEARCH = 0xAA
Global Const $VK_BROWSER_FAVORITES = 0xAB
Global Const $VK_BROWSER_HOME = 0xAC
Global Const $VK_VOLUME_MUTE = 0xAD
Global Const $VK_VOLUME_DOWN = 0xAE
Global Const $VK_VOLUME_UP = 0xAF
Global Const $VK_MEDIA_NEXT_TRACK = 0xB0
Global Const $VK_MEDIA_PREV_TRACK = 0xB1
Global Const $VK_MEDIA_STOP = 0xB2
Global Const $VK_MEDIA_PLAY_PAUSE = 0xB3
Global Const $VK_LAUNCH_MAIL = 0xB4
Global Const $VK_LAUNCH_MEDIA_SELECT = 0xB5
Global Const $VK_LAUNCH_APP1 = 0xB6
Global Const $VK_LAUNCH_APP2 = 0xB7
Global Const $VK_OEM_1 = 0xBA ; ';:'
Global Const $VK_OEM_PLUS = 0xBB ; '=+'
Global Const $VK_OEM_COMMA = 0xBC ; ',<'
Global Const $VK_OEM_MINUS = 0xBD ; '-_'
Global Const $VK_OEM_PERIOD = 0xBE ; '.>'
Global Const $VK_OEM_2 = 0xBF ; '/?'
Global Const $VK_OEM_3 = 0xC0 ; '`~'
Global Const $VK_OEM_4 = 0xDB ; '[{'
Global Const $VK_OEM_5 = 0xDC ; '\|'
Global Const $VK_OEM_6 = 0xDD ; ']}'
Global Const $VK_OEM_7 = 0xDE ; ''"'
Global Const $VK_OEM_8 = 0xDF
Global Const $VK_OEM_102 = 0xE2
Global Const $VK_ATTN = 0xF6
Global Const $VK_CRSEL = 0xF7
Global Const $VK_EXSEL = 0xF8
Global Const $VK_EREOF = 0xF9
Global Const $VK_PLAY = 0xFA
Global Const $VK_ZOOM = 0xFB
Global Const $VK_NONAME = 0xFC
Global Const $VK_PA1 = 0xFD
Global Const $VK_OEM_CLEAR = 0xFE

; ===============================================================================================================================
; _WinAPI_LoadCursor()
; ===============================================================================================================================

#cs
	
	Global Const $IDC_APPSTARTING = 32650
	Global Const $IDC_HAND = 32649
	Global Const $IDC_ARROW = 32512
	Global Const $IDC_CROSS = 32515
	Global Const $IDC_IBEAM = 32513
	Global Const $IDC_ICON = 32641
	Global Const $IDC_NO = 32648
	Global Const $IDC_SIZE = 32640
	Global Const $IDC_SIZEALL = 32646
	Global Const $IDC_SIZENESW = 32643
	Global Const $IDC_SIZENS = 32645
	Global Const $IDC_SIZENWSE = 32642
	Global Const $IDC_SIZEWE = 32644
	Global Const $IDC_UPARROW = 32516
	Global Const $IDC_WAIT = 32514
	
#ce

; ===============================================================================================================================
; _WinAPI_LoadIconWithScaleDown()
; ===============================================================================================================================

#cs
	
	Global Const $IDI_APPLICATION = 32512
	Global Const $IDI_ASTERISK = 32516
	Global Const $IDI_EXCLAMATION = 32515
	Global Const $IDI_HAND = 32513
	Global Const $IDI_QUESTION = 32514
	Global Const $IDI_SHIELD = 32518
	Global Const $IDI_WINLOGO = 32517
	Global Const $IDI_ERROR = $IDI_HAND
	Global Const $IDI_INFORMATION = $IDI_ASTERISK
	Global Const $IDI_WARNING = $IDI_EXCLAMATION
	
#ce

; ===============================================================================================================================
; _WinAPI_LookupPrivilegeValue()
; ===============================================================================================================================

#cs
	
	Global Const $SE_ASSIGNPRIMARYTOKEN_NAME = 'SeAssignPrimaryTokenPrivilege'
	Global Const $SE_AUDIT_NAME = 'SeAuditPrivilege'
	Global Const $SE_BACKUP_NAME = 'SeBackupPrivilege'
	Global Const $SE_CHANGE_NOTIFY_NAME = 'SeChangeNotifyPrivilege'
	Global Const $SE_CREATE_GLOBAL_NAME = 'SeCreateGlobalPrivilege'
	Global Const $SE_CREATE_PAGEFILE_NAME = 'SeCreatePagefilePrivilege'
	Global Const $SE_CREATE_PERMANENT_NAME = 'SeCreatePermanentPrivilege'
	Global Const $SE_CREATE_SYMBOLIC_LINK_NAME = 'SeCreateSymbolicLinkPrivilege'
	Global Const $SE_CREATE_TOKEN_NAME = 'SeCreateTokenPrivilege'
	Global Const $SE_DEBUG_NAME = 'SeDebugPrivilege'
	Global Const $SE_ENABLE_DELEGATION_NAME = 'SeEnableDelegationPrivilege'
	Global Const $SE_IMPERSONATE_NAME = 'SeImpersonatePrivilege'
	Global Const $SE_INC_BASE_PRIORITY_NAME = 'SeIncreaseBasePriorityPrivilege'
	Global Const $SE_INCREASE_QUOTA_NAME = 'SeIncreaseQuotaPrivilege'
	Global Const $SE_INC_WORKING_SET_NAME = 'SeIncreaseWorkingSetPrivilege'
	Global Const $SE_LOAD_DRIVER_NAME = 'SeLoadDriverPrivilege'
	Global Const $SE_LOCK_MEMORY_NAME = 'SeLockMemoryPrivilege'
	Global Const $SE_MACHINE_ACCOUNT_NAME = 'SeMachineAccountPrivilege'
	Global Const $SE_MANAGE_VOLUME_NAME = 'SeManageVolumePrivilege'
	Global Const $SE_PROF_SINGLE_PROCESS_NAME = 'SeProfileSingleProcessPrivilege'
	Global Const $SE_RELABEL_NAME = 'SeRelabelPrivilege'
	Global Const $SE_REMOTE_SHUTDOWN_NAME = 'SeRemoteShutdownPrivilege'
	Global Const $SE_RESTORE_NAME = 'SeRestorePrivilege'
	Global Const $SE_SECURITY_NAME = 'SeSecurityPrivilege'
	Global Const $SE_SHUTDOWN_NAME = 'SeShutdownPrivilege'
	Global Const $SE_SYNC_AGENT_NAME = 'SeSyncAgentPrivilege'
	Global Const $SE_SYSTEM_ENVIRONMENT_NAME = 'SeSystemEnvironmentPrivilege'
	Global Const $SE_SYSTEM_PROFILE_NAME = 'SeSystemProfilePrivilege'
	Global Const $SE_SYSTEMTIME_NAME = 'SeSystemtimePrivilege'
	Global Const $SE_TAKE_OWNERSHIP_NAME = 'SeTakeOwnershipPrivilege'
	Global Const $SE_TCB_NAME = 'SeTcbPrivilege'
	Global Const $SE_TIME_ZONE_NAME = 'SeTimeZonePrivilege'
	Global Const $SE_TRUSTED_CREDMAN_ACCESS_NAME = 'SeTrustedCredManAccessPrivilege'
	Global Const $SE_UNDOCK_NAME = 'SeUndockPrivilege'
	Global Const $SE_UNSOLICITED_INPUT_NAME = 'SeUnsolicitedInputPrivilege'
	
#ce

; ===============================================================================================================================
; _WinAPI_LoadLibraryEx()
; ===============================================================================================================================

Global Const $LOAD_IGNORE_CODE_AUTHZ_LEVEL = 0x00000010
;Global Const $LOAD_LIBRARY_AS_DATAFILE = 0x00000002
Global Const $LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 0x00000040
Global Const $LOAD_LIBRARY_AS_IMAGE_RESOURCE = 0x00000020
Global Const $LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 0x00000200
Global Const $LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 0x00001000
Global Const $LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 0x00000100
Global Const $LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
Global Const $LOAD_LIBRARY_SEARCH_USER_DIRS = 0x00000400
;Global Const $LOAD_WITH_ALTERED_SEARCH_PATH = 0x00000008

; ===============================================================================================================================
; _WinAPI_MapVirtualKey()
; ===============================================================================================================================

Global Const $MAPVK_VK_TO_CHAR = 2
Global Const $MAPVK_VK_TO_VSC = 0
Global Const $MAPVK_VSC_TO_VK = 1
Global Const $MAPVK_VSC_TO_VK_EX = 3

; ===============================================================================================================================
; _WinAPI_MessageBoxCheck(), _WinAPI_MessageBoxIndirect()
; ===============================================================================================================================

#cs
	
	Global Const $MB_ABORTRETRYIGNORE = 0x00000002
	Global Const $MB_CANCELTRYCONTINUE = 0x00000006
	Global Const $MB_HELP = 0x00004000
	Global Const $MB_OK = 0x00000000
	Global Const $MB_OKCANCEL = 0x00000001
	Global Const $MB_RETRYCANCEL = 0x00000005
	Global Const $MB_YESNO = 0x00000004
	Global Const $MB_YESNOCANCEL = 0x00000003
	
	Global Const $MB_ICONEXCLAMATION = 0x00000030
	Global Const $MB_ICONWARNING = 0x00000030
	Global Const $MB_ICONINFORMATION = 0x00000040
	Global Const $MB_ICONASTERISK = 0x00000040
	Global Const $MB_ICONQUESTION = 0x00000020
	Global Const $MB_ICONSTOP = 0x00000010
	Global Const $MB_ICONERROR = 0x00000010
	Global Const $MB_ICONHAND = 0x00000010
	Global Const $MB_USERICON = 0x00000080
	
	Global Const $MB_DEFBUTTON1 = 0x00000000
	Global Const $MB_DEFBUTTON2 = 0x00000100
	Global Const $MB_DEFBUTTON3 = 0x00000200
	Global Const $MB_DEFBUTTON4 = 0x00000300
	
	Global Const $MB_APPLMODAL = 0x00000000
	Global Const $MB_SYSTEMMODAL = 0x00001000
	Global Const $MB_TASKMODAL = 0x00002000
	
	Global Const $MB_DEFAULT_DESKTOP_ONLY = 0x00020000
	Global Const $MB_RIGHT = 0x00080000
	Global Const $MB_RTLREADING = 0x00100000
	Global Const $MB_SETFOREGROUND = 0x00010000L
	Global Const $MB_TOPMOST = 0x00040000
	Global Const $MB_SERVICE_NOTIFICATION = 0x00200000
	
	Global Const $IDABORT = 3
	Global Const $IDCANCEL = 2
	Global Const $IDCONTINUE = 11
	Global Const $IDIGNORE = 5
	Global Const $IDNO = 7
	Global Const $IDOK = 1
	Global Const $IDRETRY = 4
	Global Const $IDTRYAGAIN = 10
	Global Const $IDYES = 6
	
#ce
; ===============================================================================================================================
; _WinAPI_OpenMutex()
; ===============================================================================================================================

Global Const $MUTEX_ALL_ACCESS = 0x001F0001
Global Const $MUTEX_MODIFY_STATE = 0x00000001

; ===============================================================================================================================
; _WinAPI_OpenJobObject(), _WinAPI_QueryInformationJobObject(), _WinAPI_SetInformationJobObject()
; ===============================================================================================================================

Global Const $JOB_OBJECT_ALL_ACCESS = 0x001F001F
Global Const $JOB_OBJECT_ASSIGN_PROCESS = 0x00000001
Global Const $JOB_OBJECT_QUERY = 0x00000004
Global Const $JOB_OBJECT_SET_ATTRIBUTES = 0x00000002
Global Const $JOB_OBJECT_SET_SECURITY_ATTRIBUTES = 0x00000010
Global Const $JOB_OBJECT_TERMINATE = 0x00000008

Global Const $JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 0x00000008
Global Const $JOB_OBJECT_LIMIT_AFFINITY = 0x00000010
Global Const $JOB_OBJECT_LIMIT_BREAKAWAY_OK = 0x00000800
Global Const $JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x00000400
Global Const $JOB_OBJECT_LIMIT_JOB_MEMORY = 0x00000200
Global Const $JOB_OBJECT_LIMIT_JOB_TIME = 0x00000004
Global Const $JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 0x00002000
Global Const $JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 0x00000040
Global Const $JOB_OBJECT_LIMIT_PRIORITY_CLASS = 0x00000020
Global Const $JOB_OBJECT_LIMIT_PROCESS_MEMORY = 0x00000100
Global Const $JOB_OBJECT_LIMIT_PROCESS_TIME = 0x00000002
Global Const $JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 0x00000080
Global Const $JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 0x00001000
Global Const $JOB_OBJECT_LIMIT_WORKINGSET = 0x00000001

Global Const $JOB_OBJECT_UILIMIT_DESKTOP = 0x00000040
Global Const $JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 0x00000010
Global Const $JOB_OBJECT_UILIMIT_EXITWINDOWS = 0x00000080
Global Const $JOB_OBJECT_UILIMIT_GLOBALATOMS = 0x00000020
Global Const $JOB_OBJECT_UILIMIT_HANDLES = 0x00000001
Global Const $JOB_OBJECT_UILIMIT_READCLIPBOARD = 0x00000002
Global Const $JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x00000008
Global Const $JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 0x00000004

Global Const $JOB_OBJECT_SECURITY_FILTER_TOKENS = 0x00000008
Global Const $JOB_OBJECT_SECURITY_NO_ADMIN = 0x00000001
Global Const $JOB_OBJECT_SECURITY_ONLY_TOKEN = 0x00000004
Global Const $JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 0x00000002

Global Const $JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0
Global Const $JOB_OBJECT_POST_AT_END_OF_JOB = 1

; ===============================================================================================================================
; _WinAPI_OpenProcessToken()
; ===============================================================================================================================

#cs
	
	Global Const $TOKEN_ADJUST_DEFAULT = 0x00000080
	Global Const $TOKEN_ADJUST_GROUPS = 0x00000040
	Global Const $TOKEN_ADJUST_PRIVILEGES = 0x00000020
	Global Const $TOKEN_ADJUST_SESSIONID = 0x00000100
	Global Const $TOKEN_ASSIGN_PRIMARY = 0x00000001
	Global Const $TOKEN_DUPLICATE = 0x00000002
	Global Const $TOKEN_EXECUTE = 0x00020000
	Global Const $TOKEN_IMPERSONATE = 0x00000004
	Global Const $TOKEN_QUERY = 0x00000008
	Global Const $TOKEN_QUERY_SOURCE = 0x00000010
	Global Const $TOKEN_READ = 0x00020008
	Global Const $TOKEN_WRITE = 0x000200E0
	Global Const $TOKEN_ALL_ACCESS = 0x000F01FF
	
#ce

; ===============================================================================================================================
; _WinAPI_OpenSemaphore()
; ===============================================================================================================================

Global Const $SEMAPHORE_ALL_ACCESS = 0x001F0003
Global Const $SEMAPHORE_MODIFY_STATE = 0x00000002

; ===============================================================================================================================
; _WinAPI_PageSetupDlg()
; ===============================================================================================================================

Global Const $PSD_DEFAULTMINMARGINS = 0x00000000
Global Const $PSD_DISABLEMARGINS = 0x00000010
Global Const $PSD_DISABLEORIENTATION = 0x00000100
Global Const $PSD_DISABLEPAGEPAINTING = 0x00080000
Global Const $PSD_DISABLEPAPER = 0x00000200
Global Const $PSD_DISABLEPRINTER = 0x00000020
Global Const $PSD_ENABLEPAGEPAINTHOOK = 0x00040000
Global Const $PSD_ENABLEPAGESETUPHOOK = 0x00002000
Global Const $PSD_ENABLEPAGESETUPTEMPLATE = 0x00008000
Global Const $PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 0x00020000
Global Const $PSD_INHUNDREDTHSOFMILLIMETERS = 0x00000008
Global Const $PSD_INTHOUSANDTHSOFINCHES = 0x00000004
Global Const $PSD_MARGINS = 0x00000002
Global Const $PSD_MINMARGINS = 0x00000001
Global Const $PSD_NONETWORKBUTTON = 0x00200000
Global Const $PSD_NOWARNING = 0x00000080
Global Const $PSD_RETURNDEFAULT = 0x00000400
Global Const $PSD_SHOWHELP = 0x00000800

Global Const $WM_PSD_PAGESETUPDLG = $WM_USER
Global Const $WM_PSD_FULLPAGERECT = $WM_USER + 1
Global Const $WM_PSD_MINMARGINRECT = $WM_USER + 2
Global Const $WM_PSD_MARGINRECT = $WM_USER + 3
Global Const $WM_PSD_GREEKTEXTRECT = $WM_USER + 4
Global Const $WM_PSD_ENVSTAMPRECT = $WM_USER + 5
Global Const $WM_PSD_YAFULLPAGERECT = $WM_USER + 6

; ===============================================================================================================================
; _WinAPI_PathGetCharType()
; ===============================================================================================================================

Global Const $GCT_INVALID = 0x00
Global Const $GCT_LFNCHAR = 0x01
Global Const $GCT_SEPARATOR = 0x08
Global Const $GCT_SHORTCHAR = 0x02
Global Const $GCT_WILD = 0x04

; ===============================================================================================================================
; _WinAPI_PlaySound()
; ===============================================================================================================================

Global Const $SND_APPLICATION = 0x00000080
Global Const $SND_ALIAS = 0x00010000
Global Const $SND_ALIAS_ID = 0x00110000
Global Const $SND_ASYNC = 0x00000001
Global Const $SND_FILENAME = 0x00020000
Global Const $SND_LOOP = 0x00000008
Global Const $SND_MEMORY = 0x00000004
Global Const $SND_NODEFAULT = 0x00000002
Global Const $SND_NOSTOP = 0x00000010
Global Const $SND_NOWAIT = 0x00002000
Global Const $SND_PURGE = 0x00000040
Global Const $SND_RESOURCE = 0x00040004
Global Const $SND_SYNC = 0x00000000

; *Windows Vista and later
Global Const $SND_SENTRY = 0x00080000
Global Const $SND_SYSTEM = 0x00200000

Global Const $SND_ALIAS_SYSTEMASTERISK = 'SystemAsterisk'
Global Const $SND_ALIAS_SYSTEMDEFAULT = 'SystemDefault'
Global Const $SND_ALIAS_SYSTEMEXCLAMATION = 'SystemExclamation'
Global Const $SND_ALIAS_SYSTEMEXIT = 'SystemExit'
Global Const $SND_ALIAS_SYSTEMHAND = 'SystemHand'
Global Const $SND_ALIAS_SYSTEMQUESTION = 'SystemQuestion'
Global Const $SND_ALIAS_SYSTEMSTART = 'SystemStart'
Global Const $SND_ALIAS_SYSTEMWELCOME = 'SystemWelcome'

; ===============================================================================================================================
; _WinAPI_PrintDlg(), _WinAPI_PrintDlgEx()
; ===============================================================================================================================

Global Const $PD_ALLPAGES = 0x00000000
Global Const $PD_COLLATE = 0x00000010
Global Const $PD_CURRENTPAGE = 0x00400000
Global Const $PD_DISABLEPRINTTOFILE = 0x00080000
Global Const $PD_ENABLEPRINTHOOK = 0x00001000
Global Const $PD_ENABLEPRINTTEMPLATE = 0x00004000
Global Const $PD_ENABLEPRINTTEMPLATEHANDLE = 0x00010000
Global Const $PD_ENABLESETUPHOOK = 0x00002000
Global Const $PD_ENABLESETUPTEMPLATE = 0x00008000
Global Const $PD_ENABLESETUPTEMPLATEHANDLE = 0x00020000
Global Const $PD_EXCLUSIONFLAGS = 0x01000000
Global Const $PD_HIDEPRINTTOFILE = 0x00100000
Global Const $PD_NOCURRENTPAGE = 0x00800000
Global Const $PD_NONETWORKBUTTON = 0x00200000
Global Const $PD_NOPAGENUMS = 0x00000008
Global Const $PD_NOSELECTION = 0x00000004
Global Const $PD_NOWARNING = 0x00000080
Global Const $PD_PAGENUMS = 0x00000002
Global Const $PD_PRINTSETUP = 0x00000040
Global Const $PD_PRINTTOFILE = 0x00000020
Global Const $PD_RETURNDC = 0x00000100
Global Const $PD_RETURNDEFAULT = 0x00000400
Global Const $PD_RETURNIC = 0x00000200
Global Const $PD_SELECTION = 0x00000001
Global Const $PD_SHOWHELP = 0x00000800
Global Const $PD_USEDEVMODECOPIES = 0x00040000
Global Const $PD_USEDEVMODECOPIESANDCOLLATE = $PD_USEDEVMODECOPIES
Global Const $PD_USELARGETEMPLATE = 0x10000000

Global Const $PD_RESULT_APPLY = 2
Global Const $PD_RESULT_CANCEL = 0
Global Const $PD_RESULT_PRINT = 1

; ===============================================================================================================================
; _WinAPI_PolyDraw()
; ===============================================================================================================================

Global Const $PT_BEZIERTO = 4
Global Const $PT_LINETO = 2
Global Const $PT_MOVETO = 6
Global Const $PT_CLOSEFIGURE = 1

; ===============================================================================================================================
; _WinAPI_RegisterApplicationRestart()
; ===============================================================================================================================

Global Const $RESTART_NO_CRASH = 0x01
Global Const $RESTART_NO_HANG = 0x02
Global Const $RESTART_NO_PATCH = 0x04
Global Const $RESTART_NO_REBOOT = 0x08

; ===============================================================================================================================
; _WinAPI_RegisterHotKey()
; ===============================================================================================================================

Global Const $MOD_ALT = 0x0001
Global Const $MOD_CONTROL = 0x0002
Global Const $MOD_SHIFT = 0x0004
Global Const $MOD_WIN = 0x0008
Global Const $MOD_NOREPEAT = 0x4000 ; Required Windows 7 and later

; ===============================================================================================================================
; _WinAPI_RegisterPowerSettingNotification()
; ===============================================================================================================================

Global Const $GUID_ACDC_POWER_SOURCE = '{5D3E9A59-E9D5-4B00-A6BD-FF34FF516548}'
Global Const $GUID_BATTERY_PERCENTAGE_REMAINING = '{A7AD8041-B45A-4CAE-87A3-EECBB468A9E1}'
Global Const $GUID_IDLE_BACKGROUND_TASK = '{515C31D8-F734-163D-A0FD-11A08C91E8F1}'
Global Const $GUID_MONITOR_POWER_ON = '{02731015-4510-4526-99E6-E5A17EBD1AEA}'
Global Const $GUID_POWERSCHEME_PERSONALITY = '{245D8541-3943-4422-B025-13A784F679B7}'
Global Const $GUID_SYSTEM_AWAYMODE = '{98A7F580-01F7-48AA-9C0F-44352C29E5C0}'

Global Const $GUID_MIN_POWER_SAVINGS = '{8C5E7FDA-E8BF-4A96-9A85-A6E23A8C635C}'
Global Const $GUID_MAX_POWER_SAVINGS = '{A1841308-3541-4FAB-BC81-F71556F20B4A}'
Global Const $GUID_TYPICAL_POWER_SAVINGS = '{381B4222-F694-41F0-9685-FF5BB260DF2E}'

; ===============================================================================================================================
; _WinAPI_RegisterShellHookWindow
; ===============================================================================================================================

Global Const $HSHELL_WINDOWCREATED = 1
Global Const $HSHELL_WINDOWDESTROYED = 2
Global Const $HSHELL_ACTIVATESHELLWINDOW = 3
Global Const $HSHELL_WINDOWACTIVATED = 4
Global Const $HSHELL_GETMINRECT = 5
Global Const $HSHELL_REDRAW = 6
Global Const $HSHELL_TASKMAN = 7
Global Const $HSHELL_LANGUAGE = 8
Global Const $HSHELL_SYSMENU = 9
Global Const $HSHELL_ENDTASK = 10
Global Const $HSHELL_ACCESSIBILITYSTATE = 11
Global Const $HSHELL_APPCOMMAND = 12
Global Const $HSHELL_WINDOWREPLACED = 13
Global Const $HSHELL_WINDOWREPLACING = 14
Global Const $HSHELL_RUDEAPPACTIVATED = 32772
Global Const $HSHELL_FLASH = 32774

; ===============================================================================================================================
; _WinAPI_Reg...
; ===============================================================================================================================


Global Const $HKEY_CLASSES_ROOT = 0x80000000
Global Const $HKEY_CURRENT_CONFIG = 0x80000005
Global Const $HKEY_CURRENT_USER = 0x80000001
Global Const $HKEY_LOCAL_MACHINE = 0x80000002
Global Const $HKEY_PERFORMANCE_DATA = 0x80000004
Global Const $HKEY_PERFORMANCE_NLSTEXT = 0x80000060
Global Const $HKEY_PERFORMANCE_TEXT = 0x80000050
Global Const $HKEY_USERS = 0x80000003

Global Const $KEY_ALL_ACCESS = 0xF003F
Global Const $KEY_CREATE_LINK = 0x0020
Global Const $KEY_CREATE_SUB_KEY = 0x0004
Global Const $KEY_ENUMERATE_SUB_KEYS = 0x0008
Global Const $KEY_EXECUTE = 0x20019
Global Const $KEY_NOTIFY = 0x0010
Global Const $KEY_QUERY_VALUE = 0x0001
Global Const $KEY_READ = 0x20019
Global Const $KEY_SET_VALUE = 0x0002
Global Const $KEY_WOW64_32KEY = 0x0200
Global Const $KEY_WOW64_64KEY = 0x0100
Global Const $KEY_WRITE = 0x20006

Global Const $REG_NOTIFY_CHANGE_NAME = 0x01
Global Const $REG_NOTIFY_CHANGE_ATTRIBUTES = 0x02
Global Const $REG_NOTIFY_CHANGE_LAST_SET = 0x04
Global Const $REG_NOTIFY_CHANGE_SECURITY = 0x08

Global Const $REG_OPTION_BACKUP_RESTORE = 0x04
Global Const $REG_OPTION_CREATE_LINK = 0x02
Global Const $REG_OPTION_NON_VOLATILE = 0x00
Global Const $REG_OPTION_VOLATILE = 0x01


#cs
	
	Global Const $REG_BINARY = 3
	Global Const $REG_DWORD = 4
	Global Const $REG_DWORD_BIG_ENDIAN = 5
	Global Const $REG_DWORD_LITTLE_ENDIAN = 4
	Global Const $REG_EXPAND_SZ = 2
	Global Const $REG_LINK = 6
	Global Const $REG_MULTI_SZ = 7
	Global Const $REG_NONE = 0
	Global Const $REG_QWORD = 11
	Global Const $REG_QWORD_LITTLE_ENDIAN = 11
	Global Const $REG_SZ = 1
	
#ce

; ===============================================================================================================================
; _WinAPI_RestartDlg()
; ===============================================================================================================================

Global Const $EWX_LOGOFF = 0
Global Const $EWX_POWEROFF = 8
Global Const $EWX_REBOOT = 2
Global Const $EWX_SHUTDOWN = 1
Global Const $EWX_FORCE = 4
Global Const $EWX_FORCEIFHUNG = 16

; ===============================================================================================================================
; _WinAPI_SendMessageTimeout()
; ===============================================================================================================================

Global Const $SMTO_BLOCK = 0x0001
Global Const $SMTO_NORMAL = 0x0000
Global Const $SMTO_ABORTIFHUNG = 0x0002
Global Const $SMTO_NOTIMEOUTIFNOTHUNG = 0x0008
Global Const $SMTO_ERRORONEXIT = 0x0020

; ===============================================================================================================================
; _WinAPI_SetKeyboardLayout()
; ===============================================================================================================================

Global Const $INPUTLANGCHANGE_BACKWARD = 0x0004
Global Const $INPUTLANGCHANGE_FORWARD = 0x0002
Global Const $INPUTLANGCHANGE_SYSCHARSET = 0x0001

; ===============================================================================================================================
; _WinAPI_SetSystemCursor()
; ===============================================================================================================================

#cs
	
	Global Const $OCR_APPSTARTING = 32650
	Global Const $OCR_NORMAL = 32512
	Global Const $OCR_CROSS = 32515
	Global Const $OCR_HAND = 32649
	Global Const $OCR_IBEAM = 32513
	Global Const $OCR_NO = 32648
	Global Const $OCR_SIZEALL = 32646
	Global Const $OCR_SIZENESW = 32643
	Global Const $OCR_SIZENS = 32645
	Global Const $OCR_SIZENWSE = 32642
	Global Const $OCR_SIZEWE = 32644
	Global Const $OCR_UP = 32516
	Global Const $OCR_WAIT = 32514
	Global Const $OCR_ICON = 32641
	Global Const $OCR_SIZE = 32640
	
#ce

; ===============================================================================================================================
; _WinAPI_SetWinEventHook()
; ===============================================================================================================================

Global Const $EVENT_MIN = 0x00000001
Global Const $EVENT_SYSTEM_SOUND = 0x00000001
Global Const $EVENT_SYSTEM_ALERT = 0x00000002
Global Const $EVENT_SYSTEM_FOREGROUND = 0x00000003
Global Const $EVENT_SYSTEM_MENUSTART = 0x00000004
Global Const $EVENT_SYSTEM_MENUEND = 0x00000005
Global Const $EVENT_SYSTEM_MENUPOPUPSTART = 0x00000006
Global Const $EVENT_SYSTEM_MENUPOPUPEND = 0x00000007
Global Const $EVENT_SYSTEM_CAPTURESTART = 0x00000008
Global Const $EVENT_SYSTEM_CAPTUREEND = 0x00000009
Global Const $EVENT_SYSTEM_MOVESIZESTART = 0x0000000A
Global Const $EVENT_SYSTEM_MOVESIZEEND = 0x0000000B
Global Const $EVENT_SYSTEM_CONTEXTHELPSTART = 0x0000000C
Global Const $EVENT_SYSTEM_CONTEXTHELPEND = 0x0000000D
Global Const $EVENT_SYSTEM_DRAGDROPSTART = 0x0000000E
Global Const $EVENT_SYSTEM_DRAGDROPEND = 0x0000000F
Global Const $EVENT_SYSTEM_DIALOGSTART = 0x00000010
Global Const $EVENT_SYSTEM_DIALOGEND = 0x00000011
Global Const $EVENT_SYSTEM_SCROLLINGSTART = 0x00000012
Global Const $EVENT_SYSTEM_SCROLLINGEND = 0x00000013
Global Const $EVENT_SYSTEM_SWITCHSTART = 0x00000014
Global Const $EVENT_SYSTEM_SWITCHEND = 0x00000015
Global Const $EVENT_SYSTEM_MINIMIZESTART = 0x00000016
Global Const $EVENT_SYSTEM_MINIMIZEEND = 0x00000017
Global Const $EVENT_SYSTEM_DESKTOPSWITCH = 0x00000020
Global Const $EVENT_OBJECT_CREATE = 0x00008000
Global Const $EVENT_OBJECT_DESTROY = 0x00008001
Global Const $EVENT_OBJECT_SHOW = 0x00008002
Global Const $EVENT_OBJECT_HIDE = 0x00008003
Global Const $EVENT_OBJECT_REORDER = 0x00008004
Global Const $EVENT_OBJECT_FOCUS = 0x00008005
Global Const $EVENT_OBJECT_SELECTION = 0x00008006
Global Const $EVENT_OBJECT_SELECTIONADD = 0x00008007
Global Const $EVENT_OBJECT_SELECTIONREMOVE = 0x00008008
Global Const $EVENT_OBJECT_SELECTIONWITHIN = 0x00008009
Global Const $EVENT_OBJECT_STATECHANGE = 0x0000800A
Global Const $EVENT_OBJECT_LOCATIONCHANGE = 0x0000800B
Global Const $EVENT_OBJECT_NAMECHANGE = 0x0000800C
Global Const $EVENT_OBJECT_DESCRIPTIONCHANGE = 0x0000800D
Global Const $EVENT_OBJECT_VALUECHANGE = 0x0000800E
Global Const $EVENT_OBJECT_PARENTCHANGE = 0x0000800F
Global Const $EVENT_OBJECT_HELPCHANGE = 0x00008010
Global Const $EVENT_OBJECT_DEFACTIONCHANGE = 0x00008011
Global Const $EVENT_OBJECT_ACCELERATORCHANGE = 0x00008012
Global Const $EVENT_OBJECT_INVOKED = 0x00008013
Global Const $EVENT_OBJECT_TEXTSELECTIONCHANGED = 0x00008014
Global Const $EVENT_OBJECT_CONTENTSCROLLED = 0x00008015
Global Const $EVENT_MAX = 0x7FFFFFFF

Global Const $WINEVENT_INCONTEXT = 0x04
Global Const $WINEVENT_OUTOFCONTEXT = 0x00
Global Const $WINEVENT_SKIPOWNPROCESS = 0x02
Global Const $WINEVENT_SKIPOWNTHREAD = 0x01

; ===============================================================================================================================
; _WinAPI_ShellChangeNotify()
; ===============================================================================================================================

Global Const $SHCNE_ALLEVENTS = 0x7FFFFFFF
Global Const $SHCNE_ASSOCCHANGED = 0x8000000
Global Const $SHCNE_ATTRIBUTES = 0x00000800
Global Const $SHCNE_CREATE = 0x00000002
Global Const $SHCNE_DELETE = 0x00000004
Global Const $SHCNE_DRIVEADD = 0x00000100
Global Const $SHCNE_DRIVEADDGUI = 0x00010000
Global Const $SHCNE_DRIVEREMOVED = 0x00000080
Global Const $SHCNE_EXTENDED_EVENT = 0x04000000
Global Const $SHCNE_FREESPACE = 0x00040000
Global Const $SHCNE_MEDIAINSERTED = 0x00000020
Global Const $SHCNE_MEDIAREMOVED = 0x00000040
Global Const $SHCNE_MKDIR = 0x00000008
Global Const $SHCNE_NETSHARE = 0x00000200
Global Const $SHCNE_NETUNSHARE = 0x00000400
Global Const $SHCNE_RENAMEFOLDER = 0x00020000
Global Const $SHCNE_RENAMEITEM = 0x00000001
Global Const $SHCNE_RMDIR = 0x00000010
Global Const $SHCNE_SERVERDISCONNECT = 0x00004000
Global Const $SHCNE_UPDATEDIR = 0x00001000
Global Const $SHCNE_UPDATEIMAGE = 0x00008000
Global Const $SHCNE_UPDATEITEM = 0x00002000
Global Const $SHCNE_DISKEVENTS = 0x0002381F
Global Const $SHCNE_GLOBALEVENTS = 0x0C0581E0
Global Const $SHCNE_INTERRUPT = 0x80000000

Global Const $SHCNF_DWORD = 0x00000003
Global Const $SHCNF_IDLIST = 0x00000000
Global Const $SHCNF_PATH = 0x00000001
Global Const $SHCNF_PRINTER = 0x00000002
Global Const $SHCNF_FLUSH = 0x00001000
Global Const $SHCNF_FLUSHNOWAIT = 0x00002000
Global Const $SHCNF_NOTIFYRECURSIVE = 0x00010000

; ===============================================================================================================================
; _WinAPI_ShellChangeNotifyRegister()
; ===============================================================================================================================

Global Const $SHCNRF_INTERRUPTLEVEL = 0x0001
Global Const $SHCNRF_SHELLLEVEL = 0x0002
Global Const $SHCNRF_RECURSIVEINTERRUPT = 0x1000
Global Const $SHCNRF_NEWDELIVERY = 0x8000

; ===============================================================================================================================
; _WinAPI_ShellEmptyRecycleBin()
; ===============================================================================================================================

Global Const $SHERB_NOCONFIRMATION = 0x01
Global Const $SHERB_NOPROGRESSUI = 0x02
Global Const $SHERB_NOSOUND = 0x04
Global Const $SHERB_NO_UI = BitOR($SHERB_NOCONFIRMATION, $SHERB_NOPROGRESSUI, $SHERB_NOSOUND)

; ===============================================================================================================================
; _WinAPI_ShellExecute()
; ===============================================================================================================================

Global Const $SE_ERR_ACCESSDENIED = 5
Global Const $SE_ERR_ASSOCINCOMPLETE = 27
Global Const $SE_ERR_DDEBUSY = 30
Global Const $SE_ERR_DDEFAIL = 29
Global Const $SE_ERR_DDETIMEOUT = 28
Global Const $SE_ERR_DLLNOTFOUND = 32
Global Const $SE_ERR_FNF = 2
Global Const $SE_ERR_NOASSOC = 31
Global Const $SE_ERR_OOM = 8
Global Const $SE_ERR_PNF = 3
Global Const $SE_ERR_SHARE = 26

; ===============================================================================================================================
; _WinAPI_ShellFileOperation()
; ===============================================================================================================================

Global Const $FO_COPY = 2
Global Const $FO_DELETE = 3
Global Const $FO_MOVE = 1
Global Const $FO_RENAME = 4

Global Const $FOF_ALLOWUNDO = 0x0040
Global Const $FOF_CONFIRMMOUSE = 0x0002
Global Const $FOF_FILESONLY = 0x0080
Global Const $FOF_MULTIDESTFILES = 0x0001
Global Const $FOF_NOCONFIRMATION = 0x0010
Global Const $FOF_NOCONFIRMMKDIR = 0x0200
Global Const $FOF_NO_CONNECTED_ELEMENTS = 0x2000
Global Const $FOF_NOCOPYSECURITYATTRIBS = 0x0800
Global Const $FOF_NOERRORUI = 0x0400
Global Const $FOF_NORECURSEREPARSE = 0x8000
Global Const $FOF_NORECURSION = 0x1000
Global Const $FOF_RENAMEONCOLLISION = 0x0008
Global Const $FOF_SILENT = 0x0004
Global Const $FOF_SIMPLEPROGRESS = 0x0100
Global Const $FOF_WANTMAPPINGHANDLE = 0x0020
Global Const $FOF_WANTNUKEWARNING = 0x4000
Global Const $FOF_NO_UI = BitOR($FOF_NOCONFIRMATION, $FOF_NOCONFIRMMKDIR, $FOF_NOERRORUI, $FOF_SILENT)

; ===============================================================================================================================
; _WinAPI_ShellObjectProperties()
; ===============================================================================================================================

Global Const $SHOP_PRINTERNAME = 1
Global Const $SHOP_FILEPATH = 2
Global Const $SHOP_VOLUMEGUID = 4

; ===============================================================================================================================
; _WinAPI_ShellGetFileInfo()
; ===============================================================================================================================

Global Const $SHGFI_ATTR_SPECIFIED = 0x00020000
Global Const $SHGFI_ATTRIBUTES = 0x00000800
Global Const $SHGFI_DISPLAYNAME = 0x00000200
Global Const $SHGFI_EXETYPE = 0x00002000
Global Const $SHGFI_ICON = 0x00000100
Global Const $SHGFI_ICONLOCATION = 0x00001000
Global Const $SHGFI_LARGEICON = 0x00000000
Global Const $SHGFI_LINKOVERLAY = 0x00008000
Global Const $SHGFI_OPENICON = 0x00000002
Global Const $SHGFI_OVERLAYINDEX = 0x00000040
Global Const $SHGFI_PIDL = 0x00000008
Global Const $SHGFI_SELECTED = 0x00010000
Global Const $SHGFI_SHELLICONSIZE = 0x00000004
Global Const $SHGFI_SMALLICON = 0x00000001
Global Const $SHGFI_SYSICONINDEX = 0x00004000
Global Const $SHGFI_TYPENAME = 0x00000400
Global Const $SHGFI_USEFILEATTRIBUTES = 0x00000010

; ===============================================================================================================================
; _WinAPI_ShellGetKnownFolderPath()
; ===============================================================================================================================

Global Const $FOLDERID_AddNewPrograms = '{DE61D971-5EBC-4F02-A3A9-6C82895E5C04}'
Global Const $FOLDERID_AdminTools = '{724EF170-A42D-4FEF-9F26-B60E846FBA4F}'
Global Const $FOLDERID_AppUpdates = '{A305CE99-F527-492B-8B1A-7E76FA98D6E4}'
Global Const $FOLDERID_CDBurning = '{9E52AB10-F80D-49DF-ACB8-4330F5687855}'
Global Const $FOLDERID_ChangeRemovePrograms = '{DF7266AC-9274-4867-8D55-3BD661DE872D}'
Global Const $FOLDERID_CommonAdminTools = '{D0384E7D-BAC3-4797-8F14-CBA229B392B5}'
Global Const $FOLDERID_CommonOEMLinks = '{C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}'
Global Const $FOLDERID_CommonPrograms = '{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}'
Global Const $FOLDERID_CommonStartMenu = '{A4115719-D62E-491D-AA7C-E74B8BE3B067}'
Global Const $FOLDERID_CommonStartup = '{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}'
Global Const $FOLDERID_CommonTemplates = '{B94237E7-57AC-4347-9151-B08C6C32D1F7}'
Global Const $FOLDERID_ComputerFolder = '{0AC0837C-BBF8-452A-850D-79D08E667CA7}'
Global Const $FOLDERID_ConflictFolder = '{4BFEFB45-347D-4006-A5BE-AC0CB0567192}'
Global Const $FOLDERID_ConnectionsFolder = '{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}'
Global Const $FOLDERID_Contacts = '{56784854-C6CB-462B-8169-88E350ACB882}'
Global Const $FOLDERID_ControlPanelFolder = '{82A74AEB-AEB4-465C-A014-D097EE346D63}'
Global Const $FOLDERID_Cookies = '{2B0F765D-C0E9-4171-908E-08A611B84FF6}'
Global Const $FOLDERID_Desktop = '{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}'
Global Const $FOLDERID_DeviceMetadataStore = '{5CE4A5E9-E4EB-479D-B89F-130C02886155}'
Global Const $FOLDERID_DocumentsLibrary = '{7B0DB17D-9CD2-4A93-9733-46CC89022E7C}'
Global Const $FOLDERID_Downloads = '{374DE290-123F-4565-9164-39C4925E467B}'
Global Const $FOLDERID_Favorites = '{1777F761-68AD-4D8A-87BD-30B759FA33DD}'
Global Const $FOLDERID_Fonts = '{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}'
Global Const $FOLDERID_Games = '{CAC52C1A-B53D-4EDC-92D7-6B2E8AC19434}'
Global Const $FOLDERID_GameTasks = '{054FAE61-4DD8-4787-80B6-090220C4B700}'
Global Const $FOLDERID_History = '{D9DC8A3B-B784-432E-A781-5A1130A75963}'
Global Const $FOLDERID_HomeGroup = '{52528A6B-B9E3-4ADD-B60D-588C2DBA842D}'
Global Const $FOLDERID_ImplicitAppShortcuts = '{BCB5256F-79F6-4CEE-B725-DC34E402FD46}'
Global Const $FOLDERID_InternetCache = '{352481E8-33BE-4251-BA85-6007CAEDCF9D}'
Global Const $FOLDERID_InternetFolder = '{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}'
Global Const $FOLDERID_Libraries = '{1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}'
Global Const $FOLDERID_Links = '{BFB9D5E0-C6A9-404C-B2B2-AE6DB6AF4968}'
Global Const $FOLDERID_LocalAppData = '{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}'
Global Const $FOLDERID_LocalAppDataLow = '{A520A1A4-1780-4FF6-BD18-167343C5AF16}'
Global Const $FOLDERID_LocalizedResourcesDir = '{2A00375E-224C-49DE-B8D1-440DF7EF3DDC}'
Global Const $FOLDERID_Music = '{4BD8D571-6D19-48D3-BE97-422220080E43}'
Global Const $FOLDERID_MusicLibrary = '{2112AB0A-C86A-4FFE-A368-0DE96E47012E}'
Global Const $FOLDERID_NetHood = '{C5ABBF53-E17F-4121-8900-86626FC2C973}'
Global Const $FOLDERID_NetworkFolder = '{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}'
Global Const $FOLDERID_OriginalImages = '{2C36C0AA-5812-4B87-BFD0-4CD0DFB19B39}'
Global Const $FOLDERID_PhotoAlbums = '{69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}'
Global Const $FOLDERID_PicturesLibrary = '{A990AE9F-A03B-4E80-94BC-9912D7504104}'
Global Const $FOLDERID_Pictures = '{33E28130-4E1E-4676-835A-98395C3BC3BB}'
Global Const $FOLDERID_Playlists = '{DE92C1C7-837F-4F69-A3BB-86E631204A23}'
Global Const $FOLDERID_PrintersFolder = '{76FC4E2D-D6AD-4519-A663-37BD56068185}'
Global Const $FOLDERID_PrintHood = '{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}'
Global Const $FOLDERID_Profile = '{5E6C858F-0E22-4760-9AFE-EA3317B67173}'
Global Const $FOLDERID_ProgramData = '{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}'
Global Const $FOLDERID_ProgramFiles = '{905E63B6-C1BF-494E-B29C-65B732D3D21A}'
Global Const $FOLDERID_ProgramFilesX64 = '{6D809377-6AF0-444B-8957-A3773F02200E}'
Global Const $FOLDERID_ProgramFilesX86 = '{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}'
Global Const $FOLDERID_ProgramFilesCommon = '{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}'
Global Const $FOLDERID_ProgramFilesCommonX64 = '{6365D5A7-0F0D-45E5-87F6-0DA56B6A4F7D}'
Global Const $FOLDERID_ProgramFilesCommonX86 = '{DE974D24-D9C6-4D3E-BF91-F4455120B917}'
Global Const $FOLDERID_Programs = '{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}'
Global Const $FOLDERID_Public = '{DFDF76A2-C82A-4D63-906A-5644AC457385}'
Global Const $FOLDERID_PublicDesktop = '{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}'
Global Const $FOLDERID_PublicDocuments = '{ED4824AF-DCE4-45A8-81E2-FC7965083634}'
Global Const $FOLDERID_PublicDownloads = '{3D644C9B-1FB8-4F30-9B45-F670235F79C0}'
Global Const $FOLDERID_PublicGameTasks = '{DEBF2536-E1A8-4C59-B6A2-414586476AEA}'
Global Const $FOLDERID_PublicLibraries = '{48DAF80B-E6CF-4F4E-B800-0E69D84EE384}'
Global Const $FOLDERID_PublicMusic = '{3214FAB5-9757-4298-BB61-92A9DEAA44FF}'
Global Const $FOLDERID_PublicPictures = '{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}'
Global Const $FOLDERID_PublicRingtones = '{E555AB60-153B-4D17-9F04-A5FE99FC15EC}'
Global Const $FOLDERID_PublicVideos = '{2400183A-6185-49FB-A2D8-4A392A602BA3}'
Global Const $FOLDERID_QuickLaunch = '{52A4F021-7B75-48A9-9F6B-4B87A210BC8F}'
Global Const $FOLDERID_Recent = '{AE50C081-EBD2-438A-8655-8A092E34987A}'
Global Const $FOLDERID_RecordedTVLibrary = '{1A6FDBA2-F42D-4358-A798-B74D745926C5}'
Global Const $FOLDERID_RecycleBinFolder = '{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}'
Global Const $FOLDERID_ResourceDir = '{8AD10C31-2ADB-4296-A8F7-E4701232C972}'
Global Const $FOLDERID_Ringtones = '{C870044B-F49E-4126-A9C3-B52A1FF411E8}'
Global Const $FOLDERID_RoamingAppData = '{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}'
Global Const $FOLDERID_SampleMusic = '{B250C668-F57D-4EE1-A63C-290EE7D1AA1F}'
Global Const $FOLDERID_SamplePictures = '{C4900540-2379-4C75-844B-64E6FAF8716B}'
Global Const $FOLDERID_SamplePlaylists = '{15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}'
Global Const $FOLDERID_SampleVideos = '{859EAD94-2E85-48AD-A71A-0969CB56A6CD}'
Global Const $FOLDERID_SavedGames = '{4C5C32FF-BB9D-43B0-B5B4-2D72E54EAAA4}'
Global Const $FOLDERID_SavedSearches = '{7D1D3A04-DEBB-4115-95CF-2F29DA2920DA}'
Global Const $FOLDERID_SEARCH_CSC = '{EE32E446-31CA-4ABA-814F-A5EBD2FD6D5E}'
Global Const $FOLDERID_SEARCH_MAPI = '{98EC0E18-2098-4D44-8644-66979315A281}'
Global Const $FOLDERID_SearchHome = '{190337D1-B8CA-4121-A639-6D472D16972A}'
Global Const $FOLDERID_SendTo = '{8983036C-27C0-404B-8F08-102D10DCFD74}'
Global Const $FOLDERID_SidebarDefaultParts = '{7B396E54-9EC5-4300-BE0A-2482EBAE1A26}'
Global Const $FOLDERID_SidebarParts = '{A75D362E-50FC-4FB7-AC2C-A8BEAA314493}'
Global Const $FOLDERID_StartMenu = '{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}'
Global Const $FOLDERID_Startup = '{B97D20BB-F46A-4C97-BA10-5E3608430854}'
Global Const $FOLDERID_SyncManagerFolder = '{43668BF8-C14E-49B2-97C9-747784D784B7}'
Global Const $FOLDERID_SyncResultsFolder = '{289A9A43-BE44-4057-A41B-587A76D7E7F9}'
Global Const $FOLDERID_SyncSetupFolder = '{0F214138-B1D3-4A90-BBA9-27CBC0C5389A}'
Global Const $FOLDERID_System = '{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}'
Global Const $FOLDERID_SystemX86 = '{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}'
Global Const $FOLDERID_Templates = '{A63293E8-664E-48DB-A079-DF759E0509F7}'
Global Const $FOLDERID_UserPinned = '{9E3995AB-1F9C-4F13-B827-48B24B6C7174}'
Global Const $FOLDERID_UserProfiles = '{0762D272-C50A-4BB0-A382-697DCD729B80}'
Global Const $FOLDERID_UserProgramFiles = '{5CD7AEE2-2219-4A67-B85D-6C9CE15660CB}'
Global Const $FOLDERID_UserProgramFilesCommon = '{BCBD3057-CA5C-4622-B42D-BC56DB0AE516}'
Global Const $FOLDERID_UsersFiles = '{F3CE0F7C-4901-4ACC-8648-D5D44B04EF8F}'
Global Const $FOLDERID_UsersLibraries = '{A302545D-DEFF-464B-ABE8-61C8648D939B}'
Global Const $FOLDERID_Videos = '{18989B1D-99B5-455B-841C-AB7C74E4DDFC}'
Global Const $FOLDERID_VideosLibrary = '{491E922F-5643-4AF4-A7EB-4E7A138D8174}'
Global Const $FOLDERID_Windows = '{F38BF404-1D43-42F2-9305-67DE0B28FC23}'

Global Const $KF_FLAG_CREATE = 0x00008000
Global Const $KF_FLAG_DONT_VERIFY = 0x00004000
Global Const $KF_FLAG_DONT_UNEXPAND = 0x00002000
Global Const $KF_FLAG_NO_ALIAS = 0x00001000
Global Const $KF_FLAG_INIT = 0x00000800
Global Const $KF_FLAG_DEFAULT_PATH = 0x00000400
Global Const $KF_FLAG_NOT_PARENT_RELATIVE = 0x00000200
Global Const $KF_FLAG_SIMPLE_IDLIST = 0x00000100

; *Windows 7 or above
Global Const $KF_FLAG_ALIAS_ONLY = 0x80000000

; ===============================================================================================================================
; _WinAPI_ShellGetSetFolderCustomSettings()
; ===============================================================================================================================

Global Const $FCSM_VIEWID = 0x0001
Global Const $FCSM_WEBVIEWTEMPLATE = 0x0002
Global Const $FCSM_INFOTIP = 0x0004
Global Const $FCSM_CLSID = 0x0008
Global Const $FCSM_ICONFILE = 0x0010
Global Const $FCSM_LOGO = 0x0020
Global Const $FCSM_FLAGS = 0x0040

Global Const $FCS_READ = 0x0001
Global Const $FCS_FORCEWRITE = 0x0002
Global Const $FCS_WRITE = BitOR($FCS_READ, $FCS_FORCEWRITE)

; ===============================================================================================================================
; _WinAPI_ShellGetSettings(), _WinAPI_ShellSetSettings()
; ===============================================================================================================================

Global Const $SSF_SHOWALLOBJECTS = 0x00000001
Global Const $SSF_SHOWEXTENSIONS = 0x00000002
Global Const $SSF_SHOWCOMPCOLOR = 0x00000008
Global Const $SSF_SHOWSYSFILES = 0x00000020
Global Const $SSF_DOUBLECLICKINWEBVIEW = 0x00000080
Global Const $SSF_DESKTOPHTML = 0x00000200
Global Const $SSF_WIN95CLASSIC = 0x00000400
Global Const $SSF_DONTPRETTYPATH = 0x00000800
Global Const $SSF_MAPNETDRVBUTTON = 0x00001000
Global Const $SSF_SHOWINFOTIP = 0x00002000
Global Const $SSF_HIDEICONS = 0x00004000
Global Const $SSF_NOCONFIRMRECYCLE = 0x00008000
Global Const $SSF_WEBVIEW = 0x00020000
Global Const $SSF_SHOWSUPERHIDDEN = 0x00040000
Global Const $SSF_SEPPROCESS = 0x00080000
Global Const $SSF_NONETCRAWLING = 0x00100000
Global Const $SSF_STARTPANELON = 0x00200000

; *Windows Vista and later
Global Const $SSF_AUTOCHECKSELECT = 0x00800000
Global Const $SSF_ICONSONLY = 0x01000000
Global Const $SSF_SHOWTYPEOVERLAY = 0x02000000

; ===============================================================================================================================
; _WinAPI_ShellGetSpecialFolderPath()
; ===============================================================================================================================

Global Const $CSIDL_ADMINTOOLS = 0x0030
Global Const $CSIDL_ALTSTARTUP = 0x001D
Global Const $CSIDL_APPDATA = 0x001A
Global Const $CSIDL_BITBUCKET = 0x000A
Global Const $CSIDL_CDBURN_AREA = 0x003B
Global Const $CSIDL_COMMON_ADMINTOOLS = 0x002F
Global Const $CSIDL_COMMON_ALTSTARTUP = 0x001E
Global Const $CSIDL_COMMON_APPDATA = 0x0023
Global Const $CSIDL_COMMON_DESKTOPDIRECTORY = 0x0019
Global Const $CSIDL_COMMON_DOCUMENTS = 0x002E
Global Const $CSIDL_COMMON_FAVORITES = 0x001F
Global Const $CSIDL_COMMON_MUSIC = 0x0035
Global Const $CSIDL_COMMON_PICTURES = 0x0036
Global Const $CSIDL_COMMON_PROGRAMS = 0x0017
Global Const $CSIDL_COMMON_STARTMENU = 0x0016
Global Const $CSIDL_COMMON_STARTUP = 0x0018
Global Const $CSIDL_COMMON_TEMPLATES = 0x002D
Global Const $CSIDL_COMMON_VIDEO = 0x0037
Global Const $CSIDL_COMPUTERSNEARME = 0x003D
Global Const $CSIDL_CONNECTIONS = 0x0031
Global Const $CSIDL_CONTROLS = 0x0003
Global Const $CSIDL_COOKIES = 0x0021
Global Const $CSIDL_DESKTOP = 0x0000
Global Const $CSIDL_DESKTOPDIRECTORY = 0x0010
Global Const $CSIDL_DRIVES = 0x0011
Global Const $CSIDL_FAVORITES = 0x0006
Global Const $CSIDL_FONTS = 0x0014
Global Const $CSIDL_INTERNET_CACHE = 0x0020
Global Const $CSIDL_HISTORY = 0x0022
Global Const $CSIDL_LOCAL_APPDATA = 0x001C
Global Const $CSIDL_MYMUSIC = 0x000D
Global Const $CSIDL_MYPICTURES = 0x0027
Global Const $CSIDL_MYVIDEO = 0x000E
Global Const $CSIDL_NETHOOD = 0x0013
Global Const $CSIDL_PERSONAL = 0x0005
Global Const $CSIDL_PRINTERS = 0x0004
Global Const $CSIDL_PRINTHOOD = 0x001B
Global Const $CSIDL_PROFILE = 0x0028
Global Const $CSIDL_PROGRAM_FILES = 0x0026
Global Const $CSIDL_PROGRAM_FILES_COMMON = 0x002B
Global Const $CSIDL_PROGRAM_FILES_COMMONX86 = 0x002C
Global Const $CSIDL_PROGRAM_FILESX86 = 0x002A
Global Const $CSIDL_PROGRAMS = 0x0002
Global Const $CSIDL_RECENT = 0x0008
Global Const $CSIDL_SENDTO = 0x0009
Global Const $CSIDL_STARTMENU = 0x000B
Global Const $CSIDL_STARTUP = 0x0007
Global Const $CSIDL_SYSTEM = 0x0025
Global Const $CSIDL_SYSTEMX86 = 0x0029
Global Const $CSIDL_TEMPLATES = 0x0015
Global Const $CSIDL_WINDOWS = 0x0024

; ===============================================================================================================================
; _WinAPI_ShellGetStockIconInfo()
; ===============================================================================================================================

Global Const $SIID_DOCNOASSOC = 0
Global Const $SIID_DOCASSOC = 1
Global Const $SIID_APPLICATION = 2
Global Const $SIID_FOLDER = 3
Global Const $SIID_FOLDEROPEN = 4
Global Const $SIID_DRIVE525 = 5
Global Const $SIID_DRIVE35 = 6
Global Const $SIID_DRIVEREMOVE = 7
Global Const $SIID_DRIVEFIXED = 8
Global Const $SIID_DRIVENET = 9
Global Const $SIID_DRIVENETDISABLED = 10
Global Const $SIID_DRIVECD = 11
Global Const $SIID_DRIVERAM = 12
Global Const $SIID_WORLD = 13
Global Const $SIID_SERVER = 15
Global Const $SIID_PRINTER = 16
Global Const $SIID_MYNETWORK = 17
Global Const $SIID_FIND = 22
Global Const $SIID_HELP = 23
Global Const $SIID_SHARE = 28
Global Const $SIID_LINK = 29
Global Const $SIID_SLOWFILE = 30
Global Const $SIID_RECYCLER = 31
Global Const $SIID_RECYCLERFULL = 32
Global Const $SIID_MEDIACDAUDIO = 40
Global Const $SIID_LOCK = 47
Global Const $SIID_AUTOLIST = 49
Global Const $SIID_PRINTERNET = 50
Global Const $SIID_SERVERSHARE = 51
Global Const $SIID_PRINTERFAX = 52
Global Const $SIID_PRINTERFAXNET = 53
Global Const $SIID_PRINTERFILE = 54
Global Const $SIID_STACK = 55
Global Const $SIID_MEDIASVCD = 56
Global Const $SIID_STUFFEDFOLDER = 57
Global Const $SIID_DRIVEUNKNOWN = 58
Global Const $SIID_DRIVEDVD = 59
Global Const $SIID_MEDIADVD = 60
Global Const $SIID_MEDIADVDRAM = 61
Global Const $SIID_MEDIADVDRW = 62
Global Const $SIID_MEDIADVDR = 63
Global Const $SIID_MEDIADVDROM = 64
Global Const $SIID_MEDIACDAUDIOPLUS = 65
Global Const $SIID_MEDIACDRW = 66
Global Const $SIID_MEDIACDR = 67
Global Const $SIID_MEDIACDBURN = 68
Global Const $SIID_MEDIABLANKCD = 69
Global Const $SIID_MEDIACDROM = 70
Global Const $SIID_AUDIOFILES = 71
Global Const $SIID_IMAGEFILES = 72
Global Const $SIID_VIDEOFILES = 73
Global Const $SIID_MIXEDFILES = 74
Global Const $SIID_FOLDERBACK = 75
Global Const $SIID_FOLDERFRONT = 76
Global Const $SIID_SHIELD = 77
Global Const $SIID_WARNING = 78
Global Const $SIID_INFO = 79
Global Const $SIID_ERROR = 80
Global Const $SIID_KEY = 81
Global Const $SIID_SOFTWARE = 82
Global Const $SIID_RENAME = 83
Global Const $SIID_DELETE = 84
Global Const $SIID_MEDIAAUDIODVD = 85
Global Const $SIID_MEDIAMOVIEDVD = 86
Global Const $SIID_MEDIAENHANCEDCD = 87
Global Const $SIID_MEDIAENHANCEDDVD = 88
Global Const $SIID_MEDIAHDDVD = 89
Global Const $SIID_MEDIABLURAY = 90
Global Const $SIID_MEDIAVCD = 91
Global Const $SIID_MEDIADVDPLUSR = 92
Global Const $SIID_MEDIADVDPLUSRW = 93
Global Const $SIID_DESKTOPPC = 94
Global Const $SIID_MOBILEPC = 95
Global Const $SIID_USERS = 96
Global Const $SIID_MEDIASMARTMEDIA = 97
Global Const $SIID_MEDIACOMPACTFLASH = 98
Global Const $SIID_DEVICECELLPHONE = 99
Global Const $SIID_DEVICECAMERA = 100
Global Const $SIID_DEVICEVIDEOCAMERA = 101
Global Const $SIID_DEVICEAUDIOPLAYER = 102
Global Const $SIID_NETWORKCONNECT = 103
Global Const $SIID_INTERNET = 104
Global Const $SIID_ZIPFILE = 105
Global Const $SIID_SETTINGS = 106
Global Const $SIID_DRIVEHDDVD = 132
Global Const $SIID_DRIVEBD = 133
Global Const $SIID_MEDIAHDDVDROM = 134
Global Const $SIID_MEDIAHDDVDR = 135
Global Const $SIID_MEDIAHDDVDRAM = 136
Global Const $SIID_MEDIABDROM = 137
Global Const $SIID_MEDIABDR = 138
Global Const $SIID_MEDIABDRE = 139
Global Const $SIID_CLUSTEREDDRIVE = 140
Global Const $SIID_MAX_ICONS = 174

Global Const $SHGSI_ICONLOCATION = 0
Global Const $SHGSI_ICON = $SHGFI_ICON
Global Const $SHGSI_SYSICONINDEX = $SHGFI_SYSICONINDEX
Global Const $SHGSI_LINKOVERLAY = $SHGFI_LINKOVERLAY
Global Const $SHGSI_SELECTED = $SHGFI_SELECTED
Global Const $SHGSI_LARGEICON = $SHGFI_LARGEICON
Global Const $SHGSI_SMALLICON = $SHGFI_SMALLICON
Global Const $SHGSI_SHELLICONSIZE = $SHGFI_SHELLICONSIZE

; ===============================================================================================================================
; _WinAPI_ShellNotifyIcon()
; ===============================================================================================================================

Global Const $NIM_ADD = 0x00
Global Const $NIM_MODIFY = 0x01
Global Const $NIM_DELETE = 0x02
Global Const $NIM_SETFOCUS = 0x03
Global Const $NIM_SETVERSION = 0x04

Global Const $NIF_MESSAGE = 0x01
Global Const $NIF_ICON = 0x02
Global Const $NIF_TIP = 0x04
Global Const $NIF_STATE = 0x08
Global Const $NIF_INFO = 0x10
Global Const $NIF_GUID = 0x20
Global Const $NIF_REALTIME = 0x40
Global Const $NIF_SHOWTIP = 0x80

Global Const $NIS_HIDDEN = 0x01
Global Const $NIS_SHAREDICON = 0x02

Global Const $NIIF_NONE = 0x00
Global Const $NIIF_INFO = 0x01
Global Const $NIIF_WARNING = 0x02
Global Const $NIIF_ERROR = 0x03
Global Const $NIIF_USER = 0x04
Global Const $NIIF_NOSOUND = 0x10
Global Const $NIIF_LARGE_ICON = 0x10
Global Const $NIIF_RESPECT_QUIET_TIME = 0x80
Global Const $NIIF_ICON_MASK = 0x0F

; ===============================================================================================================================
; _WinAPI_ShellOpenFolderAndSelectItems()
; ===============================================================================================================================

; *Windows Vista or above
Global Const $OFASI_EDIT = 0x01
Global Const $OFASI_OPENDESKTOP = 0x02

; ===============================================================================================================================
; _WinAPI_ShellOpenWithDlg()
; ===============================================================================================================================

Global Const $OAIF_ALLOW_REGISTRATION = 0x00000001
Global Const $OAIF_REGISTER_EXT = 0x00000002
Global Const $OAIF_EXEC = 0x00000004
Global Const $OAIF_FORCE_REGISTRATION = 0x00000008
Global Const $OAIF_HIDE_REGISTRATION = 0x00000020
Global Const $OAIF_URL_PROTOCOL = 0x00000040

; ===============================================================================================================================
; _WinAPI_ShellQueryUserNotificationState()
; ===============================================================================================================================

; *Windows Vista or above
Global Const $QUNS_NOT_PRESENT = 1
Global Const $QUNS_BUSY = 2
Global Const $QUNS_RUNNING_D3D_FULL_SCREEN = 3
Global Const $QUNS_PRESENTATION_MODE = 4
Global Const $QUNS_ACCEPTS_NOTIFICATIONS = 5
Global Const $QUNS_QUIET_TIME = 6

; ===============================================================================================================================
; _WinAPI_StretchBlt()
; ===============================================================================================================================

#cs
	
	Global Const $BLACKNESS = 0x00000042
	Global Const $CAPTUREBLT = 0x40000000
	Global Const $DSTINVERT = 0x00550009
	Global Const $MERGECOPY = 0x00C000CA
	Global Const $MERGEPAINT = 0x00BB0226
	Global Const $NOMIRRORBITMAP = 0x80000000
	Global Const $NOTSRCCOPY = 0x00330008
	Global Const $NOTSRCERASE = 0x001100A6
	Global Const $PATCOPY = 0x00F00021
	Global Const $PATINVERT = 0x005A0049
	Global Const $PATPAINT = 0x00FB0A09
	Global Const $SRCAND = 0x008800C6
	Global Const $SRCCOPY = 0x00CC0020
	Global Const $SRCERASE = 0x00440328
	Global Const $SRCINVERT = 0x00660046
	Global Const $SRCPAINT = 0x00EE0086
	Global Const $WHITENESS = 0x00FF0062
	
#ce

; ===============================================================================================================================
; _WinAPI_WinHelp()
; ===============================================================================================================================

Global Const $HELP_COMMAND = 0x0102
Global Const $HELP_CONTENTS = 0x0003
Global Const $HELP_CONTEXT = 0x0001
Global Const $HELP_CONTEXTMENU = 0x000A
Global Const $HELP_CONTEXTPOPUP = 0x0008
Global Const $HELP_FINDER = 0x000B
Global Const $HELP_FORCEFILE = 0x0009
Global Const $HELP_HELPONHELP = 0x0004
Global Const $HELP_INDEX = 0x0003
Global Const $HELP_KEY = 0x0101
Global Const $HELP_MULTIKEY = 0x0201
Global Const $HELP_PARTIALKEY = 0x0105
Global Const $HELP_QUIT = 0x0002
Global Const $HELP_SETCONTENTS = 0x0005
Global Const $HELP_SETPOPUP_POS = 0x000D
Global Const $HELP_SETWINPOS = 0x0203
Global Const $HELP_TCARD = 0x8000
Global Const $HELP_WM_HELP = 0x000C

; ===============================================================================================================================
; _WinAPI_GetDiskSerialNumber()
; ===============================================================================================================================

Const $IOCTL_STORAGE_BASE = 0x2D
Const $IOCTL_STORAGE_QUERY_PROPERTY_BASE = __MakeCtrlCode($IOCTL_STORAGE_BASE, 0x500)
Const $DFP_RECEIVE_DRIVE_DATA = 0x7C088

; ===============================================================================================================================
; _WinAPI_UniqueHardwaeID()
; ===============================================================================================================================

Global Const $UHID_MB = 0x00
Global Const $UHID_BIOS = 0x01
Global Const $UHID_CPU = 0x02
Global Const $UHID_HDD = 0x04
Global Const $UHID_All = BitOR($UHID_MB, $UHID_BIOS, $UHID_CPU, $UHID_HDD)

; ===============================================================================================================================
; _WinAPI_TrackMouseEvent()
; ===============================================================================================================================

Global Const $TME_CANCEL = 0x80000000
Global Const $TME_HOVER = 0x00000001
Global Const $TME_LEAVE = 0x00000002
Global Const $TME_NONCLIENT = 0x00000010
Global Const $TME_QUERY = 0x40000000

; ===============================================================================================================================
; _WinAPI_UrlEscape()
; ===============================================================================================================================

Global Const $URL_DONT_ESCAPE_EXTRA_INFO = 0x02000000
Global Const $URL_ESCAPE_SPACES_ONLY = 0x04000000
Global Const $URL_ESCAPE_PERCENT = 0x00001000
Global Const $URL_ESCAPE_SEGMENT_ONLY = 0x00002000

; *Windows 7 or later
Global Const $URL_ESCAPE_AS_UTF8 = 0x00040000

; ===============================================================================================================================
; _WinAPI_UrlGetPart()
; ===============================================================================================================================

Global Const $URL_PART_HOSTNAME = 2
Global Const $URL_PART_PASSWORD = 4
Global Const $URL_PART_PORT = 5
Global Const $URL_PART_QUERY = 6
Global Const $URL_PART_SCHEME = 1
Global Const $URL_PART_USERNAME = 3

; ===============================================================================================================================
; _WinAPI_UrlIs()
; ===============================================================================================================================

Global Const $URLIS_APPLIABLE = 4
Global Const $URLIS_DIRECTORY = 5
Global Const $URLIS_FILEURL = 3
Global Const $URLIS_HASQUERY = 6
Global Const $URLIS_NOHISTORY = 2
Global Const $URLIS_OPAQUE = 1
Global Const $URLIS_URL = 0

; ===============================================================================================================================
; _WinAPI_UrlUnescape()
; ===============================================================================================================================

Global Const $URL_DONT_UNESCAPE_EXTRA_INFO = 0x02000000

; ===============================================================================================================================
; _WinAPI_VerQueryRoot()
; ===============================================================================================================================

Global Const $VS_FF_DEBUG = 0x00000001
Global Const $VS_FF_INFOINFERRED = 0x00000010
Global Const $VS_FF_PATCHED = 0x00000004
Global Const $VS_FF_PRERELEASE = 0x00000002
Global Const $VS_FF_PRIVATEBUILD = 0x00000008
Global Const $VS_FF_SPECIALBUILD = 0x00000020

Global Const $VOS_DOS = 0x00010000
Global Const $VOS_NT = 0x00040000
Global Const $VOS__WINDOWS16 = 0x00000001
Global Const $VOS__WINDOWS32 = 0x00000004
Global Const $VOS_OS216 = 0x00020000
Global Const $VOS_OS232 = 0x00030000
Global Const $VOS__PM16 = 0x00000002
Global Const $VOS__PM32 = 0x00000003
Global Const $VOS_UNKNOWN = 0x00000000

Global Const $VOS_DOS_WINDOWS16 = 0x00010001
Global Const $VOS_DOS_WINDOWS32 = 0x00010004
Global Const $VOS_NT_WINDOWS32 = 0x00040004
Global Const $VOS_OS216_PM16 = 0x00020002
Global Const $VOS_OS232_PM32 = 0x00030003

Global Const $VFT_APP = 0x00000001
Global Const $VFT_DLL = 0x00000002
Global Const $VFT_DRV = 0x00000003
Global Const $VFT_FONT = 0x00000004
Global Const $VFT_STATIC_LIB = 0x00000007
Global Const $VFT_UNKNOWN = 0x00000000
Global Const $VFT_VXD = 0x00000005

Global Const $VFT2_DRV_COMM = 0x0000000A
Global Const $VFT2_DRV_DISPLAY = 0x00000004
Global Const $VFT2_DRV_INSTALLABLE = 0x00000008
Global Const $VFT2_DRV_KEYBOARD = 0x00000002
Global Const $VFT2_DRV_LANGUAGE = 0x00000003
Global Const $VFT2_DRV_MOUSE = 0x00000005
Global Const $VFT2_DRV_NETWORK = 0x00000006
Global Const $VFT2_DRV_PRINTER = 0x00000001
Global Const $VFT2_DRV_SOUND = 0x00000009
Global Const $VFT2_DRV_SYSTEM = 0x00000007
Global Const $VFT2_DRV_VERSIONED_PRINTER = 0x0000000C
Global Const $VFT2_UNKNOWN = 0x00000000

Global Const $VFT2_FONT_RASTER = 0x00000001
Global Const $VFT2_FONT_TRUETYPE = 0x00000003
Global Const $VFT2_FONT_VECTOR = 0x00000002
;Global Const $VFT2_UNKNOWN = 0x00000000

; ===============================================================================================================================
; _WinAPI_ShellAppBarMessage()
; ===============================================================================================================================

Global Const $ABM_ACTIVATE = 0x06
Global Const $ABM_GETAUTOHIDEBAR = 0x07
Global Const $ABM_GETSTATE = 0x04
Global Const $ABM_SETSTATE = 0x0000000a
Global Const $ABM_GETTASKBARPOS = 0x05
Global Const $ABM_NEW = 0x00
Global Const $ABM_QUERYPOS = 0x02
Global Const $ABM_REMOVE = 0x01
Global Const $ABM_SETAUTOHIDEBAR = 0x08
Global Const $ABM_SETPOS = 0x03
Global Const $ABM_WINDOWPOSCHANGED = 0x09
;---
Global Const $ABE_LEFT = 0x0
Global Const $ABE_TOP = 0x1
Global Const $ABE_RIGHT = 0x2
Global Const $ABE_BOTTOM = 0x3
Global Const $ABS_MANUAL = 0x0
Global Const $ABS_AUTOHIDE = 0x1
Global Const $ABS_ALWAYSONTOP = 0x2
Global Const $ABS_AUTOHIDEANDONTOP = 0x3

; ===============================================================================================================================
; _WinAPI_SetThreadExecutionState()
; ===============================================================================================================================

Global Const $ES_AWAYMODE_REQUIRED = 0x00000040
Global Const $ES_CONTINUOUS = 0x80000000
Global Const $ES_DISPLAY_REQUIRED = 0x00000002
Global Const $ES_SYSTEM_REQUIRED = 0x00000001
Global Const $ES_USER_PRESENT = 0x00000004

; ===============================================================================================================================
; _WinAPI_RasEnumEntries()
; ===============================================================================================================================

Global Const $ERROR_NOT_ENOUGH_MEMORY = 8
Global Const $ERROR_BUFFER_TOO_SMALL = 603
Global Const $ERROR_INVALID_SIZE = 632

; ===============================================================================================================================
; _WinAPI_GetFinalPathNameByHandle()
; ===============================================================================================================================

Global Const $FILE_NAME_NORMALIZED = 0x0
Global Const $FILE_NAME_OPENED = 0x8

Global Const $VOLUME_NAME_DOS = 0x0
Global Const $VOLUME_NAME_GUID = 0x1
Global Const $VOLUME_NAME_NONE = 0x4
Global Const $VOLUME_NAME_NT = 0x2

; ===============================================================================================================================
; _WinAPI_GetGraphicsMode(), _WinAPI_SetGraphicsMode()
; ===============================================================================================================================

Global Const $GM_COMPATIBLE = 1
Global Const $GM_ADVANCED = 2

; ===============================================================================================================================
; _WinAPI_GetGUIThreadInfo()
; ===============================================================================================================================

Global Const $GUI_CARETBLINKING = 0x0001
Global Const $GUI_INMENUMODE = 0x0004
Global Const $GUI_INMOVESIZE = 0x0002
Global Const $GUI_POPUPMENUMODE = 0x0010
Global Const $GUI_SYSTEMMENUMODE = 0x0008

; ===============================================================================================================================
; _WinAPI_WTS*()
; ===============================================================================================================================

Global Const $WTS_CONSOLE_CONNECT = 0x01
Global Const $WTS_CONSOLE_DISCONNECT = 0x02
Global Const $WTS_REMOTE_CONNECT = 0x03
Global Const $WTS_REMOTE_DISCONNECT = 0x04
Global Const $WTS_SESSION_LOGON = 0x05
Global Const $WTS_SESSION_LOGOFF = 0x06
Global Const $WTS_SESSION_LOCK = 0x07
Global Const $WTS_SESSION_UNLOCK = 0x08
Global Const $WTS_SESSION_REMOTE_CONTROL = 0x09

Global Const $NOTIFY_FOR_THIS_SESSION = 0
Global Const $NOTIFY_FOR_ALL_SESSIONS = 1

; ===============================================================================================================================
; Windows Message (WM) Constants
; ===============================================================================================================================

;Global Const $WM_ACTIVATE = 0x0006
;Global Const $WM_ACTIVATEAPP = 0x001C
Global Const $WM_AFXFIRST = 0x0360
Global Const $WM_AFXLAST = 0x037F
Global Const $WM_APP = 0x8000
Global Const $WM_APPCOMMAND = 0x0319
;Global Const $WM_ASKCBFORMATNAME = 0x030C
;Global Const $WM_CANCELJOURNAL = 0x004B
;Global Const $WM_CANCELMODE = 0x001F
Global Const $WM_CAPTURECHANGED = 0x0215
;Global Const $WM_CHANGECBCHAIN = 0x030D
;Global Const $WM_CHANGEUISTATE = 0x0127
;Global Const $WM_CHAR = 0x0102
;Global Const $WM_CHARTOITEM = 0x002F
;Global Const $WM_CHILDACTIVATE = 0x0022
;Global Const $WM_CLEAR = 0x0303
;Global Const $WM_CLOSE = 0x0010
;Global Const $WM_COMMAND = 0x0111
;Global Const $WM_COMMNOTIFY = 0x0044
;Global Const $WM_COMPACTING = 0x0041
;Global Const $WM_COMPAREITEM = 0x0039
;Global Const $WM_CONTEXTMENU = 0x007B
;Global Const $WM_COPY = 0x0301
;Global Const $WM_COPYDATA = 0x004A
;Global Const $WM_CREATE = 0x0001
;Global Const $WM_CTLCOLORBTN = 0x0135
;Global Const $WM_CTLCOLORDLG = 0x0136
;Global Const $WM_CTLCOLOREDIT = 0x0133
;Global Const $WM_CTLCOLORLISTBOX = 0x0134
;Global Const $WM_CTLCOLORMSGBOX = 0x0132
;Global Const $WM_CTLCOLORSCROLLBAR = 0x0137
;Global Const $WM_CTLCOLORSTATIC = 0x0138
;Global Const $WM_CUT = 0x0300
;Global Const $WM_DEADCHAR = 0x0103
;Global Const $WM_DELETEITEM = 0x002D
;Global Const $WM_DESTROY = 0x0002
;Global Const $WM_DESTROYCLIPBOARD = 0x0307
Global Const $WM_DEVICECHANGE = 0x0219
;Global Const $WM_DEVMODECHANGE = 0x001B
;Global Const $WM_DISPLAYCHANGE = 0x007E
;Global Const $WM_DRAWCLIPBOARD = 0x0308
;Global Const $WM_DRAWITEM = 0x002B
Global Const $WM_DROPFILES = 0x0233
;Global Const $WM_ENABLE = 0x000A
Global Const $WM_ENDSESSION = 0x0016
;Global Const $WM_ENTERIDLE = 0x0121
Global Const $WM_ENTERMENULOOP = 0x0211
Global Const $WM_ENTERSIZEMOVE = 0x0231
;Global Const $WM_ERASEBKGND = 0x0014
Global Const $WM_EXITMENULOOP = 0x0212
Global Const $WM_EXITSIZEMOVE = 0x0232
;Global Const $WM_FONTCHANGE = 0x001D
;Global Const $WM_GETDLGCODE = 0x0087
;Global Const $WM_GETFONT = 0x0031
;Global Const $WM_GETHOTKEY = 0x0033
;Global Const $WM_GETICON = 0x007F
;Global Const $WM_GETMINMAXINFO = 0x0024
;Global Const $WM_GETOBJECT = 0x003D
;Global Const $WM_GETTEXT = 0x000D
;Global Const $WM_GETTEXTLENGTH = 0x000E
Global Const $WM_HANDHELDFIRST = 0x0358
Global Const $WM_HANDHELDLAST = 0x035F
;Global Const $WM_HELP = 0x0053
Global Const $WM_HOTKEY = 0x0312
;Global Const $WM_HSCROLL = 0x0114
;Global Const $WM_HSCROLLCLIPBOARD = 0x030E
;Global Const $WM_ICONERASEBKGND = 0x0027
Global Const $WM_IME_CHAR = 0x0286
Global Const $WM_IME_COMPOSITION = 0x010F
Global Const $WM_IME_COMPOSITIONFULL = 0x0284
Global Const $WM_IME_CONTROL = 0x0283
Global Const $WM_IME_ENDCOMPOSITION = 0x010E
Global Const $WM_IME_KEYDOWN = 0x0290
Global Const $WM_IME_KEYLAST = 0x010F
Global Const $WM_IME_KEYUP = 0x0291
Global Const $WM_IME_NOTIFY = 0x0282
Global Const $WM_IME_REQUEST = 0x0288
Global Const $WM_IME_SELECT = 0x0285
Global Const $WM_IME_SETCONTEXT = 0x0281
Global Const $WM_IME_STARTCOMPOSITION = 0x010D
;Global Const $WM_INITDIALOG = 0x0110
;Global Const $WM_INITMENU = 0x0116
;Global Const $WM_INITMENUPOPUP = 0x0117
Global Const $WM_INPUT = 0x00FF
;Global Const $WM_INPUTLANGCHANGE = 0x0051
;Global Const $WM_INPUTLANGCHANGEREQUEST = 0x0050
;Global Const $WM_KEYDOWN = 0x0100
Global Const $WM_KEYFIRST = 0x0100
Global Const $WM_KEYLAST = 0x0109
;Global Const $WM_KEYUP = 0x0101
;Global Const $WM_KILLFOCUS = 0x0008
;Global Const $WM_LBUTTONDBLCLK = 0x0203
;Global Const $WM_LBUTTONDOWN = 0x0201
;Global Const $WM_LBUTTONUP = 0x0202
Global Const $WM_MBUTTONDBLCLK = 0x0209
;Global Const $WM_MBUTTONDOWN = 0x0207
;Global Const $WM_MBUTTONUP = 0x0208
Global Const $WM_MDIACTIVATE = 0x0222
Global Const $WM_MDICASCADE = 0x0227
Global Const $WM_MDICREATE = 0x0220
Global Const $WM_MDIDESTROY = 0x0221
Global Const $WM_MDIGETACTIVE = 0x0229
Global Const $WM_MDIICONARRANGE = 0x0228
Global Const $WM_MDIMAXIMIZE = 0x0225
Global Const $WM_MDINEXT = 0x0224
Global Const $WM_MDIREFRESHMENU = 0x0234
Global Const $WM_MDIRESTORE = 0x0223
Global Const $WM_MDISETMENU = 0x0230
Global Const $WM_MDITILE = 0x0226
;Global Const $WM_MEASUREITEM = 0x002C
;Global Const $WM_MENUCHAR = 0x0120
;Global Const $WM_MENUCOMMAND = 0x0126
;Global Const $WM_MENUDRAG = 0x0123
;Global Const $WM_MENUGETOBJECT = 0x0124
;Global Const $WM_MENURBUTTONUP = 0x0122
;Global Const $WM_MENUSELECT = 0x011F
;Global Const $WM_MOUSEACTIVATE = 0x0021
Global Const $WM_MOUSEFIRST = 0x0200
Global Const $WM_MOUSEHOVER = 0x02A1
Global Const $WM_MOUSELAST = __Def(0x0600, 0x020E, 0x0500, 0x020D)
Global Const $WM_MOUSELEAVE = 0x02A3
;Global Const $WM_MOUSEMOVE = 0x0200
;Global Const $WM_MOUSEWHEEL = 0x020A
;Global Const $WM_MOVE = 0x0003
Global Const $WM_MOVING = 0x0216
;Global Const $WM_NCACTIVATE = 0x0086
;Global Const $WM_NCCALCSIZE = 0x0083
;Global Const $WM_NCCREATE = 0x0081
;Global Const $WM_NCDESTROY = 0x0082
;Global Const $WM_NCHITTEST = 0x0084
;Global Const $WM_NCLBUTTONDBLCLK = 0x00A3
;Global Const $WM_NCLBUTTONDOWN = 0x00A1
;Global Const $WM_NCLBUTTONUP = 0x00A2
;Global Const $WM_NCMBUTTONDBLCLK = 0x00A9
;Global Const $WM_NCMBUTTONDOWN = 0x00A7
;Global Const $WM_NCMBUTTONUP = 0x00A8
Global Const $WM_NCMOUSEHOVER = 0x02A0
Global Const $WM_NCMOUSELEAVE = 0x02A2
;Global Const $WM_NCMOUSEMOVE = 0x00A0
;Global Const $WM_NCPAINT = 0x0085
;Global Const $WM_NCRBUTTONDBLCLK = 0x00A6
;Global Const $WM_NCRBUTTONDOWN = 0x00A4
;Global Const $WM_NCRBUTTONUP = 0x00A5
Global Const $WM_NCXBUTTONDBLCLK = 0x00AD
Global Const $WM_NCXBUTTONDOWN = 0x00AB
Global Const $WM_NCXBUTTONUP = 0x00AC
;Global Const $WM_NEXTDLGCTL = 0x0028
Global Const $WM_NEXTMENU = 0x0213
;Global Const $WM_NOTIFY = 0x004E
;Global Const $WM_NOTIFYFORMAT = 0x0055
Global Const $WM_NULL = 0x0000
;Global Const $WM_PAINT = 0x000F
;Global Const $WM_PAINTCLIPBOARD = 0x0309
;Global Const $WM_PAINTICON = 0x0026
Global Const $WM_PALETTECHANGED = 0x0311
Global Const $WM_PALETTEISCHANGING = 0x0310
Global Const $WM_PARENTNOTIFY = 0x0210
;Global Const $WM_PASTE = 0x0302
Global Const $WM_PENWINFIRST = 0x0380
Global Const $WM_PENWINLAST = 0x038F
;Global Const $WM_POWER = 0x0048
Global Const $WM_POWERBROADCAST = 0x0218
Global Const $WM_PRINT = 0x0317
Global Const $WM_PRINTCLIENT = 0x0318
;Global Const $WM_QUERYDRAGICON = 0x0037
Global Const $WM_QUERYENDSESSION = 0x0011
Global Const $WM_QUERYNEWPALETTE = 0x030F
Global Const $WM_QUERYOPEN = 0x0013
;Global Const $WM_QUERYUISTATE = 0x0129
;Global Const $WM_QUEUESYNC = 0x0023
;Global Const $WM_QUIT = 0x0012
Global Const $WM_RBUTTONDBLCLK = 0x0206
;Global Const $WM_RBUTTONDOWN = 0x0204
;Global Const $WM_RBUTTONUP = 0x0205
;Global Const $WM_RENDERALLFORMATS = 0x0306
;Global Const $WM_RENDERFORMAT = 0x0305
;Global Const $WM_SETCURSOR = 0x0020
;Global Const $WM_SETFOCUS = 0x0007
;Global Const $WM_SETFONT = 0x0030
;Global Const $WM_SETHOTKEY = 0x0032
;Global Const $WM_SETICON = 0x0080
;Global Const $WM_SETREDRAW = 0x000B
;Global Const $WM_SETTEXT = 0x000C
Global Const $WM_SETTINGCHANGE = 0x001A
;Global Const $WM_SHOWWINDOW = 0x0018
;Global Const $WM_SIZE = 0x0005
;Global Const $WM_SIZECLIPBOARD = 0x030B
;Global Const $WM_SIZING = 0x0214
;Global Const $WM_SPOOLERSTATUS = 0x002A
;Global Const $WM_STYLECHANGED = 0x007D
;Global Const $WM_STYLECHANGING = 0x007C
;Global Const $WM_SYNCPAINT = 0x0088
;Global Const $WM_SYSCHAR = 0x0106
;Global Const $WM_SYSCOLORCHANGE = 0x0015
;Global Const $WM_SYSCOMMAND = 0x0112
;Global Const $WM_SYSDEADCHAR = 0x0107
;Global Const $WM_SYSKEYDOWN = 0x0104
;Global Const $WM_SYSKEYUP = 0x0105
Global Const $WM_TABLET_FIRST = 0x02C0
Global Const $WM_TABLET_LAST = 0x02DF
;Global Const $WM_TCARD = 0x0052
Global Const $WM_THEMECHANGED = 0x031A
;Global Const $WM_TIMECHANGE = 0x001E
;Global Const $WM_TIMER = 0x0113
;Global Const $WM_UNDO = 0x0304
Global Const $WM_UNICHAR = 0x0109
;Global Const $WM_UNINITMENUPOPUP = 0x0125
;Global Const $WM_UPDATEUISTATE = 0x0128
;Global Const $WM_USER = 0x0400
;Global Const $WM_USERCHANGED = 0x0054
;Global Const $WM_VKEYTOITEM = 0x002E
;Global Const $WM_VSCROLL = 0x0115
;Global Const $WM_VSCROLLCLIPBOARD = 0x030A
;Global Const $WM_WINDOWPOSCHANGED = 0x0047
;Global Const $WM_WINDOWPOSCHANGING = 0x0046
;Global Const $WM_WININICHANGE = 0x001A
Global Const $WM_WTSSESSION_CHANGE = 0x02B1
;Global Const $WM_XBUTTONDBLCLK = 0x020D
;Global Const $WM_XBUTTONDOWN = 0x020B
;Global Const $WM_XBUTTONUP = 0x020C
; ===============================================================================================================================
; _WinAPI_CreateFileMapping(), _WinAPI_OpenFileMapping()
; ===============================================================================================================================

; *Included in MemoryConstants.au3

#cs

Global Const $PAGE_EXECUTE = 0x0010
Global Const $PAGE_EXECUTE_READ = 0x0020
Global Const $PAGE_EXECUTE_READWRITE = 0x0040
Global Const $PAGE_EXECUTE_WRITECOPY = 0x0080
Global Const $PAGE_GUARD = 0x0100
Global Const $PAGE_NOACCESS = 0x0001
Global Const $PAGE_NOCACHE = 0x0200
Global Const $PAGE_READONLY = 0x0002
Global Const $PAGE_READWRITE = 0x0004
Global Const $PAGE_WRITECOMBINE = 0x0400
Global Const $PAGE_WRITECOPY = 0x0008

#ce

Global Const $SEC_COMMIT = 0x08000000
Global Const $SEC_IMAGE = 0x01000000
Global Const $SEC_LARGE_PAGES = 0x80000000
Global Const $SEC_NOCACHE = 0x10000000
Global Const $SEC_RESERVE = 0x04000000
Global Const $SEC_WRITECOMBINE = 0x40000000

Global Const $FILE_MAP_ALL_ACCESS = 0x001F
Global Const $FILE_MAP_COPY = 0x0001
Global Const $FILE_MAP_EXECUTE = 0x0020
Global Const $FILE_MAP_READ = 0x0004
Global Const $FILE_MAP_WRITE = 0x0002

; ===============================================================================================================================
; _WinAPI_CreatePen(), _WinAPI_ExtCreatePen()
; ===============================================================================================================================

;Global Const $PS_SOLID = 0
;Global Const $PS_DASH = 1
;Global Const $PS_DOT = 2
;Global Const $PS_DASHDOT = 3
;Global Const $PS_DASHDOTDOT = 4
;Global Const $PS_NULL = 5
;Global Const $PS_INSIDEFRAME = 6
Global Const $PS_USERSTYLE = 7
Global Const $PS_ALTERNATE = 8

Global Const $PS_ENDCAP_ROUND = 0x00000000
Global Const $PS_ENDCAP_SQUARE = 0x00000100
Global Const $PS_ENDCAP_FLAT = 0x00000200

Global Const $PS_JOIN_BEVEL = 0x00001000
Global Const $PS_JOIN_MITER = 0x00002000
Global Const $PS_JOIN_ROUND = 0x00000000

Global Const $PS_GEOMETRIC = 0x00010000
Global Const $PS_COSMETIC = 0x00000000

; ===============================================================================================================================
; _WinAPI_DrawShadowText()
; ===============================================================================================================================

; *Included in WindowsConstants.au3

#cs

Global Const $DT_BOTTOM = 0x00000008
Global Const $DT_CALCRECT = 0x00000400
Global Const $DT_CENTER = 0x00000001
Global Const $DT_EDITCONTROL = 0x00002000
Global Const $DT_END_ELLIPSIS = 0x00008000
Global Const $DT_EXPANDTABS = 0x00000040
Global Const $DT_EXTERNALLEADING = 0x00000200
Global Const $DT_HIDEPREFIX = 0x00100000
Global Const $DT_INTERNAL = 0x00001000
Global Const $DT_LEFT = 0x00000000
Global Const $DT_MODIFYSTRING = 0x00010000
Global Const $DT_NOCLIP = 0x00000100
Global Const $DT_NOFULLWIDTHCHARBREAK = 0x00080000
Global Const $DT_NOPREFIX = 0x00000800
Global Const $DT_PATH_ELLIPSIS = 0x00004000
Global Const $DT_PREFIXONLY = 0x00200000
Global Const $DT_RIGHT = 0x00000002
Global Const $DT_RTLREADING = 0x00020000
Global Const $DT_SINGLELINE = 0x00000020
Global Const $DT_TABSTOP = 0x00000080
Global Const $DT_TOP = 0x00000000
Global Const $DT_VCENTER = 0x00000004
Global Const $DT_WORDBREAK = 0x00000010
Global Const $DT_WORD_ELLIPSIS = 0x00040000

#ce

; ===============================================================================================================================
; _WinAPI_DrawThemeEdge()
; ===============================================================================================================================

;Global Const $BDR_RAISEDINNER = 0x04
;Global Const $BDR_SUNKENINNER = 0x08
;Global Const $BDR_RAISEDOUTER = 0x01
;Global Const $BDR_SUNKENOUTER = 0x02

;Global Const $EDGE_BUMP = BitOR($BDR_RAISEDOUTER, $BDR_SUNKENINNER)
;Global Const $EDGE_ETCHED = BitOR($BDR_SUNKENOUTER, $BDR_RAISEDINNER)
;Global Const $EDGE_RAISED = BitOR($BDR_RAISEDOUTER, $BDR_RAISEDINNER)
;Global Const $EDGE_SUNKEN = BitOR($BDR_SUNKENOUTER, $BDR_SUNKENINNER)

;Global Const $BF_ADJUST = 0x2000
;Global Const $BF_BOTTOM = 0x0008
;Global Const $BF_DIAGONAL = 0x0010
;Global Const $BF_FLAT = 0x4000
;Global Const $BF_LEFT = 0x0001
;Global Const $BF_MIDDLE = 0x0800
;Global Const $BF_MONO = 0x8000
;Global Const $BF_RIGHT = 0x0004
;Global Const $BF_SOFT = 0x1000
;Global Const $BF_TOP = 0x0002
;Global Const $BF_BOTTOMLEFT = BitOR($BF_BOTTOM, $BF_LEFT)
;Global Const $BF_BOTTOMRIGHT = BitOR($BF_BOTTOM, $BF_RIGHT)
;Global Const $BF_DIAGONAL_ENDBOTTOMLEFT = BitOR($BF_DIAGONAL, $BF_BOTTOM, $BF_LEFT)
;Global Const $BF_DIAGONAL_ENDBOTTOMRIGHT = BitOR($BF_DIAGONAL, $BF_BOTTOM, $BF_RIGHT)
;Global Const $BF_DIAGONAL_ENDTOPLEFT = BitOR($BF_DIAGONAL, $BF_TOP, $BF_LEFT)
;Global Const $BF_DIAGONAL_ENDTOPRIGHT = BitOR($BF_DIAGONAL, $BF_TOP, $BF_RIGHT)
;Global Const $BF_RECT = BitOR($BF_LEFT, $BF_TOP, $BF_RIGHT, $BF_BOTTOM)
;Global Const $BF_TOPLEFT = BitOR($BF_TOP, $BF_LEFT)
;Global Const $BF_TOPRIGHT = BitOR($BF_TOP, $BF_RIGHT)

; ===============================================================================================================================
; _WinAPI_DuplicateHandle()
; ===============================================================================================================================

Global Const $DUPLICATE_CLOSE_SOURCE = 0x01
Global Const $DUPLICATE_SAME_ACCESS = 0x02

; *Included in ProcessConstants.au3

#cs

Global Const $PROCESS_ALL_ACCESS = 0x001F0FFF
Global Const $PROCESS_CREATE_PROCESS = 0x00000080
Global Const $PROCESS_CREATE_THREAD = 0x00000002
Global Const $PROCESS_DUP_HANDLE = 0x00000040
Global Const $PROCESS_QUERY_INFORMATION = 0x00000400
Global Const $PROCESS_QUERY_LIMITED_INFORMATION = 0x00001000
Global Const $PROCESS_SET_INFORMATION = 0x00000200
Global Const $PROCESS_SET_QUOTA = 0x00000100
Global Const $PROCESS_SUSPEND_RESUME = 0x00000800
Global Const $PROCESS_TERMINATE = 0x00000001
Global Const $PROCESS_VM_OPERATION = 0x00000008
Global Const $PROCESS_VM_READ = 0x00000010
Global Const $PROCESS_VM_WRITE = 0x00000020

#ce
; ===============================================================================================================================
; _WinAPI_GetBoundsRect(), _WinAPI_SetBoundsRect()
; ===============================================================================================================================

Global Const $DCB_ACCUMULATE = 0x02
Global Const $DCB_DISABLE = 0x08
Global Const $DCB_ENABLE = 0x04
Global Const $DCB_RESET = 0x01
Global Const $DCB_SET = BitOR($DCB_RESET, $DCB_ACCUMULATE)

; ===============================================================================================================================
; _WinAPI_GetThemeBitmap()
; ===============================================================================================================================

Global Const $GBF_DIRECT = 0x01
Global Const $GBF_COPY = 0x02
Global Const $GBF_VALIDBITS = BitOR($GBF_DIRECT, $GBF_COPY)


; ===============================================================================================================================
; _WinAPI_GetThemePropertyOrigin()
; ===============================================================================================================================

Global Const $PO_CLASS = 2
Global Const $PO_GLOBAL = 3
Global Const $PO_NOTFOUND = 4
Global Const $PO_PART = 1
Global Const $PO_STATE = 0

; ===============================================================================================================================
; _WinAPI_ShellRestricted()
; ===============================================================================================================================

Global Const $REST_NORUN = 1
Global Const $REST_NOCLOSE = 2
Global Const $REST_NOSAVESET = 3
Global Const $REST_NOFILEMENU = 4
Global Const $REST_NOSETFOLDERS = 5
Global Const $REST_NOSETTASKBAR = 6
Global Const $REST_NODESKTOP = 7
Global Const $REST_NOFIND = 8
Global Const $REST_NODRIVES = 9
Global Const $REST_NODRIVEAUTORUN = 10
Global Const $REST_NODRIVETYPEAUTORUN = 11
Global Const $REST_NONETHOOD = 12
Global Const $REST_STARTBANNER = 13
Global Const $REST_RESTRICTRUN = 14
Global Const $REST_NOPRINTERTABS = 15
Global Const $REST_NOPRINTERDELETE = 16
Global Const $REST_NOPRINTERADD = 17
Global Const $REST_NOSTARTMENUSUBFOLDERS = 18
Global Const $REST_MYDOCSONNET = 19
Global Const $REST_NOEXITTODOS = 20
Global Const $REST_ENFORCESHELLEXTSECURITY = 21
Global Const $REST_LINKRESOLVEIGNORELINKINFO = 22
Global Const $REST_NOCOMMONGROUPS = 23
Global Const $REST_SEPARATEDESKTOPPROCESS = 24
Global Const $REST_NOWEB = 25
Global Const $REST_NOTRAYCONTEXTMENU = 26
Global Const $REST_NOVIEWCONTEXTMENU = 27
Global Const $REST_NONETCONNECTDISCONNECT = 28
Global Const $REST_STARTMENULOGOFF = 29
Global Const $REST_NOSETTINGSASSIST = 30
Global Const $REST_NOINTERNETICON = 31
Global Const $REST_NORECENTDOCSHISTORY = 32
Global Const $REST_NORECENTDOCSMENU = 33
Global Const $REST_NOACTIVEDESKTOP = 34
Global Const $REST_NOACTIVEDESKTOPCHANGES = 35
Global Const $REST_NOFAVORITESMENU = 36
Global Const $REST_CLEARRECENTDOCSONEXIT = 37
Global Const $REST_CLASSICSHELL = 38
Global Const $REST_NOCUSTOMIZEWEBVIEW = 39
Global Const $REST_NOHTMLWALLPAPER = 40
Global Const $REST_NOCHANGINGWALLPAPER = 41
Global Const $REST_NODESKCOMP = 42
Global Const $REST_NOADDDESKCOMP = 43
Global Const $REST_NODELDESKCOMP = 44
Global Const $REST_NOCLOSEDESKCOMP = 45
Global Const $REST_NOCLOSE_DRAGDROPBAND = 46
Global Const $REST_NOMOVINGBAND = 47
Global Const $REST_NOEDITDESKCOMP = 48
Global Const $REST_NORESOLVESEARCH = 49
Global Const $REST_NORESOLVETRACK = 50
Global Const $REST_FORCECOPYACLWITHFILE = 51
Global Const $REST_NOLOGO3CHANNELNOTIFY = 52
Global Const $REST_NOFORGETSOFTWAREUPDATE = 53
Global Const $REST_NOSETACTIVEDESKTOP = 54
Global Const $REST_NOUPDATEWINDOWS = 55
Global Const $REST_NOCHANGESTARMENU = 56
Global Const $REST_NOFOLDEROPTIONS = 57
Global Const $REST_HASFINDCOMPUTERS = 58
Global Const $REST_INTELLIMENUS = 59
Global Const $REST_RUNDLGMEMCHECKBOX = 60
Global Const $REST_ARP_ShowPostSetup = 61
Global Const $REST_NOCSC = 62
Global Const $REST_NOCONTROLPANEL = 63
Global Const $REST_ENUMWORKGROUP = 64
Global Const $REST_ARP_NOARP = 65
Global Const $REST_ARP_NOREMOVEPAGE = 66
Global Const $REST_ARP_NOADDPAGE = 67
Global Const $REST_ARP_NOWINSETUPPAGE = 68
Global Const $REST_GREYMSIADS = 69
Global Const $REST_NOCHANGEMAPPEDDRIVELABEL = 70
Global Const $REST_NOCHANGEMAPPEDDRIVECOMMENT = 71
Global Const $REST_MAXRECENTDOCS = 72
Global Const $REST_NONETWORKCONNECTIONS = 73
Global Const $REST_FORCESTARTMENULOGOFF = 74
Global Const $REST_NOWEBVIEW = 75
Global Const $REST_NOCUSTOMIZETHISFOLDER = 76
Global Const $REST_NOENCRYPTION = 77
Global Const $REST_DONTSHOWSUPERHIDDEN = 78
Global Const $REST_NOSHELLSEARCHBUTTON = 79
Global Const $REST_NOHARDWARETAB = 80
Global Const $REST_NORUNASINSTALLPROMPT = 81
Global Const $REST_PROMPTRUNASINSTALLNETPATH = 82
Global Const $REST_NOMANAGEMYCOMPUTERVERB = 83
Global Const $REST_NORECENTDOCSNETHOOD = 84
Global Const $REST_DISALLOWRUN = 85
Global Const $REST_NOWELCOMESCREEN = 86
Global Const $REST_RESTRICTCPL = 87
Global Const $REST_DISALLOWCPL = 88
Global Const $REST_NOSMBALLOONTIP = 89
Global Const $REST_NOSMHELP = 90
Global Const $REST_NOWINKEYS = 91
Global Const $REST_NOENCRYPTONMOVE = 92
Global Const $REST_NOLOCALMACHINERUN = 93
Global Const $REST_NOCURRENTUSERRUN = 94
Global Const $REST_NOLOCALMACHINERUNONCE = 95
Global Const $REST_NOCURRENTUSERRUNONCE = 96
Global Const $REST_FORCEACTIVEDESKTOPON = 97
Global Const $REST_NOCOMPUTERSNEARME = 98
Global Const $REST_NOVIEWONDRIVE = 99
Global Const $REST_NONETCRAWL = 100
Global Const $REST_NOSHAREDDOCUMENTS = 101
Global Const $REST_NOSMMYDOCS = 102
Global Const $REST_NOSMMYPICS = 103
Global Const $REST_ALLOWBITBUCKDRIVES = 104
Global Const $REST_NONLEGACYSHELLMODE = 105
Global Const $REST_NOCONTROLPANELBARRICADE = 106
Global Const $REST_NOSTARTPAGE = 107
Global Const $REST_NOAUTOTRAYNOTIFY = 108
Global Const $REST_NOTASKGROUPING = 109
Global Const $REST_NOCDBURNING = 110
Global Const $REST_MYCOMPNOPROP = 111
Global Const $REST_MYDOCSNOPROP = 112
Global Const $REST_NOSTARTPANEL = 113
Global Const $REST_NODISPLAYAPPEARANCEPAGE = 114
Global Const $REST_NOTHEMESTAB = 115
Global Const $REST_NOVISUALSTYLECHOICE = 116
Global Const $REST_NOSIZECHOICE = 117
Global Const $REST_NOCOLORCHOICE = 118
Global Const $REST_SETVISUALSTYLE = 119
Global Const $REST_STARTRUNNOHOMEPATH = 120
Global Const $REST_NOUSERNAMEINSTARTPANEL = 121
Global Const $REST_NOMYCOMPUTERICON = 122
Global Const $REST_NOSMNETWORKPLACES = 123
Global Const $REST_NOSMPINNEDLIST = 124
Global Const $REST_NOSMMYMUSIC = 125
Global Const $REST_NOSMEJECTPC = 126
Global Const $REST_NOSMMOREPROGRAMS = 127
Global Const $REST_NOSMMFUPROGRAMS = 128
Global Const $REST_NOTRAYITEMSDISPLAY = 129
Global Const $REST_NOTOOLBARSONTASKBAR = 130
Global Const $REST_NOSMCONFIGUREPROGRAMS = 131
Global Const $REST_HIDECLOCK = 132
Global Const $REST_NOLOWDISKSPACECHECKS = 133
Global Const $REST_NOENTIRENETWORK = 134
Global Const $REST_NODESKTOPCLEANUP = 135
Global Const $REST_BITBUCKNUKEONDELETE = 136
Global Const $REST_BITBUCKCONFIRMDELETE = 137
Global Const $REST_BITBUCKNOPROP = 138
Global Const $REST_NODISPBACKGROUND = 139
Global Const $REST_NODISPSCREENSAVEPG = 140
Global Const $REST_NODISPSETTINGSPG = 141
Global Const $REST_NODISPSCREENSAVEPREVIEW = 142
Global Const $REST_NODISPLAYCPL = 143
Global Const $REST_HIDERUNASVERB = 144
Global Const $REST_NOTHUMBNAILCACHE = 145
Global Const $REST_NOSTRCMPLOGICAL = 146
Global Const $REST_NOPUBLISHWIZARD = 147
Global Const $REST_NOONLINEPRINTSWIZARD = 148
Global Const $REST_NOWEBSERVICES = 149
Global Const $REST_ALLOWUNHASHEDWEBVIEW = 150
Global Const $REST_ALLOWLEGACYWEBVIEW = 151
Global Const $REST_REVERTWEBVIEWSECURITY = 152
Global Const $REST_INHERITCONSOLEHANDLES = 153
Global Const $REST_SORTMAXITEMCOUNT = 154
Global Const $REST_NOREMOTERECURSIVEEVENTS = 155
Global Const $REST_NOREMOTECHANGENOTIFY = 156
Global Const $REST_NOSIMPLENETIDLIST = 157
Global Const $REST_NOENUMENTIRENETWORK = 158
Global Const $REST_NODETAILSTHUMBNAILONNETWORK = 159
Global Const $REST_NOINTERNETOPENWITH = 160
Global Const $REST_ALLOWLEGACYLMZBEHAVIOR = 161
Global Const $REST_DONTRETRYBADNETNAME = 162
Global Const $REST_ALLOWFILECLSIDJUNCTIONS = 163
Global Const $REST_NOUPNPINSTALL = 164
Global Const $REST_ARP_DONTGROUPPATCHES = 165
Global Const $REST_ARP_NOCHOOSEPROGRAMSPAGE = 166
Global Const $REST_NODISCONNECT = 167
Global Const $REST_NOSECURITY = 168
Global Const $REST_NOFILEASSOCIATE = 169
Global Const $REST_ALLOWCOMMENTTOGGLE = 170
Global Const $REST_USEDESKTOPINICACHE = 171

; ===============================================================================================================================
; _WinAPI_SetSystemCursor()
; ===============================================================================================================================

Global Const $OCR_APPSTARTING = 32650
Global Const $OCR_NORMAL = 32512
Global Const $OCR_CROSS = 32515
Global Const $OCR_HAND = 32649
Global Const $OCR_IBEAM = 32513
Global Const $OCR_NO = 32648
Global Const $OCR_SIZEALL = 32646
Global Const $OCR_SIZENESW = 32643
Global Const $OCR_SIZENS = 32645
Global Const $OCR_SIZENWSE = 32642
Global Const $OCR_SIZEWE = 32644
Global Const $OCR_UP = 32516
Global Const $OCR_WAIT = 32514
Global Const $OCR_ICON = 32641
Global Const $OCR_SIZE = 32640

; ===============================================================================================================================
; _WinAPI_*Theme*()
; ===============================================================================================================================

Global Const $TMT_BOOL = 203
Global Const $TMT_COLOR = 204
Global Const $TMT_DIBDATA = 2
Global Const $TMT_DISKSTREAM = 213
Global Const $TMT_ENUM = 200
Global Const $TMT_FILENAME = 206
Global Const $TMT_FONT = 210
Global Const $TMT_GLYPHDIBDATA = 8
Global Const $TMT_HBITMAP = 212
Global Const $TMT_INT = 202
Global Const $TMT_INTLIST = 211
Global Const $TMT_MARGINS = 205
Global Const $TMT_POSITION = 208
Global Const $TMT_RECT = 209
Global Const $TMT_SIZE = 207
Global Const $TMT_STRING = 201

; *Bool
Global Const $TMT_ALWAYSSHOWSIZINGBAR = 2208
Global Const $TMT_AUTOSIZE = 2202
Global Const $TMT_BGFILL = 2205
Global Const $TMT_BORDERONLY = 2203
Global Const $TMT_COMPOSITED = 2204
Global Const $TMT_COMPOSITEDOPAQUE = 2219
Global Const $TMT_DRAWBORDERS = 2214
Global Const $TMT_FLATMENUS = 1001
Global Const $TMT_GLYPHONLY = 2207
Global Const $TMT_GLYPHTRANSPARENT = 2206
Global Const $TMT_INTEGRALSIZING = 2211
Global Const $TMT_LOCALIZEDMIRRORIMAGE = 2220
Global Const $TMT_MIRRORIMAGE = 2209
Global Const $TMT_NOETCHEDEFFECT = 2215
Global Const $TMT_SOURCEGROW = 2212
Global Const $TMT_SOURCESHRINK = 2213
Global Const $TMT_TEXTAPPLYOVERLAY = 2216
Global Const $TMT_TEXTGLOW = 2217
Global Const $TMT_TEXTITALIC = 2218
Global Const $TMT_TRANSPARENT = 2201
Global Const $TMT_UNIFORMSIZING = 2210
Global Const $TMT_USERPICTURE = 5001

; *Color
Global Const $TMT_ACCENTCOLORHINT = 3823
Global Const $TMT_ACTIVEBORDER = 1611
Global Const $TMT_ACTIVECAPTION = 1603
Global Const $TMT_APPWORKSPACE = 1613
Global Const $TMT_BACKGROUND = 1602
Global Const $TMT_BLENDCOLOR = 5003
Global Const $TMT_BODYTEXTCOLOR = 3827
Global Const $TMT_BORDERCOLOR = 3801
Global Const $TMT_BORDERCOLORHINT = 3822
Global Const $TMT_BTNFACE = 1616
Global Const $TMT_BTNHIGHLIGHT = 1621
Global Const $TMT_BTNSHADOW = 1617
Global Const $TMT_BTNTEXT = 1619
Global Const $TMT_BUTTONALTERNATEFACE = 1626
Global Const $TMT_CAPTIONTEXT = 1610
Global Const $TMT_DKSHADOW3D = 1622
Global Const $TMT_EDGEDKSHADOWCOLOR = 3807
Global Const $TMT_EDGEFILLCOLOR = 3808
Global Const $TMT_EDGEHIGHLIGHTCOLOR = 3805
Global Const $TMT_EDGELIGHTCOLOR = 3804
Global Const $TMT_EDGESHADOWCOLOR = 3806
Global Const $TMT_FILLCOLOR = 3802
Global Const $TMT_FILLCOLORHINT = 3821
Global Const $TMT_FROMCOLOR1 = 2001
Global Const $TMT_FROMCOLOR2 = 2002
Global Const $TMT_FROMCOLOR3 = 2003
Global Const $TMT_FROMCOLOR4 = 2004
Global Const $TMT_FROMCOLOR5 = 2005
Global Const $TMT_GLOWCOLOR = 3816
Global Const $TMT_GLYPHTEXTCOLOR = 3819
Global Const $TMT_GLYPHTRANSPARENTCOLOR = 3820
Global Const $TMT_GRADIENTACTIVECAPTION = 1628
Global Const $TMT_GRADIENTCOLOR1 = 3810
Global Const $TMT_GRADIENTCOLOR2 = 3811
Global Const $TMT_GRADIENTCOLOR3 = 3812
Global Const $TMT_GRADIENTCOLOR4 = 3813
Global Const $TMT_GRADIENTCOLOR5 = 3814
Global Const $TMT_GRADIENTINACTIVECAPTION = 1629
Global Const $TMT_GRAYTEXT = 1618
Global Const $TMT_HEADING1TEXTCOLOR = 3825
Global Const $TMT_HEADING2TEXTCOLOR = 3826
Global Const $TMT_HIGHLIGHT = 1614
Global Const $TMT_HIGHLIGHTTEXT = 1615
Global Const $TMT_HOTTRACKING = 1627
Global Const $TMT_INACTIVEBORDER = 1612
Global Const $TMT_INACTIVECAPTION = 1604
Global Const $TMT_INACTIVECAPTIONTEXT = 1620
Global Const $TMT_INFOBK = 1625
Global Const $TMT_INFOTEXT = 1624
Global Const $TMT_LIGHT3D = 1623
Global Const $TMT_MENU = 1605
Global Const $TMT_MENUBAR = 1631
Global Const $TMT_MENUHILIGHT = 1630
Global Const $TMT_MENUTEXT = 1608
Global Const $TMT_SCROLLBAR = 1601
Global Const $TMT_SHADOWCOLOR = 3815
Global Const $TMT_TEXTBORDERCOLOR = 3817
Global Const $TMT_TEXTCOLOR = 3803
Global Const $TMT_TEXTCOLORHINT = 3824
Global Const $TMT_TEXTSHADOWCOLOR = 3818
Global Const $TMT_TRANSPARENTCOLOR = 3809
Global Const $TMT_WINDOW = 1606
Global Const $TMT_WINDOWFRAME = 1607
Global Const $TMT_WINDOWTEXT = 1609

; *Stream
Global Const $TMT_ATLASIMAGE = 8000

; *Enum
Global Const $TMT_BGTYPE = 4001
Global Const $TMT_BORDERTYPE = 4002
Global Const $TMT_CONTENTALIGNMENT = 4006
Global Const $TMT_FILLTYPE = 4003
Global Const $TMT_GLYPHTYPE = 4012
Global Const $TMT_GLYPHFONTSIZINGTYPE = 4014
Global Const $TMT_HALIGN = 4005
Global Const $TMT_ICONEFFECT = 4009
Global Const $TMT_IMAGELAYOUT = 4011
Global Const $TMT_IMAGESELECTTYPE = 4013
Global Const $TMT_OFFSETTYPE = 4008
Global Const $TMT_SIZINGTYPE = 4004
Global Const $TMT_TEXTSHADOWTYPE = 4010
Global Const $TMT_TRUESIZESCALINGTYPE = 4015
Global Const $TMT_VALIGN = 4007

; *Filename
Global Const $TMT_GLYPHIMAGEFILE = 3008
Global Const $TMT_IMAGEFILE = 3001
Global Const $TMT_IMAGEFILE1 = 3002
Global Const $TMT_IMAGEFILE2 = 3003
Global Const $TMT_IMAGEFILE3 = 3004
Global Const $TMT_IMAGEFILE4 = 3005
Global Const $TMT_IMAGEFILE5 = 3006
Global Const $TMT_SCALEDBACKGROUND = 7001

; *Font
Global Const $TMT_BODYFONT = 809
Global Const $TMT_CAPTIONFONT = 801
Global Const $TMT_GLYPHFONT = 2601
Global Const $TMT_HEADING1FONT = 807
Global Const $TMT_HEADING2FONT = 808
Global Const $TMT_ICONTITLEFONT = 806
Global Const $TMT_MENUFONT = 803
Global Const $TMT_MSGBOXFONT = 805
Global Const $TMT_SMALLCAPTIONFONT = 802
Global Const $TMT_STATUSFONT = 804

; *Int
Global Const $TMT_ALPHALEVEL = 2402
Global Const $TMT_ALPHATHRESHOLD = 2415
Global Const $TMT_ANIMATIONDELAY = 2428
Global Const $TMT_ANIMATIONDURATION = 5006
Global Const $TMT_BORDERSIZE = 2403
Global Const $TMT_CHARSET = 403
Global Const $TMT_COLORIZATIONCOLOR = 2431
Global Const $TMT_COLORIZATIONOPACITY = 2432
Global Const $TMT_FRAMESPERSECOND = 2426
Global Const $TMT_FROMHUE1 = 1801
Global Const $TMT_FROMHUE2 = 1802
Global Const $TMT_FROMHUE3 = 1803
Global Const $TMT_FROMHUE4 = 1804
Global Const $TMT_FROMHUE5 = 1805
Global Const $TMT_GLOWINTENSITY = 2429
Global Const $TMT_GLYPHINDEX = 2418
Global Const $TMT_GRADIENTRATIO1 = 2406
Global Const $TMT_GRADIENTRATIO2 = 2407
Global Const $TMT_GRADIENTRATIO3 = 2408
Global Const $TMT_GRADIENTRATIO4 = 2409
Global Const $TMT_GRADIENTRATIO5 = 2410
Global Const $TMT_HEIGHT = 2417
Global Const $TMT_IMAGECOUNT = 2401
Global Const $TMT_MINCOLORDEPTH = 1301
Global Const $TMT_MINDPI1 = 2420
Global Const $TMT_MINDPI2 = 2421
Global Const $TMT_MINDPI3 = 2422
Global Const $TMT_MINDPI4 = 2423
Global Const $TMT_MINDPI5 = 2424
Global Const $TMT_OPACITY = 2430
Global Const $TMT_PIXELSPERFRAME = 2427
Global Const $TMT_PROGRESSCHUNKSIZE = 2411
Global Const $TMT_PROGRESSSPACESIZE = 2412
Global Const $TMT_ROUNDCORNERHEIGHT = 2405
Global Const $TMT_ROUNDCORNERWIDTH = 2404
Global Const $TMT_SATURATION = 2413
Global Const $TMT_TEXTBORDERSIZE = 2414
Global Const $TMT_TEXTGLOWSIZE = 2425
Global Const $TMT_TOCOLOR1 = 2006
Global Const $TMT_TOCOLOR2 = 2007
Global Const $TMT_TOCOLOR3 = 2008
Global Const $TMT_TOCOLOR4 = 2009
Global Const $TMT_TOCOLOR5 = 2010
Global Const $TMT_TOHUE1 = 1806
Global Const $TMT_TOHUE2 = 1807
Global Const $TMT_TOHUE3 = 1808
Global Const $TMT_TOHUE4 = 1809
Global Const $TMT_TOHUE5 = 1810
Global Const $TMT_TRUESIZESTRETCHMARK = 2419
Global Const $TMT_WIDTH = 2416

; *IntList
Global Const $TMT_TRANSITIONDURATIONS = 6000

; *Margins
Global Const $TMT_CAPTIONMARGINS = 3603
Global Const $TMT_CONTENTMARGINS = 3602
Global Const $TMT_SIZINGMARGINS = 3601

; *Position
Global Const $TMT_MINSIZE = 3403
Global Const $TMT_MINSIZE1 = 3404
Global Const $TMT_MINSIZE2 = 3405
Global Const $TMT_MINSIZE3 = 3406
Global Const $TMT_MINSIZE4 = 3407
Global Const $TMT_MINSIZE5 = 3408
Global Const $TMT_NORMALSIZE = 3409
Global Const $TMT_OFFSET = 3401
Global Const $TMT_TEXTSHADOWOFFSET = 3402

; *Rect
Global Const $TMT_ANIMATIONBUTTONRECT = 5005
Global Const $TMT_ATLASRECT = 8002
Global Const $TMT_CUSTOMSPLITRECT = 5004
Global Const $TMT_DEFAULTPANESIZE = 5002

; *Size
Global Const $TMT_CAPTIONBARHEIGHT = 1205
Global Const $TMT_CAPTIONBARWIDTH = 1204
Global Const $TMT_MENUBARHEIGHT = 1209
Global Const $TMT_MENUBARWIDTH = 1208
Global Const $TMT_PADDEDBORDERWIDTH = 1210
Global Const $TMT_SCROLLBARHEIGHT = 1203
Global Const $TMT_SCROLLBARWIDTH = 1202
Global Const $TMT_SIZINGBORDERWIDTH = 1201
Global Const $TMT_SMCAPTIONBARHEIGHT = 1207
Global Const $TMT_SMCAPTIONBARWIDTH = 1206

; *String
Global Const $TMT_ALIAS = 1404
Global Const $TMT_ATLASINPUTIMAGE = 8001
Global Const $TMT_AUTHOR = 604
Global Const $TMT_CLASSICVALUE = 3202
Global Const $TMT_COLORSCHEMES = 401
Global Const $TMT_COMPANY = 603
Global Const $TMT_COPYRIGHT = 605
Global Const $TMT_CSSNAME = 1401
Global Const $TMT_DESCRIPTION = 608
Global Const $TMT_DISPLAYNAME = 601
Global Const $TMT_LASTUPDATED = 1403
Global Const $TMT_SIZES = 402
Global Const $TMT_TEXT = 3201
Global Const $TMT_TOOLTIP = 602
Global Const $TMT_URL = 606
Global Const $TMT_VERSION = 607
Global Const $TMT_XMLNAME = 1402
Global Const $TMT_NAME = 600


Global Const $ERROR_SUCCESS = 0                                                   ; The operation completed successfully.
Global Const $ERROR_INVALID_FUNCTION = 1                                          ; Incorrect function.
Global Const $ERROR_FILE_NOT_FOUND = 2                                            ; The system cannot find the file specified.
Global Const $ERROR_PATH_NOT_FOUND = 3                                            ; The system cannot find the path specified.
Global Const $ERROR_TOO_MANY_OPEN_FILES = 4                                       ; The system cannot open the file.
Global Const $ERROR_ACCESS_DENIED = 5                                             ; Access is denied.
Global Const $ERROR_INVALID_HANDLE = 6                                            ; The handle is invalid.
Global Const $ERROR_ARENA_TRASHED = 7                                             ; The storage control blocks were destroyed.
;Global Const $ERROR_NOT_ENOUGH_MEMORY = 8                                         ; Not enough storage is available to process this command.
Global Const $ERROR_INVALID_BLOCK = 9                                             ; The storage control block address is invalid.
Global Const $ERROR_BAD_ENVIRONMENT = 10                                          ; The environment is incorrect.
Global Const $ERROR_BAD_FORMAT = 11                                               ; An attempt was made to load a program with an incorrect format.
Global Const $ERROR_INVALID_ACCESS = 12                                           ; The access code is invalid.
Global Const $ERROR_INVALID_DATA = 13                                             ; The data is invalid.
Global Const $ERROR_OUTOFMEMORY = 14                                              ; Not enough storage is available to complete this operation.
Global Const $ERROR_INVALID_DRIVE = 15                                            ; The system cannot find the drive specified.
Global Const $ERROR_CURRENT_DIRECTORY = 16                                        ; The directory cannot be removed.
Global Const $ERROR_NOT_SAME_DEVICE = 17                                          ; The system cannot move the file to a different disk drive.
Global Const $ERROR_NO_MORE_FILES = 18                                            ; There are no more files.
Global Const $ERROR_WRITE_PROTECT = 19                                            ; The media is write protected.
Global Const $ERROR_BAD_UNIT = 20                                                 ; The system cannot find the device specified.
Global Const $ERROR_NOT_READY = 21                                                ; The device is not ready.
Global Const $ERROR_BAD_COMMAND = 22                                              ; The device does not recognize the command.
Global Const $ERROR_CRC = 23                                                      ; Data error (cyclic redundancy check).
Global Const $ERROR_BAD_LENGTH = 24                                               ; The program issued a command but the command length is incorrect.
Global Const $ERROR_SEEK = 25                                                     ; The drive cannot locate a specific area or track on the disk.
Global Const $ERROR_NOT_DOS_DISK = 26                                             ; The specified disk or diskette cannot be accessed.
Global Const $ERROR_SECTOR_NOT_FOUND = 27                                         ; The drive cannot find the sector requested.
Global Const $ERROR_OUT_OF_PAPER = 28                                             ; The printer is out of paper.
Global Const $ERROR_WRITE_FAULT = 29                                              ; The system cannot write to the specified device.
Global Const $ERROR_READ_FAULT = 30                                               ; The system cannot read from the specified device.
Global Const $ERROR_GEN_FAILURE = 31                                              ; A device attached to the system is not functioning.
Global Const $ERROR_SHARING_VIOLATION = 32                                        ; The process cannot access the file because it is being used by another process.
Global Const $ERROR_LOCK_VIOLATION = 33                                           ; The process cannot access the file because another process has locked a portion of the file.
Global Const $ERROR_WRONG_DISK = 34                                               ; The wrong diskette is in the drive. Insert %2 (Volume Serial Number: %3) into drive %1.
Global Const $ERROR_SHARING_BUFFER_EXCEEDED = 36                                  ; Too many files opened for sharing.
Global Const $ERROR_HANDLE_EOF = 38                                               ; Reached the end of the file.
Global Const $ERROR_HANDLE_DISK_FULL = 39                                         ; The disk is full.
Global Const $ERROR_NOT_SUPPORTED = 50                                            ; The request is not supported.
Global Const $ERROR_REM_NOT_LIST = 51                                             ; Windows cannot find the network path. Verify that the network path is correct and the destination computer is not busy or turned off. If Windows still cannot find the network path, contact your network administrator.
Global Const $ERROR_DUP_NAME = 52                                                 ; You were not connected because a duplicate name exists on the network. If joining a domain, go to System in Control Panel to change the computer name and try again. If joining a workgroup, choose another workgroup name.
Global Const $ERROR_BAD_NETPATH = 53                                              ; The network path was not found.
Global Const $ERROR_NETWORK_BUSY = 54                                             ; The network is busy.
Global Const $ERROR_DEV_NOT_EXIST = 55                                            ; The specified network resource or device is no longer available.
Global Const $ERROR_TOO_MANY_CMDS = 56                                            ; The network BIOS command limit has been reached.
Global Const $ERROR_ADAP_HDW_ERR = 57                                             ; A network adapter hardware error occurred.
Global Const $ERROR_BAD_NET_RESP = 58                                             ; The specified server cannot perform the requested operation.
Global Const $ERROR_UNEXP_NET_ERR = 59                                            ; An unexpected network error occurred.
Global Const $ERROR_BAD_REM_ADAP = 60                                             ; The remote adapter is not compatible.
Global Const $ERROR_PRINTQ_FULL = 61                                              ; The printer queue is full.
Global Const $ERROR_NO_SPOOL_SPACE = 62                                           ; Space to store the file waiting to be printed is not available on the server.
Global Const $ERROR_PRINT_CANCELLED = 63                                          ; Your file waiting to be printed was deleted.
Global Const $ERROR_NETNAME_DELETED = 64                                          ; The specified network name is no longer available.
Global Const $ERROR_NETWORK_ACCESS_DENIED = 65                                    ; Network access is denied.
Global Const $ERROR_BAD_DEV_TYPE = 66                                             ; The network resource type is not correct.
Global Const $ERROR_BAD_NET_NAME = 67                                             ; The network name cannot be found.
Global Const $ERROR_TOO_MANY_NAMES = 68                                           ; The name limit for the local computer network adapter card was exceeded.
Global Const $ERROR_TOO_MANY_SESS = 69                                            ; The network BIOS session limit was exceeded.
Global Const $ERROR_SHARING_PAUSED = 70                                           ; The remote server has been paused or is in the process of being started.
Global Const $ERROR_REQ_NOT_ACCEP = 71                                            ; No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept.
Global Const $ERROR_REDIR_PAUSED = 72                                             ; The specified printer or disk device has been paused.
Global Const $ERROR_FILE_EXISTS = 80                                              ; The file exists.
Global Const $ERROR_CANNOT_MAKE = 82                                              ; The directory or file cannot be created.
Global Const $ERROR_FAIL_I24 = 83                                                 ; Fail on INT 24.
Global Const $ERROR_OUT_OF_STRUCTURES = 84                                        ; Storage to process this request is not available.
Global Const $ERROR_ALREADY_ASSIGNED = 85                                         ; The local device name is already in use.
Global Const $ERROR_INVALID_PASSWORD = 86                                         ; The specified network password is not correct.
Global Const $ERROR_INVALID_PARAMETER = 87                                        ; The parameter is incorrect.
Global Const $ERROR_NET_WRITE_FAULT = 88                                          ; A write fault occurred on the network.
Global Const $ERROR_NO_PROC_SLOTS = 89                                            ; The system cannot start another process at this time.
Global Const $ERROR_TOO_MANY_SEMAPHORES = 100                                     ; Cannot create another system semaphore.
Global Const $ERROR_EXCL_SEM_ALREADY_OWNED = 101                                  ; The exclusive semaphore is owned by another process.
Global Const $ERROR_SEM_IS_SET = 102                                              ; The semaphore is set and cannot be closed.
Global Const $ERROR_TOO_MANY_SEM_REQUESTS = 103                                   ; The semaphore cannot be set again.
Global Const $ERROR_INVALID_AT_INTERRUPT_TIME = 104                               ; Cannot request exclusive semaphores at interrupt time.
Global Const $ERROR_SEM_OWNER_DIED = 105                                          ; The previous ownership of this semaphore has ended.
Global Const $ERROR_SEM_USER_LIMIT = 106                                          ; Insert the diskette for drive %1.
Global Const $ERROR_DISK_CHANGE = 107                                             ; The program stopped because an alternate diskette was not inserted.
Global Const $ERROR_DRIVE_LOCKED = 108                                            ; The disk is in use or locked by another process.
Global Const $ERROR_BROKEN_PIPE = 109                                             ; The pipe has been ended.
Global Const $ERROR_OPEN_FAILED = 110                                             ; The system cannot open the device or file specified.
Global Const $ERROR_BUFFER_OVERFLOW = 111                                         ; The file name is too long.
Global Const $ERROR_DISK_FULL = 112                                               ; There is not enough space on the disk.
Global Const $ERROR_NO_MORE_SEARCH_HANDLES = 113                                  ; No more internal file identifiers available.
Global Const $ERROR_INVALID_TARGET_HANDLE = 114                                   ; The target internal file identifier is incorrect.
Global Const $ERROR_INVALID_CATEGORY = 117                                        ; The IOCTL call made by the application program is not correct.
Global Const $ERROR_INVALID_VERIFY_SWITCH = 118                                   ; The verify-on-write switch parameter value is not correct.
Global Const $ERROR_BAD_DRIVER_LEVEL = 119                                        ; The system does not support the command requested.
Global Const $ERROR_CALL_NOT_IMPLEMENTED = 120                                    ; This function is not supported on this system.
Global Const $ERROR_SEM_TIMEOUT = 121                                             ; The semaphore timeout period has expired.
Global Const $ERROR_INSUFFICIENT_BUFFER = 122                                     ; The data area passed to a system call is too small.
Global Const $ERROR_INVALID_NAME = 123                                            ; The filename, directory name, or volume label syntax is incorrect.
Global Const $ERROR_INVALID_LEVEL = 124                                           ; The system call level is not correct.
Global Const $ERROR_NO_VOLUME_LABEL = 125                                         ; The disk has no volume label.
Global Const $ERROR_MOD_NOT_FOUND = 126                                           ; The specified module could not be found.
Global Const $ERROR_PROC_NOT_FOUND = 127                                          ; The specified procedure could not be found.
Global Const $ERROR_WAIT_NO_CHILDREN = 128                                        ; There are no child processes to wait for.
Global Const $ERROR_CHILD_NOT_COMPLETE = 129                                      ; The %1 application cannot be run in Win32 mode.
Global Const $ERROR_DIRECT_ACCESS_HANDLE = 130                                    ; Attempt to use a file handle to an open disk partition for an operation other than raw disk I/O.
Global Const $ERROR_NEGATIVE_SEEK = 131                                           ; An attempt was made to move the file pointer before the beginning of the file.
Global Const $ERROR_SEEK_ON_DEVICE = 132                                          ; The file pointer cannot be set on the specified device or file.
Global Const $ERROR_IS_JOIN_TARGET = 133                                          ; A JOIN or SUBST command cannot be used for a drive that contains previously joined drives.
Global Const $ERROR_IS_JOINED = 134                                               ; An attempt was made to use a JOIN or SUBST command on a drive that has already been joined.
Global Const $ERROR_IS_SUBSTED = 135                                              ; An attempt was made to use a JOIN or SUBST command on a drive that has already been substituted.
Global Const $ERROR_NOT_JOINED = 136                                              ; The system tried to delete the JOIN of a drive that is not joined.
Global Const $ERROR_NOT_SUBSTED = 137                                             ; The system tried to delete the substitution of a drive that is not substituted.
Global Const $ERROR_JOIN_TO_JOIN = 138                                            ; The system tried to join a drive to a directory on a joined drive.
Global Const $ERROR_SUBST_TO_SUBST = 139                                          ; The system tried to substitute a drive to a directory on a substituted drive.
Global Const $ERROR_JOIN_TO_SUBST = 140                                           ; The system tried to join a drive to a directory on a substituted drive.
Global Const $ERROR_SUBST_TO_JOIN = 141                                           ; The system tried to SUBST a drive to a directory on a joined drive.
Global Const $ERROR_BUSY_DRIVE = 142                                              ; The system cannot perform a JOIN or SUBST at this time.
Global Const $ERROR_SAME_DRIVE = 143                                              ; The system cannot join or substitute a drive to or for a directory on the same drive.
Global Const $ERROR_DIR_NOT_ROOT = 144                                            ; The directory is not a subdirectory of the root directory.
Global Const $ERROR_DIR_NOT_EMPTY = 145                                           ; The directory is not empty.
Global Const $ERROR_IS_SUBST_PATH = 146                                           ; The path specified is being used in a substitute.
Global Const $ERROR_IS_JOIN_PATH = 147                                            ; Not enough resources are available to process this command.
Global Const $ERROR_PATH_BUSY = 148                                               ; The path specified cannot be used at this time.
Global Const $ERROR_IS_SUBST_TARGET = 149                                         ; An attempt was made to join or substitute a drive for which a directory on the drive is the target of a previous substitute.
Global Const $ERROR_SYSTEM_TRACE = 150                                            ; System trace information was not specified in your CONFIG.SYS file, or tracing is disallowed.
Global Const $ERROR_INVALID_EVENT_COUNT = 151                                     ; The number of specified semaphore events for DosMuxSemWait is not correct.
Global Const $ERROR_TOO_MANY_MUXWAITERS = 152                                     ; DosMuxSemWait did not execute; too many semaphores are already set.
Global Const $ERROR_INVALID_LIST_FORMAT = 153                                     ; The DosMuxSemWait list is not correct.
Global Const $ERROR_LABEL_TOO_LONG = 154                                          ; The volume label you entered exceeds the label character limit of the target file system.
Global Const $ERROR_TOO_MANY_TCBS = 155                                           ; Cannot create another thread.
Global Const $ERROR_SIGNAL_REFUSED = 156                                          ; The recipient process has refused the signal.
Global Const $ERROR_DISCARDED = 157                                               ; The segment is already discarded and cannot be locked.
Global Const $ERROR_NOT_LOCKED = 158                                              ; The segment is already unlocked.
Global Const $ERROR_BAD_THREADID_ADDR = 159                                       ; The address for the thread ID is not correct.
Global Const $ERROR_BAD_ARGUMENTS = 160                                           ; One or more arguments are not correct.
Global Const $ERROR_BAD_PATHNAME = 161                                            ; The specified path is invalid.
Global Const $ERROR_SIGNAL_PENDING = 162                                          ; A signal is already pending.
Global Const $ERROR_MAX_THRDS_REACHED = 164                                       ; No more threads can be created in the system.
Global Const $ERROR_LOCK_FAILED = 167                                             ; Unable to lock a region of a file.
Global Const $ERROR_BUSY = 170                                                    ; The requested resource is in use.
Global Const $ERROR_CANCEL_VIOLATION = 173                                        ; A lock request was not outstanding for the supplied cancel region.
Global Const $ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = 174                              ; The file system does not support atomic changes to the lock type.
Global Const $ERROR_INVALID_SEGMENT_NUMBER = 180                                  ; The system detected a segment number that was not correct.
Global Const $ERROR_INVALID_ORDINAL = 182                                         ; The operating system cannot run %1.
Global Const $ERROR_ALREADY_EXISTS = 183                                          ; Cannot create a file when that file already exists.
Global Const $ERROR_INVALID_FLAG_NUMBER = 186                                     ; The flag passed is not correct.
Global Const $ERROR_SEM_NOT_FOUND = 187                                           ; The specified system semaphore name was not found.
Global Const $ERROR_INVALID_STARTING_CODESEG = 188                                ; The operating system cannot run %1.
Global Const $ERROR_INVALID_STACKSEG = 189                                        ; The operating system cannot run %1.
Global Const $ERROR_INVALID_MODULETYPE = 190                                      ; The operating system cannot run %1.
Global Const $ERROR_INVALID_EXE_SIGNATURE = 191                                   ; Cannot run %1 in Win32 mode.
Global Const $ERROR_EXE_MARKED_INVALID = 192                                      ; The operating system cannot run %1.
Global Const $ERROR_BAD_EXE_FORMAT = 193                                          ; %1 is not a valid Win32 application.
Global Const $ERROR_ITERATED_DATA_EXCEEDS_64k = 194                               ; The operating system cannot run %1.
Global Const $ERROR_INVALID_MINALLOCSIZE = 195                                    ; The operating system cannot run %1.
Global Const $ERROR_DYNLINK_FROM_INVALID_RING = 196                               ; The operating system cannot run this application program.
Global Const $ERROR_IOPL_NOT_ENABLED = 197                                        ; The operating system is not presently configured to run this application.
Global Const $ERROR_INVALID_SEGDPL = 198                                          ; The operating system cannot run %1.
Global Const $ERROR_AUTODATASEG_EXCEEDS_64k = 199                                 ; The operating system cannot run this application program.
Global Const $ERROR_RING2SEG_MUST_BE_MOVABLE = 200                                ; The code segment cannot be greater than or equal to 64K.
Global Const $ERROR_RELOC_CHAIN_XEEDS_SEGLIM = 201                                ; The operating system cannot run %1.
Global Const $ERROR_INFLOOP_IN_RELOC_CHAIN = 202                                  ; The operating system cannot run %1.
Global Const $ERROR_ENVVAR_NOT_FOUND = 203                                        ; The system could not find the environment option that was entered.
Global Const $ERROR_NO_SIGNAL_SENT = 205                                          ; No process in the command subtree has a signal handler.
Global Const $ERROR_FILENAME_EXCED_RANGE = 206                                    ; The filename or extension is too long.
Global Const $ERROR_RING2_STACK_IN_USE = 207                                      ; The ring 2 stack is in use.
Global Const $ERROR_META_EXPANSION_TOO_LONG = 208                                 ; The global filename characters, * or ?, are entered incorrectly or too many global filename characters are specified.
Global Const $ERROR_INVALID_SIGNAL_NUMBER = 209                                   ; The signal being posted is not correct.
Global Const $ERROR_THREAD_1_INACTIVE = 210                                       ; The signal handler cannot be set.
Global Const $ERROR_LOCKED = 212                                                  ; The segment is locked and cannot be reallocated.
Global Const $ERROR_TOO_MANY_MODULES = 214                                        ; Too many dynamic-link modules are attached to this program or dynamic-link module.
Global Const $ERROR_NESTING_NOT_ALLOWED = 215                                     ; Cannot nest calls to LoadModule.
Global Const $ERROR_EXE_MACHINE_TYPE_MISMATCH = 216                               ; The version of %1 is not compatible with the version you're running. Check your computer's system information to see whether you need a x86 (32-bit) or x64 (64-bit) version of the program, and then contact the software publisher.
Global Const $ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY = 217                         ; The image file %1 is signed, unable to modify.
Global Const $ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY = 218                  ; The image file %1 is strong signed, unable to modify.
Global Const $ERROR_FILE_CHECKED_OUT = 220                                        ; This file is checked out or locked for editing by another user.
Global Const $ERROR_CHECKOUT_REQUIRED = 221                                       ; The file must be checked out before saving changes.
Global Const $ERROR_BAD_FILE_TYPE = 222                                           ; The file type being saved or retrieved has been blocked.
Global Const $ERROR_FILE_TOO_LARGE = 223                                          ; The file size exceeds the limit allowed and cannot be saved.
Global Const $ERROR_FORMS_AUTH_REQUIRED = 224                                     ; Access Denied. Before opening files in this location, you must first add the web site to your trusted sites list, browse to the web site, and select the option to login automatically.
Global Const $ERROR_VIRUS_INFECTED = 225                                          ; Operation did not complete successfully because the file contains a virus.
Global Const $ERROR_VIRUS_DELETED = 226                                           ; This file contains a virus and cannot be opened. Due to the nature of this virus, the file has been removed from this location.
Global Const $ERROR_PIPE_LOCAL = 229                                              ; The pipe is local.
Global Const $ERROR_BAD_PIPE = 230                                                ; The pipe state is invalid.
Global Const $ERROR_PIPE_BUSY = 231                                               ; All pipe instances are busy.
Global Const $ERROR_NO_DATA = 232                                                 ; The pipe is being closed.
Global Const $ERROR_PIPE_NOT_CONNECTED = 233                                      ; No process is on the other end of the pipe.
Global Const $ERROR_MORE_DATA = 234                                               ; More data is available.
Global Const $ERROR_VC_DISCONNECTED = 240                                         ; The session was canceled.
Global Const $ERROR_INVALID_EA_NAME = 254                                         ; The specified extended attribute name was invalid.
Global Const $ERROR_EA_LIST_INCONSISTENT = 255                                    ; The extended attributes are inconsistent.
Global Const $WAIT_TIMEOUT = 258                                                  ; The wait operation timed out.
Global Const $ERROR_NO_MORE_ITEMS = 259                                           ; No more data is available.
Global Const $ERROR_CANNOT_COPY = 266                                             ; The copy functions cannot be used.
Global Const $ERROR_DIRECTORY = 267                                               ; The directory name is invalid.
Global Const $ERROR_EAS_DIDNT_FIT = 275                                           ; The extended attributes did not fit in the buffer.
Global Const $ERROR_EA_FILE_CORRUPT = 276                                         ; The extended attribute file on the mounted file system is corrupt.
Global Const $ERROR_EA_TABLE_FULL = 277                                           ; The extended attribute table file is full.
Global Const $ERROR_INVALID_EA_HANDLE = 278                                       ; The specified extended attribute handle is invalid.
Global Const $ERROR_EAS_NOT_SUPPORTED = 282                                       ; The mounted file system does not support extended attributes.
Global Const $ERROR_NOT_OWNER = 288                                               ; Attempt to release mutex not owned by caller.
Global Const $ERROR_TOO_MANY_POSTS = 298                                          ; Too many posts were made to a semaphore.
Global Const $ERROR_PARTIAL_COPY = 299                                            ; Only part of a ReadProcessMemory or WriteProcessMemory request was completed.
Global Const $ERROR_OPLOCK_NOT_GRANTED = 300                                      ; The oplock request is denied.
Global Const $ERROR_INVALID_OPLOCK_PROTOCOL = 301                                 ; An invalid oplock acknowledgment was received by the system.
Global Const $ERROR_DISK_TOO_FRAGMENTED = 302                                     ; The volume is too fragmented to complete this operation.
Global Const $ERROR_DELETE_PENDING = 303                                          ; The file cannot be opened because it is in the process of being deleted.
Global Const $ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = 304    ; Short name settings may not be changed on this volume due to the global registry setting.
Global Const $ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = 305                       ; Short names are not enabled on this volume.
Global Const $ERROR_SECURITY_STREAM_IS_INCONSISTENT = 306                         ; The security stream for the given volume is in an inconsistent state. Please run CHKDSK on the volume.
Global Const $ERROR_INVALID_LOCK_RANGE = 307                                      ; A requested file lock operation cannot be processed due to an invalid byte range.
Global Const $ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT = 308                             ; The subsystem needed to support the image type is not present.
Global Const $ERROR_NOTIFICATION_GUID_ALREADY_DEFINED = 309                       ; The specified file already has a notification GUID associated with it.
Global Const $ERROR_MR_MID_NOT_FOUND = 317                                        ; The system cannot find message text for message number 0x%1 in the message file for %2.
Global Const $ERROR_SCOPE_NOT_FOUND = 318                                         ; The scope specified was not found.
Global Const $ERROR_FAIL_NOACTION_REBOOT = 350                                    ; No action was taken as a system reboot is required.
Global Const $ERROR_FAIL_SHUTDOWN = 351                                           ; The shutdown operation failed.
Global Const $ERROR_FAIL_RESTART = 352                                            ; The restart operation failed.
Global Const $ERROR_MAX_SESSIONS_REACHED = 353                                    ; The maximum number of sessions has been reached.
Global Const $ERROR_THREAD_MODE_ALREADY_BACKGROUND = 400                          ; The thread is already in background processing mode.
Global Const $ERROR_THREAD_MODE_NOT_BACKGROUND = 401                              ; The thread is not in background processing mode.
Global Const $ERROR_PROCESS_MODE_ALREADY_BACKGROUND = 402                         ; The process is already in background processing mode.
Global Const $ERROR_PROCESS_MODE_NOT_BACKGROUND = 403                             ; The process is not in background processing mode.
Global Const $ERROR_INVALID_ADDRESS = 487                                         ; Attempt to access invalid address.
Global Const $ERROR_USER_PROFILE_LOAD = 500                                       ; User profile cannot be loaded.
Global Const $ERROR_ARITHMETIC_OVERFLOW = 534                                     ; Arithmetic result exceeded 32 bits.
Global Const $ERROR_PIPE_CONNECTED = 535                                          ; There is a process on other end of the pipe.
Global Const $ERROR_PIPE_LISTENING = 536                                          ; Waiting for a process to open the other end of the pipe.
Global Const $ERROR_VERIFIER_STOP = 537                                           ; Application verifier has found an error in the current process.
Global Const $ERROR_ABIOS_ERROR = 538                                             ; An error occurred in the ABIOS subsystem.
Global Const $ERROR_WX86_WARNING = 539                                            ; A warning occurred in the WX86 subsystem.
Global Const $ERROR_WX86_ERROR = 540                                              ; An error occurred in the WX86 subsystem.
Global Const $ERROR_TIMER_NOT_CANCELED = 541                                      ; An attempt was made to cancel or set a timer that has an associated APC and the subject thread is not the thread that originally set the timer with an associated APC routine.
Global Const $ERROR_UNWIND = 542                                                  ; Unwind exception code.
Global Const $ERROR_BAD_STACK = 543                                               ; An invalid or unaligned stack was encountered during an unwind operation.
Global Const $ERROR_INVALID_UNWIND_TARGET = 544                                   ; An invalid unwind target was encountered during an unwind operation.
Global Const $ERROR_INVALID_PORT_ATTRIBUTES = 545                                 ; Invalid Object Attributes specified to NtCreatePort or invalid Port Attributes specified to NtConnectPort.
Global Const $ERROR_PORT_MESSAGE_TOO_LONG = 546                                   ; Length of message passed to NtRequestPort or NtRequestWaitReplyPort was longer than the maximum message allowed by the port.
Global Const $ERROR_INVALID_QUOTA_LOWER = 547                                     ; An attempt was made to lower a quota limit below the current usage.
Global Const $ERROR_DEVICE_ALREADY_ATTACHED = 548                                 ; An attempt was made to attach to a device that was already attached to another device.
Global Const $ERROR_INSTRUCTION_MISALIGNMENT = 549                                ; An attempt was made to execute an instruction at an unaligned address and the host system does not support unaligned instruction references.
Global Const $ERROR_PROFILING_NOT_STARTED = 550                                   ; Profiling not started.
Global Const $ERROR_PROFILING_NOT_STOPPED = 551                                   ; Profiling not stopped.
Global Const $ERROR_COULD_NOT_INTERPRET = 552                                     ; The passed ACL did not contain the minimum required information.
Global Const $ERROR_PROFILING_AT_LIMIT = 553                                      ; The number of active profiling objects is at the maximum and no more may be started.
Global Const $ERROR_CANT_WAIT = 554                                               ; Used to indicate that an operation cannot continue without blocking for I/O.
Global Const $ERROR_CANT_TERMINATE_SELF = 555                                     ; Indicates that a thread attempted to terminate itself by default (called NtTerminateThread with NULL) and it was the last thread in the current process.
Global Const $ERROR_UNEXPECTED_MM_CREATE_ERR = 556                                ; If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter. In this case information is lost, however, the filter correctly handles the exception.
Global Const $ERROR_UNEXPECTED_MM_MAP_ERROR = 557                                 ; If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter. In this case information is lost, however, the filter correctly handles the exception.
Global Const $ERROR_UNEXPECTED_MM_EXTEND_ERR = 558                                ; If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter. In this case information is lost, however, the filter correctly handles the exception.
Global Const $ERROR_BAD_FUNCTION_TABLE = 559                                      ; A malformed function table was encountered during an unwind operation.
Global Const $ERROR_NO_GUID_TRANSLATION = 560                                     ; Indicates that an attempt was made to assign protection to a file system file or directory and one of the SIDs in the security descriptor could not be translated into a GUID that could be stored by the file system. This causes the protection attempt to fail, which may cause a file creation attempt to fail.
Global Const $ERROR_INVALID_LDT_SIZE = 561                                        ; Indicates that an attempt was made to grow an LDT by setting its size, or that the size was not an even number of selectors.
Global Const $ERROR_INVALID_LDT_OFFSET = 563                                      ; Indicates that the starting value for the LDT information was not an integral multiple of the selector size.
Global Const $ERROR_INVALID_LDT_DESCRIPTOR = 564                                  ; Indicates that the user supplied an invalid descriptor when trying to set up Ldt descriptors.
Global Const $ERROR_TOO_MANY_THREADS = 565                                        ; Indicates a process has too many threads to perform the requested action. For example, assignment of a primary token may only be performed when a process has zero or one threads.
Global Const $ERROR_THREAD_NOT_IN_PROCESS = 566                                   ; An attempt was made to operate on a thread within a specific process, but the thread specified is not in the process specified.
Global Const $ERROR_PAGEFILE_QUOTA_EXCEEDED = 567                                 ; Page file quota was exceeded.
Global Const $ERROR_LOGON_SERVER_CONFLICT = 568                                   ; The Netlogon service cannot start because another Netlogon service running in the domain conflicts with the specified role.
Global Const $ERROR_SYNCHRONIZATION_REQUIRED = 569                                ; The SAM database on a Windows Server is significantly out of synchronization with the copy on the Domain Controller. A complete synchronization is required.
Global Const $ERROR_NET_OPEN_FAILED = 570                                         ; The NtCreateFile API failed. This error should never be returned to an application, it is a place holder for the Windows Lan Manager Redirector to use in its internal error mapping routines.
Global Const $ERROR_IO_PRIVILEGE_FAILED = 571                                     ; {Privilege Failed} The I/O permissions for the process could not be changed.
Global Const $ERROR_CONTROL_C_EXIT = 572                                          ; {Application Exit by CTRL+C} The application terminated as a result of a CTRL+C.
Global Const $ERROR_MISSING_SYSTEMFILE = 573                                      ; {Missing System File} The required system file %hs is bad or missing.
Global Const $ERROR_UNHANDLED_EXCEPTION = 574                                     ; {Application Error} The exception %s (0x%08lx) occurred in the application at location 0x%08lx.
Global Const $ERROR_APP_INIT_FAILURE = 575                                        ; {Application Error} The application failed to initialize properly (0x%lx). Click OK to terminate the application.
Global Const $ERROR_PAGEFILE_CREATE_FAILED = 576                                  ; {Unable to Create Paging File} The creation of the paging file %hs failed (%lx). The requested size was %ld.
Global Const $ERROR_INVALID_IMAGE_HASH = 577                                      ; Windows cannot verify the digital signature for this file. A recent hardware or software change might have installed a file that is signed incorrectly or damaged, or that might be malicious software from an unknown source.
Global Const $ERROR_NO_PAGEFILE = 578                                             ; {No Paging File Specified} No paging file was specified in the system configuration.
Global Const $ERROR_ILLEGAL_FLOAT_CONTEXT = 579                                   ; {EXCEPTION} A real-mode application issued a floating-point instruction and floating-point hardware is not present.
Global Const $ERROR_NO_EVENT_PAIR = 580                                           ; An event pair synchronization operation was performed using the thread specific client/server event pair object, but no event pair object was associated with the thread.
Global Const $ERROR_DOMAIN_CTRLR_CONFIG_ERROR = 581                               ; A Windows Server has an incorrect configuration.
Global Const $ERROR_ILLEGAL_CHARACTER = 582                                       ; An illegal character was encountered. For a multi-byte character set this includes a lead byte without a succeeding trail byte. For the Unicode character set this includes the characters 0xFFFF and 0xFFFE.
Global Const $ERROR_UNDEFINED_CHARACTER = 583                                     ; The Unicode character is not defined in the Unicode character set installed on the system.
Global Const $ERROR_FLOPPY_VOLUME = 584                                           ; The paging file cannot be created on a floppy diskette.
Global Const $ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT = 585                        ; The system BIOS failed to connect a system interrupt to the device or bus for which the device is connected.
Global Const $ERROR_BACKUP_CONTROLLER = 586                                       ; This operation is only allowed for the Primary Domain Controller of the domain.
Global Const $ERROR_MUTANT_LIMIT_EXCEEDED = 587                                   ; An attempt was made to acquire a mutant such that its maximum count would have been exceeded.
Global Const $ERROR_FS_DRIVER_REQUIRED = 588                                      ; A volume has been accessed for which a file system driver is required that has not yet been loaded.
Global Const $ERROR_CANNOT_LOAD_REGISTRY_FILE = 589                               ; {Registry File Failure} The registry cannot load the hive (file): %hs or its log or alternate. It is corrupt, absent, or not writable.
Global Const $ERROR_DEBUG_ATTACH_FAILED = 590                                     ; {Unexpected Failure in DebugActiveProcess} An unexpected failure occurred while processing a DebugActiveProcess API request. You may choose OK to terminate the process, or Cancel to ignore the error.
Global Const $ERROR_SYSTEM_PROCESS_TERMINATED = 591                               ; {Fatal System Error} The %hs system process terminated unexpectedly with a status of 0x%08x (0x%08x 0x%08x). The system has been shut down.
Global Const $ERROR_DATA_NOT_ACCEPTED = 592                                       ; {Data Not Accepted} The TDI client could not handle the data received during an indication.
Global Const $ERROR_VDM_HARD_ERROR = 593                                          ; NTVDM encountered a hard error.
Global Const $ERROR_DRIVER_CANCEL_TIMEOUT = 594                                   ; {Cancel Timeout} The driver %hs failed to complete a canceled I/O request in the allotted time.
Global Const $ERROR_REPLY_MESSAGE_MISMATCH = 595                                  ; {Reply Message Mismatch} An attempt was made to reply to an LPC message, but the thread specified by the client ID in the message was not waiting on that message.
Global Const $ERROR_LOST_WRITEBEHIND_DATA = 596                                   ; {Delayed Write Failed} Windows was unable to save all the data for the file %hs. The data has been lost. This error may be caused by a failure of your computer hardware or network connection. Please try to save this file elsewhere.
Global Const $ERROR_CLIENT_SERVER_PARAMETERS_INVALID = 597                        ; The parameter(s) passed to the server in the client/server shared memory window were invalid. Too much data may have been put in the shared memory window.
Global Const $ERROR_NOT_TINY_STREAM = 598                                         ; The stream is not a tiny stream.
Global Const $ERROR_STACK_OVERFLOW_READ = 599                                     ; The request must be handled by the stack overflow code.
Global Const $ERROR_CONVERT_TO_LARGE = 600                                        ; Internal OFS status codes indicating how an allocation operation is handled. Either it is retried after the containing node is moved or the extent stream is converted to a large stream.
Global Const $ERROR_FOUND_OUT_OF_SCOPE = 601                                      ; The attempt to find the object found an object matching by ID on the volume but it is out of the scope of the handle used for the operation.
Global Const $ERROR_ALLOCATE_BUCKET = 602                                         ; The bucket array must be grown. Retry transaction after doing so.
Global Const $ERROR_MARSHALL_OVERFLOW = 603                                       ; The user/kernel marshalling buffer has overflowed.
Global Const $ERROR_INVALID_VARIANT = 604                                         ; The supplied variant structure contains invalid data.
Global Const $ERROR_BAD_COMPRESSION_BUFFER = 605                                  ; The specified buffer contains ill-formed data.
Global Const $ERROR_AUDIT_FAILED = 606                                            ; {Audit Failed} An attempt to generate a security audit failed.
Global Const $ERROR_TIMER_RESOLUTION_NOT_SET = 607                                ; The timer resolution was not previously set by the current process.
Global Const $ERROR_INSUFFICIENT_LOGON_INFO = 608                                 ; There is insufficient account information to log you on.
Global Const $ERROR_BAD_DLL_ENTRYPOINT = 609                                      ; {Invalid DLL Entry point} The dynamic link library %hs is not written correctly. The stack pointer has been left in an inconsistent state. The entry point should be declared as WINAPI or STDCALL. Select YES to fail the DLL load. Select NO to continue execution. Selecting NO may cause the application to operate incorrectly.
Global Const $ERROR_BAD_SERVICE_ENTRYPOINT = 610                                  ; {Invalid Service Callback Entry point} The %hs service is not written correctly. The stack pointer has been left in an inconsistent state. The callback entry point should be declared as WINAPI or STDCALL. Selecting OK will cause the service to continue operation. However, the service process may operate incorrectly.
Global Const $ERROR_IP_ADDRESS_CONFLICT1 = 611                                    ; There is an IP address conflict with another system on the network.
Global Const $ERROR_IP_ADDRESS_CONFLICT2 = 612                                    ; There is an IP address conflict with another system on the network.
Global Const $ERROR_REGISTRY_QUOTA_LIMIT = 613                                    ; {Low On Registry Space} The system has reached the maximum size allowed for the system part of the registry. Additional storage requests will be ignored.
Global Const $ERROR_NO_CALLBACK_ACTIVE = 614                                      ; A callback return system service cannot be executed when no callback is active.
Global Const $ERROR_PWD_TOO_SHORT = 615                                           ; The password provided is too short to meet the policy of your user account. Please choose a longer password.
Global Const $ERROR_PWD_TOO_RECENT = 616                                          ; The policy of your user account does not allow you to change passwords too frequently. This is done to prevent users from changing back to a familiar, but potentially discovered, password. If you feel your password has been compromised then please contact your administrator immediately to have a new one assigned.
Global Const $ERROR_PWD_HISTORY_CONFLICT = 617                                    ; You have attempted to change your password to one that you have used in the past. The policy of your user account does not allow this. Please select a password that you have not previously used.
Global Const $ERROR_UNSUPPORTED_COMPRESSION = 618                                 ; The specified compression format is unsupported.
Global Const $ERROR_INVALID_HW_PROFILE = 619                                      ; The specified hardware profile configuration is invalid.
Global Const $ERROR_INVALID_PLUGPLAY_DEVICE_PATH = 620                            ; The specified Plug and Play registry device path is invalid.
Global Const $ERROR_QUOTA_LIST_INCONSISTENT = 621                                 ; The specified quota list is internally inconsistent with its descriptor.
Global Const $ERROR_EVALUATION_EXPIRATION = 622                                   ; {Windows Evaluation Notification} The evaluation period for this installation of Windows has expired. This system will shutdown in 1 hour. To restore access to this installation of Windows, please upgrade this installation using a licensed distribution of this product.
Global Const $ERROR_ILLEGAL_DLL_RELOCATION = 623                                  ; {Illegal System DLL Relocation} The system DLL %hs was relocated in memory. The application will not run properly. The relocation occurred because the DLL %hs occupied an address range reserved for Windows system DLLs. The vendor supplying the DLL should be contacted for a new DLL.
Global Const $ERROR_DLL_INIT_FAILED_LOGOFF = 624                                  ; {DLL Initialization Failed} The application failed to initialize because the window station is shutting down.
Global Const $ERROR_VALIDATE_CONTINUE = 625                                       ; The validation process needs to continue on to the next step.
Global Const $ERROR_NO_MORE_MATCHES = 626                                         ; There are no more matches for the current index enumeration.
Global Const $ERROR_RANGE_LIST_CONFLICT = 627                                     ; The range could not be added to the range list because of a conflict.
Global Const $ERROR_SERVER_SID_MISMATCH = 628                                     ; The server process is running under a SID different than that required by client.
Global Const $ERROR_CANT_ENABLE_DENY_ONLY = 629                                   ; A group marked use for deny only cannot be enabled.
Global Const $ERROR_FLOAT_MULTIPLE_FAULTS = 630                                   ; {EXCEPTION} Multiple floating point faults.
Global Const $ERROR_FLOAT_MULTIPLE_TRAPS = 631                                    ; {EXCEPTION} Multiple floating point traps.
Global Const $ERROR_NOINTERFACE = 632                                             ; The requested interface is not supported.
Global Const $ERROR_DRIVER_FAILED_SLEEP = 633                                     ; {System Standby Failed} The driver %hs does not support standby mode. Updating this driver may allow the system to go to standby mode.
Global Const $ERROR_CORRUPT_SYSTEM_FILE = 634                                     ; The system file %1 has become corrupt and has been replaced.
Global Const $ERROR_COMMITMENT_MINIMUM = 635                                      ; {Virtual Memory Minimum Too Low} Your system is low on virtual memory. Windows is increasing the size of your virtual memory paging file. During this process, memory requests for some applications may be denied. For more information, see Help.
Global Const $ERROR_PNP_RESTART_ENUMERATION = 636                                 ; A device was removed so enumeration must be restarted.
Global Const $ERROR_SYSTEM_IMAGE_BAD_SIGNATURE = 637                              ; {Fatal System Error} The system image %s is not properly signed. The file has been replaced with the signed file. The system has been shut down.
Global Const $ERROR_PNP_REBOOT_REQUIRED = 638                                     ; Device will not start without a reboot.
Global Const $ERROR_INSUFFICIENT_POWER = 639                                      ; There is not enough power to complete the requested operation.
Global Const $ERROR_MULTIPLE_FAULT_VIOLATION = 640                                ; ERROR_MULTIPLE_FAULT_VIOLATION
Global Const $ERROR_SYSTEM_SHUTDOWN = 641                                         ; The system is in the process of shutting down.
Global Const $ERROR_PORT_NOT_SET = 642                                            ; An attempt to remove a processes DebugPort was made, but a port was not already associated with the process.
Global Const $ERROR_DS_VERSION_CHECK_FAILURE = 643                                ; This version of Windows is not compatible with the behavior version of directory forest, domain or domain controller.
Global Const $ERROR_RANGE_NOT_FOUND = 644                                         ; The specified range could not be found in the range list.
Global Const $ERROR_NOT_SAFE_MODE_DRIVER = 646                                    ; The driver was not loaded because the system is booting into safe mode.
Global Const $ERROR_FAILED_DRIVER_ENTRY = 647                                     ; The driver was not loaded because it failed it's initialization call.
Global Const $ERROR_DEVICE_ENUMERATION_ERROR = 648                                ; The "%hs" encountered an error while applying power or reading the device configuration. This may be caused by a failure of your hardware or by a poor connection.
Global Const $ERROR_MOUNT_POINT_NOT_RESOLVED = 649                                ; The create operation failed because the name contained at least one mount point which resolves to a volume to which the specified device object is not attached.
Global Const $ERROR_INVALID_DEVICE_OBJECT_PARAMETER = 650                         ; The device object parameter is either not a valid device object or is not attached to the volume specified by the file name.
Global Const $ERROR_MCA_OCCURED = 651                                             ; A Machine Check Error has occurred. Please check the system event log for additional information.
Global Const $ERROR_DRIVER_DATABASE_ERROR = 652                                   ; There was error [%2] processing the driver database.
Global Const $ERROR_SYSTEM_HIVE_TOO_LARGE = 653                                   ; System hive size has exceeded its limit.
Global Const $ERROR_DRIVER_FAILED_PRIOR_UNLOAD = 654                              ; The driver could not be loaded because a previous version of the driver is still in memory.
Global Const $ERROR_VOLSNAP_PREPARE_HIBERNATE = 655                               ; {Volume Shadow Copy Service} Please wait while the Volume Shadow Copy Service prepares volume %hs for hibernation.
Global Const $ERROR_HIBERNATION_FAILURE = 656                                     ; The system has failed to hibernate (The error code is %hs). Hibernation will be disabled until the system is restarted.
Global Const $ERROR_FILE_SYSTEM_LIMITATION = 665                                  ; The requested operation could not be completed due to a file system limitation.
Global Const $ERROR_ASSERTION_FAILURE = 668                                       ; An assertion failure has occurred.
Global Const $ERROR_ACPI_ERROR = 669                                              ; An error occurred in the ACPI subsystem.
Global Const $ERROR_WOW_ASSERTION = 670                                           ; WOW Assertion Error.
Global Const $ERROR_PNP_BAD_MPS_TABLE = 671                                       ; A device is missing in the system BIOS MPS table. This device will not be used. Please contact your system vendor for system BIOS update.
Global Const $ERROR_PNP_TRANSLATION_FAILED = 672                                  ; A translator failed to translate resources.
Global Const $ERROR_PNP_IRQ_TRANSLATION_FAILED = 673                              ; A IRQ translator failed to translate resources.
Global Const $ERROR_PNP_INVALID_ID = 674                                          ; Driver %2 returned invalid ID for a child device (%3).
Global Const $ERROR_WAKE_SYSTEM_DEBUGGER = 675                                    ; {Kernel Debugger Awakened} the system debugger was awakened by an interrupt.
Global Const $ERROR_HANDLES_CLOSED = 676                                          ; {Handles Closed} Handles to objects have been automatically closed as a result of the requested operation.
Global Const $ERROR_EXTRANEOUS_INFORMATION = 677                                  ; {Too Much Information} The specified access control list (ACL) contained more information than was expected.
Global Const $ERROR_RXACT_COMMIT_NECESSARY = 678                                  ; This warning level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted. The commit has NOT been completed, but has not been rolled back either (so it may still be committed if desired).
Global Const $ERROR_MEDIA_CHECK = 679                                             ; {Media Changed} The media may have changed.
Global Const $ERROR_GUID_SUBSTITUTION_MADE = 680                                  ; {GUID Substitution} During the translation of a global identifier (GUID) to a Windows security ID (SID), no administratively-defined GUID prefix was found. A substitute prefix was used, which will not compromise system security. However, this may provide a more restrictive access than intended.
Global Const $ERROR_STOPPED_ON_SYMLINK = 681                                      ; The create operation stopped after reaching a symbolic link.
Global Const $ERROR_LONGJUMP = 682                                                ; A long jump has been executed.
Global Const $ERROR_PLUGPLAY_QUERY_VETOED = 683                                   ; The Plug and Play query operation was not successful.
Global Const $ERROR_UNWIND_CONSOLIDATE = 684                                      ; A frame consolidation has been executed.
Global Const $ERROR_REGISTRY_HIVE_RECOVERED = 685                                 ; {Registry Hive Recovered} Registry hive (file): %hs was corrupted and it has been recovered. Some data might have been lost.
Global Const $ERROR_DLL_MIGHT_BE_INSECURE = 686                                   ; The application is attempting to run executable code from the module %hs. This may be insecure. An alternative, %hs, is available. Should the application use the secure module %hs?
Global Const $ERROR_DLL_MIGHT_BE_INCOMPATIBLE = 687                               ; The application is loading executable code from the module %hs. This is secure, but may be incompatible with previous releases of the operating system. An alternative, %hs, is available. Should the application use the secure module %hs?
Global Const $ERROR_DBG_EXCEPTION_NOT_HANDLED = 688                               ; Debugger did not handle the exception.
Global Const $ERROR_DBG_REPLY_LATER = 689                                         ; Debugger will reply later.
Global Const $ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE = 690                            ; Debugger cannot provide handle.
Global Const $ERROR_DBG_TERMINATE_THREAD = 691                                    ; Debugger terminated thread.
Global Const $ERROR_DBG_TERMINATE_PROCESS = 692                                   ; Debugger terminated process.
Global Const $ERROR_DBG_CONTROL_C = 693                                           ; Debugger got control C.
Global Const $ERROR_DBG_PRINTEXCEPTION_C = 694                                    ; Debugger printed exception on control C.
Global Const $ERROR_DBG_RIPEXCEPTION = 695                                        ; Debugger received RIP exception.
Global Const $ERROR_DBG_CONTROL_BREAK = 696                                       ; Debugger received control break.
Global Const $ERROR_DBG_COMMAND_EXCEPTION = 697                                   ; Debugger command communication exception.
Global Const $ERROR_OBJECT_NAME_EXISTS = 698                                      ; {Object Exists} An attempt was made to create an object and the object name already existed.
Global Const $ERROR_THREAD_WAS_SUSPENDED = 699                                    ; {Thread Suspended} A thread termination occurred while the thread was suspended. The thread was resumed, and termination proceeded.
Global Const $ERROR_IMAGE_NOT_AT_BASE = 700                                       ; {Image Relocated} An image file could not be mapped at the address specified in the image file. Local fixups must be performed on this image.
Global Const $ERROR_RXACT_STATE_CREATED = 701                                     ; This informational level status indicates that a specified registry sub-tree transaction state did not yet exist and had to be created.
Global Const $ERROR_SEGMENT_NOTIFICATION = 702                                    ; {Segment Load} A virtual DOS machine (VDM) is loading, unloading, or moving an MS-DOS or Win16 program segment image. An exception is raised so a debugger can load, unload or track symbols and breakpoints within these 16-bit segments.
Global Const $ERROR_BAD_CURRENT_DIRECTORY = 703                                   ; {Invalid Current Directory} The process cannot switch to the startup current directory %hs. Select OK to set current directory to %hs, or select CANCEL to exit.
Global Const $ERROR_FT_READ_RECOVERY_FROM_BACKUP = 704                            ; {Redundant Read} To satisfy a read request, the NT fault-tolerant file system successfully read the requested data from a redundant copy. This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was unable to reassign the failing area of the device.
Global Const $ERROR_FT_WRITE_RECOVERY = 705                                       ; {Redundant Write} To satisfy a write request, the NT fault-tolerant file system successfully wrote a redundant copy of the information. This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was not able to reassign the failing area of the device.
Global Const $ERROR_IMAGE_MACHINE_TYPE_MISMATCH = 706                             ; {Machine Type Mismatch} The image file %hs is valid, but is for a machine type other than the current machine. Select OK to continue, or CANCEL to fail the DLL load.
Global Const $ERROR_RECEIVE_PARTIAL = 707                                         ; {Partial Data Received} The network transport returned partial data to its client. The remaining data will be sent later.
Global Const $ERROR_RECEIVE_EXPEDITED = 708                                       ; {Expedited Data Received} The network transport returned data to its client that was marked as expedited by the remote system.
Global Const $ERROR_RECEIVE_PARTIAL_EXPEDITED = 709                               ; {Partial Expedited Data Received} The network transport returned partial data to its client and this data was marked as expedited by the remote system. The remaining data will be sent later.
Global Const $ERROR_EVENT_DONE = 710                                              ; {TDI Event Done} The TDI indication has completed successfully.
Global Const $ERROR_EVENT_PENDING = 711                                           ; {TDI Event Pending} The TDI indication has entered the pending state.
Global Const $ERROR_CHECKING_FILE_SYSTEM = 712                                    ; Checking file system on %wZ
Global Const $ERROR_FATAL_APP_EXIT = 713                                          ; {Fatal Application Exit} %hs
Global Const $ERROR_PREDEFINED_HANDLE = 714                                       ; The specified registry key is referenced by a predefined handle.
Global Const $ERROR_WAS_UNLOCKED = 715                                            ; {Page Unlocked} The page protection of a locked page was changed to 'No Access' and the page was unlocked from memory and from the process.
Global Const $ERROR_SERVICE_NOTIFICATION = 716                                    ; %hs
Global Const $ERROR_WAS_LOCKED = 717                                              ; {Page Locked} One of the pages to lock was already locked.
Global Const $ERROR_LOG_HARD_ERROR = 718                                          ; Application popup: %1 : %2
Global Const $ERROR_ALREADY_WIN32 = 719                                           ; ERROR_ALREADY_WIN32
Global Const $ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE = 720                         ; {Machine Type Mismatch} The image file %hs is valid, but is for a machine type other than the current machine.
Global Const $ERROR_NO_YIELD_PERFORMED = 721                                      ; A yield execution was performed and no thread was available to run.
Global Const $ERROR_TIMER_RESUME_IGNORED = 722                                    ; The resumable flag to a timer API was ignored.
Global Const $ERROR_ARBITRATION_UNHANDLED = 723                                   ; The arbiter has deferred arbitration of these resources to its parent.
Global Const $ERROR_CARDBUS_NOT_SUPPORTED = 724                                   ; The inserted CardBus device cannot be started because of a configuration error on "%hs".
Global Const $ERROR_MP_PROCESSOR_MISMATCH = 725                                   ; The CPUs in this multiprocessor system are not all the same revision level. To use all processors the operating system restricts itself to the features of the least capable processor in the system. Should problems occur with this system, contact the CPU manufacturer to see if this mix of processors is supported.
Global Const $ERROR_HIBERNATED = 726                                              ; The system was put into hibernation.
Global Const $ERROR_RESUME_HIBERNATION = 727                                      ; The system was resumed from hibernation.
Global Const $ERROR_FIRMWARE_UPDATED = 728                                        ; Windows has detected that the system firmware (BIOS) was updated [previous firmware date = %2, current firmware date %3].
Global Const $ERROR_DRIVERS_LEAKING_LOCKED_PAGES = 729                            ; A device driver is leaking locked I/O pages causing system degradation. The system has automatically enabled tracking code in order to try and catch the culprit.
Global Const $ERROR_WAKE_SYSTEM = 730                                             ; The system has awoken.
Global Const $ERROR_WAIT_1 = 731                                                  ; ERROR_WAIT_1
Global Const $ERROR_WAIT_2 = 732                                                  ; ERROR_WAIT_2
Global Const $ERROR_WAIT_3 = 733                                                  ; ERROR_WAIT_3
Global Const $ERROR_WAIT_63 = 734                                                 ; ERROR_WAIT_63
Global Const $ERROR_ABANDONED_WAIT_0 = 735                                        ; ERROR_ABANDONED_WAIT_0
Global Const $ERROR_ABANDONED_WAIT_63 = 736                                       ; ERROR_ABANDONED_WAIT_63
Global Const $ERROR_USER_APC = 737                                                ; ERROR_USER_APC
Global Const $ERROR_KERNEL_APC = 738                                              ; ERROR_KERNEL_APC
Global Const $ERROR_ALERTED = 739                                                 ; ERROR_ALERTED
Global Const $ERROR_ELEVATION_REQUIRED = 740                                      ; The requested operation requires elevation.
Global Const $ERROR_REPARSE = 741                                                 ; A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.
Global Const $ERROR_OPLOCK_BREAK_IN_PROGRESS = 742                                ; An open/create operation completed while an oplock break is underway.
Global Const $ERROR_VOLUME_MOUNTED = 743                                          ; A new volume has been mounted by a file system.
Global Const $ERROR_RXACT_COMMITTED = 744                                         ; This success level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted. The commit has now been completed.
Global Const $ERROR_NOTIFY_CLEANUP = 745                                          ; This indicates that a notify change request has been completed due to closing the handle which made the notify change request.
Global Const $ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED = 746                        ; {Connect Failure on Primary Transport} An attempt was made to connect to the remote server %hs on the primary transport, but the connection failed. The computer WAS able to connect on a secondary transport.
Global Const $ERROR_PAGE_FAULT_TRANSITION = 747                                   ; Page fault was a transition fault.
Global Const $ERROR_PAGE_FAULT_DEMAND_ZERO = 748                                  ; Page fault was a demand zero fault.
Global Const $ERROR_PAGE_FAULT_COPY_ON_WRITE = 749                                ; Page fault was a demand zero fault.
Global Const $ERROR_PAGE_FAULT_GUARD_PAGE = 750                                   ; Page fault was a demand zero fault.
Global Const $ERROR_PAGE_FAULT_PAGING_FILE = 751                                  ; Page fault was satisfied by reading from a secondary storage device.
Global Const $ERROR_CACHE_PAGE_LOCKED = 752                                       ; Cached page was locked during operation.
Global Const $ERROR_CRASH_DUMP = 753                                              ; Crash dump exists in paging file.
Global Const $ERROR_BUFFER_ALL_ZEROS = 754                                        ; Specified buffer contains all zeros.
Global Const $ERROR_REPARSE_OBJECT = 755                                          ; A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.
Global Const $ERROR_RESOURCE_REQUIREMENTS_CHANGED = 756                           ; The device has succeeded a query-stop and its resource requirements have changed.
Global Const $ERROR_TRANSLATION_COMPLETE = 757                                    ; The translator has translated these resources into the global space and no further translations should be performed.
Global Const $ERROR_NOTHING_TO_TERMINATE = 758                                    ; A process being terminated has no threads to terminate.
Global Const $ERROR_PROCESS_NOT_IN_JOB = 759                                      ; The specified process is not part of a job.
Global Const $ERROR_PROCESS_IN_JOB = 760                                          ; The specified process is part of a job.
Global Const $ERROR_VOLSNAP_HIBERNATE_READY = 761                                 ; {Volume Shadow Copy Service} The system is now ready for hibernation.
Global Const $ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY = 762                      ; A file system or file system filter driver has successfully completed an FsFilter operation.
Global Const $ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED = 763                      ; The specified interrupt vector was already connected.
Global Const $ERROR_INTERRUPT_STILL_CONNECTED = 764                               ; The specified interrupt vector is still connected.
Global Const $ERROR_WAIT_FOR_OPLOCK = 765                                         ; An operation is blocked waiting for an oplock.
Global Const $ERROR_DBG_EXCEPTION_HANDLED = 766                                   ; Debugger handled exception.
Global Const $ERROR_DBG_CONTINUE = 767                                            ; Debugger continued.
Global Const $ERROR_CALLBACK_POP_STACK = 768                                      ; An exception occurred in a user mode callback and the kernel callback frame should be removed.
Global Const $ERROR_COMPRESSION_DISABLED = 769                                    ; Compression is disabled for this volume.
Global Const $ERROR_CANTFETCHBACKWARDS = 770                                      ; The data provider cannot fetch backwards through a result set.
Global Const $ERROR_CANTSCROLLBACKWARDS = 771                                     ; The data provider cannot scroll backwards through a result set.
Global Const $ERROR_ROWSNOTRELEASED = 772                                         ; The data provider requires that previously fetched data is released before asking for more data.
Global Const $ERROR_BAD_ACCESSOR_FLAGS = 773                                      ; The data provider was not able to interpret the flags set for a column binding in an accessor.
Global Const $ERROR_ERRORS_ENCOUNTERED = 774                                      ; One or more errors occurred while processing the request.
Global Const $ERROR_NOT_CAPABLE = 775                                             ; The implementation is not capable of performing the request.
Global Const $ERROR_REQUEST_OUT_OF_SEQUENCE = 776                                 ; The client of a component requested an operation which is not valid given the state of the component instance.
Global Const $ERROR_VERSION_PARSE_ERROR = 777                                     ; A version number could not be parsed.
Global Const $ERROR_BADSTARTPOSITION = 778                                        ; The iterator's start position is invalid.
Global Const $ERROR_MEMORY_HARDWARE = 779                                         ; The hardware has reported an uncorrectable memory error.
Global Const $ERROR_DISK_REPAIR_DISABLED = 780                                    ; The attempted operation required self healing to be enabled.
Global Const $ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = 781 ; The Desktop heap encountered an error while allocating session memory. There is more information in the system event log.
Global Const $ERROR_SYSTEM_POWERSTATE_TRANSITION = 782                            ; The system power state is transitioning from %2 to %3.
Global Const $ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION = 783                    ; The system power state is transitioning from %2 to %3 but could enter %4.
Global Const $ERROR_MCA_EXCEPTION = 784                                           ; A thread is getting dispatched with MCA EXCEPTION because of MCA.
Global Const $ERROR_ACCESS_AUDIT_BY_POLICY = 785                                  ; Access to %1 is monitored by policy rule %2.
Global Const $ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = 786                   ; Access to %1 has been restricted by your Administrator by policy rule %2.
Global Const $ERROR_ABANDON_HIBERFILE = 787                                       ; A valid hibernation file has been invalidated and should be abandoned.
Global Const $ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = 788              ; {Delayed Write Failed} Windows was unable to save all the data for the file %hs; the data has been lost. This error may be caused by network connectivity issues. Please try to save this file elsewhere.
Global Const $ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = 789              ; {Delayed Write Failed} Windows was unable to save all the data for the file %hs; the data has been lost. This error was returned by the server on which the file exists. Please try to save this file elsewhere.
Global Const $ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = 790                  ; {Delayed Write Failed} Windows was unable to save all the data for the file %hs; the data has been lost. This error may be caused if the device has been removed or the media is write-protected.
Global Const $ERROR_BAD_MCFG_TABLE = 791                                          ; The resources required for this device conflict with the MCFG table.
Global Const $ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE = 800                           ; The oplock that was associated with this handle is now associated with a different handle.
Global Const $ERROR_CANNOT_GRANT_REQUESTED_OPLOCK = 801                           ; An oplock of the requested level cannot be granted. An oplock of a lower level may be available.
Global Const $ERROR_CANNOT_BREAK_OPLOCK = 802                                     ; The operation did not complete successfully because it would cause an oplock to be broken. The caller has requested that existing oplocks not be broken.
Global Const $ERROR_OPLOCK_HANDLE_CLOSED = 803                                    ; The handle with which this oplock was associated has been closed. The oplock is now broken.
Global Const $ERROR_NO_ACE_CONDITION = 804                                        ; The specified access control entry (ACE) does not contain a condition.
Global Const $ERROR_INVALID_ACE_CONDITION = 805                                   ; The specified access control entry (ACE) contains an invalid condition.
Global Const $ERROR_EA_ACCESS_DENIED = 994                                        ; Access to the extended attribute was denied.
Global Const $ERROR_OPERATION_ABORTED = 995                                       ; The I/O operation has been aborted because of either a thread exit or an application request.
Global Const $ERROR_IO_INCOMPLETE = 996                                           ; Overlapped I/O event is not in a signaled state.
Global Const $ERROR_IO_PENDING = 997                                              ; Overlapped I/O operation is in progress.
Global Const $ERROR_NOACCESS = 998                                                ; Invalid access to memory location.
Global Const $ERROR_SWAPERROR = 999                                               ; Error performing inpage operation.
Global Const $ERROR_STACK_OVERFLOW = 1001                                         ; Recursion too deep; the stack overflowed.
Global Const $ERROR_INVALID_MESSAGE = 1002                                        ; The window cannot act on the sent message.
Global Const $ERROR_CAN_NOT_COMPLETE = 1003                                       ; Cannot complete this function.
Global Const $ERROR_INVALID_FLAGS = 1004                                          ; Invalid flags.
Global Const $ERROR_UNRECOGNIZED_VOLUME = 1005                                    ; The volume does not contain a recognized file system. Please make sure that all required file system drivers are loaded and that the volume is not corrupted.
Global Const $ERROR_FILE_INVALID = 1006                                           ; The volume for a file has been externally altered so that the opened file is no longer valid.
Global Const $ERROR_FULLSCREEN_MODE = 1007                                        ; The requested operation cannot be performed in full-screen mode.
;Global Const $ERROR_NO_TOKEN = 1008                                               ; An attempt was made to reference a token that does not exist.
Global Const $ERROR_BADDB = 1009                                                  ; The configuration registry database is corrupt.
Global Const $ERROR_BADKEY = 1010                                                 ; The configuration registry key is invalid.
Global Const $ERROR_CANTOPEN = 1011                                               ; The configuration registry key could not be opened.
Global Const $ERROR_CANTREAD = 1012                                               ; The configuration registry key could not be read.
Global Const $ERROR_CANTWRITE = 1013                                              ; The configuration registry key could not be written.
Global Const $ERROR_REGISTRY_RECOVERED = 1014                                     ; One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful.
Global Const $ERROR_REGISTRY_CORRUPT = 1015                                       ; The registry is corrupted. The structure of one of the files containing registry data is corrupted, or the system's memory image of the file is corrupted, or the file could not be recovered because the alternate copy or log was absent or corrupted.
Global Const $ERROR_REGISTRY_IO_FAILED = 1016                                     ; An I/O operation initiated by the registry failed unrecoverably. The registry could not read in, or write out, or flush, one of the files that contain the system's image of the registry.
Global Const $ERROR_NOT_REGISTRY_FILE = 1017                                      ; The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format.
Global Const $ERROR_KEY_DELETED = 1018                                            ; Illegal operation attempted on a registry key that has been marked for deletion.
Global Const $ERROR_NO_LOG_SPACE = 1019                                           ; System could not allocate the required space in a registry log.
Global Const $ERROR_KEY_HAS_CHILDREN = 1020                                       ; Cannot create a symbolic link in a registry key that already has subkeys or values.
Global Const $ERROR_CHILD_MUST_BE_VOLATILE = 1021                                 ; Cannot create a stable subkey under a volatile parent key.
Global Const $ERROR_NOTIFY_ENUM_DIR = 1022                                        ; A notify change request is being completed and the information is not being returned in the caller's buffer. The caller now needs to enumerate the files to find the changes.
Global Const $ERROR_DEPENDENT_SERVICES_RUNNING = 1051                             ; A stop control has been sent to a service that other running services are dependent on.
Global Const $ERROR_INVALID_SERVICE_CONTROL = 1052                                ; The requested control is not valid for this service.
Global Const $ERROR_SERVICE_REQUEST_TIMEOUT = 1053                                ; The service did not respond to the start or control request in a timely fashion.
Global Const $ERROR_SERVICE_NO_THREAD = 1054                                      ; A thread could not be created for the service.
Global Const $ERROR_SERVICE_DATABASE_LOCKED = 1055                                ; The service database is locked.
Global Const $ERROR_SERVICE_ALREADY_RUNNING = 1056                                ; An instance of the service is already running.
Global Const $ERROR_INVALID_SERVICE_ACCOUNT = 1057                                ; The account name is invalid or does not exist, or the password is invalid for the account name specified.
Global Const $ERROR_SERVICE_DISABLED = 1058                                       ; The service cannot be started, either because it is disabled or because it has no enabled devices associated with it.
Global Const $ERROR_CIRCULAR_DEPENDENCY = 1059                                    ; Circular service dependency was specified.
Global Const $ERROR_SERVICE_DOES_NOT_EXIST = 1060                                 ; The specified service does not exist as an installed service.
Global Const $ERROR_SERVICE_CANNOT_ACCEPT_CTRL = 1061                             ; The service cannot accept control messages at this time.
Global Const $ERROR_SERVICE_NOT_ACTIVE = 1062                                     ; The service has not been started.
Global Const $ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = 1063                      ; The service process could not connect to the service controller.
Global Const $ERROR_EXCEPTION_IN_SERVICE = 1064                                   ; An exception occurred in the service when handling the control request.
Global Const $ERROR_DATABASE_DOES_NOT_EXIST = 1065                                ; The database specified does not exist.
;Global Const $ERROR_SERVICE_SPECIFIC_ERROR = 1066                                 ; The service has returned a service-specific error code.
Global Const $ERROR_PROCESS_ABORTED = 1067                                        ; The process terminated unexpectedly.
;Global Const $ERROR_SERVICE_DEPENDENCY_FAIL = 1068                                ; The dependency service or group failed to start.
Global Const $ERROR_SERVICE_LOGON_FAILED = 1069                                   ; The service did not start due to a logon failure.
Global Const $ERROR_SERVICE_START_HANG = 1070                                     ; After starting, the service hung in a start-pending state.
Global Const $ERROR_INVALID_SERVICE_LOCK = 1071                                   ; The specified service database lock is invalid.
Global Const $ERROR_SERVICE_MARKED_FOR_DELETE = 1072                              ; The specified service has been marked for deletion.
Global Const $ERROR_SERVICE_EXISTS = 1073                                         ; The specified service already exists.
Global Const $ERROR_ALREADY_RUNNING_LKG = 1074                                    ; The system is currently running with the last-known-good configuration.
Global Const $ERROR_SERVICE_DEPENDENCY_DELETED = 1075                             ; The dependency service does not exist or has been marked for deletion.
Global Const $ERROR_BOOT_ALREADY_ACCEPTED = 1076                                  ; The current boot has already been accepted for use as the last-known-good control set.
;Global Const $ERROR_SERVICE_NEVER_STARTED = 1077                                  ; No attempts to start the service have been made since the last boot.
Global Const $ERROR_DUPLICATE_SERVICE_NAME = 1078                                 ; The name is already in use as either a service name or a service display name.
Global Const $ERROR_DIFFERENT_SERVICE_ACCOUNT = 1079                              ; The account specified for this service is different from the account specified for other services running in the same process.
Global Const $ERROR_CANNOT_DETECT_DRIVER_FAILURE = 1080                           ; Failure actions can only be set for Win32 services, not for drivers.
Global Const $ERROR_CANNOT_DETECT_PROCESS_ABORT = 1081                            ; This service runs in the same process as the service control manager. Therefore, the service control manager cannot take action if this service's process terminates unexpectedly.
Global Const $ERROR_NO_RECOVERY_PROGRAM = 1082                                    ; No recovery program has been configured for this service.
Global Const $ERROR_SERVICE_NOT_IN_EXE = 1083                                     ; The executable program that this service is configured to run in does not implement the service.
Global Const $ERROR_NOT_SAFEBOOT_SERVICE = 1084                                   ; This service cannot be started in Safe Mode.
Global Const $ERROR_END_OF_MEDIA = 1100                                           ; The physical end of the tape has been reached.
Global Const $ERROR_FILEMARK_DETECTED = 1101                                      ; A tape access reached a filemark.
Global Const $ERROR_BEGINNING_OF_MEDIA = 1102                                     ; The beginning of the tape or a partition was encountered.
Global Const $ERROR_SETMARK_DETECTED = 1103                                       ; A tape access reached the end of a set of files.
Global Const $ERROR_NO_DATA_DETECTED = 1104                                       ; No more data is on the tape.
Global Const $ERROR_PARTITION_FAILURE = 1105                                      ; Tape could not be partitioned.
Global Const $ERROR_INVALID_BLOCK_LENGTH = 1106                                   ; When accessing a new tape of a multivolume partition, the current block size is incorrect.
Global Const $ERROR_DEVICE_NOT_PARTITIONED = 1107                                 ; Tape partition information could not be found when loading a tape.
Global Const $ERROR_UNABLE_TO_LOCK_MEDIA = 1108                                   ; Unable to lock the media eject mechanism.
Global Const $ERROR_UNABLE_TO_UNLOAD_MEDIA = 1109                                 ; Unable to unload the media.
Global Const $ERROR_MEDIA_CHANGED = 1110                                          ; The media in the drive may have changed.
Global Const $ERROR_BUS_RESET = 1111                                              ; The I/O bus was reset.
Global Const $ERROR_NO_MEDIA_IN_DRIVE = 1112                                      ; No media in drive.
Global Const $ERROR_NO_UNICODE_TRANSLATION = 1113                                 ; No mapping for the Unicode character exists in the target multi-byte code page.
Global Const $ERROR_DLL_INIT_FAILED = 1114                                        ; A dynamic link library (DLL) initialization routine failed.
Global Const $ERROR_SHUTDOWN_IN_PROGRESS = 1115                                   ; A system shutdown is in progress.
Global Const $ERROR_NO_SHUTDOWN_IN_PROGRESS = 1116                                ; Unable to abort the system shutdown because no shutdown was in progress.
Global Const $ERROR_IO_DEVICE = 1117                                              ; The request could not be performed because of an I/O device error.
Global Const $ERROR_SERIAL_NO_DEVICE = 1118                                       ; No serial device was successfully initialized. The serial driver will unload.
Global Const $ERROR_IRQ_BUSY = 1119                                               ; Unable to open a device that was sharing an interrupt request (IRQ) with other devices. At least one other device that uses that IRQ was already opened.
Global Const $ERROR_MORE_WRITES = 1120                                            ; A serial I/O operation was completed by another write to the serial port. (The IOCTL_SERIAL_XOFF_COUNTER reached zero)
Global Const $ERROR_COUNTER_TIMEOUT = 1121                                        ; A serial I/O operation completed because the timeout period expired. (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero)
Global Const $ERROR_FLOPPY_ID_MARK_NOT_FOUND = 1122                               ; No ID address mark was found on the floppy disk.
Global Const $ERROR_FLOPPY_WRONG_CYLINDER = 1123                                  ; Mismatch between the floppy disk sector ID field and the floppy disk controller track address.
Global Const $ERROR_FLOPPY_UNKNOWN_ERROR = 1124                                   ; The floppy disk controller reported an error that is not recognized by the floppy disk driver.
Global Const $ERROR_FLOPPY_BAD_REGISTERS = 1125                                   ; The floppy disk controller returned inconsistent results in its registers.
Global Const $ERROR_DISK_RECALIBRATE_FAILED = 1126                                ; While accessing the hard disk, a recalibrate operation failed, even after retries.
Global Const $ERROR_DISK_OPERATION_FAILED = 1127                                  ; While accessing the hard disk, a disk operation failed even after retries.
Global Const $ERROR_DISK_RESET_FAILED = 1128                                      ; While accessing the hard disk, a disk controller reset was needed, but even that failed.
Global Const $ERROR_EOM_OVERFLOW = 1129                                           ; Physical end of tape encountered.
Global Const $ERROR_NOT_ENOUGH_SERVER_MEMORY = 1130                               ; Not enough server storage is available to process this command.
Global Const $ERROR_POSSIBLE_DEADLOCK = 1131                                      ; A potential deadlock condition has been detected.
Global Const $ERROR_MAPPED_ALIGNMENT = 1132                                       ; The base address or the file offset specified does not have the proper alignment.
Global Const $ERROR_SET_POWER_STATE_VETOED = 1140                                 ; An attempt to change the system power state was vetoed by another application or driver.
Global Const $ERROR_SET_POWER_STATE_FAILED = 1141                                 ; The system BIOS failed an attempt to change the system power state.
Global Const $ERROR_TOO_MANY_LINKS = 1142                                         ; An attempt was made to create more links on a file than the file system supports.
Global Const $ERROR_OLD_WIN_VERSION = 1150                                        ; The specified program requires a newer version of Windows.
Global Const $ERROR_APP_WRONG_OS = 1151                                           ; The specified program is not a Windows or MS-DOS program.
Global Const $ERROR_SINGLE_INSTANCE_APP = 1152                                    ; Cannot start more than one instance of the specified program.
Global Const $ERROR_RMODE_APP = 1153                                              ; The specified program was written for an earlier version of Windows.
Global Const $ERROR_INVALID_DLL = 1154                                            ; One of the library files needed to run this application is damaged.
Global Const $ERROR_NO_ASSOCIATION = 1155                                         ; No application is associated with the specified file for this operation.
Global Const $ERROR_DDE_FAIL = 1156                                               ; An error occurred in sending the command to the application.
Global Const $ERROR_DLL_NOT_FOUND = 1157                                          ; One of the library files needed to run this application cannot be found.
Global Const $ERROR_NO_MORE_USER_HANDLES = 1158                                   ; The current process has used all of its system allowance of handles for Window Manager objects.
Global Const $ERROR_MESSAGE_SYNC_ONLY = 1159                                      ; The message can be used only with synchronous operations.
Global Const $ERROR_SOURCE_ELEMENT_EMPTY = 1160                                   ; The indicated source element has no media.
Global Const $ERROR_DESTINATION_ELEMENT_FULL = 1161                               ; The indicated destination element already contains media.
Global Const $ERROR_ILLEGAL_ELEMENT_ADDRESS = 1162                                ; The indicated element does not exist.
Global Const $ERROR_MAGAZINE_NOT_PRESENT = 1163                                   ; The indicated element is part of a magazine that is not present.
Global Const $ERROR_DEVICE_REINITIALIZATION_NEEDED = 1164                         ; The indicated device requires reinitialization due to hardware errors.
Global Const $ERROR_DEVICE_REQUIRES_CLEANING = 1165                               ; The device has indicated that cleaning is required before further operations are attempted.
Global Const $ERROR_DEVICE_DOOR_OPEN = 1166                                       ; The device has indicated that its door is open.
Global Const $ERROR_DEVICE_NOT_CONNECTED = 1167                                   ; The device is not connected.
Global Const $ERROR_NOT_FOUND = 1168                                              ; Element not found.
Global Const $ERROR_NO_MATCH = 1169                                               ; There was no match for the specified key in the index.
Global Const $ERROR_SET_NOT_FOUND = 1170                                          ; The property set specified does not exist on the object.
Global Const $ERROR_POINT_NOT_FOUND = 1171                                        ; The point passed to GetMouseMovePoints is not in the buffer.
Global Const $ERROR_NO_TRACKING_SERVICE = 1172                                    ; The tracking (workstation) service is not running.
Global Const $ERROR_NO_VOLUME_ID = 1173                                           ; The Volume ID could not be found.
Global Const $ERROR_UNABLE_TO_REMOVE_REPLACED = 1175                              ; Unable to remove the file to be replaced.
Global Const $ERROR_UNABLE_TO_MOVE_REPLACEMENT = 1176                             ; Unable to move the replacement file to the file to be replaced. The file to be replaced has retained its original name.
Global Const $ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 = 1177                           ; Unable to move the replacement file to the file to be replaced. The file to be replaced has been renamed using the backup name.
Global Const $ERROR_JOURNAL_DELETE_IN_PROGRESS = 1178                             ; The volume change journal is being deleted.
Global Const $ERROR_JOURNAL_NOT_ACTIVE = 1179                                     ; The volume change journal is not active.
Global Const $ERROR_POTENTIAL_FILE_FOUND = 1180                                   ; A file was found, but it may not be the correct file.
Global Const $ERROR_JOURNAL_ENTRY_DELETED = 1181                                  ; The journal entry has been deleted from the journal.
Global Const $ERROR_SHUTDOWN_IS_SCHEDULED = 1190                                  ; A system shutdown has already been scheduled.
Global Const $ERROR_SHUTDOWN_USERS_LOGGED_ON = 1191                               ; The system shutdown cannot be initiated because there are other users logged on to the computer.
Global Const $ERROR_BAD_DEVICE = 1200                                             ; The specified device name is invalid.
Global Const $ERROR_CONNECTION_UNAVAIL = 1201                                     ; The device is not currently connected but it is a remembered connection.
Global Const $ERROR_DEVICE_ALREADY_REMEMBERED = 1202                              ; The local device name has a remembered connection to another network resource.
Global Const $ERROR_NO_NET_OR_BAD_PATH = 1203                                     ; The network path was either typed incorrectly, does not exist, or the network provider is not currently available. Please try retyping the path or contact your network administrator.
Global Const $ERROR_BAD_PROVIDER = 1204                                           ; The specified network provider name is invalid.
Global Const $ERROR_CANNOT_OPEN_PROFILE = 1205                                    ; Unable to open the network connection profile.
Global Const $ERROR_BAD_PROFILE = 1206                                            ; The network connection profile is corrupted.
Global Const $ERROR_NOT_CONTAINER = 1207                                          ; Cannot enumerate a noncontainer.
Global Const $ERROR_EXTENDED_ERROR = 1208                                         ; An extended error has occurred.
Global Const $ERROR_INVALID_GROUPNAME = 1209                                      ; The format of the specified group name is invalid.
Global Const $ERROR_INVALID_COMPUTERNAME = 1210                                   ; The format of the specified computer name is invalid.
Global Const $ERROR_INVALID_EVENTNAME = 1211                                      ; The format of the specified event name is invalid.
Global Const $ERROR_INVALID_DOMAINNAME = 1212                                     ; The format of the specified domain name is invalid.
Global Const $ERROR_INVALID_SERVICENAME = 1213                                    ; The format of the specified service name is invalid.
Global Const $ERROR_INVALID_NETNAME = 1214                                        ; The format of the specified network name is invalid.
Global Const $ERROR_INVALID_SHARENAME = 1215                                      ; The format of the specified share name is invalid.
Global Const $ERROR_INVALID_PASSWORDNAME = 1216                                   ; The format of the specified password is invalid.
Global Const $ERROR_INVALID_MESSAGENAME = 1217                                    ; The format of the specified message name is invalid.
Global Const $ERROR_INVALID_MESSAGEDEST = 1218                                    ; The format of the specified message destination is invalid.
Global Const $ERROR_SESSION_CREDENTIAL_CONFLICT = 1219                            ; Multiple connections to a server or shared resource by the same user, using more than one user name, are not allowed. Disconnect all previous connections to the server or shared resource and try again.
Global Const $ERROR_REMOTE_SESSION_LIMIT_EXCEEDED = 1220                          ; An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.
Global Const $ERROR_DUP_DOMAINNAME = 1221                                         ; The workgroup or domain name is already in use by another computer on the network.
Global Const $ERROR_NO_NETWORK = 1222                                             ; The network is not present or not started.
Global Const $ERROR_CANCELLED = 1223                                              ; The operation was canceled by the user.
Global Const $ERROR_USER_MAPPED_FILE = 1224                                       ; The requested operation cannot be performed on a file with a user-mapped section open.
Global Const $ERROR_CONNECTION_REFUSED = 1225                                     ; The remote computer refused the network connection.
Global Const $ERROR_GRACEFUL_DISCONNECT = 1226                                    ; The network connection was gracefully closed.
Global Const $ERROR_ADDRESS_ALREADY_ASSOCIATED = 1227                             ; The network transport endpoint already has an address associated with it.
Global Const $ERROR_ADDRESS_NOT_ASSOCIATED = 1228                                 ; An address has not yet been associated with the network endpoint.
Global Const $ERROR_CONNECTION_INVALID = 1229                                     ; An operation was attempted on a nonexistent network connection.
Global Const $ERROR_CONNECTION_ACTIVE = 1230                                      ; An invalid operation was attempted on an active network connection.
Global Const $ERROR_NETWORK_UNREACHABLE = 1231                                    ; The network location cannot be reached. For information about network troubleshooting, see Windows Help.
Global Const $ERROR_HOST_UNREACHABLE = 1232                                       ; The network location cannot be reached. For information about network troubleshooting, see Windows Help.
Global Const $ERROR_PROTOCOL_UNREACHABLE = 1233                                   ; The network location cannot be reached. For information about network troubleshooting, see Windows Help.
Global Const $ERROR_PORT_UNREACHABLE = 1234                                       ; No service is operating at the destination network endpoint on the remote system.
Global Const $ERROR_REQUEST_ABORTED = 1235                                        ; The request was aborted.
Global Const $ERROR_CONNECTION_ABORTED = 1236                                     ; The network connection was aborted by the local system.
Global Const $ERROR_RETRY = 1237                                                  ; The operation could not be completed. A retry should be performed.
Global Const $ERROR_CONNECTION_COUNT_LIMIT = 1238                                 ; A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.
Global Const $ERROR_LOGIN_TIME_RESTRICTION = 1239                                 ; Attempting to log in during an unauthorized time of day for this account.
Global Const $ERROR_LOGIN_WKSTA_RESTRICTION = 1240                                ; The account is not authorized to log in from this station.
Global Const $ERROR_INCORRECT_ADDRESS = 1241                                      ; The network address could not be used for the operation requested.
Global Const $ERROR_ALREADY_REGISTERED = 1242                                     ; The service is already registered.
Global Const $ERROR_SERVICE_NOT_FOUND = 1243                                      ; The specified service does not exist.
Global Const $ERROR_NOT_AUTHENTICATED = 1244                                      ; The operation being requested was not performed because the user has not been authenticated.
Global Const $ERROR_NOT_LOGGED_ON = 1245                                          ; The operation being requested was not performed because the user has not logged on to the network. The specified service does not exist.
Global Const $ERROR_CONTINUE = 1246                                               ; Continue with work in progress.
Global Const $ERROR_ALREADY_INITIALIZED = 1247                                    ; An attempt was made to perform an initialization operation when initialization has already been completed.
Global Const $ERROR_NO_MORE_DEVICES = 1248                                        ; No more local devices.
Global Const $ERROR_NO_SUCH_SITE = 1249                                           ; The specified site does not exist.
Global Const $ERROR_DOMAIN_CONTROLLER_EXISTS = 1250                               ; A domain controller with the specified name already exists.
Global Const $ERROR_ONLY_IF_CONNECTED = 1251                                      ; This operation is supported only when you are connected to the server.
Global Const $ERROR_OVERRIDE_NOCHANGES = 1252                                     ; The group policy framework should call the extension even if there are no changes.
Global Const $ERROR_BAD_USER_PROFILE = 1253                                       ; The specified user does not have a valid profile.
Global Const $ERROR_NOT_SUPPORTED_ON_SBS = 1254                                   ; This operation is not supported on a computer running Windows Server 2003 for Small Business Server.
Global Const $ERROR_SERVER_SHUTDOWN_IN_PROGRESS = 1255                            ; The server machine is shutting down.
Global Const $ERROR_HOST_DOWN = 1256                                              ; The remote system is not available. For information about network troubleshooting, see Windows Help.
Global Const $ERROR_NON_ACCOUNT_SID = 1257                                        ; The security identifier provided is not from an account domain.
Global Const $ERROR_NON_DOMAIN_SID = 1258                                         ; The security identifier provided does not have a domain component.
Global Const $ERROR_APPHELP_BLOCK = 1259                                          ; AppHelp dialog canceled thus preventing the application from starting.
Global Const $ERROR_ACCESS_DISABLED_BY_POLICY = 1260                              ; This program is blocked by group policy. For more information, contact your system administrator.
Global Const $ERROR_REG_NAT_CONSUMPTION = 1261                                    ; A program attempt to use an invalid register value. Normally caused by an uninitialized register. This error is Itanium specific.
Global Const $ERROR_CSCSHARE_OFFLINE = 1262                                       ; The share is currently offline or does not exist.
Global Const $ERROR_PKINIT_FAILURE = 1263                                         ; The Kerberos protocol encountered an error while validating the KDC certificate during smartcard logon. There is more information in the system event log.
Global Const $ERROR_SMARTCARD_SUBSYSTEM_FAILURE = 1264                            ; The Kerberos protocol encountered an error while attempting to utilize the smartcard subsystem.
Global Const $ERROR_DOWNGRADE_DETECTED = 1265                                     ; The system detected a possible attempt to compromise security. Please ensure that you can contact the server that authenticated you.
Global Const $ERROR_MACHINE_LOCKED = 1271                                         ; The machine is locked and cannot be shut down without the force option.
Global Const $ERROR_CALLBACK_SUPPLIED_INVALID_DATA = 1273                         ; An application-defined callback gave invalid data when called.
Global Const $ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED = 1274                       ; The group policy framework should call the extension in the synchronous foreground policy refresh.
Global Const $ERROR_DRIVER_BLOCKED = 1275                                         ; This driver has been blocked from loading.
Global Const $ERROR_INVALID_IMPORT_OF_NON_DLL = 1276                              ; A dynamic link library (DLL) referenced a module that was neither a DLL nor the process's executable image.
Global Const $ERROR_ACCESS_DISABLED_WEBBLADE = 1277                               ; Windows cannot open this program since it has been disabled.
Global Const $ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER = 1278                        ; Windows cannot open this program because the license enforcement system has been tampered with or become corrupted.
Global Const $ERROR_RECOVERY_FAILURE = 1279                                       ; A transaction recover failed.
Global Const $ERROR_ALREADY_FIBER = 1280                                          ; The current thread has already been converted to a fiber.
Global Const $ERROR_ALREADY_THREAD = 1281                                         ; The current thread has already been converted from a fiber.
Global Const $ERROR_STACK_BUFFER_OVERRUN = 1282                                   ; The system detected an overrun of a stack-based buffer in this application. This overrun could potentially allow a malicious user to gain control of this application.
Global Const $ERROR_PARAMETER_QUOTA_EXCEEDED = 1283                               ; Data present in one of the parameters is more than the function can operate on.
Global Const $ERROR_DEBUGGER_INACTIVE = 1284                                      ; An attempt to do an operation on a debug object failed because the object is in the process of being deleted.
Global Const $ERROR_DELAY_LOAD_FAILED = 1285                                      ; An attempt to delay-load a .dll or get a function address in a delay-loaded .dll failed.
Global Const $ERROR_VDM_DISALLOWED = 1286                                         ; %1 is a 16-bit application. You do not have permissions to execute 16-bit applications. Check your permissions with your system administrator.
Global Const $ERROR_UNIDENTIFIED_ERROR = 1287                                     ; Insufficient information exists to identify the cause of failure.
Global Const $ERROR_INVALID_CRUNTIME_PARAMETER = 1288                             ; The parameter passed to a C runtime function is incorrect.
Global Const $ERROR_BEYOND_VDL = 1289                                             ; The operation occurred beyond the valid data length of the file.
Global Const $ERROR_INCOMPATIBLE_SERVICE_SID_TYPE = 1290                          ; The service start failed since one or more services in the same process have an incompatible service SID type setting. A service with restricted service SID type can only coexist in the same process with other services with a restricted SID type. If the service SID type for this service was just configured, the hosting process must be restarted in order to start this service. On Windows Server 2003 and Windows XP, an unrestricted service cannot coexist in the same process with other services. The service with the unrestricted service SID type must be moved to an owned process in order to start this service.
Global Const $ERROR_DRIVER_PROCESS_TERMINATED = 1291                              ; The process hosting the driver for this device has been terminated.
Global Const $ERROR_IMPLEMENTATION_LIMIT = 1292                                   ; An operation attempted to exceed an implementation-defined limit.
Global Const $ERROR_PROCESS_IS_PROTECTED = 1293                                   ; Either the target process, or the target thread's containing process, is a protected process.
Global Const $ERROR_SERVICE_NOTIFY_CLIENT_LAGGING = 1294                          ; The service notification client is lagging too far behind the current state of services in the machine.
Global Const $ERROR_DISK_QUOTA_EXCEEDED = 1295                                    ; The requested file operation failed because the storage quota was exceeded. To free up disk space, move files to a different location or delete unnecessary files. For more information, contact your system administrator.
Global Const $ERROR_CONTENT_BLOCKED = 1296                                        ; The requested files operation failed because the storage policy blocks that type of file. For more information, contact your system administrator.
Global Const $ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE = 1297                         ; A privilege that the service requires to function properly does not exist in the service account configuration. You may use the Services Microsoft Management Console (MMC) snap-in (services.msc) and the Local Security Settings MMC snap-in (secpol.msc) to view the service configuration and the account configuration.
Global Const $ERROR_APP_HANG = 1298                                               ; A thread involved in this operation appears to be unresponsive.
Global Const $ERROR_INVALID_LABEL = 1299                                          ; Indicates a particular Security ID may not be assigned as the label of an object.
Global Const $ERROR_NOT_ALL_ASSIGNED = 1300                                       ; Not all privileges or groups referenced are assigned to the caller.
Global Const $ERROR_SOME_NOT_MAPPED = 1301                                        ; Some mapping between account names and security IDs was not done.
Global Const $ERROR_NO_QUOTAS_FOR_ACCOUNT = 1302                                  ; No system quota limits are specifically set for this account.
Global Const $ERROR_LOCAL_USER_SESSION_KEY = 1303                                 ; No encryption key is available. A well-known encryption key was returned.
Global Const $ERROR_NULL_LM_PASSWORD = 1304                                       ; The password is too complex to be converted to a LAN Manager password. The LAN Manager password returned is a NULL string.
Global Const $ERROR_UNKNOWN_REVISION = 1305                                       ; The revision level is unknown.
Global Const $ERROR_REVISION_MISMATCH = 1306                                      ; Indicates two revision levels are incompatible.
Global Const $ERROR_INVALID_OWNER = 1307                                          ; This security ID may not be assigned as the owner of this object.
Global Const $ERROR_INVALID_PRIMARY_GROUP = 1308                                  ; This security ID may not be assigned as the primary group of an object.
Global Const $ERROR_NO_IMPERSONATION_TOKEN = 1309                                 ; An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.
Global Const $ERROR_CANT_DISABLE_MANDATORY = 1310                                 ; The group may not be disabled.
Global Const $ERROR_NO_LOGON_SERVERS = 1311                                       ; There are currently no logon servers available to service the logon request.
Global Const $ERROR_NO_SUCH_LOGON_SESSION = 1312                                  ; A specified logon session does not exist. It may already have been terminated.
Global Const $ERROR_NO_SUCH_PRIVILEGE = 1313                                      ; A specified privilege does not exist.
Global Const $ERROR_PRIVILEGE_NOT_HELD = 1314                                     ; A required privilege is not held by the client.
Global Const $ERROR_INVALID_ACCOUNT_NAME = 1315                                   ; The name provided is not a properly formed account name.
Global Const $ERROR_USER_EXISTS = 1316                                            ; The specified account already exists.
Global Const $ERROR_NO_SUCH_USER = 1317                                           ; The specified account does not exist.
Global Const $ERROR_GROUP_EXISTS = 1318                                           ; The specified group already exists.
Global Const $ERROR_NO_SUCH_GROUP = 1319                                          ; The specified group does not exist.
Global Const $ERROR_MEMBER_IN_GROUP = 1320                                        ; Either the specified user account is already a member of the specified group, or the specified group cannot be deleted because it contains a member.
Global Const $ERROR_MEMBER_NOT_IN_GROUP = 1321                                    ; The specified user account is not a member of the specified group account.
Global Const $ERROR_LAST_ADMIN = 1322                                             ; The last remaining administration account cannot be disabled or deleted.
Global Const $ERROR_WRONG_PASSWORD = 1323                                         ; Unable to update the password. The value provided as the current password is incorrect.
Global Const $ERROR_ILL_FORMED_PASSWORD = 1324                                    ; Unable to update the password. The value provided for the new password contains values that are not allowed in passwords.
Global Const $ERROR_PASSWORD_RESTRICTION = 1325                                   ; Unable to update the password. The value provided for the new password does not meet the length, complexity, or history requirements of the domain.
Global Const $ERROR_LOGON_FAILURE = 1326                                          ; Logon failure: unknown user name or bad password.
Global Const $ERROR_ACCOUNT_RESTRICTION = 1327                                    ; Logon failure: user account restriction. Possible reasons are blank passwords not allowed, logon hour restrictions, or a policy restriction has been enforced.
Global Const $ERROR_INVALID_LOGON_HOURS = 1328                                    ; Logon failure: account logon time restriction violation.
Global Const $ERROR_INVALID_WORKSTATION = 1329                                    ; Logon failure: user not allowed to log on to this computer.
Global Const $ERROR_PASSWORD_EXPIRED = 1330                                       ; Logon failure: the specified account password has expired.
Global Const $ERROR_ACCOUNT_DISABLED = 1331                                       ; Logon failure: account currently disabled.
Global Const $ERROR_NONE_MAPPED = 1332                                            ; No mapping between account names and security IDs was done.
Global Const $ERROR_TOO_MANY_LUIDS_REQUESTED = 1333                               ; Too many local user identifiers (LUIDs) were requested at one time.
Global Const $ERROR_LUIDS_EXHAUSTED = 1334                                        ; No more local user identifiers (LUIDs) are available.
Global Const $ERROR_INVALID_SUB_AUTHORITY = 1335                                  ; The subauthority part of a security ID is invalid for this particular use.
Global Const $ERROR_INVALID_ACL = 1336                                            ; The access control list (ACL) structure is invalid.
Global Const $ERROR_INVALID_SID = 1337                                            ; The security ID structure is invalid.
Global Const $ERROR_INVALID_SECURITY_DESCR = 1338                                 ; The security descriptor structure is invalid.
Global Const $ERROR_BAD_INHERITANCE_ACL = 1340                                    ; The inherited access control list (ACL) or access control entry (ACE) could not be built.
Global Const $ERROR_SERVER_DISABLED = 1341                                        ; The server is currently disabled.
Global Const $ERROR_SERVER_NOT_DISABLED = 1342                                    ; The server is currently enabled.
Global Const $ERROR_INVALID_ID_AUTHORITY = 1343                                   ; The value provided was an invalid value for an identifier authority.
Global Const $ERROR_ALLOTTED_SPACE_EXCEEDED = 1344                                ; No more memory is available for security information updates.
Global Const $ERROR_INVALID_GROUP_ATTRIBUTES = 1345                               ; The specified attributes are invalid, or incompatible with the attributes for the group as a whole.
Global Const $ERROR_BAD_IMPERSONATION_LEVEL = 1346                                ; Either a required impersonation level was not provided, or the provided impersonation level is invalid.
Global Const $ERROR_CANT_OPEN_ANONYMOUS = 1347                                    ; Cannot open an anonymous level security token.
Global Const $ERROR_BAD_VALIDATION_CLASS = 1348                                   ; The validation information class requested was invalid.
Global Const $ERROR_BAD_TOKEN_TYPE = 1349                                         ; The type of the token is inappropriate for its attempted use.
Global Const $ERROR_NO_SECURITY_ON_OBJECT = 1350                                  ; Unable to perform a security operation on an object that has no associated security.
Global Const $ERROR_CANT_ACCESS_DOMAIN_INFO = 1351                                ; Configuration information could not be read from the domain controller, either because the machine is unavailable, or access has been denied.
Global Const $ERROR_INVALID_SERVER_STATE = 1352                                   ; The security account manager (SAM) or local security authority (LSA) server was in the wrong state to perform the security operation.
Global Const $ERROR_INVALID_DOMAIN_STATE = 1353                                   ; The domain was in the wrong state to perform the security operation.
Global Const $ERROR_INVALID_DOMAIN_ROLE = 1354                                    ; This operation is only allowed for the Primary Domain Controller of the domain.
Global Const $ERROR_NO_SUCH_DOMAIN = 1355                                         ; The specified domain either does not exist or could not be contacted.
Global Const $ERROR_DOMAIN_EXISTS = 1356                                          ; The specified domain already exists.
Global Const $ERROR_DOMAIN_LIMIT_EXCEEDED = 1357                                  ; An attempt was made to exceed the limit on the number of domains per server.
Global Const $ERROR_INTERNAL_DB_CORRUPTION = 1358                                 ; Unable to complete the requested operation because of either a catastrophic media failure or a data structure corruption on the disk.
Global Const $ERROR_INTERNAL_ERROR = 1359                                         ; An internal error occurred.
Global Const $ERROR_GENERIC_NOT_MAPPED = 1360                                     ; Generic access types were contained in an access mask which should already be mapped to nongeneric types.
Global Const $ERROR_BAD_DESCRIPTOR_FORMAT = 1361                                  ; A security descriptor is not in the right format (absolute or self-relative).
Global Const $ERROR_NOT_LOGON_PROCESS = 1362                                      ; The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process.
Global Const $ERROR_LOGON_SESSION_EXISTS = 1363                                   ; Cannot start a new logon session with an ID that is already in use.
Global Const $ERROR_NO_SUCH_PACKAGE = 1364                                        ; A specified authentication package is unknown.
Global Const $ERROR_BAD_LOGON_SESSION_STATE = 1365                                ; The logon session is not in a state that is consistent with the requested operation.
Global Const $ERROR_LOGON_SESSION_COLLISION = 1366                                ; The logon session ID is already in use.
Global Const $ERROR_INVALID_LOGON_TYPE = 1367                                     ; A logon request contained an invalid logon type value.
Global Const $ERROR_CANNOT_IMPERSONATE = 1368                                     ; Unable to impersonate using a named pipe until data has been read from that pipe.
Global Const $ERROR_RXACT_INVALID_STATE = 1369                                    ; The transaction state of a registry subtree is incompatible with the requested operation.
Global Const $ERROR_RXACT_COMMIT_FAILURE = 1370                                   ; An internal security database corruption has been encountered.
Global Const $ERROR_SPECIAL_ACCOUNT = 1371                                        ; Cannot perform this operation on built-in accounts.
Global Const $ERROR_SPECIAL_GROUP = 1372                                          ; Cannot perform this operation on this built-in special group.
Global Const $ERROR_SPECIAL_USER = 1373                                           ; Cannot perform this operation on this built-in special user.
Global Const $ERROR_MEMBERS_PRIMARY_GROUP = 1374                                  ; The user cannot be removed from a group because the group is currently the user's primary group.
Global Const $ERROR_TOKEN_ALREADY_IN_USE = 1375                                   ; The token is already in use as a primary token.
Global Const $ERROR_NO_SUCH_ALIAS = 1376                                          ; The specified local group does not exist.
Global Const $ERROR_MEMBER_NOT_IN_ALIAS = 1377                                    ; The specified account name is not a member of the group.
Global Const $ERROR_MEMBER_IN_ALIAS = 1378                                        ; The specified account name is already a member of the group.
Global Const $ERROR_ALIAS_EXISTS = 1379                                           ; The specified local group already exists.
Global Const $ERROR_LOGON_NOT_GRANTED = 1380                                      ; Logon failure: the user has not been granted the requested logon type at this computer.
Global Const $ERROR_TOO_MANY_SECRETS = 1381                                       ; The maximum number of secrets that may be stored in a single system has been exceeded.
Global Const $ERROR_SECRET_TOO_LONG = 1382                                        ; The length of a secret exceeds the maximum length allowed.
Global Const $ERROR_INTERNAL_DB_ERROR = 1383                                      ; The local security authority database contains an internal inconsistency.
Global Const $ERROR_TOO_MANY_CONTEXT_IDS = 1384                                   ; During a logon attempt, the user's security context accumulated too many security IDs.
Global Const $ERROR_LOGON_TYPE_NOT_GRANTED = 1385                                 ; Logon failure: the user has not been granted the requested logon type at this computer.
Global Const $ERROR_NT_CROSS_ENCRYPTION_REQUIRED = 1386                           ; A cross-encrypted password is necessary to change a user password.
Global Const $ERROR_NO_SUCH_MEMBER = 1387                                         ; A member could not be added to or removed from the local group because the member does not exist.
Global Const $ERROR_INVALID_MEMBER = 1388                                         ; A new member could not be added to a local group because the member has the wrong account type.
Global Const $ERROR_TOO_MANY_SIDS = 1389                                          ; Too many security IDs have been specified.
Global Const $ERROR_LM_CROSS_ENCRYPTION_REQUIRED = 1390                           ; A cross-encrypted password is necessary to change this user password.
Global Const $ERROR_NO_INHERITANCE = 1391                                         ; Indicates an ACL contains no inheritable components.
Global Const $ERROR_FILE_CORRUPT = 1392                                           ; The file or directory is corrupted and unreadable.
Global Const $ERROR_DISK_CORRUPT = 1393                                           ; The disk structure is corrupted and unreadable.
Global Const $ERROR_NO_USER_SESSION_KEY = 1394                                    ; There is no user session key for the specified logon session.
Global Const $ERROR_LICENSE_QUOTA_EXCEEDED = 1395                                 ; The service being accessed is licensed for a particular number of connections. No more connections can be made to the service at this time because there are already as many connections as the service can accept.
Global Const $ERROR_WRONG_TARGET_NAME = 1396                                      ; Logon Failure: The target account name is incorrect.
Global Const $ERROR_MUTUAL_AUTH_FAILED = 1397                                     ; Mutual Authentication failed. The server's password is out of date at the domain controller.
Global Const $ERROR_TIME_SKEW = 1398                                              ; There is a time and/or date difference between the client and server.
Global Const $ERROR_CURRENT_DOMAIN_NOT_ALLOWED = 1399                             ; This operation cannot be performed on the current domain.
Global Const $ERROR_INVALID_WINDOW_HANDLE = 1400                                  ; Invalid window handle.
Global Const $ERROR_INVALID_MENU_HANDLE = 1401                                    ; Invalid menu handle.
Global Const $ERROR_INVALID_CURSOR_HANDLE = 1402                                  ; Invalid cursor handle.
Global Const $ERROR_INVALID_ACCEL_HANDLE = 1403                                   ; Invalid accelerator table handle.
Global Const $ERROR_INVALID_HOOK_HANDLE = 1404                                    ; Invalid hook handle.
Global Const $ERROR_INVALID_DWP_HANDLE = 1405                                     ; Invalid handle to a multiple-window position structure.
Global Const $ERROR_TLW_WITH_WSCHILD = 1406                                       ; Cannot create a top-level child window.
Global Const $ERROR_CANNOT_FIND_WND_CLASS = 1407                                  ; Cannot find window class.
Global Const $ERROR_WINDOW_OF_OTHER_THREAD = 1408                                 ; Invalid window; it belongs to other thread.
Global Const $ERROR_HOTKEY_ALREADY_REGISTERED = 1409                              ; Hot key is already registered.
Global Const $ERROR_CLASS_ALREADY_EXISTS = 1410                                   ; Class already exists.
Global Const $ERROR_CLASS_DOES_NOT_EXIST = 1411                                   ; Class does not exist.
Global Const $ERROR_CLASS_HAS_WINDOWS = 1412                                      ; Class still has open windows.
Global Const $ERROR_INVALID_INDEX = 1413                                          ; Invalid index.
Global Const $ERROR_INVALID_ICON_HANDLE = 1414                                    ; Invalid icon handle.
Global Const $ERROR_PRIVATE_DIALOG_INDEX = 1415                                   ; Using private DIALOG window words.
Global Const $ERROR_LISTBOX_ID_NOT_FOUND = 1416                                   ; The list box identifier was not found.
Global Const $ERROR_NO_WILDCARD_CHARACTERS = 1417                                 ; No wildcards were found.
Global Const $ERROR_CLIPBOARD_NOT_OPEN = 1418                                     ; Thread does not have a clipboard open.
Global Const $ERROR_HOTKEY_NOT_REGISTERED = 1419                                  ; Hot key is not registered.
Global Const $ERROR_WINDOW_NOT_DIALOG = 1420                                      ; The window is not a valid dialog window.
Global Const $ERROR_CONTROL_ID_NOT_FOUND = 1421                                   ; Control ID not found.
Global Const $ERROR_INVALID_COMBOBOX_MESSAGE = 1422                               ; Invalid message for a combo box because it does not have an edit control.
Global Const $ERROR_WINDOW_NOT_COMBOBOX = 1423                                    ; The window is not a combo box.
Global Const $ERROR_INVALID_EDIT_HEIGHT = 1424                                    ; Height must be less than 256.
Global Const $ERROR_DC_NOT_FOUND = 1425                                           ; Invalid device context (DC) handle.
Global Const $ERROR_INVALID_HOOK_FILTER = 1426                                    ; Invalid hook procedure type.
Global Const $ERROR_INVALID_FILTER_PROC = 1427                                    ; Invalid hook procedure.
Global Const $ERROR_HOOK_NEEDS_HMOD = 1428                                        ; Cannot set nonlocal hook without a module handle.
Global Const $ERROR_GLOBAL_ONLY_HOOK = 1429                                       ; This hook procedure can only be set globally.
Global Const $ERROR_JOURNAL_HOOK_SET = 1430                                       ; The journal hook procedure is already installed.
Global Const $ERROR_HOOK_NOT_INSTALLED = 1431                                     ; The hook procedure is not installed.
Global Const $ERROR_INVALID_LB_MESSAGE = 1432                                     ; Invalid message for single-selection list box.
Global Const $ERROR_SETCOUNT_ON_BAD_LB = 1433                                     ; LB_SETCOUNT sent to non-lazy list box.
Global Const $ERROR_LB_WITHOUT_TABSTOPS = 1434                                    ; This list box does not support tab stops.
Global Const $ERROR_DESTROY_OBJECT_OF_OTHER_THREAD = 1435                         ; Cannot destroy object created by another thread.
Global Const $ERROR_CHILD_WINDOW_MENU = 1436                                      ; Child windows cannot have menus.
Global Const $ERROR_NO_SYSTEM_MENU = 1437                                         ; The window does not have a system menu.
Global Const $ERROR_INVALID_MSGBOX_STYLE = 1438                                   ; Invalid message box style.
Global Const $ERROR_INVALID_SPI_VALUE = 1439                                      ; Invalid system-wide (SPI_*) parameter.
Global Const $ERROR_SCREEN_ALREADY_LOCKED = 1440                                  ; Screen already locked.
Global Const $ERROR_HWNDS_HAVE_DIFF_PARENT = 1441                                 ; All handles to windows in a multiple-window position structure must have the same parent.
Global Const $ERROR_NOT_CHILD_WINDOW = 1442                                       ; The window is not a child window.
Global Const $ERROR_INVALID_GW_COMMAND = 1443                                     ; Invalid GW_* command.
Global Const $ERROR_INVALID_THREAD_ID = 1444                                      ; Invalid thread identifier.
Global Const $ERROR_NON_MDICHILD_WINDOW = 1445                                    ; Cannot process a message from a window that is not a multiple document interface (MDI) window.
Global Const $ERROR_POPUP_ALREADY_ACTIVE = 1446                                   ; Popup menu already active.
Global Const $ERROR_NO_SCROLLBARS = 1447                                          ; The window does not have scroll bars.
Global Const $ERROR_INVALID_SCROLLBAR_RANGE = 1448                                ; Scroll bar range cannot be greater than MAXLONG.
Global Const $ERROR_INVALID_SHOWWIN_COMMAND = 1449                                ; Cannot show or remove the window in the way specified.
Global Const $ERROR_NO_SYSTEM_RESOURCES = 1450                                    ; Insufficient system resources exist to complete the requested service.
Global Const $ERROR_NONPAGED_SYSTEM_RESOURCES = 1451                              ; Insufficient system resources exist to complete the requested service.
Global Const $ERROR_PAGED_SYSTEM_RESOURCES = 1452                                 ; Insufficient system resources exist to complete the requested service.
Global Const $ERROR_WORKING_SET_QUOTA = 1453                                      ; Insufficient quota to complete the requested service.
Global Const $ERROR_PAGEFILE_QUOTA = 1454                                         ; Insufficient quota to complete the requested service.
Global Const $ERROR_COMMITMENT_LIMIT = 1455                                       ; The paging file is too small for this operation to complete.
Global Const $ERROR_MENU_ITEM_NOT_FOUND = 1456                                    ; A menu item was not found.
Global Const $ERROR_INVALID_KEYBOARD_HANDLE = 1457                                ; Invalid keyboard layout handle.
Global Const $ERROR_HOOK_TYPE_NOT_ALLOWED = 1458                                  ; Hook type not allowed.
Global Const $ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION = 1459                     ; This operation requires an interactive window station.
Global Const $ERROR_TIMEOUT = 1460                                                ; This operation returned because the timeout period expired.
Global Const $ERROR_INVALID_MONITOR_HANDLE = 1461                                 ; Invalid monitor handle.
Global Const $ERROR_INCORRECT_SIZE = 1462                                         ; Incorrect size argument.
Global Const $ERROR_SYMLINK_CLASS_DISABLED = 1463                                 ; The symbolic link cannot be followed because its type is disabled.
Global Const $ERROR_SYMLINK_NOT_SUPPORTED = 1464                                  ; This application does not support the current operation on symbolic links.
Global Const $ERROR_XML_PARSE_ERROR = 1465                                        ; Windows was unable to parse the requested XML data.
Global Const $ERROR_XMLDSIG_ERROR = 1466                                          ; An error was encountered while processing an XML digital signature.
Global Const $ERROR_RESTART_APPLICATION = 1467                                    ; This application must be restarted.
Global Const $ERROR_WRONG_COMPARTMENT = 1468                                      ; The caller made the connection request in the wrong routing compartment.
Global Const $ERROR_AUTHIP_FAILURE = 1469                                         ; There was an AuthIP failure when attempting to connect to the remote host.
Global Const $ERROR_NO_NVRAM_RESOURCES = 1470                                     ; Insufficient NVRAM resources exist to complete the requested service. A reboot might be required.
Global Const $ERROR_EVENTLOG_FILE_CORRUPT = 1500                                  ; The event log file is corrupted.
Global Const $ERROR_EVENTLOG_CANT_START = 1501                                    ; No event log file could be opened, so the event logging service did not start.
Global Const $ERROR_LOG_FILE_FULL = 1502                                          ; The event log file is full.
Global Const $ERROR_EVENTLOG_FILE_CHANGED = 1503                                  ; The event log file has changed between read operations.
Global Const $ERROR_INVALID_TASK_NAME = 1550                                      ; The specified task name is invalid.
Global Const $ERROR_INVALID_TASK_INDEX = 1551                                     ; The specified task index is invalid.
Global Const $ERROR_THREAD_ALREADY_IN_TASK = 1552                                 ; The specified thread is already joining a task.
Global Const $ERROR_INSTALL_SERVICE_FAILURE = 1601                                ; The Windows Installer Service could not be accessed. This can occur if the Windows Installer is not correctly installed. Contact your support personnel for assistance.
Global Const $ERROR_INSTALL_USEREXIT = 1602                                       ; User canceled installation.
Global Const $ERROR_INSTALL_FAILURE = 1603                                        ; Fatal error during installation.
Global Const $ERROR_INSTALL_SUSPEND = 1604                                        ; Installation suspended, incomplete.
Global Const $ERROR_UNKNOWN_PRODUCT = 1605                                        ; This action is only valid for products that are currently installed.
Global Const $ERROR_UNKNOWN_FEATURE = 1606                                        ; Feature ID not registered.
Global Const $ERROR_UNKNOWN_COMPONENT = 1607                                      ; Component ID not registered.
Global Const $ERROR_UNKNOWN_PROPERTY = 1608                                       ; Unknown property.
Global Const $ERROR_INVALID_HANDLE_STATE = 1609                                   ; A handle is in an invalid state.
Global Const $ERROR_BAD_CONFIGURATION = 1610                                      ; The configuration data for this product is corrupt. Contact your support personnel.
Global Const $ERROR_INDEX_ABSENT = 1611                                           ; Component qualifier not present.
Global Const $ERROR_INSTALL_SOURCE_ABSENT = 1612                                  ; The installation source for this product is not available. Verify that the source exists and that you can access it.
Global Const $ERROR_INSTALL_PACKAGE_VERSION = 1613                                ; This installation package cannot be installed by the Windows Installer service. You must install a Windows service pack that contains a newer version of the Windows Installer service.
Global Const $ERROR_PRODUCT_UNINSTALLED = 1614                                    ; Product is uninstalled.
Global Const $ERROR_BAD_QUERY_SYNTAX = 1615                                       ; SQL query syntax invalid or unsupported.
Global Const $ERROR_INVALID_FIELD = 1616                                          ; Record field does not exist.
Global Const $ERROR_DEVICE_REMOVED = 1617                                         ; The device has been removed.
Global Const $ERROR_INSTALL_ALREADY_RUNNING = 1618                                ; Another installation is already in progress. Complete that installation before proceeding with this install.
Global Const $ERROR_INSTALL_PACKAGE_OPEN_FAILED = 1619                            ; This installation package could not be opened. Verify that the package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer package.
Global Const $ERROR_INSTALL_PACKAGE_INVALID = 1620                                ; This installation package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer package.
Global Const $ERROR_INSTALL_UI_FAILURE = 1621                                     ; There was an error starting the Windows Installer service user interface. Contact your support personnel.
Global Const $ERROR_INSTALL_LOG_FAILURE = 1622                                    ; Error opening installation log file. Verify that the specified log file location exists and that you can write to it.
Global Const $ERROR_INSTALL_LANGUAGE_UNSUPPORTED = 1623                           ; The language of this installation package is not supported by your system.
Global Const $ERROR_INSTALL_TRANSFORM_FAILURE = 1624                              ; Error applying transforms. Verify that the specified transform paths are valid.
Global Const $ERROR_INSTALL_PACKAGE_REJECTED = 1625                               ; This installation is forbidden by system policy. Contact your system administrator.
Global Const $ERROR_FUNCTION_NOT_CALLED = 1626                                    ; Function could not be executed.
Global Const $ERROR_FUNCTION_FAILED = 1627                                        ; Function failed during execution.
Global Const $ERROR_INVALID_TABLE = 1628                                          ; Invalid or unknown table specified.
Global Const $ERROR_DATATYPE_MISMATCH = 1629                                      ; Data supplied is of wrong type.
Global Const $ERROR_UNSUPPORTED_TYPE = 1630                                       ; Data of this type is not supported.
Global Const $ERROR_CREATE_FAILED = 1631                                          ; The Windows Installer service failed to start. Contact your support personnel.
Global Const $ERROR_INSTALL_TEMP_UNWRITABLE = 1632                                ; The Temp folder is on a drive that is full or is inaccessible. Free up space on the drive or verify that you have write permission on the Temp folder.
Global Const $ERROR_INSTALL_PLATFORM_UNSUPPORTED = 1633                           ; This installation package is not supported by this processor type. Contact your product vendor.
Global Const $ERROR_INSTALL_NOTUSED = 1634                                        ; Component not used on this computer.
Global Const $ERROR_PATCH_PACKAGE_OPEN_FAILED = 1635                              ; This update package could not be opened. Verify that the update package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer update package.
Global Const $ERROR_PATCH_PACKAGE_INVALID = 1636                                  ; This update package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer update package.
Global Const $ERROR_PATCH_PACKAGE_UNSUPPORTED = 1637                              ; This update package cannot be processed by the Windows Installer service. You must install a Windows service pack that contains a newer version of the Windows Installer service.
Global Const $ERROR_PRODUCT_VERSION = 1638                                        ; Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.
Global Const $ERROR_INVALID_COMMAND_LINE = 1639                                   ; Invalid command line argument. Consult the Windows Installer SDK for detailed command line help.
Global Const $ERROR_INSTALL_REMOTE_DISALLOWED = 1640                              ; Only administrators have permission to add, remove, or configure server software during a Terminal services remote session. If you want to install or configure software on the server, contact your network administrator.
Global Const $ERROR_SUCCESS_REBOOT_INITIATED = 1641                               ; The requested operation completed successfully. The system will be restarted so the changes can take effect.
Global Const $ERROR_PATCH_TARGET_NOT_FOUND = 1642                                 ; The upgrade cannot be installed by the Windows Installer service because the program to be upgraded may be missing, or the upgrade may update a different version of the program. Verify that the program to be upgraded exists on your computer and that you have the correct upgrade.
Global Const $ERROR_PATCH_PACKAGE_REJECTED = 1643                                 ; The update package is not permitted by software restriction policy.
Global Const $ERROR_INSTALL_TRANSFORM_REJECTED = 1644                             ; One or more customizations are not permitted by software restriction policy.
Global Const $ERROR_INSTALL_REMOTE_PROHIBITED = 1645                              ; The Windows Installer does not permit installation from a Remote Desktop Connection.
Global Const $ERROR_PATCH_REMOVAL_UNSUPPORTED = 1646                              ; Uninstallation of the update package is not supported.
Global Const $ERROR_UNKNOWN_PATCH = 1647                                          ; The update is not applied to this product.
Global Const $ERROR_PATCH_NO_SEQUENCE = 1648                                      ; No valid sequence could be found for the set of updates.
Global Const $ERROR_PATCH_REMOVAL_DISALLOWED = 1649                               ; Update removal was disallowed by policy.
Global Const $ERROR_INVALID_PATCH_XML = 1650                                      ; The XML update data is invalid.
Global Const $ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT = 1651                       ; Windows Installer does not permit updating of managed advertised products. At least one feature of the product must be installed before applying the update.
Global Const $ERROR_INSTALL_SERVICE_SAFEBOOT = 1652                               ; The Windows Installer service is not accessible in Safe Mode. Please try again when your computer is not in Safe Mode or you can use System Restore to return your machine to a previous good state.
Global Const $ERROR_FAIL_FAST_EXCEPTION = 1653                                    ; A fail fast exception occurred. Exception handlers will not be invoked and the process will be terminated immediately.
Global Const $RPC_S_INVALID_STRING_BINDING = 1700                                 ; The string binding is invalid.
Global Const $RPC_S_WRONG_KIND_OF_BINDING = 1701                                  ; The binding handle is not the correct type.
Global Const $RPC_S_INVALID_BINDING = 1702                                        ; The binding handle is invalid.
Global Const $RPC_S_PROTSEQ_NOT_SUPPORTED = 1703                                  ; The RPC protocol sequence is not supported.
Global Const $RPC_S_INVALID_RPC_PROTSEQ = 1704                                    ; The RPC protocol sequence is invalid.
Global Const $RPC_S_INVALID_STRING_UUID = 1705                                    ; The string universal unique identifier (UUID) is invalid.
Global Const $RPC_S_INVALID_ENDPOINT_FORMAT = 1706                                ; The endpoint format is invalid.
Global Const $RPC_S_INVALID_NET_ADDR = 1707                                       ; The network address is invalid.
Global Const $RPC_S_NO_ENDPOINT_FOUND = 1708                                      ; No endpoint was found.
Global Const $RPC_S_INVALID_TIMEOUT = 1709                                        ; The timeout value is invalid.
Global Const $RPC_S_OBJECT_NOT_FOUND = 1710                                       ; The object universal unique identifier (UUID) was not found.
Global Const $RPC_S_ALREADY_REGISTERED = 1711                                     ; The object universal unique identifier (UUID) has already been registered.
Global Const $RPC_S_TYPE_ALREADY_REGISTERED = 1712                                ; The type universal unique identifier (UUID) has already been registered.
Global Const $RPC_S_ALREADY_LISTENING = 1713                                      ; The RPC server is already listening.
Global Const $RPC_S_NO_PROTSEQS_REGISTERED = 1714                                 ; No protocol sequences have been registered.
Global Const $RPC_S_NOT_LISTENING = 1715                                          ; The RPC server is not listening.
Global Const $RPC_S_UNKNOWN_MGR_TYPE = 1716                                       ; The manager type is unknown.
Global Const $RPC_S_UNKNOWN_IF = 1717                                             ; The interface is unknown.
Global Const $RPC_S_NO_BINDINGS = 1718                                            ; There are no bindings.
Global Const $RPC_S_NO_PROTSEQS = 1719                                            ; There are no protocol sequences.
Global Const $RPC_S_CANT_CREATE_ENDPOINT = 1720                                   ; The endpoint cannot be created.
Global Const $RPC_S_OUT_OF_RESOURCES = 1721                                       ; Not enough resources are available to complete this operation.
Global Const $RPC_S_SERVER_UNAVAILABLE = 1722                                     ; The RPC server is unavailable.
Global Const $RPC_S_SERVER_TOO_BUSY = 1723                                        ; The RPC server is too busy to complete this operation.
Global Const $RPC_S_INVALID_NETWORK_OPTIONS = 1724                                ; The network options are invalid.
Global Const $RPC_S_NO_CALL_ACTIVE = 1725                                         ; There are no remote procedure calls active on this thread.
Global Const $RPC_S_CALL_FAILED = 1726                                            ; The remote procedure call failed.
Global Const $RPC_S_CALL_FAILED_DNE = 1727                                        ; The remote procedure call failed and did not execute.
Global Const $RPC_S_PROTOCOL_ERROR = 1728                                         ; A remote procedure call (RPC) protocol error occurred.
Global Const $RPC_S_PROXY_ACCESS_DENIED = 1729                                    ; Access to the HTTP proxy is denied.
Global Const $RPC_S_UNSUPPORTED_TRANS_SYN = 1730                                  ; The transfer syntax is not supported by the RPC server.
Global Const $RPC_S_UNSUPPORTED_TYPE = 1732                                       ; The universal unique identifier (UUID) type is not supported.
Global Const $RPC_S_INVALID_TAG = 1733                                            ; The tag is invalid.
Global Const $RPC_S_INVALID_BOUND = 1734                                          ; The array bounds are invalid.
Global Const $RPC_S_NO_ENTRY_NAME = 1735                                          ; The binding does not contain an entry name.
Global Const $RPC_S_INVALID_NAME_SYNTAX = 1736                                    ; The name syntax is invalid.
Global Const $RPC_S_UNSUPPORTED_NAME_SYNTAX = 1737                                ; The name syntax is not supported.
Global Const $RPC_S_UUID_NO_ADDRESS = 1739                                        ; No network address is available to use to construct a universal unique identifier (UUID).
Global Const $RPC_S_DUPLICATE_ENDPOINT = 1740                                     ; The endpoint is a duplicate.
Global Const $RPC_S_UNKNOWN_AUTHN_TYPE = 1741                                     ; The authentication type is unknown.
Global Const $RPC_S_MAX_CALLS_TOO_SMALL = 1742                                    ; The maximum number of calls is too small.
Global Const $RPC_S_STRING_TOO_LONG = 1743                                        ; The string is too long.
Global Const $RPC_S_PROTSEQ_NOT_FOUND = 1744                                      ; The RPC protocol sequence was not found.
Global Const $RPC_S_PROCNUM_OUT_OF_RANGE = 1745                                   ; The procedure number is out of range.
Global Const $RPC_S_BINDING_HAS_NO_AUTH = 1746                                    ; The binding does not contain any authentication information.
Global Const $RPC_S_UNKNOWN_AUTHN_SERVICE = 1747                                  ; The authentication service is unknown.
Global Const $RPC_S_UNKNOWN_AUTHN_LEVEL = 1748                                    ; The authentication level is unknown.
Global Const $RPC_S_INVALID_AUTH_IDENTITY = 1749                                  ; The security context is invalid.
Global Const $RPC_S_UNKNOWN_AUTHZ_SERVICE = 1750                                  ; The authorization service is unknown.
Global Const $EPT_S_INVALID_ENTRY = 1751                                          ; The entry is invalid.
Global Const $EPT_S_CANT_PERFORM_OP = 1752                                        ; The server endpoint cannot perform the operation.
Global Const $EPT_S_NOT_REGISTERED = 1753                                         ; There are no more endpoints available from the endpoint mapper.
Global Const $RPC_S_NOTHING_TO_EXPORT = 1754                                      ; No interfaces have been exported.
Global Const $RPC_S_INCOMPLETE_NAME = 1755                                        ; The entry name is incomplete.
Global Const $RPC_S_INVALID_VERS_OPTION = 1756                                    ; The version option is invalid.
Global Const $RPC_S_NO_MORE_MEMBERS = 1757                                        ; There are no more members.
Global Const $RPC_S_NOT_ALL_OBJS_UNEXPORTED = 1758                                ; There is nothing to unexport.
Global Const $RPC_S_INTERFACE_NOT_FOUND = 1759                                    ; The interface was not found.
Global Const $RPC_S_ENTRY_ALREADY_EXISTS = 1760                                   ; The entry already exists.
Global Const $RPC_S_ENTRY_NOT_FOUND = 1761                                        ; The entry is not found.
Global Const $RPC_S_NAME_SERVICE_UNAVAILABLE = 1762                               ; The name service is unavailable.
Global Const $RPC_S_INVALID_NAF_ID = 1763                                         ; The network address family is invalid.
Global Const $RPC_S_CANNOT_SUPPORT = 1764                                         ; The requested operation is not supported.
Global Const $RPC_S_NO_CONTEXT_AVAILABLE = 1765                                   ; No security context is available to allow impersonation.
Global Const $RPC_S_INTERNAL_ERROR = 1766                                         ; An internal error occurred in a remote procedure call (RPC).
Global Const $RPC_S_ZERO_DIVIDE = 1767                                            ; The RPC server attempted an integer division by zero.
Global Const $RPC_S_ADDRESS_ERROR = 1768                                          ; An addressing error occurred in the RPC server.
Global Const $RPC_S_FP_DIV_ZERO = 1769                                            ; A floating-point operation at the RPC server caused a division by zero.
Global Const $RPC_S_FP_UNDERFLOW = 1770                                           ; A floating-point underflow occurred at the RPC server.
Global Const $RPC_S_FP_OVERFLOW = 1771                                            ; A floating-point overflow occurred at the RPC server.
Global Const $RPC_X_NO_MORE_ENTRIES = 1772                                        ; The list of RPC servers available for the binding of auto handles has been exhausted.
Global Const $RPC_X_SS_CHAR_TRANS_OPEN_FAIL = 1773                                ; Unable to open the character translation table file.
Global Const $RPC_X_SS_CHAR_TRANS_SHORT_FILE = 1774                               ; The file containing the character translation table has fewer than 512 bytes.
Global Const $RPC_X_SS_IN_NULL_CONTEXT = 1775                                     ; A null context handle was passed from the client to the host during a remote procedure call.
Global Const $RPC_X_SS_CONTEXT_DAMAGED = 1777                                     ; The context handle changed during a remote procedure call.
Global Const $RPC_X_SS_HANDLES_MISMATCH = 1778                                    ; The binding handles passed to a remote procedure call do not match.
Global Const $RPC_X_SS_CANNOT_GET_CALL_HANDLE = 1779                              ; The stub is unable to get the remote procedure call handle.
Global Const $RPC_X_NULL_REF_POINTER = 1780                                       ; A null reference pointer was passed to the stub.
Global Const $RPC_X_ENUM_VALUE_OUT_OF_RANGE = 1781                                ; The enumeration value is out of range.
Global Const $RPC_X_BYTE_COUNT_TOO_SMALL = 1782                                   ; The byte count is too small.
Global Const $RPC_X_BAD_STUB_DATA = 1783                                          ; The stub received bad data.
Global Const $ERROR_INVALID_USER_BUFFER = 1784                                    ; The supplied user buffer is not valid for the requested operation.
Global Const $ERROR_UNRECOGNIZED_MEDIA = 1785                                     ; The disk media is not recognized. It may not be formatted.
Global Const $ERROR_NO_TRUST_LSA_SECRET = 1786                                    ; The workstation does not have a trust secret.
Global Const $ERROR_NO_TRUST_SAM_ACCOUNT = 1787                                   ; The security database on the server does not have a computer account for this workstation trust relationship.
Global Const $ERROR_TRUSTED_DOMAIN_FAILURE = 1788                                 ; The trust relationship between the primary domain and the trusted domain failed.
Global Const $ERROR_TRUSTED_RELATIONSHIP_FAILURE = 1789                           ; The trust relationship between this workstation and the primary domain failed.
Global Const $ERROR_TRUST_FAILURE = 1790                                          ; The network logon failed.
Global Const $RPC_S_CALL_IN_PROGRESS = 1791                                       ; A remote procedure call is already in progress for this thread.
Global Const $ERROR_NETLOGON_NOT_STARTED = 1792                                   ; An attempt was made to logon, but the network logon service was not started.
Global Const $ERROR_ACCOUNT_EXPIRED = 1793                                        ; The user's account has expired.
Global Const $ERROR_REDIRECTOR_HAS_OPEN_HANDLES = 1794                            ; The redirector is in use and cannot be unloaded.
Global Const $ERROR_PRINTER_DRIVER_ALREADY_INSTALLED = 1795                       ; The specified printer driver is already installed.
Global Const $ERROR_UNKNOWN_PORT = 1796                                           ; The specified port is unknown.
Global Const $ERROR_UNKNOWN_PRINTER_DRIVER = 1797                                 ; The printer driver is unknown.
Global Const $ERROR_UNKNOWN_PRINTPROCESSOR = 1798                                 ; The print processor is unknown.
Global Const $ERROR_INVALID_SEPARATOR_FILE = 1799                                 ; The specified separator file is invalid.
Global Const $ERROR_INVALID_PRIORITY = 1800                                       ; The specified priority is invalid.
Global Const $ERROR_INVALID_PRINTER_NAME = 1801                                   ; The printer name is invalid.
Global Const $ERROR_PRINTER_ALREADY_EXISTS = 1802                                 ; The printer already exists.
Global Const $ERROR_INVALID_PRINTER_COMMAND = 1803                                ; The printer command is invalid.
Global Const $ERROR_INVALID_DATATYPE = 1804                                       ; The specified datatype is invalid.
Global Const $ERROR_INVALID_ENVIRONMENT = 1805                                    ; The environment specified is invalid.
Global Const $RPC_S_NO_MORE_BINDINGS = 1806                                       ; There are no more bindings.
Global Const $ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 1807                      ; The account used is an interdomain trust account. Use your global user account or local user account to access this server.
Global Const $ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT = 1808                      ; The account used is a computer account. Use your global user account or local user account to access this server.
Global Const $ERROR_NOLOGON_SERVER_TRUST_ACCOUNT = 1809                           ; The account used is a server trust account. Use your global user account or local user account to access this server.
Global Const $ERROR_DOMAIN_TRUST_INCONSISTENT = 1810                              ; The name or security ID (SID) of the domain specified is inconsistent with the trust information for that domain.
Global Const $ERROR_SERVER_HAS_OPEN_HANDLES = 1811                                ; The server is in use and cannot be unloaded.
Global Const $ERROR_RESOURCE_DATA_NOT_FOUND = 1812                                ; The specified image file did not contain a resource section.
Global Const $ERROR_RESOURCE_TYPE_NOT_FOUND = 1813                                ; The specified resource type cannot be found in the image file.
Global Const $ERROR_RESOURCE_NAME_NOT_FOUND = 1814                                ; The specified resource name cannot be found in the image file.
Global Const $ERROR_RESOURCE_LANG_NOT_FOUND = 1815                                ; The specified resource language ID cannot be found in the image file.
Global Const $ERROR_NOT_ENOUGH_QUOTA = 1816                                       ; Not enough quota is available to process this command.
Global Const $RPC_S_NO_INTERFACES = 1817                                          ; No interfaces have been registered.
Global Const $RPC_S_CALL_CANCELLED = 1818                                         ; The remote procedure call was canceled.
Global Const $RPC_S_BINDING_INCOMPLETE = 1819                                     ; The binding handle does not contain all required information.
Global Const $RPC_S_COMM_FAILURE = 1820                                           ; A communications failure occurred during a remote procedure call.
Global Const $RPC_S_UNSUPPORTED_AUTHN_LEVEL = 1821                                ; The requested authentication level is not supported.
Global Const $RPC_S_NO_PRINC_NAME = 1822                                          ; No principal name registered.
Global Const $RPC_S_NOT_RPC_ERROR = 1823                                          ; The error specified is not a valid Windows RPC error code.
Global Const $RPC_S_UUID_LOCAL_ONLY = 1824                                        ; A UUID that is valid only on this computer has been allocated.
Global Const $RPC_S_SEC_PKG_ERROR = 1825                                          ; A security package specific error occurred.
Global Const $RPC_S_NOT_CANCELLED = 1826                                          ; Thread is not canceled.
Global Const $RPC_X_INVALID_ES_ACTION = 1827                                      ; Invalid operation on the encoding/decoding handle.
Global Const $RPC_X_WRONG_ES_VERSION = 1828                                       ; Incompatible version of the serializing package.
Global Const $RPC_X_WRONG_STUB_VERSION = 1829                                     ; Incompatible version of the RPC stub.
Global Const $RPC_X_INVALID_PIPE_OBJECT = 1830                                    ; The RPC pipe object is invalid or corrupted.
Global Const $RPC_X_WRONG_PIPE_ORDER = 1831                                       ; An invalid operation was attempted on an RPC pipe object.
Global Const $RPC_X_WRONG_PIPE_VERSION = 1832                                     ; Unsupported RPC pipe version.
Global Const $RPC_S_COOKIE_AUTH_FAILED = 1833                                     ; HTTP proxy server rejected the connection because the cookie authentication failed.
Global Const $RPC_S_GROUP_MEMBER_NOT_FOUND = 1898                                 ; The group member was not found.
Global Const $EPT_S_CANT_CREATE = 1899                                            ; The endpoint mapper database entry could not be created.
Global Const $RPC_S_INVALID_OBJECT = 1900                                         ; The object universal unique identifier (UUID) is the nil UUID.
Global Const $ERROR_INVALID_TIME = 1901                                           ; The specified time is invalid.
Global Const $ERROR_INVALID_FORM_NAME = 1902                                      ; The specified form name is invalid.
Global Const $ERROR_INVALID_FORM_SIZE = 1903                                      ; The specified form size is invalid.
Global Const $ERROR_ALREADY_WAITING = 1904                                        ; The specified printer handle is already being waited on.
Global Const $ERROR_PRINTER_DELETED = 1905                                        ; The specified printer has been deleted.
Global Const $ERROR_INVALID_PRINTER_STATE = 1906                                  ; The state of the printer is invalid.
Global Const $ERROR_PASSWORD_MUST_CHANGE = 1907                                   ; The user's password must be changed before logging on the first time.
Global Const $ERROR_DOMAIN_CONTROLLER_NOT_FOUND = 1908                            ; Could not find the domain controller for this domain.
Global Const $ERROR_ACCOUNT_LOCKED_OUT = 1909                                     ; The referenced account is currently locked out and may not be logged on to.
Global Const $OR_INVALID_OXID = 1910                                              ; The object exporter specified was not found.
Global Const $OR_INVALID_OID = 1911                                               ; The object specified was not found.
Global Const $OR_INVALID_SET = 1912                                               ; The object resolver set specified was not found.
Global Const $RPC_S_SEND_INCOMPLETE = 1913                                        ; Some data remains to be sent in the request buffer.
Global Const $RPC_S_INVALID_ASYNC_HANDLE = 1914                                   ; Invalid asynchronous remote procedure call handle.
Global Const $RPC_S_INVALID_ASYNC_CALL = 1915                                     ; Invalid asynchronous RPC call handle for this operation.
Global Const $RPC_X_PIPE_CLOSED = 1916                                            ; The RPC pipe object has already been closed.
Global Const $RPC_X_PIPE_DISCIPLINE_ERROR = 1917                                  ; The RPC call completed before all pipes were processed.
Global Const $RPC_X_PIPE_EMPTY = 1918                                             ; No more data is available from the RPC pipe.
Global Const $ERROR_NO_SITENAME = 1919                                            ; No site name is available for this machine.
Global Const $ERROR_CANT_ACCESS_FILE = 1920                                       ; The file cannot be accessed by the system.
Global Const $ERROR_CANT_RESOLVE_FILENAME = 1921                                  ; The name of the file cannot be resolved by the system.
Global Const $RPC_S_ENTRY_TYPE_MISMATCH = 1922                                    ; The entry is not of the expected type.
Global Const $RPC_S_NOT_ALL_OBJS_EXPORTED = 1923                                  ; Not all object UUIDs could be exported to the specified entry.
Global Const $RPC_S_INTERFACE_NOT_EXPORTED = 1924                                 ; Interface could not be exported to the specified entry.
Global Const $RPC_S_PROFILE_NOT_ADDED = 1925                                      ; The specified profile entry could not be added.
Global Const $RPC_S_PRF_ELT_NOT_ADDED = 1926                                      ; The specified profile element could not be added.
Global Const $RPC_S_PRF_ELT_NOT_REMOVED = 1927                                    ; The specified profile element could not be removed.
Global Const $RPC_S_GRP_ELT_NOT_ADDED = 1928                                      ; The group element could not be added.
Global Const $RPC_S_GRP_ELT_NOT_REMOVED = 1929                                    ; The group element could not be removed.
Global Const $ERROR_KM_DRIVER_BLOCKED = 1930                                      ; The printer driver is not compatible with a policy enabled on your computer that blocks NT 4.0 drivers.
Global Const $ERROR_CONTEXT_EXPIRED = 1931                                        ; The context has expired and can no longer be used.
Global Const $ERROR_PER_USER_TRUST_QUOTA_EXCEEDED = 1932                          ; The current user's delegated trust creation quota has been exceeded.
Global Const $ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED = 1933                          ; The total delegated trust creation quota has been exceeded.
Global Const $ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED = 1934                       ; The current user's delegated trust deletion quota has been exceeded.
Global Const $ERROR_AUTHENTICATION_FIREWALL_FAILED = 1935                         ; Logon Failure: The machine you are logging onto is protected by an authentication firewall. The specified account is not allowed to authenticate to the machine.
Global Const $ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED = 1936                       ; Remote connections to the Print Spooler are blocked by a policy set on your machine.
Global Const $ERROR_NTLM_BLOCKED = 1937                                           ; Authentication failed because NTLM authentication has been disabled.
Global Const $ERROR_INVALID_PIXEL_FORMAT = 2000                                   ; The pixel format is invalid.
Global Const $ERROR_BAD_DRIVER = 2001                                             ; The specified driver is invalid.
Global Const $ERROR_INVALID_WINDOW_STYLE = 2002                                   ; The window style or class attribute is invalid for this operation.
Global Const $ERROR_METAFILE_NOT_SUPPORTED = 2003                                 ; The requested metafile operation is not supported.
Global Const $ERROR_TRANSFORM_NOT_SUPPORTED = 2004                                ; The requested transformation operation is not supported.
Global Const $ERROR_CLIPPING_NOT_SUPPORTED = 2005                                 ; The requested clipping operation is not supported.
Global Const $ERROR_INVALID_CMM = 2010                                            ; The specified color management module is invalid.
Global Const $ERROR_INVALID_PROFILE = 2011                                        ; The specified color profile is invalid.
Global Const $ERROR_TAG_NOT_FOUND = 2012                                          ; The specified tag was not found.
Global Const $ERROR_TAG_NOT_PRESENT = 2013                                        ; A required tag is not present.
Global Const $ERROR_DUPLICATE_TAG = 2014                                          ; The specified tag is already present.
Global Const $ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE = 2015                     ; The specified color profile is not associated with the specified device.
Global Const $ERROR_PROFILE_NOT_FOUND = 2016                                      ; The specified color profile was not found.
Global Const $ERROR_INVALID_COLORSPACE = 2017                                     ; The specified color space is invalid.
Global Const $ERROR_ICM_NOT_ENABLED = 2018                                        ; Image Color Management is not enabled.
Global Const $ERROR_DELETING_ICM_XFORM = 2019                                     ; There was an error while deleting the color transform.
Global Const $ERROR_INVALID_TRANSFORM = 2020                                      ; The specified color transform is invalid.
Global Const $ERROR_COLORSPACE_MISMATCH = 2021                                    ; The specified transform does not match the bitmap's color space.
Global Const $ERROR_INVALID_COLORINDEX = 2022                                     ; The specified named color index is not present in the profile.
Global Const $ERROR_PROFILE_DOES_NOT_MATCH_DEVICE = 2023                          ; The specified profile is intended for a device of a different type than the specified device.
Global Const $ERROR_CONNECTED_OTHER_PASSWORD = 2108                               ; The network connection was made successfully, but the user had to be prompted for a password other than the one originally specified.
Global Const $ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT = 2109                       ; The network connection was made successfully using default credentials.
Global Const $ERROR_BAD_USERNAME = 2202                                           ; The specified user name is invalid.
Global Const $ERROR_NOT_CONNECTED = 2250                                          ; This network connection does not exist.
Global Const $ERROR_OPEN_FILES = 2401                                             ; This network connection has files open or requests pending.
Global Const $ERROR_ACTIVE_CONNECTIONS = 2402                                     ; Active connections still exist.
Global Const $ERROR_DEVICE_IN_USE = 2404                                          ; The device is in use by an active process and cannot be disconnected.
Global Const $ERROR_UNKNOWN_PRINT_MONITOR = 3000                                  ; The specified print monitor is unknown.
Global Const $ERROR_PRINTER_DRIVER_IN_USE = 3001                                  ; The specified printer driver is currently in use.
Global Const $ERROR_SPOOL_FILE_NOT_FOUND = 3002                                   ; The spool file was not found.
Global Const $ERROR_SPL_NO_STARTDOC = 3003                                        ; A StartDocPrinter call was not issued.
Global Const $ERROR_SPL_NO_ADDJOB = 3004                                          ; An AddJob call was not issued.
Global Const $ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED = 3005                      ; The specified print processor has already been installed.
Global Const $ERROR_PRINT_MONITOR_ALREADY_INSTALLED = 3006                        ; The specified print monitor has already been installed.
Global Const $ERROR_INVALID_PRINT_MONITOR = 3007                                  ; The specified print monitor does not have the required functions.
Global Const $ERROR_PRINT_MONITOR_IN_USE = 3008                                   ; The specified print monitor is currently in use.
Global Const $ERROR_PRINTER_HAS_JOBS_QUEUED = 3009                                ; The requested operation is not allowed when there are jobs queued to the printer.
Global Const $ERROR_SUCCESS_REBOOT_REQUIRED = 3010                                ; The requested operation is successful. Changes will not be effective until the system is rebooted.
Global Const $ERROR_SUCCESS_RESTART_REQUIRED = 3011                               ; The requested operation is successful. Changes will not be effective until the service is restarted.
Global Const $ERROR_PRINTER_NOT_FOUND = 3012                                      ; No printers were found.
Global Const $ERROR_PRINTER_DRIVER_WARNED = 3013                                  ; The printer driver is known to be unreliable.
Global Const $ERROR_PRINTER_DRIVER_BLOCKED = 3014                                 ; The printer driver is known to harm the system.
Global Const $ERROR_PRINTER_DRIVER_PACKAGE_IN_USE = 3015                          ; The specified printer driver package is currently in use.
Global Const $ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND = 3016                          ; Unable to find a core driver package that is required by the printer driver package.
Global Const $ERROR_FAIL_REBOOT_REQUIRED = 3017                                   ; The requested operation failed. A system reboot is required to roll back changes made.
Global Const $ERROR_FAIL_REBOOT_INITIATED = 3018                                  ; The requested operation failed. A system reboot has been initiated to roll back changes made.
Global Const $ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED = 3019                         ; The specified printer driver was not found on the system and needs to be downloaded.
Global Const $ERROR_PRINT_JOB_RESTART_REQUIRED = 3020                             ; The requested print job has failed to print. A print system update requires the job to be resubmitted.
Global Const $ERROR_IO_REISSUE_AS_CACHED = 3950                                   ; Reissue the given operation as a cached I/O operation.
Global Const $ERROR_WINS_INTERNAL = 4000                                          ; WINS encountered an error while processing the command.
Global Const $ERROR_CAN_NOT_DEL_LOCAL_WINS = 4001                                 ; The local WINS cannot be deleted.
Global Const $ERROR_STATIC_INIT = 4002                                            ; The importation from the file failed.
Global Const $ERROR_INC_BACKUP = 4003                                             ; The backup failed. Was a full backup done before?
Global Const $ERROR_FULL_BACKUP = 4004                                            ; The backup failed. Check the directory to which you are backing the database.
Global Const $ERROR_REC_NON_EXISTENT = 4005                                       ; The name does not exist in the WINS database.
Global Const $ERROR_RPL_NOT_ALLOWED = 4006                                        ; Replication with a nonconfigured partner is not allowed.
Global Const $ERROR_DHCP_ADDRESS_CONFLICT = 4100                                  ; The DHCP client has obtained an IP address that is already in use on the network. The local interface will be disabled until the DHCP client can obtain a new address.
Global Const $ERROR_WMI_GUID_NOT_FOUND = 4200                                     ; The GUID passed was not recognized as valid by a WMI data provider.
Global Const $ERROR_WMI_INSTANCE_NOT_FOUND = 4201                                 ; The instance name passed was not recognized as valid by a WMI data provider.
Global Const $ERROR_WMI_ITEMID_NOT_FOUND = 4202                                   ; The data item ID passed was not recognized as valid by a WMI data provider.
Global Const $ERROR_WMI_TRY_AGAIN = 4203                                          ; The WMI request could not be completed and should be retried.
Global Const $ERROR_WMI_DP_NOT_FOUND = 4204                                       ; The WMI data provider could not be located.
Global Const $ERROR_WMI_UNRESOLVED_INSTANCE_REF = 4205                            ; The WMI data provider references an instance set that has not been registered.
Global Const $ERROR_WMI_ALREADY_ENABLED = 4206                                    ; The WMI data block or event notification has already been enabled.
Global Const $ERROR_WMI_GUID_DISCONNECTED = 4207                                  ; The WMI data block is no longer available.
Global Const $ERROR_WMI_SERVER_UNAVAILABLE = 4208                                 ; The WMI data service is not available.
Global Const $ERROR_WMI_DP_FAILED = 4209                                          ; The WMI data provider failed to carry out the request.
Global Const $ERROR_WMI_INVALID_MOF = 4210                                        ; The WMI MOF information is not valid.
Global Const $ERROR_WMI_INVALID_REGINFO = 4211                                    ; The WMI registration information is not valid.
Global Const $ERROR_WMI_ALREADY_DISABLED = 4212                                   ; The WMI data block or event notification has already been disabled.
Global Const $ERROR_WMI_READ_ONLY = 4213                                          ; The WMI data item or data block is read only.
Global Const $ERROR_WMI_SET_FAILURE = 4214                                        ; The WMI data item or data block could not be changed.
Global Const $ERROR_INVALID_MEDIA = 4300                                          ; The media identifier does not represent a valid medium.
Global Const $ERROR_INVALID_LIBRARY = 4301                                        ; The library identifier does not represent a valid library.
Global Const $ERROR_INVALID_MEDIA_POOL = 4302                                     ; The media pool identifier does not represent a valid media pool.
Global Const $ERROR_DRIVE_MEDIA_MISMATCH = 4303                                   ; The drive and medium are not compatible or exist in different libraries.
Global Const $ERROR_MEDIA_OFFLINE = 4304                                          ; The medium currently exists in an offline library and must be online to perform this operation.
Global Const $ERROR_LIBRARY_OFFLINE = 4305                                        ; The operation cannot be performed on an offline library.
Global Const $ERROR_EMPTY = 4306                                                  ; The library, drive, or media pool is empty.
Global Const $ERROR_NOT_EMPTY = 4307                                              ; The library, drive, or media pool must be empty to perform this operation.
Global Const $ERROR_MEDIA_UNAVAILABLE = 4308                                      ; No media is currently available in this media pool or library.
Global Const $ERROR_RESOURCE_DISABLED = 4309                                      ; A resource required for this operation is disabled.
Global Const $ERROR_INVALID_CLEANER = 4310                                        ; The media identifier does not represent a valid cleaner.
Global Const $ERROR_UNABLE_TO_CLEAN = 4311                                        ; The drive cannot be cleaned or does not support cleaning.
Global Const $ERROR_OBJECT_NOT_FOUND = 4312                                       ; The object identifier does not represent a valid object.
Global Const $ERROR_DATABASE_FAILURE = 4313                                       ; Unable to read from or write to the database.
Global Const $ERROR_DATABASE_FULL = 4314                                          ; The database is full.
Global Const $ERROR_MEDIA_INCOMPATIBLE = 4315                                     ; The medium is not compatible with the device or media pool.
Global Const $ERROR_RESOURCE_NOT_PRESENT = 4316                                   ; The resource required for this operation does not exist.
Global Const $ERROR_INVALID_OPERATION = 4317                                      ; The operation identifier is not valid.
Global Const $ERROR_MEDIA_NOT_AVAILABLE = 4318                                    ; The media is not mounted or ready for use.
Global Const $ERROR_DEVICE_NOT_AVAILABLE = 4319                                   ; The device is not ready for use.
Global Const $ERROR_REQUEST_REFUSED = 4320                                        ; The operator or administrator has refused the request.
Global Const $ERROR_INVALID_DRIVE_OBJECT = 4321                                   ; The drive identifier does not represent a valid drive.
Global Const $ERROR_LIBRARY_FULL = 4322                                           ; Library is full. No slot is available for use.
Global Const $ERROR_MEDIUM_NOT_ACCESSIBLE = 4323                                  ; The transport cannot access the medium.
Global Const $ERROR_UNABLE_TO_LOAD_MEDIUM = 4324                                  ; Unable to load the medium into the drive.
Global Const $ERROR_UNABLE_TO_INVENTORY_DRIVE = 4325                              ; Unable to retrieve the drive status.
Global Const $ERROR_UNABLE_TO_INVENTORY_SLOT = 4326                               ; Unable to retrieve the slot status.
Global Const $ERROR_UNABLE_TO_INVENTORY_TRANSPORT = 4327                          ; Unable to retrieve status about the transport.
Global Const $ERROR_TRANSPORT_FULL = 4328                                         ; Cannot use the transport because it is already in use.
Global Const $ERROR_CONTROLLING_IEPORT = 4329                                     ; Unable to open or close the inject/eject port.
Global Const $ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA = 4330                          ; Unable to eject the medium because it is in a drive.
Global Const $ERROR_CLEANER_SLOT_SET = 4331                                       ; A cleaner slot is already reserved.
Global Const $ERROR_CLEANER_SLOT_NOT_SET = 4332                                   ; A cleaner slot is not reserved.
Global Const $ERROR_CLEANER_CARTRIDGE_SPENT = 4333                                ; The cleaner cartridge has performed the maximum number of drive cleanings.
Global Const $ERROR_UNEXPECTED_OMID = 4334                                        ; Unexpected on-medium identifier.
Global Const $ERROR_CANT_DELETE_LAST_ITEM = 4335                                  ; The last remaining item in this group or resource cannot be deleted.
Global Const $ERROR_MESSAGE_EXCEEDS_MAX_SIZE = 4336                               ; The message provided exceeds the maximum size allowed for this parameter.
Global Const $ERROR_VOLUME_CONTAINS_SYS_FILES = 4337                              ; The volume contains system or paging files.
Global Const $ERROR_INDIGENOUS_TYPE = 4338                                        ; The media type cannot be removed from this library since at least one drive in the library reports it can support this media type.
Global Const $ERROR_NO_SUPPORTING_DRIVES = 4339                                   ; This offline media cannot be mounted on this system since no enabled drives are present which can be used.
Global Const $ERROR_CLEANER_CARTRIDGE_INSTALLED = 4340                            ; A cleaner cartridge is present in the tape library.
Global Const $ERROR_IEPORT_FULL = 4341                                            ; Cannot use the inject/eject port because it is not empty.
Global Const $ERROR_FILE_OFFLINE = 4350                                           ; The file is currently not available for use on this computer.
Global Const $ERROR_REMOTE_STORAGE_NOT_ACTIVE = 4351                              ; The remote storage service is not operational at this time.
Global Const $ERROR_REMOTE_STORAGE_MEDIA_ERROR = 4352                             ; The remote storage service encountered a media error.
Global Const $ERROR_NOT_A_REPARSE_POINT = 4390                                    ; The file or directory is not a reparse point.
Global Const $ERROR_REPARSE_ATTRIBUTE_CONFLICT = 4391                             ; The reparse point attribute cannot be set because it conflicts with an existing attribute.
Global Const $ERROR_INVALID_REPARSE_DATA = 4392                                   ; The data present in the reparse point buffer is invalid.
Global Const $ERROR_REPARSE_TAG_INVALID = 4393                                    ; The tag present in the reparse point buffer is invalid.
Global Const $ERROR_REPARSE_TAG_MISMATCH = 4394                                   ; There is a mismatch between the tag specified in the request and the tag present in the reparse point.
Global Const $ERROR_VOLUME_NOT_SIS_ENABLED = 4500                                 ; Single Instance Storage is not available on this volume.
Global Const $ERROR_DEPENDENT_RESOURCE_EXISTS = 5001                              ; The operation cannot be completed because other resources are dependent on this resource.
Global Const $ERROR_DEPENDENCY_NOT_FOUND = 5002                                   ; The cluster resource dependency cannot be found.
Global Const $ERROR_DEPENDENCY_ALREADY_EXISTS = 5003                              ; The cluster resource cannot be made dependent on the specified resource because it is already dependent.
Global Const $ERROR_RESOURCE_NOT_ONLINE = 5004                                    ; The cluster resource is not online.
Global Const $ERROR_HOST_NODE_NOT_AVAILABLE = 5005                                ; A cluster node is not available for this operation.
Global Const $ERROR_RESOURCE_NOT_AVAILABLE = 5006                                 ; The cluster resource is not available.
Global Const $ERROR_RESOURCE_NOT_FOUND = 5007                                     ; The cluster resource could not be found.
Global Const $ERROR_SHUTDOWN_CLUSTER = 5008                                       ; The cluster is being shut down.
Global Const $ERROR_CANT_EVICT_ACTIVE_NODE = 5009                                 ; A cluster node cannot be evicted from the cluster unless the node is down or it is the last node.
Global Const $ERROR_OBJECT_ALREADY_EXISTS = 5010                                  ; The object already exists.
Global Const $ERROR_OBJECT_IN_LIST = 5011                                         ; The object is already in the list.
Global Const $ERROR_GROUP_NOT_AVAILABLE = 5012                                    ; The cluster group is not available for any new requests.
Global Const $ERROR_GROUP_NOT_FOUND = 5013                                        ; The cluster group could not be found.
Global Const $ERROR_GROUP_NOT_ONLINE = 5014                                       ; The operation could not be completed because the cluster group is not online.
Global Const $ERROR_HOST_NODE_NOT_RESOURCE_OWNER = 5015                           ; The operation failed because either the specified cluster node is not the owner of the resource, or the node is not a possible owner of the resource.
Global Const $ERROR_HOST_NODE_NOT_GROUP_OWNER = 5016                              ; The operation failed because either the specified cluster node is not the owner of the group, or the node is not a possible owner of the group.
Global Const $ERROR_RESMON_CREATE_FAILED = 5017                                   ; The cluster resource could not be created in the specified resource monitor.
Global Const $ERROR_RESMON_ONLINE_FAILED = 5018                                   ; The cluster resource could not be brought online by the resource monitor.
Global Const $ERROR_RESOURCE_ONLINE = 5019                                        ; The operation could not be completed because the cluster resource is online.
Global Const $ERROR_QUORUM_RESOURCE = 5020                                        ; The cluster resource could not be deleted or brought offline because it is the quorum resource.
Global Const $ERROR_NOT_QUORUM_CAPABLE = 5021                                     ; The cluster could not make the specified resource a quorum resource because it is not capable of being a quorum resource.
Global Const $ERROR_CLUSTER_SHUTTING_DOWN = 5022                                  ; The cluster software is shutting down.
Global Const $ERROR_INVALID_STATE = 5023                                          ; The group or resource is not in the correct state to perform the requested operation.
Global Const $ERROR_RESOURCE_PROPERTIES_STORED = 5024                             ; The properties were stored but not all changes will take effect until the next time the resource is brought online.
Global Const $ERROR_NOT_QUORUM_CLASS = 5025                                       ; The cluster could not make the specified resource a quorum resource because it does not belong to a shared storage class.
Global Const $ERROR_CORE_RESOURCE = 5026                                          ; The cluster resource could not be deleted since it is a core resource.
Global Const $ERROR_QUORUM_RESOURCE_ONLINE_FAILED = 5027                          ; The quorum resource failed to come online.
Global Const $ERROR_QUORUMLOG_OPEN_FAILED = 5028                                  ; The quorum log could not be created or mounted successfully.
Global Const $ERROR_CLUSTERLOG_CORRUPT = 5029                                     ; The cluster log is corrupt.
Global Const $ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE = 5030                      ; The record could not be written to the cluster log since it exceeds the maximum size.
Global Const $ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE = 5031                             ; The cluster log exceeds its maximum size.
Global Const $ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND = 5032                          ; No checkpoint record was found in the cluster log.
Global Const $ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE = 5033                            ; The minimum required disk space needed for logging is not available.
Global Const $ERROR_QUORUM_OWNER_ALIVE = 5034                                     ; The cluster node failed to take control of the quorum resource because the resource is owned by another active node.
Global Const $ERROR_NETWORK_NOT_AVAILABLE = 5035                                  ; A cluster network is not available for this operation.
Global Const $ERROR_NODE_NOT_AVAILABLE = 5036                                     ; A cluster node is not available for this operation.
Global Const $ERROR_ALL_NODES_NOT_AVAILABLE = 5037                                ; All cluster nodes must be running to perform this operation.
Global Const $ERROR_RESOURCE_FAILED = 5038                                        ; A cluster resource failed.
Global Const $ERROR_CLUSTER_INVALID_NODE = 5039                                   ; The cluster node is not valid.
Global Const $ERROR_CLUSTER_NODE_EXISTS = 5040                                    ; The cluster node already exists.
Global Const $ERROR_CLUSTER_JOIN_IN_PROGRESS = 5041                               ; A node is in the process of joining the cluster.
Global Const $ERROR_CLUSTER_NODE_NOT_FOUND = 5042                                 ; The cluster node was not found.
Global Const $ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND = 5043                           ; The cluster local node information was not found.
Global Const $ERROR_CLUSTER_NETWORK_EXISTS = 5044                                 ; The cluster network already exists.
Global Const $ERROR_CLUSTER_NETWORK_NOT_FOUND = 5045                              ; The cluster network was not found.
Global Const $ERROR_CLUSTER_NETINTERFACE_EXISTS = 5046                            ; The cluster network interface already exists.
Global Const $ERROR_CLUSTER_NETINTERFACE_NOT_FOUND = 5047                         ; The cluster network interface was not found.
Global Const $ERROR_CLUSTER_INVALID_REQUEST = 5048                                ; The cluster request is not valid for this object.
Global Const $ERROR_CLUSTER_INVALID_NETWORK_PROVIDER = 5049                       ; The cluster network provider is not valid.
Global Const $ERROR_CLUSTER_NODE_DOWN = 5050                                      ; The cluster node is down.
Global Const $ERROR_CLUSTER_NODE_UNREACHABLE = 5051                               ; The cluster node is not reachable.
Global Const $ERROR_CLUSTER_NODE_NOT_MEMBER = 5052                                ; The cluster node is not a member of the cluster.
Global Const $ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS = 5053                           ; A cluster join operation is not in progress.
Global Const $ERROR_CLUSTER_INVALID_NETWORK = 5054                                ; The cluster network is not valid.
Global Const $ERROR_CLUSTER_NODE_UP = 5056                                        ; The cluster node is up.
Global Const $ERROR_CLUSTER_IPADDR_IN_USE = 5057                                  ; The cluster IP address is already in use.
Global Const $ERROR_CLUSTER_NODE_NOT_PAUSED = 5058                                ; The cluster node is not paused.
Global Const $ERROR_CLUSTER_NO_SECURITY_CONTEXT = 5059                            ; No cluster security context is available.
Global Const $ERROR_CLUSTER_NETWORK_NOT_INTERNAL = 5060                           ; The cluster network is not configured for internal cluster communication.
Global Const $ERROR_CLUSTER_NODE_ALREADY_UP = 5061                                ; The cluster node is already up.
Global Const $ERROR_CLUSTER_NODE_ALREADY_DOWN = 5062                              ; The cluster node is already down.
Global Const $ERROR_CLUSTER_NETWORK_ALREADY_ONLINE = 5063                         ; The cluster network is already online.
Global Const $ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE = 5064                        ; The cluster network is already offline.
Global Const $ERROR_CLUSTER_NODE_ALREADY_MEMBER = 5065                            ; The cluster node is already a member of the cluster.
Global Const $ERROR_CLUSTER_LAST_INTERNAL_NETWORK = 5066                          ; The cluster network is the only one configured for internal cluster communication between two or more active cluster nodes. The internal communication capability cannot be removed from the network.
Global Const $ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS = 5067                         ; One or more cluster resources depend on the network to provide service to clients. The client access capability cannot be removed from the network.
Global Const $ERROR_INVALID_OPERATION_ON_QUORUM = 5068                            ; This operation cannot be performed on the cluster resource as it the quorum resource. You may not bring the quorum resource offline or modify its possible owners list.
Global Const $ERROR_DEPENDENCY_NOT_ALLOWED = 5069                                 ; The cluster quorum resource is not allowed to have any dependencies.
Global Const $ERROR_CLUSTER_NODE_PAUSED = 5070                                    ; The cluster node is paused.
Global Const $ERROR_NODE_CANT_HOST_RESOURCE = 5071                                ; The cluster resource cannot be brought online. The owner node cannot run this resource.
Global Const $ERROR_CLUSTER_NODE_NOT_READY = 5072                                 ; The cluster node is not ready to perform the requested operation.
Global Const $ERROR_CLUSTER_NODE_SHUTTING_DOWN = 5073                             ; The cluster node is shutting down.
Global Const $ERROR_CLUSTER_JOIN_ABORTED = 5074                                   ; The cluster join operation was aborted.
Global Const $ERROR_CLUSTER_INCOMPATIBLE_VERSIONS = 5075                          ; The cluster join operation failed due to incompatible software versions between the joining node and its sponsor.
Global Const $ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED = 5076                   ; This resource cannot be created because the cluster has reached the limit on the number of resources it can monitor.
Global Const $ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED = 5077                          ; The system configuration changed during the cluster join or form operation. The join or form operation was aborted.
Global Const $ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND = 5078                        ; The specified resource type was not found.
Global Const $ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED = 5079                          ; The specified node does not support a resource of this type. This may be due to version inconsistencies or due to the absence of the resource DLL on this node.
Global Const $ERROR_CLUSTER_RESNAME_NOT_FOUND = 5080                              ; The specified resource name is not supported by this resource DLL. This may be due to a bad (or changed) name supplied to the resource DLL.
Global Const $ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED = 5081                     ; No authentication package could be registered with the RPC server.
Global Const $ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST = 5082                          ; You cannot bring the group online because the owner of the group is not in the preferred list for the group. To change the owner node for the group, move the group.
Global Const $ERROR_CLUSTER_DATABASE_SEQMISMATCH = 5083                           ; The join operation failed because the cluster database sequence number has changed or is incompatible with the locker node. This may happen during a join operation if the cluster database was changing during the join.
Global Const $ERROR_RESMON_INVALID_STATE = 5084                                   ; The resource monitor will not allow the fail operation to be performed while the resource is in its current state. This may happen if the resource is in a pending state.
Global Const $ERROR_CLUSTER_GUM_NOT_LOCKER = 5085                                 ; A non locker code got a request to reserve the lock for making global updates.
Global Const $ERROR_QUORUM_DISK_NOT_FOUND = 5086                                  ; The quorum disk could not be located by the cluster service.
Global Const $ERROR_DATABASE_BACKUP_CORRUPT = 5087                                ; The backed up cluster database is possibly corrupt.
Global Const $ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT = 5088                      ; A DFS root already exists in this cluster node.
Global Const $ERROR_RESOURCE_PROPERTY_UNCHANGEABLE = 5089                         ; An attempt to modify a resource property failed because it conflicts with another existing property.
Global Const $ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE = 5890                       ; An operation was attempted that is incompatible with the current membership state of the node.
Global Const $ERROR_CLUSTER_QUORUMLOG_NOT_FOUND = 5891                            ; The quorum resource does not contain the quorum log.
Global Const $ERROR_CLUSTER_MEMBERSHIP_HALT = 5892                                ; The membership engine requested shutdown of the cluster service on this node.
Global Const $ERROR_CLUSTER_INSTANCE_ID_MISMATCH = 5893                           ; The join operation failed because the cluster instance ID of the joining node does not match the cluster instance ID of the sponsor node.
Global Const $ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP = 5894                       ; A matching cluster network for the specified IP address could not be found.
Global Const $ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH = 5895                    ; The actual data type of the property did not match the expected data type of the property.
Global Const $ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP = 5896                          ; The cluster node was evicted from the cluster successfully, but the node was not cleaned up. To determine what cleanup steps failed and how to recover, see the Failover Clustering application event log using Event Viewer.
Global Const $ERROR_CLUSTER_PARAMETER_MISMATCH = 5897                             ; Two or more parameter values specified for a resource's properties are in conflict.
Global Const $ERROR_NODE_CANNOT_BE_CLUSTERED = 5898                               ; This computer cannot be made a member of a cluster.
Global Const $ERROR_CLUSTER_WRONG_OS_VERSION = 5899                               ; This computer cannot be made a member of a cluster because it does not have the correct version of Windows installed.
Global Const $ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME = 5900                   ; A cluster cannot be created with the specified cluster name because that cluster name is already in use. Specify a different name for the cluster.
Global Const $ERROR_CLUSCFG_ALREADY_COMMITTED = 5901                              ; The cluster configuration action has already been committed.
Global Const $ERROR_CLUSCFG_ROLLBACK_FAILED = 5902                                ; The cluster configuration action could not be rolled back.
Global Const $ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT = 5903              ; The drive letter assigned to a system disk on one node conflicted with the drive letter assigned to a disk on another node.
Global Const $ERROR_CLUSTER_OLD_VERSION = 5904                                    ; One or more nodes in the cluster are running a version of Windows that does not support this operation.
Global Const $ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME = 5905                  ; The name of the corresponding computer account doesn't match the Network Name for this resource.
Global Const $ERROR_CLUSTER_NO_NET_ADAPTERS = 5906                                ; No network adapters are available.
Global Const $ERROR_CLUSTER_POISONED = 5907                                       ; The cluster node has been poisoned.
Global Const $ERROR_CLUSTER_GROUP_MOVING = 5908                                   ; The group is unable to accept the request since it is moving to another node.
Global Const $ERROR_CLUSTER_RESOURCE_TYPE_BUSY = 5909                             ; The resource type cannot accept the request since is too busy performing another operation.
Global Const $ERROR_RESOURCE_CALL_TIMED_OUT = 5910                                ; The call to the cluster resource DLL timed out.
Global Const $ERROR_INVALID_CLUSTER_IPV6_ADDRESS = 5911                           ; The address is not valid for an IPv6 Address resource. A global IPv6 address is required, and it must match a cluster network. Compatibility addresses are not permitted.
Global Const $ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION = 5912                      ; An internal cluster error occurred. A call to an invalid function was attempted.
Global Const $ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS = 5913                        ; A parameter value is out of acceptable range.
Global Const $ERROR_CLUSTER_PARTIAL_SEND = 5914                                   ; A network error occurred while sending data to another node in the cluster. The number of bytes transmitted was less than required.
Global Const $ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION = 5915                      ; An invalid cluster registry operation was attempted.
Global Const $ERROR_CLUSTER_INVALID_STRING_TERMINATION = 5916                     ; An input string of characters is not properly terminated.
Global Const $ERROR_CLUSTER_INVALID_STRING_FORMAT = 5917                          ; An input string of characters is not in a valid format for the data it represents.
Global Const $ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS = 5918               ; An internal cluster error occurred. A cluster database transaction was attempted while a transaction was already in progress.
Global Const $ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS = 5919           ; An internal cluster error occurred. There was an attempt to commit a cluster database transaction while no transaction was in progress.
Global Const $ERROR_CLUSTER_NULL_DATA = 5920                                      ; An internal cluster error occurred. Data was not properly initialized.
Global Const $ERROR_CLUSTER_PARTIAL_READ = 5921                                   ; An error occurred while reading from a stream of data. An unexpected number of bytes was returned.
Global Const $ERROR_CLUSTER_PARTIAL_WRITE = 5922                                  ; An error occurred while writing to a stream of data. The required number of bytes could not be written.
Global Const $ERROR_CLUSTER_CANT_DESERIALIZE_DATA = 5923                          ; An error occurred while deserializing a stream of cluster data.
Global Const $ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT = 5924                   ; One or more property values for this resource are in conflict with one or more property values associated with its dependent resource(s).
Global Const $ERROR_CLUSTER_NO_QUORUM = 5925                                      ; An quorum of cluster nodes was not present to form a cluster.
Global Const $ERROR_CLUSTER_INVALID_IPV6_NETWORK = 5926                           ; The cluster network is not valid for an IPv6 Address resource, or it does not match the configured address.
Global Const $ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK = 5927                    ; The cluster network is not valid for an IPv6 Tunnel resource. Check the configuration of the IP Address resource on which the IPv6 Tunnel resource depends.
Global Const $ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP = 5928                       ; Quorum resource cannot reside in the Available Storage group.
Global Const $ERROR_DEPENDENCY_TREE_TOO_COMPLEX = 5929                            ; The dependencies for this resource are nested too deeply.
Global Const $ERROR_EXCEPTION_IN_RESOURCE_CALL = 5930                             ; The call into the resource DLL raised an unhandled exception.
Global Const $ERROR_CLUSTER_RHS_FAILED_INITIALIZATION = 5931                      ; The RHS process failed to initialize.
Global Const $ERROR_CLUSTER_NOT_INSTALLED = 5932                                  ; The Failover Clustering feature is not installed on this node.
Global Const $ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE = 5933      ; The resources must be online on the same node for this operation.
Global Const $ERROR_CLUSTER_MAX_NODES_IN_CLUSTER = 5934                           ; A new node cannot be added since this cluster is already at its maximum number of nodes.
Global Const $ERROR_CLUSTER_TOO_MANY_NODES = 5935                                 ; This cluster cannot be created since the specified number of nodes exceeds the maximum allowed limit.
Global Const $ERROR_CLUSTER_OBJECT_ALREADY_USED = 5936                            ; An attempt to use the specified cluster name failed because an enabled computer object with the given name already exists in the domain.
Global Const $ERROR_NONCORE_GROUPS_FOUND = 5937                                   ; This cluster cannot be destroyed. It has non-core application groups which must be deleted before the cluster can be destroyed.
Global Const $ERROR_FILE_SHARE_RESOURCE_CONFLICT = 5938                           ; File share associated with file share witness resource cannot be hosted by this cluster or any of its nodes.
Global Const $ERROR_CLUSTER_EVICT_INVALID_REQUEST = 5939                          ; Eviction of this node is invalid at this time. Due to quorum requirements node eviction will result in cluster shutdown. If it is the last node in the cluster, destroy cluster command should be used.
Global Const $ERROR_CLUSTER_SINGLETON_RESOURCE = 5940                             ; Only one instance of this resource type is allowed in the cluster.
Global Const $ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE = 5941                       ; Only one instance of this resource type is allowed per resource group.
Global Const $ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED = 5942                       ; The resource failed to come online due to the failure of one or more provider resources.
Global Const $ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR = 5943                   ; The resource has indicated that it cannot come online on any node.
Global Const $ERROR_CLUSTER_GROUP_BUSY = 5944                                     ; The current operation cannot be performed on this group at this time.
Global Const $ERROR_CLUSTER_NOT_SHARED_VOLUME = 5945                              ; The directory or file is not located on a cluster shared volume.
Global Const $ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR = 5946                    ; The Security Descriptor must explicitly grant full control to the Builtin Administrators group.
Global Const $ERROR_CLUSTER_SHARED_VOLUMES_IN_USE = 5947                          ; There is one or more shared volumes resources configured in the cluster. Those resources needs to be moved to available storage in order for operation to succeed.
Global Const $ERROR_CLUSTER_USE_SHARED_VOLUMES_API = 5948                         ; This group or resource cannot be directly manipulated. Use shared volume APIs to perform desired operation.
Global Const $ERROR_CLUSTER_BACKUP_IN_PROGRESS = 5949                             ; Back up is in progress. Please wait for backup completion before trying this operation again.
Global Const $ERROR_ENCRYPTION_FAILED = 6000                                      ; The specified file could not be encrypted.
Global Const $ERROR_DECRYPTION_FAILED = 6001                                      ; The specified file could not be decrypted.
Global Const $ERROR_FILE_ENCRYPTED = 6002                                         ; The specified file is encrypted and the user does not have the ability to decrypt it.
Global Const $ERROR_NO_RECOVERY_POLICY = 6003                                     ; There is no valid encryption recovery policy configured for this system.
Global Const $ERROR_NO_EFS = 6004                                                 ; The required encryption driver is not loaded for this system.
Global Const $ERROR_WRONG_EFS = 6005                                              ; The file was encrypted with a different encryption driver than is currently loaded.
Global Const $ERROR_NO_USER_KEYS = 6006                                           ; There are no EFS keys defined for the user.
Global Const $ERROR_FILE_NOT_ENCRYPTED = 6007                                     ; The specified file is not encrypted.
Global Const $ERROR_NOT_EXPORT_FORMAT = 6008                                      ; The specified file is not in the defined EFS export format.
Global Const $ERROR_FILE_READ_ONLY = 6009                                         ; The specified file is read only.
Global Const $ERROR_DIR_EFS_DISALLOWED = 6010                                     ; The directory has been disabled for encryption.
Global Const $ERROR_EFS_SERVER_NOT_TRUSTED = 6011                                 ; The server is not trusted for remote encryption operation.
Global Const $ERROR_BAD_RECOVERY_POLICY = 6012                                    ; Recovery policy configured for this system contains invalid recovery certificate.
Global Const $ERROR_EFS_ALG_BLOB_TOO_BIG = 6013                                   ; The encryption algorithm used on the source file needs a bigger key buffer than the one on the destination file.
Global Const $ERROR_VOLUME_NOT_SUPPORT_EFS = 6014                                 ; The disk partition does not support file encryption.
Global Const $ERROR_EFS_DISABLED = 6015                                           ; This machine is disabled for file encryption.
Global Const $ERROR_EFS_VERSION_NOT_SUPPORT = 6016                                ; A newer system is required to decrypt this encrypted file.
Global Const $ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = 6017                  ; The remote server sent an invalid response for a file being opened with Client Side Encryption.
Global Const $ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER = 6018                       ; Client Side Encryption is not supported by the remote server even though it claims to support it.
Global Const $ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = 6019                  ; File is encrypted and should be opened in Client Side Encryption mode.
Global Const $ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = 6020                       ; A new encrypted file is being created and a $EFS needs to be provided.
Global Const $ERROR_CS_ENCRYPTION_FILE_NOT_CSE = 6021                             ; The SMB client requested a CSE FSCTL on a non-CSE file.
Global Const $ERROR_ENCRYPTION_POLICY_DENIES_OPERATION = 6022                     ; The requested operation was blocked by policy. For more information, contact your system administrator.
Global Const $ERROR_NO_BROWSER_SERVERS_FOUND = 6118                               ; The list of servers for this workgroup is not currently available.
Global Const $SCHED_E_SERVICE_NOT_LOCALSYSTEM = 6200                              ; The Task Scheduler service must be configured to run in the System account to function properly. Individual tasks may be configured to run in other accounts.
Global Const $ERROR_LOG_SECTOR_INVALID = 6600                                     ; Log service encountered an invalid log sector.
Global Const $ERROR_LOG_SECTOR_PARITY_INVALID = 6601                              ; Log service encountered a log sector with invalid block parity.
Global Const $ERROR_LOG_SECTOR_REMAPPED = 6602                                    ; Log service encountered a remapped log sector.
Global Const $ERROR_LOG_BLOCK_INCOMPLETE = 6603                                   ; Log service encountered a partial or incomplete log block.
Global Const $ERROR_LOG_INVALID_RANGE = 6604                                      ; Log service encountered an attempt access data outside the active log range.
Global Const $ERROR_LOG_BLOCKS_EXHAUSTED = 6605                                   ; Log service user marshalling buffers are exhausted.
Global Const $ERROR_LOG_READ_CONTEXT_INVALID = 6606                               ; Log service encountered an attempt read from a marshalling area with an invalid read context.
Global Const $ERROR_LOG_RESTART_INVALID = 6607                                    ; Log service encountered an invalid log restart area.
Global Const $ERROR_LOG_BLOCK_VERSION = 6608                                      ; Log service encountered an invalid log block version.
Global Const $ERROR_LOG_BLOCK_INVALID = 6609                                      ; Log service encountered an invalid log block.
Global Const $ERROR_LOG_READ_MODE_INVALID = 6610                                  ; Log service encountered an attempt to read the log with an invalid read mode.
Global Const $ERROR_LOG_NO_RESTART = 6611                                         ; Log service encountered a log stream with no restart area.
Global Const $ERROR_LOG_METADATA_CORRUPT = 6612                                   ; Log service encountered a corrupted metadata file.
Global Const $ERROR_LOG_METADATA_INVALID = 6613                                   ; Log service encountered a metadata file that could not be created by the log file system.
Global Const $ERROR_LOG_METADATA_INCONSISTENT = 6614                              ; Log service encountered a metadata file with inconsistent data.
Global Const $ERROR_LOG_RESERVATION_INVALID = 6615                                ; Log service encountered an attempt to erroneous allocate or dispose reservation space.
Global Const $ERROR_LOG_CANT_DELETE = 6616                                        ; Log service cannot delete log file or file system container.
Global Const $ERROR_LOG_CONTAINER_LIMIT_EXCEEDED = 6617                           ; Log service has reached the maximum allowable containers allocated to a log file.
Global Const $ERROR_LOG_START_OF_LOG = 6618                                       ; Log service has attempted to read or write backward past the start of the log.
Global Const $ERROR_LOG_POLICY_ALREADY_INSTALLED = 6619                           ; Log policy could not be installed because a policy of the same type is already present.
Global Const $ERROR_LOG_POLICY_NOT_INSTALLED = 6620                               ; Log policy in question was not installed at the time of the request.
Global Const $ERROR_LOG_POLICY_INVALID = 6621                                     ; The installed set of policies on the log is invalid.
Global Const $ERROR_LOG_POLICY_CONFLICT = 6622                                    ; A policy on the log in question prevented the operation from completing.
Global Const $ERROR_LOG_PINNED_ARCHIVE_TAIL = 6623                                ; Log space cannot be reclaimed because the log is pinned by the archive tail.
Global Const $ERROR_LOG_RECORD_NONEXISTENT = 6624                                 ; Log record is not a record in the log file.
Global Const $ERROR_LOG_RECORDS_RESERVED_INVALID = 6625                           ; The number of reserved log records or the adjustment of the number of reserved log records is invalid.
Global Const $ERROR_LOG_SPACE_RESERVED_INVALID = 6626                             ; Reserved log space or the adjustment of the log space is invalid.
Global Const $ERROR_LOG_TAIL_INVALID = 6627                                       ; An new or existing archive tail or base of the active log is invalid.
Global Const $ERROR_LOG_FULL = 6628                                               ; Log space is exhausted.
Global Const $ERROR_COULD_NOT_RESIZE_LOG = 6629                                   ; The log could not be set to the requested size.
Global Const $ERROR_LOG_MULTIPLEXED = 6630                                        ; Log is multiplexed, no direct writes to the physical log is allowed.
Global Const $ERROR_LOG_DEDICATED = 6631                                          ; The operation failed because the log is a dedicated log.
Global Const $ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS = 6632                            ; The operation requires an archive context.
Global Const $ERROR_LOG_ARCHIVE_IN_PROGRESS = 6633                                ; Log archival is in progress.
Global Const $ERROR_LOG_EPHEMERAL = 6634                                          ; The operation requires a non-ephemeral log, but the log is ephemeral.
Global Const $ERROR_LOG_NOT_ENOUGH_CONTAINERS = 6635                              ; The log must have at least two containers before it can be read from or written to.
Global Const $ERROR_LOG_CLIENT_ALREADY_REGISTERED = 6636                          ; A log client has already registered on the stream.
Global Const $ERROR_LOG_CLIENT_NOT_REGISTERED = 6637                              ; A log client has not been registered on the stream.
Global Const $ERROR_LOG_FULL_HANDLER_IN_PROGRESS = 6638                           ; A request has already been made to handle the log full condition.
Global Const $ERROR_LOG_CONTAINER_READ_FAILED = 6639                              ; Log service encountered an error when attempting to read from a log container.
Global Const $ERROR_LOG_CONTAINER_WRITE_FAILED = 6640                             ; Log service encountered an error when attempting to write to a log container.
Global Const $ERROR_LOG_CONTAINER_OPEN_FAILED = 6641                              ; Log service encountered an error when attempting open a log container.
Global Const $ERROR_LOG_CONTAINER_STATE_INVALID = 6642                            ; Log service encountered an invalid container state when attempting a requested action.
Global Const $ERROR_LOG_STATE_INVALID = 6643                                      ; Log service is not in the correct state to perform a requested action.
Global Const $ERROR_LOG_PINNED = 6644                                             ; Log space cannot be reclaimed because the log is pinned.
Global Const $ERROR_LOG_METADATA_FLUSH_FAILED = 6645                              ; Log metadata flush failed.
Global Const $ERROR_LOG_INCONSISTENT_SECURITY = 6646                              ; Security on the log and its containers is inconsistent.
Global Const $ERROR_LOG_APPENDED_FLUSH_FAILED = 6647                              ; Records were appended to the log or reservation changes were made, but the log could not be flushed.
Global Const $ERROR_LOG_PINNED_RESERVATION = 6648                                 ; The log is pinned due to reservation consuming most of the log space. Free some reserved records to make space available.
Global Const $ERROR_INVALID_TRANSACTION = 6700                                    ; The transaction handle associated with this operation is not valid.
Global Const $ERROR_TRANSACTION_NOT_ACTIVE = 6701                                 ; The requested operation was made in the context of a transaction that is no longer active.
Global Const $ERROR_TRANSACTION_REQUEST_NOT_VALID = 6702                          ; The requested operation is not valid on the Transaction object in its current state.
Global Const $ERROR_TRANSACTION_NOT_REQUESTED = 6703                              ; The caller has called a response API, but the response is not expected because the TM did not issue the corresponding request to the caller.
Global Const $ERROR_TRANSACTION_ALREADY_ABORTED = 6704                            ; It is too late to perform the requested operation, since the Transaction has already been aborted.
Global Const $ERROR_TRANSACTION_ALREADY_COMMITTED = 6705                          ; It is too late to perform the requested operation, since the Transaction has already been committed.
Global Const $ERROR_TM_INITIALIZATION_FAILED = 6706                               ; The Transaction Manager was unable to be successfully initialized. Transacted operations are not supported.
Global Const $ERROR_RESOURCEMANAGER_READ_ONLY = 6707                              ; The specified ResourceManager made no changes or updates to the resource under this transaction.
Global Const $ERROR_TRANSACTION_NOT_JOINED = 6708                                 ; The resource manager has attempted to prepare a transaction that it has not successfully joined.
Global Const $ERROR_TRANSACTION_SUPERIOR_EXISTS = 6709                            ; The Transaction object already has a superior enlistment, and the caller attempted an operation that would have created a new superior. Only a single superior enlistment is allow.
Global Const $ERROR_CRM_PROTOCOL_ALREADY_EXISTS = 6710                            ; The RM tried to register a protocol that already exists.
Global Const $ERROR_TRANSACTION_PROPAGATION_FAILED = 6711                         ; The attempt to propagate the Transaction failed.
Global Const $ERROR_CRM_PROTOCOL_NOT_FOUND = 6712                                 ; The requested propagation protocol was not registered as a CRM.
Global Const $ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER = 6713                    ; The buffer passed in to PushTransaction or PullTransaction is not in a valid format.
Global Const $ERROR_CURRENT_TRANSACTION_NOT_VALID = 6714                          ; The current transaction context associated with the thread is not a valid handle to a transaction object.
Global Const $ERROR_TRANSACTION_NOT_FOUND = 6715                                  ; The specified Transaction object could not be opened, because it was not found.
Global Const $ERROR_RESOURCEMANAGER_NOT_FOUND = 6716                              ; The specified ResourceManager object could not be opened, because it was not found.
Global Const $ERROR_ENLISTMENT_NOT_FOUND = 6717                                   ; The specified Enlistment object could not be opened, because it was not found.
Global Const $ERROR_TRANSACTIONMANAGER_NOT_FOUND = 6718                           ; The specified TransactionManager object could not be opened, because it was not found. The TransactionManager must be brought fully Online by calling RecoverTransactionManager to recover to the end of its LogFile before objects in its Transaction or ResourceManager namespaces can be opened. In addition, errors in writing records to its LogFile can cause a TransactionManager to go offline.
Global Const $ERROR_TRANSACTIONMANAGER_NOT_ONLINE = 6719                          ; The object specified could not be created or opened, because its associated TransactionManager is not online.
Global Const $ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = 6720             ; The specified TransactionManager was unable to create the objects contained in its logfile in the Ob namespace. Therefore, the TransactionManager was unable to recover.
Global Const $ERROR_TRANSACTION_NOT_ROOT = 6721                                   ; The call to create a superior Enlistment on this Transaction object could not be completed, because the Transaction object specified for the enlistment is a subordinate branch of the Transaction. Only the root of the Transaction can be enlisted on as a superior.
Global Const $ERROR_TRANSACTION_OBJECT_EXPIRED = 6722                             ; Because the associated transaction manager or resource manager has been closed, the handle is no longer valid.
Global Const $ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED = 6723                      ; The specified operation could not be performed on this Superior enlistment, because the enlistment was not created with the corresponding completion response in the NotificationMask.
Global Const $ERROR_TRANSACTION_RECORD_TOO_LONG = 6724                            ; The specified operation could not be performed, because the record that would be logged was too long. This can occur because of two conditions: either there are too many Enlistments on this Transaction, or the combined RecoveryInformation being logged on behalf of those Enlistments is too long.
Global Const $ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED = 6725                     ; Implicit transactions are not supported.
Global Const $ERROR_TRANSACTION_INTEGRITY_VIOLATED = 6726                         ; The kernel transaction manager had to abort or forget the transaction because it blocked forward progress.
Global Const $ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH = 6727                   ; The TransactionManager identity that was supplied did not match the one recorded in the TransactionManager's log file.
Global Const $ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT = 6728                       ; This snapshot operation cannot continue because a transactional resource manager cannot be frozen in its current state. Please try again.
Global Const $ERROR_TRANSACTION_MUST_WRITETHROUGH = 6729                          ; The transaction cannot be enlisted on with the specified EnlistmentMask, because the transaction has already completed the PrePrepare phase. In order to ensure correctness, the ResourceManager must switch to a write-through mode and cease caching data within this transaction. Enlisting for only subsequent transaction phases may still succeed.
Global Const $ERROR_TRANSACTION_NO_SUPERIOR = 6730                                ; The transaction does not have a superior enlistment.
Global Const $ERROR_TRANSACTIONAL_CONFLICT = 6800                                 ; The function attempted to use a name that is reserved for use by another transaction.
Global Const $ERROR_RM_NOT_ACTIVE = 6801                                          ; Transaction support within the specified resource manager is not started or was shut down due to an error.
Global Const $ERROR_RM_METADATA_CORRUPT = 6802                                    ; The metadata of the RM has been corrupted. The RM will not function.
Global Const $ERROR_DIRECTORY_NOT_RM = 6803                                       ; The specified directory does not contain a resource manager.
Global Const $ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE = 6805                        ; The remote server or share does not support transacted file operations.
Global Const $ERROR_LOG_RESIZE_INVALID_SIZE = 6806                                ; The requested log size is invalid.
Global Const $ERROR_OBJECT_NO_LONGER_EXISTS = 6807                                ; The object (file, stream, link) corresponding to the handle has been deleted by a Transaction Savepoint Rollback.
Global Const $ERROR_STREAM_MINIVERSION_NOT_FOUND = 6808                           ; The specified file miniversion was not found for this transacted file open.
Global Const $ERROR_STREAM_MINIVERSION_NOT_VALID = 6809                           ; The specified file miniversion was found but has been invalidated. Most likely cause is a transaction savepoint rollback.
Global Const $ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = 6810    ; A miniversion may only be opened in the context of the transaction that created it.
Global Const $ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = 6811               ; It is not possible to open a miniversion with modify access.
Global Const $ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS = 6812                   ; It is not possible to create any more miniversions for this stream.
Global Const $ERROR_REMOTE_FILE_VERSION_MISMATCH = 6814                           ; The remote server sent mismatching version number or Fid for a file opened with transactions.
Global Const $ERROR_HANDLE_NO_LONGER_VALID = 6815                                 ; The handle has been invalidated by a transaction. The most likely cause is the presence of memory mapping on a file or an open handle when the transaction ended or rolled back to savepoint.
Global Const $ERROR_NO_TXF_METADATA = 6816                                        ; There is no transaction metadata on the file.
Global Const $ERROR_LOG_CORRUPTION_DETECTED = 6817                                ; The log data is corrupt.
Global Const $ERROR_CANT_RECOVER_WITH_HANDLE_OPEN = 6818                          ; The file can't be recovered because there is a handle still open on it.
Global Const $ERROR_RM_DISCONNECTED = 6819                                        ; The transaction outcome is unavailable because the resource manager responsible for it has disconnected.
Global Const $ERROR_ENLISTMENT_NOT_SUPERIOR = 6820                                ; The request was rejected because the enlistment in question is not a superior enlistment.
Global Const $ERROR_RECOVERY_NOT_NEEDED = 6821                                    ; The transactional resource manager is already consistent. Recovery is not needed.
Global Const $ERROR_RM_ALREADY_STARTED = 6822                                     ; The transactional resource manager has already been started.
Global Const $ERROR_FILE_IDENTITY_NOT_PERSISTENT = 6823                           ; The file cannot be opened transactionally, because its identity depends on the outcome of an unresolved transaction.
Global Const $ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = 6824                    ; The operation cannot be performed because another transaction is depending on the fact that this property will not change.
Global Const $ERROR_CANT_CROSS_RM_BOUNDARY = 6825                                 ; The operation would involve a single file with two transactional resource managers and is therefore not allowed.
Global Const $ERROR_TXF_DIR_NOT_EMPTY = 6826                                      ; The $Txf directory must be empty for this operation to succeed.
Global Const $ERROR_INDOUBT_TRANSACTIONS_EXIST = 6827                             ; The operation would leave a transactional resource manager in an inconsistent state and is therefore not allowed.
Global Const $ERROR_TM_VOLATILE = 6828                                            ; The operation could not be completed because the transaction manager does not have a log.
Global Const $ERROR_ROLLBACK_TIMER_EXPIRED = 6829                                 ; A rollback could not be scheduled because a previously scheduled rollback has already executed or been queued for execution.
Global Const $ERROR_TXF_ATTRIBUTE_CORRUPT = 6830                                  ; The transactional metadata attribute on the file or directory is corrupt and unreadable.
Global Const $ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION = 6831                         ; The encryption operation could not be completed because a transaction is active.
Global Const $ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED = 6832                         ; This object is not allowed to be opened in a transaction.
Global Const $ERROR_LOG_GROWTH_FAILED = 6833                                      ; An attempt to create space in the transactional resource manager's log failed. The failure status has been recorded in the event log.
Global Const $ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = 6834                  ; Memory mapping (creating a mapped section) a remote file under a transaction is not supported.
Global Const $ERROR_TXF_METADATA_ALREADY_PRESENT = 6835                           ; Transaction metadata is already present on this file and cannot be superseded.
Global Const $ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET = 6836                    ; A transaction scope could not be entered because the scope handler has not been initialized.
Global Const $ERROR_TRANSACTION_REQUIRED_PROMOTION = 6837                         ; Promotion was required in order to allow the resource manager to enlist, but the transaction was set to disallow it.
Global Const $ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION = 6838                     ; This file is open for modification in an unresolved transaction and may be opened for execute only by a transacted reader.
Global Const $ERROR_TRANSACTIONS_NOT_FROZEN = 6839                                ; The request to thaw frozen transactions was ignored because transactions had not previously been frozen.
Global Const $ERROR_TRANSACTION_FREEZE_IN_PROGRESS = 6840                         ; Transactions cannot be frozen because a freeze is already in progress.
Global Const $ERROR_NOT_SNAPSHOT_VOLUME = 6841                                    ; The target volume is not a snapshot volume. This operation is only valid on a volume mounted as a snapshot.
Global Const $ERROR_NO_SAVEPOINT_WITH_OPEN_FILES = 6842                           ; The savepoint operation failed because files are open on the transaction. This is not permitted.
Global Const $ERROR_DATA_LOST_REPAIR = 6843                                       ; Windows has discovered corruption in a file, and that file has since been repaired. Data loss may have occurred.
Global Const $ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION = 6844                      ; The sparse operation could not be completed because a transaction is active on the file.
Global Const $ERROR_TM_IDENTITY_MISMATCH = 6845                                   ; The call to create a TransactionManager object failed because the Tm Identity stored in the logfile does not match the Tm Identity that was passed in as an argument.
Global Const $ERROR_FLOATED_SECTION = 6846                                        ; I/O was attempted on a section object that has been floated as a result of a transaction ending. There is no valid data.
Global Const $ERROR_CANNOT_ACCEPT_TRANSACTED_WORK = 6847                          ; The transactional resource manager cannot currently accept transacted work due to a transient condition such as low resources.
Global Const $ERROR_CANNOT_ABORT_TRANSACTIONS = 6848                              ; The transactional resource manager had too many transactions outstanding that could not be aborted. The transactional resource manager has been shut down.
Global Const $ERROR_BAD_CLUSTERS = 6849                                           ; The operation could not be completed due to bad clusters on disk.
Global Const $ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = 6850                 ; The compression operation could not be completed because a transaction is active on the file.
Global Const $ERROR_VOLUME_DIRTY = 6851                                           ; The operation could not be completed because the volume is dirty. Please run chkdsk and try again.
Global Const $ERROR_NO_LINK_TRACKING_IN_TRANSACTION = 6852                        ; The link tracking operation could not be completed because a transaction is active.
Global Const $ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = 6853                 ; This operation cannot be performed in a transaction.
Global Const $ERROR_EXPIRED_HANDLE = 6854                                         ; The handle is no longer properly associated with its transaction. It may have been opened in a transactional resource manager that was subsequently forced to restart. Please close the handle and open a new one.
Global Const $ERROR_TRANSACTION_NOT_ENLISTED = 6855                               ; The specified operation could not be performed because the resource manager is not enlisted in the transaction.
Global Const $ERROR_CTX_WINSTATION_NAME_INVALID = 7001                            ; The specified session name is invalid.
Global Const $ERROR_CTX_INVALID_PD = 7002                                         ; The specified protocol driver is invalid.
Global Const $ERROR_CTX_PD_NOT_FOUND = 7003                                       ; The specified protocol driver was not found in the system path.
Global Const $ERROR_CTX_WD_NOT_FOUND = 7004                                       ; The specified terminal connection driver was not found in the system path.
Global Const $ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY = 7005                         ; A registry key for event logging could not be created for this session.
Global Const $ERROR_CTX_SERVICE_NAME_COLLISION = 7006                             ; A service with the same name already exists on the system.
Global Const $ERROR_CTX_CLOSE_PENDING = 7007                                      ; A close operation is pending on the session.
Global Const $ERROR_CTX_NO_OUTBUF = 7008                                          ; There are no free output buffers available.
Global Const $ERROR_CTX_MODEM_INF_NOT_FOUND = 7009                                ; The MODEM.INF file was not found.
Global Const $ERROR_CTX_INVALID_MODEMNAME = 7010                                  ; The modem name was not found in MODEM.INF.
Global Const $ERROR_CTX_MODEM_RESPONSE_ERROR = 7011                               ; The modem did not accept the command sent to it. Verify that the configured modem name matches the attached modem.
Global Const $ERROR_CTX_MODEM_RESPONSE_TIMEOUT = 7012                             ; The modem did not respond to the command sent to it. Verify that the modem is properly cabled and powered on.
Global Const $ERROR_CTX_MODEM_RESPONSE_NO_CARRIER = 7013                          ; Carrier detect has failed or carrier has been dropped due to disconnect.
Global Const $ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE = 7014                         ; Dial tone not detected within the required time. Verify that the phone cable is properly attached and functional.
Global Const $ERROR_CTX_MODEM_RESPONSE_BUSY = 7015                                ; Busy signal detected at remote site on callback.
Global Const $ERROR_CTX_MODEM_RESPONSE_VOICE = 7016                               ; Voice detected at remote site on callback.
Global Const $ERROR_CTX_TD_ERROR = 7017                                           ; Transport driver error.
Global Const $ERROR_CTX_WINSTATION_NOT_FOUND = 7022                               ; The specified session cannot be found.
Global Const $ERROR_CTX_WINSTATION_ALREADY_EXISTS = 7023                          ; The specified session name is already in use.
Global Const $ERROR_CTX_WINSTATION_BUSY = 7024                                    ; The requested operation cannot be completed because the terminal connection is currently busy processing a connect, disconnect, reset, or delete operation.
Global Const $ERROR_CTX_BAD_VIDEO_MODE = 7025                                     ; An attempt has been made to connect to a session whose video mode is not supported by the current client.
Global Const $ERROR_CTX_GRAPHICS_INVALID = 7035                                   ; The application attempted to enable DOS graphics mode. DOS graphics mode is not supported.
Global Const $ERROR_CTX_LOGON_DISABLED = 7037                                     ; Your interactive logon privilege has been disabled. Please contact your administrator.
Global Const $ERROR_CTX_NOT_CONSOLE = 7038                                        ; The requested operation can be performed only on the system console. This is most often the result of a driver or system DLL requiring direct console access.
Global Const $ERROR_CTX_CLIENT_QUERY_TIMEOUT = 7040                               ; The client failed to respond to the server connect message.
Global Const $ERROR_CTX_CONSOLE_DISCONNECT = 7041                                 ; Disconnecting the console session is not supported.
Global Const $ERROR_CTX_CONSOLE_CONNECT = 7042                                    ; Reconnecting a disconnected session to the console is not supported.
Global Const $ERROR_CTX_SHADOW_DENIED = 7044                                      ; The request to control another session remotely was denied.
Global Const $ERROR_CTX_WINSTATION_ACCESS_DENIED = 7045                           ; The requested session access is denied.
Global Const $ERROR_CTX_INVALID_WD = 7049                                         ; The specified terminal connection driver is invalid.
Global Const $ERROR_CTX_SHADOW_INVALID = 7050                                     ; The requested session cannot be controlled remotely. This may be because the session is disconnected or does not currently have a user logged on.
Global Const $ERROR_CTX_SHADOW_DISABLED = 7051                                    ; The requested session is not configured to allow remote control.
Global Const $ERROR_CTX_CLIENT_LICENSE_IN_USE = 7052                              ; Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number is currently being used by another user. Please call your system administrator to obtain a unique license number.
Global Const $ERROR_CTX_CLIENT_LICENSE_NOT_SET = 7053                             ; Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number has not been entered for this copy of the Terminal Server client. Please contact your system administrator.
Global Const $ERROR_CTX_LICENSE_NOT_AVAILABLE = 7054                              ; The number of connections to this computer is limited and all connections are in use right now. Try connecting later or contact your system administrator.
Global Const $ERROR_CTX_LICENSE_CLIENT_INVALID = 7055                             ; The client you are using is not licensed to use this system. Your logon request is denied.
Global Const $ERROR_CTX_LICENSE_EXPIRED = 7056                                    ; The system license has expired. Your logon request is denied.
Global Const $ERROR_CTX_SHADOW_NOT_RUNNING = 7057                                 ; Remote control could not be terminated because the specified session is not currently being remotely controlled.
Global Const $ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE = 7058                        ; The remote control of the console was terminated because the display mode was changed. Changing the display mode in a remote control session is not supported.
Global Const $ERROR_ACTIVATION_COUNT_EXCEEDED = 7059                              ; Activation has already been reset the maximum number of times for this installation. Your activation timer will not be cleared.
Global Const $ERROR_CTX_WINSTATIONS_DISABLED = 7060                               ; Remote logins are currently disabled.
Global Const $ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED = 7061                          ; You do not have the proper encryption level to access this Session.
Global Const $ERROR_CTX_SESSION_IN_USE = 7062                                     ; The user %s\\%s is currently logged on to this computer. Only the current user or an administrator can log on to this computer.
Global Const $ERROR_CTX_NO_FORCE_LOGOFF = 7063                                    ; The user %s\\%s is already logged on to the console of this computer. You do not have permission to log in at this time. To resolve this issue, contact %s\\%s and have them log off.
Global Const $ERROR_CTX_ACCOUNT_RESTRICTION = 7064                                ; Unable to log you on because of an account restriction.
Global Const $ERROR_RDP_PROTOCOL_ERROR = 7065                                     ; The RDP protocol component %2 detected an error in the protocol stream and has disconnected the client.
Global Const $ERROR_CTX_CDM_CONNECT = 7066                                        ; The Client Drive Mapping Service Has Connected on Terminal Connection.
Global Const $ERROR_CTX_CDM_DISCONNECT = 7067                                     ; The Client Drive Mapping Service Has Disconnected on Terminal Connection.
Global Const $ERROR_CTX_SECURITY_LAYER_ERROR = 7068                               ; The Terminal Server security layer detected an error in the protocol stream and has disconnected the client.
Global Const $ERROR_TS_INCOMPATIBLE_SESSIONS = 7069                               ; The target session is incompatible with the current session.
Global Const $FRS_ERR_INVALID_API_SEQUENCE = 8001                                 ; The file replication service API was called incorrectly.
Global Const $FRS_ERR_STARTING_SERVICE = 8002                                     ; The file replication service cannot be started.
Global Const $FRS_ERR_STOPPING_SERVICE = 8003                                     ; The file replication service cannot be stopped.
Global Const $FRS_ERR_INTERNAL_API = 8004                                         ; The file replication service API terminated the request. The event log may have more information.
Global Const $FRS_ERR_INTERNAL = 8005                                             ; The file replication service terminated the request. The event log may have more information.
Global Const $FRS_ERR_SERVICE_COMM = 8006                                         ; The file replication service cannot be contacted. The event log may have more information.
Global Const $FRS_ERR_INSUFFICIENT_PRIV = 8007                                    ; The file replication service cannot satisfy the request because the user has insufficient privileges. The event log may have more information.
Global Const $FRS_ERR_AUTHENTICATION = 8008                                       ; The file replication service cannot satisfy the request because authenticated RPC is not available. The event log may have more information.
Global Const $FRS_ERR_PARENT_INSUFFICIENT_PRIV = 8009                             ; The file replication service cannot satisfy the request because the user has insufficient privileges on the domain controller. The event log may have more information.
Global Const $FRS_ERR_PARENT_AUTHENTICATION = 8010                                ; The file replication service cannot satisfy the request because authenticated RPC is not available on the domain controller. The event log may have more information.
Global Const $FRS_ERR_CHILD_TO_PARENT_COMM = 8011                                 ; The file replication service cannot communicate with the file replication service on the domain controller. The event log may have more information.
Global Const $FRS_ERR_PARENT_TO_CHILD_COMM = 8012                                 ; The file replication service on the domain controller cannot communicate with the file replication service on this computer. The event log may have more information.
Global Const $FRS_ERR_SYSVOL_POPULATE = 8013                                      ; The file replication service cannot populate the system volume because of an internal error. The event log may have more information.
Global Const $FRS_ERR_SYSVOL_POPULATE_TIMEOUT = 8014                              ; The file replication service cannot populate the system volume because of an internal timeout. The event log may have more information.
Global Const $FRS_ERR_SYSVOL_IS_BUSY = 8015                                       ; The file replication service cannot process the request. The system volume is busy with a previous request.
Global Const $FRS_ERR_SYSVOL_DEMOTE = 8016                                        ; The file replication service cannot stop replicating the system volume because of an internal error. The event log may have more information.
Global Const $FRS_ERR_INVALID_SERVICE_PARAMETER = 8017                            ; The file replication service detected an invalid parameter.
Global Const $ERROR_DS_NOT_INSTALLED = 8200                                       ; An error occurred while installing the directory service. For more information, see the event log.
Global Const $ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY = 8201                        ; The directory service evaluated group memberships locally.
Global Const $ERROR_DS_NO_ATTRIBUTE_OR_VALUE = 8202                               ; The specified directory service attribute or value does not exist.
Global Const $ERROR_DS_INVALID_ATTRIBUTE_SYNTAX = 8203                            ; The attribute syntax specified to the directory service is invalid.
Global Const $ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED = 8204                            ; The attribute type specified to the directory service is not defined.
Global Const $ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS = 8205                           ; The specified directory service attribute or value already exists.
Global Const $ERROR_DS_BUSY = 8206                                                ; The directory service is busy.
Global Const $ERROR_DS_UNAVAILABLE = 8207                                         ; The directory service is unavailable.
Global Const $ERROR_DS_NO_RIDS_ALLOCATED = 8208                                   ; The directory service was unable to allocate a relative identifier.
Global Const $ERROR_DS_NO_MORE_RIDS = 8209                                        ; The directory service has exhausted the pool of relative identifiers.
Global Const $ERROR_DS_INCORRECT_ROLE_OWNER = 8210                                ; The requested operation could not be performed because the directory service is not the master for that type of operation.
Global Const $ERROR_DS_RIDMGR_INIT_ERROR = 8211                                   ; The directory service was unable to initialize the subsystem that allocates relative identifiers.
Global Const $ERROR_DS_OBJ_CLASS_VIOLATION = 8212                                 ; The requested operation did not satisfy one or more constraints associated with the class of the object.
Global Const $ERROR_DS_CANT_ON_NON_LEAF = 8213                                    ; The directory service can perform the requested operation only on a leaf object.
Global Const $ERROR_DS_CANT_ON_RDN = 8214                                         ; The directory service cannot perform the requested operation on the RDN attribute of an object.
Global Const $ERROR_DS_CANT_MOD_OBJ_CLASS = 8215                                  ; The directory service detected an attempt to modify the object class of an object.
Global Const $ERROR_DS_CROSS_DOM_MOVE_ERROR = 8216                                ; The requested cross-domain move operation could not be performed.
Global Const $ERROR_DS_GC_NOT_AVAILABLE = 8217                                    ; Unable to contact the global catalog server.
Global Const $ERROR_SHARED_POLICY = 8218                                          ; The policy object is shared and can only be modified at the root.
Global Const $ERROR_POLICY_OBJECT_NOT_FOUND = 8219                                ; The policy object does not exist.
Global Const $ERROR_POLICY_ONLY_IN_DS = 8220                                      ; The requested policy information is only in the directory service.
Global Const $ERROR_PROMOTION_ACTIVE = 8221                                       ; A domain controller promotion is currently active.
Global Const $ERROR_NO_PROMOTION_ACTIVE = 8222                                    ; A domain controller promotion is not currently active.
Global Const $ERROR_DS_OPERATIONS_ERROR = 8224                                    ; An operations error occurred.
Global Const $ERROR_DS_PROTOCOL_ERROR = 8225                                      ; A protocol error occurred.
Global Const $ERROR_DS_TIMELIMIT_EXCEEDED = 8226                                  ; The time limit for this request was exceeded.
Global Const $ERROR_DS_SIZELIMIT_EXCEEDED = 8227                                  ; The size limit for this request was exceeded.
Global Const $ERROR_DS_ADMIN_LIMIT_EXCEEDED = 8228                                ; The administrative limit for this request was exceeded.
Global Const $ERROR_DS_COMPARE_FALSE = 8229                                       ; The compare response was false.
Global Const $ERROR_DS_COMPARE_TRUE = 8230                                        ; The compare response was true.
Global Const $ERROR_DS_AUTH_METHOD_NOT_SUPPORTED = 8231                           ; The requested authentication method is not supported by the server.
Global Const $ERROR_DS_STRONG_AUTH_REQUIRED = 8232                                ; A more secure authentication method is required for this server.
Global Const $ERROR_DS_INAPPROPRIATE_AUTH = 8233                                  ; Inappropriate authentication.
Global Const $ERROR_DS_AUTH_UNKNOWN = 8234                                        ; The authentication mechanism is unknown.
Global Const $ERROR_DS_REFERRAL = 8235                                            ; A referral was returned from the server.
Global Const $ERROR_DS_UNAVAILABLE_CRIT_EXTENSION = 8236                          ; The server does not support the requested critical extension.
Global Const $ERROR_DS_CONFIDENTIALITY_REQUIRED = 8237                            ; This request requires a secure connection.
Global Const $ERROR_DS_INAPPROPRIATE_MATCHING = 8238                              ; Inappropriate matching.
Global Const $ERROR_DS_CONSTRAINT_VIOLATION = 8239                                ; A constraint violation occurred.
Global Const $ERROR_DS_NO_SUCH_OBJECT = 8240                                      ; There is no such object on the server.
Global Const $ERROR_DS_ALIAS_PROBLEM = 8241                                       ; There is an alias problem.
Global Const $ERROR_DS_INVALID_DN_SYNTAX = 8242                                   ; An invalid dn syntax has been specified.
Global Const $ERROR_DS_IS_LEAF = 8243                                             ; The object is a leaf object.
Global Const $ERROR_DS_ALIAS_DEREF_PROBLEM = 8244                                 ; There is an alias dereferencing problem.
Global Const $ERROR_DS_UNWILLING_TO_PERFORM = 8245                                ; The server is unwilling to process the request.
Global Const $ERROR_DS_LOOP_DETECT = 8246                                         ; A loop has been detected.
Global Const $ERROR_DS_NAMING_VIOLATION = 8247                                    ; There is a naming violation.
Global Const $ERROR_DS_OBJECT_RESULTS_TOO_LARGE = 8248                            ; The result set is too large.
Global Const $ERROR_DS_AFFECTS_MULTIPLE_DSAS = 8249                               ; The operation affects multiple DSAs.
Global Const $ERROR_DS_SERVER_DOWN = 8250                                         ; The server is not operational.
Global Const $ERROR_DS_LOCAL_ERROR = 8251                                         ; A local error has occurred.
Global Const $ERROR_DS_ENCODING_ERROR = 8252                                      ; An encoding error has occurred.
Global Const $ERROR_DS_DECODING_ERROR = 8253                                      ; A decoding error has occurred.
Global Const $ERROR_DS_FILTER_UNKNOWN = 8254                                      ; The search filter cannot be recognized.
Global Const $ERROR_DS_PARAM_ERROR = 8255                                         ; One or more parameters are illegal.
Global Const $ERROR_DS_NOT_SUPPORTED = 8256                                       ; The specified method is not supported.
Global Const $ERROR_DS_NO_RESULTS_RETURNED = 8257                                 ; No results were returned.
Global Const $ERROR_DS_CONTROL_NOT_FOUND = 8258                                   ; The specified control is not supported by the server.
Global Const $ERROR_DS_CLIENT_LOOP = 8259                                         ; A referral loop was detected by the client.
Global Const $ERROR_DS_REFERRAL_LIMIT_EXCEEDED = 8260                             ; The preset referral limit was exceeded.
Global Const $ERROR_DS_SORT_CONTROL_MISSING = 8261                                ; The search requires a SORT control.
Global Const $ERROR_DS_OFFSET_RANGE_ERROR = 8262                                  ; The search results exceed the offset range specified.
Global Const $ERROR_DS_ROOT_MUST_BE_NC = 8301                                     ; The root object must be the head of a naming context. The root object cannot have an instantiated parent.
Global Const $ERROR_DS_ADD_REPLICA_INHIBITED = 8302                               ; The add replica operation cannot be performed. The naming context must be writeable in order to create the replica.
Global Const $ERROR_DS_ATT_NOT_DEF_IN_SCHEMA = 8303                               ; A reference to an attribute that is not defined in the schema occurred.
Global Const $ERROR_DS_MAX_OBJ_SIZE_EXCEEDED = 8304                               ; The maximum size of an object has been exceeded.
Global Const $ERROR_DS_OBJ_STRING_NAME_EXISTS = 8305                              ; An attempt was made to add an object to the directory with a name that is already in use.
Global Const $ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA = 8306                            ; An attempt was made to add an object of a class that does not have an RDN defined in the schema.
Global Const $ERROR_DS_RDN_DOESNT_MATCH_SCHEMA = 8307                             ; An attempt was made to add an object using an RDN that is not the RDN defined in the schema.
Global Const $ERROR_DS_NO_REQUESTED_ATTS_FOUND = 8308                             ; None of the requested attributes were found on the objects.
Global Const $ERROR_DS_USER_BUFFER_TO_SMALL = 8309                                ; The user buffer is too small.
Global Const $ERROR_DS_ATT_IS_NOT_ON_OBJ = 8310                                   ; The attribute specified in the operation is not present on the object.
Global Const $ERROR_DS_ILLEGAL_MOD_OPERATION = 8311                               ; Illegal modify operation. Some aspect of the modification is not permitted.
Global Const $ERROR_DS_OBJ_TOO_LARGE = 8312                                       ; The specified object is too large.
Global Const $ERROR_DS_BAD_INSTANCE_TYPE = 8313                                   ; The specified instance type is not valid.
Global Const $ERROR_DS_MASTERDSA_REQUIRED = 8314                                  ; The operation must be performed at a master DSA.
Global Const $ERROR_DS_OBJECT_CLASS_REQUIRED = 8315                               ; The object class attribute must be specified.
Global Const $ERROR_DS_MISSING_REQUIRED_ATT = 8316                                ; A required attribute is missing.
Global Const $ERROR_DS_ATT_NOT_DEF_FOR_CLASS = 8317                               ; An attempt was made to modify an object to include an attribute that is not legal for its class.
Global Const $ERROR_DS_ATT_ALREADY_EXISTS = 8318                                  ; The specified attribute is already present on the object.
Global Const $ERROR_DS_CANT_ADD_ATT_VALUES = 8320                                 ; The specified attribute is not present, or has no values.
Global Const $ERROR_DS_SINGLE_VALUE_CONSTRAINT = 8321                             ; Multiple values were specified for an attribute that can have only one value.
Global Const $ERROR_DS_RANGE_CONSTRAINT = 8322                                    ; A value for the attribute was not in the acceptable range of values.
Global Const $ERROR_DS_ATT_VAL_ALREADY_EXISTS = 8323                              ; The specified value already exists.
Global Const $ERROR_DS_CANT_REM_MISSING_ATT = 8324                                ; The attribute cannot be removed because it is not present on the object.
Global Const $ERROR_DS_CANT_REM_MISSING_ATT_VAL = 8325                            ; The attribute value cannot be removed because it is not present on the object.
Global Const $ERROR_DS_ROOT_CANT_BE_SUBREF = 8326                                 ; The specified root object cannot be a subreference.
Global Const $ERROR_DS_NO_CHAINING = 8327                                         ; Chaining is not permitted.
Global Const $ERROR_DS_NO_CHAINED_EVAL = 8328                                     ; Chained evaluation is not permitted.
Global Const $ERROR_DS_NO_PARENT_OBJECT = 8329                                    ; The operation could not be performed because the object's parent is either uninstantiated or deleted.
Global Const $ERROR_DS_PARENT_IS_AN_ALIAS = 8330                                  ; Having a parent that is an alias is not permitted. Aliases are leaf objects.
Global Const $ERROR_DS_CANT_MIX_MASTER_AND_REPS = 8331                            ; The object and parent must be of the same type, either both masters or both replicas.
Global Const $ERROR_DS_CHILDREN_EXIST = 8332                                      ; The operation cannot be performed because child objects exist. This operation can only be performed on a leaf object.
Global Const $ERROR_DS_OBJ_NOT_FOUND = 8333                                       ; Directory object not found.
Global Const $ERROR_DS_ALIASED_OBJ_MISSING = 8334                                 ; The aliased object is missing.
Global Const $ERROR_DS_BAD_NAME_SYNTAX = 8335                                     ; The object name has bad syntax.
Global Const $ERROR_DS_ALIAS_POINTS_TO_ALIAS = 8336                               ; It is not permitted for an alias to refer to another alias.
Global Const $ERROR_DS_CANT_DEREF_ALIAS = 8337                                    ; The alias cannot be dereferenced.
Global Const $ERROR_DS_OUT_OF_SCOPE = 8338                                        ; The operation is out of scope.
Global Const $ERROR_DS_OBJECT_BEING_REMOVED = 8339                                ; The operation cannot continue because the object is in the process of being removed.
Global Const $ERROR_DS_CANT_DELETE_DSA_OBJ = 8340                                 ; The DSA object cannot be deleted.
Global Const $ERROR_DS_GENERIC_ERROR = 8341                                       ; A directory service error has occurred.
Global Const $ERROR_DS_DSA_MUST_BE_INT_MASTER = 8342                              ; The operation can only be performed on an internal master DSA object.
Global Const $ERROR_DS_CLASS_NOT_DSA = 8343                                       ; The object must be of class DSA.
Global Const $ERROR_DS_INSUFF_ACCESS_RIGHTS = 8344                                ; Insufficient access rights to perform the operation.
Global Const $ERROR_DS_ILLEGAL_SUPERIOR = 8345                                    ; The object cannot be added because the parent is not on the list of possible superiors.
Global Const $ERROR_DS_ATTRIBUTE_OWNED_BY_SAM = 8346                              ; Access to the attribute is not permitted because the attribute is owned by the Security Accounts Manager (SAM).
Global Const $ERROR_DS_NAME_TOO_MANY_PARTS = 8347                                 ; The name has too many parts.
Global Const $ERROR_DS_NAME_TOO_LONG = 8348                                       ; The name is too long.
Global Const $ERROR_DS_NAME_VALUE_TOO_LONG = 8349                                 ; The name value is too long.
Global Const $ERROR_DS_NAME_UNPARSEABLE = 8350                                    ; The directory service encountered an error parsing a name.
Global Const $ERROR_DS_NAME_TYPE_UNKNOWN = 8351                                   ; The directory service cannot get the attribute type for a name.
Global Const $ERROR_DS_NOT_AN_OBJECT = 8352                                       ; The name does not identify an object; the name identifies a phantom.
Global Const $ERROR_DS_SEC_DESC_TOO_SHORT = 8353                                  ; The security descriptor is too short.
Global Const $ERROR_DS_SEC_DESC_INVALID = 8354                                    ; The security descriptor is invalid.
Global Const $ERROR_DS_NO_DELETED_NAME = 8355                                     ; Failed to create name for deleted object.
Global Const $ERROR_DS_SUBREF_MUST_HAVE_PARENT = 8356                             ; The parent of a new subref must exist.
Global Const $ERROR_DS_NCNAME_MUST_BE_NC = 8357                                   ; The object must be a naming context.
Global Const $ERROR_DS_CANT_ADD_SYSTEM_ONLY = 8358                                ; It is not permitted to add an attribute which is owned by the system.
Global Const $ERROR_DS_CLASS_MUST_BE_CONCRETE = 8359                              ; The class of the object must be structural; you cannot instantiate an abstract class.
Global Const $ERROR_DS_INVALID_DMD = 8360                                         ; The schema object could not be found.
Global Const $ERROR_DS_OBJ_GUID_EXISTS = 8361                                     ; A local object with this GUID (dead or alive) already exists.
Global Const $ERROR_DS_NOT_ON_BACKLINK = 8362                                     ; The operation cannot be performed on a back link.
Global Const $ERROR_DS_NO_CROSSREF_FOR_NC = 8363                                  ; The cross reference for the specified naming context could not be found.
Global Const $ERROR_DS_SHUTTING_DOWN = 8364                                       ; The operation could not be performed because the directory service is shutting down.
Global Const $ERROR_DS_UNKNOWN_OPERATION = 8365                                   ; The directory service request is invalid.
Global Const $ERROR_DS_INVALID_ROLE_OWNER = 8366                                  ; The role owner attribute could not be read.
Global Const $ERROR_DS_COULDNT_CONTACT_FSMO = 8367                                ; The requested FSMO operation failed. The current FSMO holder could not be contacted.
Global Const $ERROR_DS_CROSS_NC_DN_RENAME = 8368                                  ; Modification of a DN across a naming context is not permitted.
Global Const $ERROR_DS_CANT_MOD_SYSTEM_ONLY = 8369                                ; The attribute cannot be modified because it is owned by the system.
Global Const $ERROR_DS_REPLICATOR_ONLY = 8370                                     ; Only the replicator can perform this function.
Global Const $ERROR_DS_OBJ_CLASS_NOT_DEFINED = 8371                               ; The specified class is not defined.
Global Const $ERROR_DS_OBJ_CLASS_NOT_SUBCLASS = 8372                              ; The specified class is not a subclass.
Global Const $ERROR_DS_NAME_REFERENCE_INVALID = 8373                              ; The name reference is invalid.
Global Const $ERROR_DS_CROSS_REF_EXISTS = 8374                                    ; A cross reference already exists.
Global Const $ERROR_DS_CANT_DEL_MASTER_CROSSREF = 8375                            ; It is not permitted to delete a master cross reference.
Global Const $ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD = 8376                          ; Subtree notifications are only supported on NC heads.
Global Const $ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX = 8377                           ; Notification filter is too complex.
Global Const $ERROR_DS_DUP_RDN = 8378                                             ; Schema update failed: duplicate RDN.
Global Const $ERROR_DS_DUP_OID = 8379                                             ; Schema update failed: duplicate OID.
Global Const $ERROR_DS_DUP_MAPI_ID = 8380                                         ; Schema update failed: duplicate MAPI identifier.
Global Const $ERROR_DS_DUP_SCHEMA_ID_GUID = 8381                                  ; Schema update failed: duplicate schema-id GUID.
Global Const $ERROR_DS_DUP_LDAP_DISPLAY_NAME = 8382                               ; Schema update failed: duplicate LDAP display name.
Global Const $ERROR_DS_SEMANTIC_ATT_TEST = 8383                                   ; Schema update failed: range-lower less than range upper.
Global Const $ERROR_DS_SYNTAX_MISMATCH = 8384                                     ; Schema update failed: syntax mismatch.
Global Const $ERROR_DS_EXISTS_IN_MUST_HAVE = 8385                                 ; Schema deletion failed: attribute is used in must-contain.
Global Const $ERROR_DS_EXISTS_IN_MAY_HAVE = 8386                                  ; Schema deletion failed: attribute is used in may-contain.
Global Const $ERROR_DS_NONEXISTENT_MAY_HAVE = 8387                                ; Schema update failed: attribute in may-contain does not exist.
Global Const $ERROR_DS_NONEXISTENT_MUST_HAVE = 8388                               ; Schema update failed: attribute in must-contain does not exist.
Global Const $ERROR_DS_AUX_CLS_TEST_FAIL = 8389                                   ; Schema update failed: class in aux-class list does not exist or is not an auxiliary class.
Global Const $ERROR_DS_NONEXISTENT_POSS_SUP = 8390                                ; Schema update failed: class in poss-superiors does not exist.
Global Const $ERROR_DS_SUB_CLS_TEST_FAIL = 8391                                   ; Schema update failed: class in subclassof list does not exist or does not satisfy hierarchy rules.
Global Const $ERROR_DS_BAD_RDN_ATT_ID_SYNTAX = 8392                               ; Schema update failed: Rdn-Att-Id has wrong syntax.
Global Const $ERROR_DS_EXISTS_IN_AUX_CLS = 8393                                   ; Schema deletion failed: class is used as auxiliary class.
Global Const $ERROR_DS_EXISTS_IN_SUB_CLS = 8394                                   ; Schema deletion failed: class is used as sub class.
Global Const $ERROR_DS_EXISTS_IN_POSS_SUP = 8395                                  ; Schema deletion failed: class is used as poss superior.
Global Const $ERROR_DS_RECALCSCHEMA_FAILED = 8396                                 ; Schema update failed in recalculating validation cache.
Global Const $ERROR_DS_TREE_DELETE_NOT_FINISHED = 8397                            ; The tree deletion is not finished. The request must be made again to continue deleting the tree.
Global Const $ERROR_DS_CANT_DELETE = 8398                                         ; The requested delete operation could not be performed.
Global Const $ERROR_DS_ATT_SCHEMA_REQ_ID = 8399                                   ; Cannot read the governs class identifier for the schema record.
Global Const $ERROR_DS_BAD_ATT_SCHEMA_SYNTAX = 8400                               ; The attribute schema has bad syntax.
Global Const $ERROR_DS_CANT_CACHE_ATT = 8401                                      ; The attribute could not be cached.
Global Const $ERROR_DS_CANT_CACHE_CLASS = 8402                                    ; The class could not be cached.
Global Const $ERROR_DS_CANT_REMOVE_ATT_CACHE = 8403                               ; The attribute could not be removed from the cache.
Global Const $ERROR_DS_CANT_REMOVE_CLASS_CACHE = 8404                             ; The class could not be removed from the cache.
Global Const $ERROR_DS_CANT_RETRIEVE_DN = 8405                                    ; The distinguished name attribute could not be read.
Global Const $ERROR_DS_MISSING_SUPREF = 8406                                      ; No superior reference has been configured for the directory service. The directory service is therefore unable to issue referrals to objects outside this forest.
Global Const $ERROR_DS_CANT_RETRIEVE_INSTANCE = 8407                              ; The instance type attribute could not be retrieved.
Global Const $ERROR_DS_CODE_INCONSISTENCY = 8408                                  ; An internal error has occurred.
Global Const $ERROR_DS_DATABASE_ERROR = 8409                                      ; A database error has occurred.
Global Const $ERROR_DS_GOVERNSID_MISSING = 8410                                   ; The attribute GOVERNSID is missing.
Global Const $ERROR_DS_MISSING_EXPECTED_ATT = 8411                                ; An expected attribute is missing.
Global Const $ERROR_DS_NCNAME_MISSING_CR_REF = 8412                               ; The specified naming context is missing a cross reference.
Global Const $ERROR_DS_SECURITY_CHECKING_ERROR = 8413                             ; A security checking error has occurred.
Global Const $ERROR_DS_SCHEMA_NOT_LOADED = 8414                                   ; The schema is not loaded.
Global Const $ERROR_DS_SCHEMA_ALLOC_FAILED = 8415                                 ; Schema allocation failed. Please check if the machine is running low on memory.
Global Const $ERROR_DS_ATT_SCHEMA_REQ_SYNTAX = 8416                               ; Failed to obtain the required syntax for the attribute schema.
Global Const $ERROR_DS_GCVERIFY_ERROR = 8417                                      ; The global catalog verification failed. The global catalog is not available or does not support the operation. Some part of the directory is currently not available.
Global Const $ERROR_DS_DRA_SCHEMA_MISMATCH = 8418                                 ; The replication operation failed because of a schema mismatch between the servers involved.
Global Const $ERROR_DS_CANT_FIND_DSA_OBJ = 8419                                   ; The DSA object could not be found.
Global Const $ERROR_DS_CANT_FIND_EXPECTED_NC = 8420                               ; The naming context could not be found.
Global Const $ERROR_DS_CANT_FIND_NC_IN_CACHE = 8421                               ; The naming context could not be found in the cache.
Global Const $ERROR_DS_CANT_RETRIEVE_CHILD = 8422                                 ; The child object could not be retrieved.
Global Const $ERROR_DS_SECURITY_ILLEGAL_MODIFY = 8423                             ; The modification was not permitted for security reasons.
Global Const $ERROR_DS_CANT_REPLACE_HIDDEN_REC = 8424                             ; The operation cannot replace the hidden record.
Global Const $ERROR_DS_BAD_HIERARCHY_FILE = 8425                                  ; The hierarchy file is invalid.
Global Const $ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED = 8426                        ; The attempt to build the hierarchy table failed.
Global Const $ERROR_DS_CONFIG_PARAM_MISSING = 8427                                ; The directory configuration parameter is missing from the registry.
Global Const $ERROR_DS_COUNTING_AB_INDICES_FAILED = 8428                          ; The attempt to count the address book indices failed.
Global Const $ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED = 8429                       ; The allocation of the hierarchy table failed.
Global Const $ERROR_DS_INTERNAL_FAILURE = 8430                                    ; The directory service encountered an internal failure.
Global Const $ERROR_DS_UNKNOWN_ERROR = 8431                                       ; The directory service encountered an unknown failure.
Global Const $ERROR_DS_ROOT_REQUIRES_CLASS_TOP = 8432                             ; A root object requires a class of 'top'.
Global Const $ERROR_DS_REFUSING_FSMO_ROLES = 8433                                 ; This directory server is shutting down, and cannot take ownership of new floating single-master operation roles.
Global Const $ERROR_DS_MISSING_FSMO_SETTINGS = 8434                               ; The directory service is missing mandatory configuration information, and is unable to determine the ownership of floating single-master operation roles.
Global Const $ERROR_DS_UNABLE_TO_SURRENDER_ROLES = 8435                           ; The directory service was unable to transfer ownership of one or more floating single-master operation roles to other servers.
Global Const $ERROR_DS_DRA_GENERIC = 8436                                         ; The replication operation failed.
Global Const $ERROR_DS_DRA_INVALID_PARAMETER = 8437                               ; An invalid parameter was specified for this replication operation.
Global Const $ERROR_DS_DRA_BUSY = 8438                                            ; The directory service is too busy to complete the replication operation at this time.
Global Const $ERROR_DS_DRA_BAD_DN = 8439                                          ; The distinguished name specified for this replication operation is invalid.
Global Const $ERROR_DS_DRA_BAD_NC = 8440                                          ; The naming context specified for this replication operation is invalid.
Global Const $ERROR_DS_DRA_DN_EXISTS = 8441                                       ; The distinguished name specified for this replication operation already exists.
Global Const $ERROR_DS_DRA_INTERNAL_ERROR = 8442                                  ; The replication system encountered an internal error.
Global Const $ERROR_DS_DRA_INCONSISTENT_DIT = 8443                                ; The replication operation encountered a database inconsistency.
Global Const $ERROR_DS_DRA_CONNECTION_FAILED = 8444                               ; The server specified for this replication operation could not be contacted.
Global Const $ERROR_DS_DRA_BAD_INSTANCE_TYPE = 8445                               ; The replication operation encountered an object with an invalid instance type.
Global Const $ERROR_DS_DRA_OUT_OF_MEM = 8446                                      ; The replication operation failed to allocate memory.
Global Const $ERROR_DS_DRA_MAIL_PROBLEM = 8447                                    ; The replication operation encountered an error with the mail system.
Global Const $ERROR_DS_DRA_REF_ALREADY_EXISTS = 8448                              ; The replication reference information for the target server already exists.
Global Const $ERROR_DS_DRA_REF_NOT_FOUND = 8449                                   ; The replication reference information for the target server does not exist.
Global Const $ERROR_DS_DRA_OBJ_IS_REP_SOURCE = 8450                               ; The naming context cannot be removed because it is replicated to another server.
Global Const $ERROR_DS_DRA_DB_ERROR = 8451                                        ; The replication operation encountered a database error.
Global Const $ERROR_DS_DRA_NO_REPLICA = 8452                                      ; The naming context is in the process of being removed or is not replicated from the specified server.
Global Const $ERROR_DS_DRA_ACCESS_DENIED = 8453                                   ; Replication access was denied.
Global Const $ERROR_DS_DRA_NOT_SUPPORTED = 8454                                   ; The requested operation is not supported by this version of the directory service.
Global Const $ERROR_DS_DRA_RPC_CANCELLED = 8455                                   ; The replication remote procedure call was canceled.
Global Const $ERROR_DS_DRA_SOURCE_DISABLED = 8456                                 ; The source server is currently rejecting replication requests.
Global Const $ERROR_DS_DRA_SINK_DISABLED = 8457                                   ; The destination server is currently rejecting replication requests.
Global Const $ERROR_DS_DRA_NAME_COLLISION = 8458                                  ; The replication operation failed due to a collision of object names.
Global Const $ERROR_DS_DRA_SOURCE_REINSTALLED = 8459                              ; The replication source has been reinstalled.
Global Const $ERROR_DS_DRA_MISSING_PARENT = 8460                                  ; The replication operation failed because a required parent object is missing.
Global Const $ERROR_DS_DRA_PREEMPTED = 8461                                       ; The replication operation was preempted.
Global Const $ERROR_DS_DRA_ABANDON_SYNC = 8462                                    ; The replication synchronization attempt was abandoned because of a lack of updates.
Global Const $ERROR_DS_DRA_SHUTDOWN = 8463                                        ; The replication operation was terminated because the system is shutting down.
Global Const $ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET = 8464                        ; Synchronization attempt failed because the destination DC is currently waiting to synchronize new partial attributes from source. This condition is normal if a recent schema change modified the partial attribute set. The destination partial attribute set is not a subset of source partial attribute set.
Global Const $ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA = 8465                       ; The replication synchronization attempt failed because a master replica attempted to sync from a partial replica.
Global Const $ERROR_DS_DRA_EXTN_CONNECTION_FAILED = 8466                          ; The server specified for this replication operation was contacted, but that server was unable to contact an additional server needed to complete the operation.
Global Const $ERROR_DS_INSTALL_SCHEMA_MISMATCH = 8467                             ; The version of the directory service schema of the source forest is not compatible with the version of the directory service on this computer.
Global Const $ERROR_DS_DUP_LINK_ID = 8468                                         ; Schema update failed: An attribute with the same link identifier already exists.
Global Const $ERROR_DS_NAME_ERROR_RESOLVING = 8469                                ; Name translation: Generic processing error.
Global Const $ERROR_DS_NAME_ERROR_NOT_FOUND = 8470                                ; Name translation: Could not find the name or insufficient right to see name.
Global Const $ERROR_DS_NAME_ERROR_NOT_UNIQUE = 8471                               ; Name translation: Input name mapped to more than one output name.
Global Const $ERROR_DS_NAME_ERROR_NO_MAPPING = 8472                               ; Name translation: Input name found, but not the associated output format.
Global Const $ERROR_DS_NAME_ERROR_DOMAIN_ONLY = 8473                              ; Name translation: Unable to resolve completely, only the domain was found.
Global Const $ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING = 8474                   ; Name translation: Unable to perform purely syntactical mapping at the client without going out to the wire.
Global Const $ERROR_DS_CONSTRUCTED_ATT_MOD = 8475                                 ; Modification of a constructed attribute is not allowed.
Global Const $ERROR_DS_WRONG_OM_OBJ_CLASS = 8476                                  ; The OM-Object-Class specified is incorrect for an attribute with the specified syntax.
Global Const $ERROR_DS_DRA_REPL_PENDING = 8477                                    ; The replication request has been posted; waiting for reply.
Global Const $ERROR_DS_DS_REQUIRED = 8478                                         ; The requested operation requires a directory service, and none was available.
Global Const $ERROR_DS_INVALID_LDAP_DISPLAY_NAME = 8479                           ; The LDAP display name of the class or attribute contains non-ASCII characters.
Global Const $ERROR_DS_NON_BASE_SEARCH = 8480                                     ; The requested search operation is only supported for base searches.
Global Const $ERROR_DS_CANT_RETRIEVE_ATTS = 8481                                  ; The search failed to retrieve attributes from the database.
Global Const $ERROR_DS_BACKLINK_WITHOUT_LINK = 8482                               ; The schema update operation tried to add a backward link attribute that has no corresponding forward link.
Global Const $ERROR_DS_EPOCH_MISMATCH = 8483                                      ; Source and destination of a cross-domain move do not agree on the object's epoch number. Either source or destination does not have the latest version of the object.
Global Const $ERROR_DS_SRC_NAME_MISMATCH = 8484                                   ; Source and destination of a cross-domain move do not agree on the object's current name. Either source or destination does not have the latest version of the object.
Global Const $ERROR_DS_SRC_AND_DST_NC_IDENTICAL = 8485                            ; Source and destination for the cross-domain move operation are identical. Caller should use local move operation instead of cross-domain move operation.
Global Const $ERROR_DS_DST_NC_MISMATCH = 8486                                     ; Source and destination for a cross-domain move are not in agreement on the naming contexts in the forest. Either source or destination does not have the latest version of the Partitions container.
Global Const $ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC = 8487                          ; Destination of a cross-domain move is not authoritative for the destination naming context.
Global Const $ERROR_DS_SRC_GUID_MISMATCH = 8488                                   ; Source and destination of a cross-domain move do not agree on the identity of the source object. Either source or destination does not have the latest version of the source object.
Global Const $ERROR_DS_CANT_MOVE_DELETED_OBJECT = 8489                            ; Object being moved across-domains is already known to be deleted by the destination server. The source server does not have the latest version of the source object.
Global Const $ERROR_DS_PDC_OPERATION_IN_PROGRESS = 8490                           ; Another operation which requires exclusive access to the PDC FSMO is already in progress.
Global Const $ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD = 8491                           ; A cross-domain move operation failed such that two versions of the moved object exist - one each in the source and destination domains. The destination object needs to be removed to restore the system to a consistent state.
Global Const $ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION = 8492                         ; This object may not be moved across domain boundaries either because cross-domain moves for this class are disallowed, or the object has some special characteristics, e.g.: trust account or restricted RID, which prevent its move.
Global Const $ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS = 8493                     ; Can't move objects with memberships across domain boundaries as once moved, this would violate the membership conditions of the account group. Remove the object from any account group memberships and retry.
Global Const $ERROR_DS_NC_MUST_HAVE_NC_PARENT = 8494                              ; A naming context head must be the immediate child of another naming context head, not of an interior node.
Global Const $ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE = 8495                           ; The directory cannot validate the proposed naming context name because it does not hold a replica of the naming context above the proposed naming context. Please ensure that the domain naming master role is held by a server that is configured as a global catalog server, and that the server is up to date with its replication partners. (Applies only to Windows 2000 Domain Naming masters)
Global Const $ERROR_DS_DST_DOMAIN_NOT_NATIVE = 8496                               ; Destination domain must be in native mode.
Global Const $ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER = 8497                    ; The operation cannot be performed because the server does not have an infrastructure container in the domain of interest.
Global Const $ERROR_DS_CANT_MOVE_ACCOUNT_GROUP = 8498                             ; Cross-domain move of non-empty account groups is not allowed.
Global Const $ERROR_DS_CANT_MOVE_RESOURCE_GROUP = 8499                            ; Cross-domain move of non-empty resource groups is not allowed.
Global Const $ERROR_DS_INVALID_SEARCH_FLAG = 8500                                 ; The search flags for the attribute are invalid. The ANR bit is valid only on attributes of Unicode or Teletex strings.
Global Const $ERROR_DS_NO_TREE_DELETE_ABOVE_NC = 8501                             ; Tree deletions starting at an object which has an NC head as a descendant are not allowed.
Global Const $ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE = 8502                        ; The directory service failed to lock a tree in preparation for a tree deletion because the tree was in use.
Global Const $ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE = 8503            ; The directory service failed to identify the list of objects to delete while attempting a tree deletion.
Global Const $ERROR_DS_SAM_INIT_FAILURE = 8504                                    ; Security Accounts Manager initialization failed because of the following error: %1. Error Status: 0x%2. Please shut down this system and reboot into Directory Services Restore Mode. Check the event log for more detailed information.
Global Const $ERROR_DS_SENSITIVE_GROUP_VIOLATION = 8505                           ; Only an administrator can modify the membership list of an administrative group.
Global Const $ERROR_DS_CANT_MOD_PRIMARYGROUPID = 8506                             ; Cannot change the primary group ID of a domain controller account.
Global Const $ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD = 8507                             ; An attempt is made to modify the base schema.
Global Const $ERROR_DS_NONSAFE_SCHEMA_CHANGE = 8508                               ; Adding a new mandatory attribute to an existing class, deleting a mandatory attribute from an existing class, or adding an optional attribute to the special class Top that is not a backlink attribute (directly or through inheritance, for example, by adding or deleting an auxiliary class) is not allowed.
Global Const $ERROR_DS_SCHEMA_UPDATE_DISALLOWED = 8509                            ; Schema update is not allowed on this DC because the DC is not the schema FSMO Role Owner.
Global Const $ERROR_DS_CANT_CREATE_UNDER_SCHEMA = 8510                            ; An object of this class cannot be created under the schema container. You can only create attribute-schema and class-schema objects under the schema container.
Global Const $ERROR_DS_INSTALL_NO_SRC_SCH_VERSION = 8511                          ; The replica/child install failed to get the objectVersion attribute on the schema container on the source DC. Either the attribute is missing on the schema container or the credentials supplied do not have permission to read it.
Global Const $ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE = 8512                   ; The replica/child install failed to read the objectVersion attribute in the SCHEMA section of the file schema.ini in the system32 directory.
Global Const $ERROR_DS_INVALID_GROUP_TYPE = 8513                                  ; The specified group type is invalid.
Global Const $ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = 8514                  ; You cannot nest global groups in a mixed domain if the group is security-enabled.
Global Const $ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = 8515                   ; You cannot nest local groups in a mixed domain if the group is security-enabled.
Global Const $ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = 8516                       ; A global group cannot have a local group as a member.
Global Const $ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = 8517                   ; A global group cannot have a universal group as a member.
Global Const $ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = 8518                    ; A universal group cannot have a local group as a member.
Global Const $ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = 8519                 ; A global group cannot have a cross-domain member.
Global Const $ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = 8520            ; A local group cannot have another cross domain local group as a member.
Global Const $ERROR_DS_HAVE_PRIMARY_MEMBERS = 8521                                ; A group with primary members cannot change to a security-disabled group.
Global Const $ERROR_DS_STRING_SD_CONVERSION_FAILED = 8522                         ; The schema cache load failed to convert the string default SD on a class-schema object.
Global Const $ERROR_DS_NAMING_MASTER_GC = 8523                                    ; Only DSAs configured to be Global Catalog servers should be allowed to hold the Domain Naming Master FSMO role. (Applies only to Windows 2000 servers)
Global Const $ERROR_DS_DNS_LOOKUP_FAILURE = 8524                                  ; The DSA operation is unable to proceed because of a DNS lookup failure.
Global Const $ERROR_DS_COULDNT_UPDATE_SPNS = 8525                                 ; While processing a change to the DNS Host Name for an object, the Service Principal Name values could not be kept in sync.
Global Const $ERROR_DS_CANT_RETRIEVE_SD = 8526                                    ; The Security Descriptor attribute could not be read.
Global Const $ERROR_DS_KEY_NOT_UNIQUE = 8527                                      ; The object requested was not found, but an object with that key was found.
Global Const $ERROR_DS_WRONG_LINKED_ATT_SYNTAX = 8528                             ; The syntax of the linked attribute being added is incorrect. Forward links can only have syntax 2.5.5.1, 2.5.5.7, and 2.5.5.14, and backlinks can only have syntax 2.5.5.1
Global Const $ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD = 8529                           ; Security Account Manager needs to get the boot password.
Global Const $ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY = 8530                             ; Security Account Manager needs to get the boot key from floppy disk.
Global Const $ERROR_DS_CANT_START = 8531                                          ; Directory Service cannot start.
Global Const $ERROR_DS_INIT_FAILURE = 8532                                        ; Directory Services could not start.
Global Const $ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION = 8533                        ; The connection between client and server requires packet privacy or better.
Global Const $ERROR_DS_SOURCE_DOMAIN_IN_FOREST = 8534                             ; The source domain may not be in the same forest as destination.
Global Const $ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST = 8535                    ; The destination domain must be in the forest.
Global Const $ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED = 8536                    ; The operation requires that destination domain auditing be enabled.
Global Const $ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN = 8537                         ; The operation couldn't locate a DC for the source domain.
Global Const $ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER = 8538                           ; The source object must be a group or user.
Global Const $ERROR_DS_SRC_SID_EXISTS_IN_FOREST = 8539                            ; The source object's SID already exists in destination forest.
Global Const $ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH = 8540                   ; The source and destination object must be of the same type.
Global Const $ERROR_SAM_INIT_FAILURE = 8541                                       ; Security Accounts Manager initialization failed because of the following error: %1. Error Status: 0x%2. Click OK to shut down the system and reboot into Safe Mode. Check the event log for detailed information.
Global Const $ERROR_DS_DRA_SCHEMA_INFO_SHIP = 8542                                ; Schema information could not be included in the replication request.
Global Const $ERROR_DS_DRA_SCHEMA_CONFLICT = 8543                                 ; The replication operation could not be completed due to a schema incompatibility.
Global Const $ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT = 8544                         ; The replication operation could not be completed due to a previous schema incompatibility.
Global Const $ERROR_DS_DRA_OBJ_NC_MISMATCH = 8545                                 ; The replication update could not be applied because either the source or the destination has not yet received information regarding a recent cross-domain move operation.
Global Const $ERROR_DS_NC_STILL_HAS_DSAS = 8546                                   ; The requested domain could not be deleted because there exist domain controllers that still host this domain.
Global Const $ERROR_DS_GC_REQUIRED = 8547                                         ; The requested operation can be performed only on a global catalog server.
Global Const $ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = 8548                          ; A local group can only be a member of other local groups in the same domain.
Global Const $ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS = 8549                          ; Foreign security principals cannot be members of universal groups.
Global Const $ERROR_DS_CANT_ADD_TO_GC = 8550                                      ; The attribute is not allowed to be replicated to the GC because of security reasons.
Global Const $ERROR_DS_NO_CHECKPOINT_WITH_PDC = 8551                              ; The checkpoint with the PDC could not be taken because there too many modifications being processed currently.
Global Const $ERROR_DS_SOURCE_AUDITING_NOT_ENABLED = 8552                         ; The operation requires that source domain auditing be enabled.
Global Const $ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC = 8553                         ; Security principal objects can only be created inside domain naming contexts.
Global Const $ERROR_DS_INVALID_NAME_FOR_SPN = 8554                                ; A Service Principal Name (SPN) could not be constructed because the provided hostname is not in the necessary format.
Global Const $ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS = 8555                        ; A Filter was passed that uses constructed attributes.
Global Const $ERROR_DS_UNICODEPWD_NOT_IN_QUOTES = 8556                            ; The unicodePwd attribute value must be enclosed in double quotes.
Global Const $ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = 8557                      ; Your computer could not be joined to the domain. You have exceeded the maximum number of computer accounts you are allowed to create in this domain. Contact your system administrator to have this limit reset or increased.
Global Const $ERROR_DS_MUST_BE_RUN_ON_DST_DC = 8558                               ; For security reasons, the operation must be run on the destination DC.
Global Const $ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER = 8559                       ; For security reasons, the source DC must be NT4SP4 or greater.
Global Const $ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ = 8560                       ; Critical Directory Service System objects cannot be deleted during tree delete operations. The tree delete may have been partially performed.
Global Const $ERROR_DS_INIT_FAILURE_CONSOLE = 8561                                ; Directory Services could not start because of the following error: %1. Error Status: 0x%2. Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.
Global Const $ERROR_DS_SAM_INIT_FAILURE_CONSOLE = 8562                            ; Security Accounts Manager initialization failed because of the following error: %1. Error Status: 0x%2. Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.
Global Const $ERROR_DS_FOREST_VERSION_TOO_HIGH = 8563                             ; The version of the operating system is incompatible with the current AD DS forest functional level or AD LDS Configuration Set functional level. You must upgrade to a new version of the operating system before this server can become an AD DS Domain Controller or add an AD LDS Instance in this AD DS forest or AD LDS Configuration Set.
Global Const $ERROR_DS_DOMAIN_VERSION_TOO_HIGH = 8564                             ; The version of the operating system installed is incompatible with the current domain functional level. You must upgrade to a new version of the operating system before this server can become a domain controller in this domain.
Global Const $ERROR_DS_FOREST_VERSION_TOO_LOW = 8565                              ; The version of the operating system installed on this server no longer supports the current AD DS Forest functional level or AD LDS Configuration Set functional level. You must raise the AD DS Forest functional level or AD LDS Configuration Set functional level before this server can become an AD DS Domain Controller or an AD LDS Instance in this Forest or Configuration Set.
Global Const $ERROR_DS_DOMAIN_VERSION_TOO_LOW = 8566                              ; The version of the operating system installed on this server no longer supports the current domain functional level. You must raise the domain functional level before this server can become a domain controller in this domain.
Global Const $ERROR_DS_INCOMPATIBLE_VERSION = 8567                                ; The version of the operating system installed on this server is incompatible with the functional level of the domain or forest.
Global Const $ERROR_DS_LOW_DSA_VERSION = 8568                                     ; The functional level of the domain (or forest) cannot be raised to the requested value, because there exist one or more domain controllers in the domain (or forest) that are at a lower incompatible functional level.
Global Const $ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN = 8569                  ; The forest functional level cannot be raised to the requested value since one or more domains are still in mixed domain mode. All domains in the forest must be in native mode, for you to raise the forest functional level.
Global Const $ERROR_DS_NOT_SUPPORTED_SORT_ORDER = 8570                            ; The sort order requested is not supported.
Global Const $ERROR_DS_NAME_NOT_UNIQUE = 8571                                     ; The requested name already exists as a unique identifier.
Global Const $ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4 = 8572                      ; The machine account was created pre-NT4. The account needs to be recreated.
Global Const $ERROR_DS_OUT_OF_VERSION_STORE = 8573                                ; The database is out of version store.
Global Const $ERROR_DS_INCOMPATIBLE_CONTROLS_USED = 8574                          ; Unable to continue operation because multiple conflicting controls were used.
Global Const $ERROR_DS_NO_REF_DOMAIN = 8575                                       ; Unable to find a valid security descriptor reference domain for this partition.
Global Const $ERROR_DS_RESERVED_LINK_ID = 8576                                    ; Schema update failed: The link identifier is reserved.
Global Const $ERROR_DS_LINK_ID_NOT_AVAILABLE = 8577                               ; Schema update failed: There are no link identifiers available.
Global Const $ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = 8578                       ; An account group cannot have a universal group as a member.
Global Const $ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE = 8579                ; Rename or move operations on naming context heads or read-only objects are not allowed.
Global Const $ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC = 8580                         ; Move operations on objects in the schema naming context are not allowed.
Global Const $ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG = 8581                         ; A system flag has been set on the object and does not allow the object to be moved or renamed.
Global Const $ERROR_DS_MODIFYDN_WRONG_GRANDPARENT = 8582                          ; This object is not allowed to change its grandparent container. Moves are not forbidden on this object, but are restricted to sibling containers.
Global Const $ERROR_DS_NAME_ERROR_TRUST_REFERRAL = 8583                           ; Unable to resolve completely, a referral to another forest is generated.
Global Const $ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER = 8584                       ; The requested action is not supported on standard server.
Global Const $ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD = 8585                       ; Could not access a partition of the directory service located on a remote server. Make sure at least one server is running for the partition in question.
Global Const $ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2 = 8586                        ; The directory cannot validate the proposed naming context (or partition) name because it does not hold a replica nor can it contact a replica of the naming context above the proposed naming context. Please ensure that the parent naming context is properly registered in DNS, and at least one replica of this naming context is reachable by the Domain Naming master.
Global Const $ERROR_DS_THREAD_LIMIT_EXCEEDED = 8587                               ; The thread limit for this request was exceeded.
Global Const $ERROR_DS_NOT_CLOSEST = 8588                                         ; The Global catalog server is not in the closest site.
Global Const $ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF = 8589                  ; The DS cannot derive a service principal name (SPN) with which to mutually authenticate the target server because the corresponding server object in the local DS database has no serverReference attribute.
Global Const $ERROR_DS_SINGLE_USER_MODE_FAILED = 8590                             ; The Directory Service failed to enter single user mode.
Global Const $ERROR_DS_NTDSCRIPT_SYNTAX_ERROR = 8591                              ; The Directory Service cannot parse the script because of a syntax error.
Global Const $ERROR_DS_NTDSCRIPT_PROCESS_ERROR = 8592                             ; The Directory Service cannot process the script because of an error.
Global Const $ERROR_DS_DIFFERENT_REPL_EPOCHS = 8593                               ; The directory service cannot perform the requested operation because the servers involved are of different replication epochs (which is usually related to a domain rename that is in progress).
Global Const $ERROR_DS_DRS_EXTENSIONS_CHANGED = 8594                              ; The directory service binding must be renegotiated due to a change in the server extensions information.
Global Const $ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR = 8595       ; Operation not allowed on a disabled cross reference.
Global Const $ERROR_DS_NO_MSDS_INTID = 8596                                       ; Schema update failed: No values for msDS-IntId are available.
Global Const $ERROR_DS_DUP_MSDS_INTID = 8597                                      ; Schema update failed: Duplicate msDS-INtId. Retry the operation.
Global Const $ERROR_DS_EXISTS_IN_RDNATTID = 8598                                  ; Schema deletion failed: attribute is used in rDNAttID.
Global Const $ERROR_DS_AUTHORIZATION_FAILED = 8599                                ; The directory service failed to authorize the request.
Global Const $ERROR_DS_INVALID_SCRIPT = 8600                                      ; The Directory Service cannot process the script because it is invalid.
Global Const $ERROR_DS_REMOTE_CROSSREF_OP_FAILED = 8601                           ; The remote create cross reference operation failed on the Domain Naming Master FSMO. The operation's error is in the extended data.
Global Const $ERROR_DS_CROSS_REF_BUSY = 8602                                      ; A cross reference is in use locally with the same name.
Global Const $ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN = 8603                  ; The DS cannot derive a service principal name (SPN) with which to mutually authenticate the target server because the server's domain has been deleted from the forest.
Global Const $ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC = 8604                       ; Writeable NCs prevent this DC from demoting.
Global Const $ERROR_DS_DUPLICATE_ID_FOUND = 8605                                  ; The requested object has a non-unique identifier and cannot be retrieved.
Global Const $ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT = 8606                  ; Insufficient attributes were given to create an object. This object may not exist because it may have been deleted and already garbage collected.
Global Const $ERROR_DS_GROUP_CONVERSION_ERROR = 8607                              ; The group cannot be converted due to attribute restrictions on the requested group type.
Global Const $ERROR_DS_CANT_MOVE_APP_BASIC_GROUP = 8608                           ; Cross-domain move of non-empty basic application groups is not allowed.
Global Const $ERROR_DS_CANT_MOVE_APP_QUERY_GROUP = 8609                           ; Cross-domain move of non-empty query based application groups is not allowed.
Global Const $ERROR_DS_ROLE_NOT_VERIFIED = 8610                                   ; The FSMO role ownership could not be verified because its directory partition has not replicated successfully with at least one replication partner.
Global Const $ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL = 8611                     ; The target container for a redirection of a well known object container cannot already be a special container.
Global Const $ERROR_DS_DOMAIN_RENAME_IN_PROGRESS = 8612                           ; The Directory Service cannot perform the requested operation because a domain rename operation is in progress.
Global Const $ERROR_DS_EXISTING_AD_CHILD_NC = 8613                                ; The directory service detected a child partition below the requested new partition name. The partition hierarchy must be created in a top down method.
Global Const $ERROR_DS_REPL_LIFETIME_EXCEEDED = 8614                              ; The directory service cannot replicate with this server because the time since the last replication with this server has exceeded the tombstone lifetime.
Global Const $ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER = 8615                      ; The requested operation is not allowed on an object under the system container.
Global Const $ERROR_DS_LDAP_SEND_QUEUE_FULL = 8616                                ; The LDAP servers network send queue has filled up because the client is not processing the results of it's requests fast enough. No more requests will be processed until the client catches up. If the client does not catch up then it will be disconnected.
Global Const $ERROR_DS_DRA_OUT_SCHEDULE_WINDOW = 8617                             ; The scheduled replication did not take place because the system was too busy to execute the request within the schedule window. The replication queue is overloaded. Consider reducing the number of partners or decreasing the scheduled replication frequency.
Global Const $ERROR_DS_POLICY_NOT_KNOWN = 8618                                    ; At this time, it cannot be determined if the branch replication policy is available on the hub domain controller. Please retry at a later time to account for replication latencies.
Global Const $ERROR_NO_SITE_SETTINGS_OBJECT = 8619                                ; The site settings object for the specified site does not exist.
Global Const $ERROR_NO_SECRETS = 8620                                             ; The local account store does not contain secret material for the specified account.
Global Const $ERROR_NO_WRITABLE_DC_FOUND = 8621                                   ; Could not find a writable domain controller in the domain.
Global Const $ERROR_DS_NO_SERVER_OBJECT = 8622                                    ; The server object for the domain controller does not exist.
Global Const $ERROR_DS_NO_NTDSA_OBJECT = 8623                                     ; The NTDS Settings object for the domain controller does not exist.
Global Const $ERROR_DS_NON_ASQ_SEARCH = 8624                                      ; The requested search operation is not supported for ASQ searches.
Global Const $ERROR_DS_AUDIT_FAILURE = 8625                                       ; A required audit event could not be generated for the operation.
Global Const $ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE = 8626                         ; The search flags for the attribute are invalid. The subtree index bit is valid only on single valued attributes.
Global Const $ERROR_DS_INVALID_SEARCH_FLAG_TUPLE = 8627                           ; The search flags for the attribute are invalid. The tuple index bit is valid only on attributes of Unicode strings.
Global Const $ERROR_DS_HIERARCHY_TABLE_TOO_DEEP = 8628                            ; The address books are nested too deeply. Failed to build the hierarchy table.
Global Const $ERROR_DS_DRA_CORRUPT_UTD_VECTOR = 8629                              ; The specified up-to-date-ness vector is corrupt.
Global Const $ERROR_DS_DRA_SECRETS_DENIED = 8630                                  ; The request to replicate secrets is denied.
Global Const $ERROR_DS_RESERVED_MAPI_ID = 8631                                    ; Schema update failed: The MAPI identifier is reserved.
Global Const $ERROR_DS_MAPI_ID_NOT_AVAILABLE = 8632                               ; Schema update failed: There are no MAPI identifiers available.
Global Const $ERROR_DS_DRA_MISSING_KRBTGT_SECRET = 8633                           ; The replication operation failed because the required attributes of the local krbtgt object are missing.
Global Const $ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST = 8634                        ; The domain name of the trusted domain already exists in the forest.
Global Const $ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST = 8635                          ; The flat name of the trusted domain already exists in the forest.
Global Const $ERROR_INVALID_USER_PRINCIPAL_NAME = 8636                            ; The User Principal Name (UPN) is invalid.
Global Const $ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = 8637                  ; OID mapped groups cannot have members.
Global Const $ERROR_DS_OID_NOT_FOUND = 8638                                       ; The specified OID cannot be found.
Global Const $DNS_ERROR_RCODE_FORMAT_ERROR = 9001                                 ; DNS server unable to interpret format.
Global Const $DNS_ERROR_RCODE_SERVER_FAILURE = 9002                               ; DNS server failure.
Global Const $DNS_ERROR_RCODE_NAME_ERROR = 9003                                   ; DNS name does not exist.
Global Const $DNS_ERROR_RCODE_NOT_IMPLEMENTED = 9004                              ; DNS request not supported by name server.
Global Const $DNS_ERROR_RCODE_REFUSED = 9005                                      ; DNS operation refused.
Global Const $DNS_ERROR_RCODE_YXDOMAIN = 9006                                     ; DNS name that ought not exist, does exist.
Global Const $DNS_ERROR_RCODE_YXRRSET = 9007                                      ; DNS RR set that ought not exist, does exist.
Global Const $DNS_ERROR_RCODE_NXRRSET = 9008                                      ; DNS RR set that ought to exist, does not exist.
Global Const $DNS_ERROR_RCODE_NOTAUTH = 9009                                      ; DNS server not authoritative for zone.
Global Const $DNS_ERROR_RCODE_NOTZONE = 9010                                      ; DNS name in update or prereq is not in zone.
Global Const $DNS_ERROR_RCODE_BADSIG = 9016                                       ; DNS signature failed to verify.
Global Const $DNS_ERROR_RCODE_BADKEY = 9017                                       ; DNS bad key.
Global Const $DNS_ERROR_RCODE_BADTIME = 9018                                      ; DNS signature validity expired.
Global Const $DNS_INFO_NO_RECORDS = 9501                                          ; No records found for given DNS query.
Global Const $DNS_ERROR_BAD_PACKET = 9502                                         ; Bad DNS packet.
Global Const $DNS_ERROR_NO_PACKET = 9503                                          ; No DNS packet.
Global Const $DNS_ERROR_RCODE = 9504                                              ; DNS error, check rcode.
Global Const $DNS_ERROR_UNSECURE_PACKET = 9505                                    ; Unsecured DNS packet.
Global Const $DNS_ERROR_INVALID_TYPE = 9551                                       ; Invalid DNS type.
Global Const $DNS_ERROR_INVALID_IP_ADDRESS = 9552                                 ; Invalid IP address.
Global Const $DNS_ERROR_INVALID_PROPERTY = 9553                                   ; Invalid property.
Global Const $DNS_ERROR_TRY_AGAIN_LATER = 9554                                    ; Try DNS operation again later.
Global Const $DNS_ERROR_NOT_UNIQUE = 9555                                         ; Record for given name and type is not unique.
Global Const $DNS_ERROR_NON_RFC_NAME = 9556                                       ; DNS name does not comply with RFC specifications.
Global Const $DNS_STATUS_FQDN = 9557                                              ; DNS name is a fully-qualified DNS name.
Global Const $DNS_STATUS_DOTTED_NAME = 9558                                       ; DNS name is dotted (multi-label).
Global Const $DNS_STATUS_SINGLE_PART_NAME = 9559                                  ; DNS name is a single-part name.
Global Const $DNS_ERROR_INVALID_NAME_CHAR = 9560                                  ; DNS name contains an invalid character.
Global Const $DNS_ERROR_NUMERIC_NAME = 9561                                       ; DNS name is entirely numeric.
Global Const $DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER = 9562                         ; The operation requested is not permitted on a DNS root server.
Global Const $DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION = 9563                       ; The record could not be created because this part of the DNS namespace has been delegated to another server.
Global Const $DNS_ERROR_CANNOT_FIND_ROOT_HINTS = 9564                             ; The DNS server could not find a set of root hints.
Global Const $DNS_ERROR_INCONSISTENT_ROOT_HINTS = 9565                            ; The DNS server found root hints but they were not consistent across all adapters.
Global Const $DNS_ERROR_DWORD_VALUE_TOO_SMALL = 9566                              ; The specified value is too small for this parameter.
Global Const $DNS_ERROR_DWORD_VALUE_TOO_LARGE = 9567                              ; The specified value is too large for this parameter.
Global Const $DNS_ERROR_BACKGROUND_LOADING = 9568                                 ; This operation is not allowed while the DNS server is loading zones in the background. Please try again later.
Global Const $DNS_ERROR_NOT_ALLOWED_ON_RODC = 9569                                ; The operation requested is not permitted on against a DNS server running on a read-only DC.
Global Const $DNS_ERROR_NOT_ALLOWED_UNDER_DNAME = 9570                            ; No data is allowed to exist underneath a DNAME record.
Global Const $DNS_ERROR_DELEGATION_REQUIRED = 9571                                ; This operation requires credentials delegation.
Global Const $DNS_ERROR_ZONE_DOES_NOT_EXIST = 9601                                ; DNS zone does not exist.
Global Const $DNS_ERROR_NO_ZONE_INFO = 9602                                       ; DNS zone information not available.
Global Const $DNS_ERROR_INVALID_ZONE_OPERATION = 9603                             ; Invalid operation for DNS zone.
Global Const $DNS_ERROR_ZONE_CONFIGURATION_ERROR = 9604                           ; Invalid DNS zone configuration.
Global Const $DNS_ERROR_ZONE_HAS_NO_SOA_RECORD = 9605                             ; DNS zone has no start of authority (SOA) record.
Global Const $DNS_ERROR_ZONE_HAS_NO_NS_RECORDS = 9606                             ; DNS zone has no Name Server (NS) record.
Global Const $DNS_ERROR_ZONE_LOCKED = 9607                                        ; DNS zone is locked.
Global Const $DNS_ERROR_ZONE_CREATION_FAILED = 9608                               ; DNS zone creation failed.
Global Const $DNS_ERROR_ZONE_ALREADY_EXISTS = 9609                                ; DNS zone already exists.
Global Const $DNS_ERROR_AUTOZONE_ALREADY_EXISTS = 9610                            ; DNS automatic zone already exists.
Global Const $DNS_ERROR_INVALID_ZONE_TYPE = 9611                                  ; Invalid DNS zone type.
Global Const $DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP = 9612                       ; Secondary DNS zone requires master IP address.
Global Const $DNS_ERROR_ZONE_NOT_SECONDARY = 9613                                 ; DNS zone not secondary.
Global Const $DNS_ERROR_NEED_SECONDARY_ADDRESSES = 9614                           ; Need secondary IP address.
Global Const $DNS_ERROR_WINS_INIT_FAILED = 9615                                   ; WINS initialization failed.
Global Const $DNS_ERROR_NEED_WINS_SERVERS = 9616                                  ; Need WINS servers.
Global Const $DNS_ERROR_NBSTAT_INIT_FAILED = 9617                                 ; NBTSTAT initialization call failed.
Global Const $DNS_ERROR_SOA_DELETE_INVALID = 9618                                 ; Invalid delete of start of authority (SOA).
Global Const $DNS_ERROR_FORWARDER_ALREADY_EXISTS = 9619                           ; A conditional forwarding zone already exists for that name.
Global Const $DNS_ERROR_ZONE_REQUIRES_MASTER_IP = 9620                            ; This zone must be configured with one or more master DNS server IP addresses.
Global Const $DNS_ERROR_ZONE_IS_SHUTDOWN = 9621                                   ; The operation cannot be performed because this zone is shutdown.
Global Const $DNS_ERROR_PRIMARY_REQUIRES_DATAFILE = 9651                          ; Primary DNS zone requires datafile.
Global Const $DNS_ERROR_INVALID_DATAFILE_NAME = 9652                              ; Invalid datafile name for DNS zone.
Global Const $DNS_ERROR_DATAFILE_OPEN_FAILURE = 9653                              ; Failed to open datafile for DNS zone.
Global Const $DNS_ERROR_FILE_WRITEBACK_FAILED = 9654                              ; Failed to write datafile for DNS zone.
Global Const $DNS_ERROR_DATAFILE_PARSING = 9655                                   ; Failure while reading datafile for DNS zone.
Global Const $DNS_ERROR_RECORD_DOES_NOT_EXIST = 9701                              ; DNS record does not exist.
Global Const $DNS_ERROR_RECORD_FORMAT = 9702                                      ; DNS record format error.
Global Const $DNS_ERROR_NODE_CREATION_FAILED = 9703                               ; Node creation failure in DNS.
Global Const $DNS_ERROR_UNKNOWN_RECORD_TYPE = 9704                                ; Unknown DNS record type.
Global Const $DNS_ERROR_RECORD_TIMED_OUT = 9705                                   ; DNS record timed out.
Global Const $DNS_ERROR_NAME_NOT_IN_ZONE = 9706                                   ; Name not in DNS zone.
Global Const $DNS_ERROR_CNAME_LOOP = 9707                                         ; CNAME loop detected.
Global Const $DNS_ERROR_NODE_IS_CNAME = 9708                                      ; Node is a CNAME DNS record.
Global Const $DNS_ERROR_CNAME_COLLISION = 9709                                    ; A CNAME record already exists for given name.
Global Const $DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT = 9710                           ; Record only at DNS zone root.
Global Const $DNS_ERROR_RECORD_ALREADY_EXISTS = 9711                              ; DNS record already exists.
Global Const $DNS_ERROR_SECONDARY_DATA = 9712                                     ; Secondary DNS zone data error.
Global Const $DNS_ERROR_NO_CREATE_CACHE_DATA = 9713                               ; Could not create DNS cache data.
Global Const $DNS_ERROR_NAME_DOES_NOT_EXIST = 9714                                ; DNS name does not exist.
Global Const $DNS_WARNING_PTR_CREATE_FAILED = 9715                                ; Could not create pointer (PTR) record.
Global Const $DNS_WARNING_DOMAIN_UNDELETED = 9716                                 ; DNS domain was undeleted.
Global Const $DNS_ERROR_DS_UNAVAILABLE = 9717                                     ; The directory service is unavailable.
Global Const $DNS_ERROR_DS_ZONE_ALREADY_EXISTS = 9718                             ; DNS zone already exists in the directory service.
Global Const $DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE = 9719                             ; DNS server not creating or reading the boot file for the directory service integrated DNS zone.
Global Const $DNS_ERROR_NODE_IS_DNAME = 9720                                      ; Node is a DNAME DNS record.
Global Const $DNS_ERROR_DNAME_COLLISION = 9721                                    ; A DNAME record already exists for given name.
Global Const $DNS_ERROR_ALIAS_LOOP = 9722                                         ; An alias loop has been detected with either CNAME or DNAME records.
Global Const $DNS_INFO_AXFR_COMPLETE = 9751                                       ; DNS AXFR (zone transfer) complete.
Global Const $DNS_ERROR_AXFR = 9752                                               ; DNS zone transfer failed.
Global Const $DNS_INFO_ADDED_LOCAL_WINS = 9753                                    ; Added local WINS server.
Global Const $DNS_STATUS_CONTINUE_NEEDED = 9801                                   ; Secure update call needs to continue update request.
Global Const $DNS_ERROR_NO_TCPIP = 9851                                           ; TCP/IP network protocol not installed.
Global Const $DNS_ERROR_NO_DNS_SERVERS = 9852                                     ; No DNS servers configured for local system.
Global Const $DNS_ERROR_DP_DOES_NOT_EXIST = 9901                                  ; The specified directory partition does not exist.
Global Const $DNS_ERROR_DP_ALREADY_EXISTS = 9902                                  ; The specified directory partition already exists.
Global Const $DNS_ERROR_DP_NOT_ENLISTED = 9903                                    ; This DNS server is not enlisted in the specified directory partition.
Global Const $DNS_ERROR_DP_ALREADY_ENLISTED = 9904                                ; This DNS server is already enlisted in the specified directory partition.
Global Const $DNS_ERROR_DP_NOT_AVAILABLE = 9905                                   ; The directory partition is not available at this time. Please wait a few minutes and try again.
Global Const $DNS_ERROR_DP_FSMO_ERROR = 9906                                      ; The application directory partition operation failed. The domain controller holding the domain naming master role is down or unable to service the request or is not running Windows Server 2003.
Global Const $WSAEINTR = 10004                                                    ; A blocking operation was interrupted by a call to WSACancelBlockingCall.
Global Const $WSAEBADF = 10009                                                    ; The file handle supplied is not valid.
Global Const $WSAEACCES = 10013                                                   ; An attempt was made to access a socket in a way forbidden by its access permissions.
Global Const $WSAEFAULT = 10014                                                   ; The system detected an invalid pointer address in attempting to use a pointer argument in a call.
Global Const $WSAEINVAL = 10022                                                   ; An invalid argument was supplied.
Global Const $WSAEMFILE = 10024                                                   ; Too many open sockets.
Global Const $WSAEWOULDBLOCK = 10035                                              ; A non-blocking socket operation could not be completed immediately.
Global Const $WSAEINPROGRESS = 10036                                              ; A blocking operation is currently executing.
Global Const $WSAEALREADY = 10037                                                 ; An operation was attempted on a non-blocking socket that already had an operation in progress.
Global Const $WSAENOTSOCK = 10038                                                 ; An operation was attempted on something that is not a socket.
Global Const $WSAEDESTADDRREQ = 10039                                             ; A required address was omitted from an operation on a socket.
Global Const $WSAEMSGSIZE = 10040                                                 ; A message sent on a datagram socket was larger than the internal message buffer or some other network limit, or the buffer used to receive a datagram into was smaller than the datagram itself.
Global Const $WSAEPROTOTYPE = 10041                                               ; A protocol was specified in the socket function call that does not support the semantics of the socket type requested.
Global Const $WSAENOPROTOOPT = 10042                                              ; An unknown, invalid, or unsupported option or level was specified in a getsockopt or setsockopt call.
Global Const $WSAEPROTONOSUPPORT = 10043                                          ; The requested protocol has not been configured into the system, or no implementation for it exists.
Global Const $WSAESOCKTNOSUPPORT = 10044                                          ; The support for the specified socket type does not exist in this address family.
Global Const $WSAEOPNOTSUPP = 10045                                               ; The attempted operation is not supported for the type of object referenced.
Global Const $WSAEPFNOSUPPORT = 10046                                             ; The protocol family has not been configured into the system or no implementation for it exists.
Global Const $WSAEAFNOSUPPORT = 10047                                             ; An address incompatible with the requested protocol was used.
Global Const $WSAEADDRINUSE = 10048                                               ; Only one usage of each socket address (protocol/network address/port) is normally permitted.
Global Const $WSAEADDRNOTAVAIL = 10049                                            ; The requested address is not valid in its context.
Global Const $WSAENETDOWN = 10050                                                 ; A socket operation encountered a dead network.
Global Const $WSAENETUNREACH = 10051                                              ; A socket operation was attempted to an unreachable network.
Global Const $WSAENETRESET = 10052                                                ; The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress.
Global Const $WSAECONNABORTED = 10053                                             ; An established connection was aborted by the software in your host machine.
Global Const $WSAECONNRESET = 10054                                               ; An existing connection was forcibly closed by the remote host.
Global Const $WSAENOBUFS = 10055                                                  ; An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.
Global Const $WSAEISCONN = 10056                                                  ; A connect request was made on an already connected socket.
Global Const $WSAENOTCONN = 10057                                                 ; A request to send or receive data was disallowed because the socket is not connected and (when sending on a datagram socket using a sendto call) no address was supplied.
Global Const $WSAESHUTDOWN = 10058                                                ; A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call.
Global Const $WSAETOOMANYREFS = 10059                                             ; Too many references to some kernel object.
Global Const $WSAETIMEDOUT = 10060                                                ; A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.
Global Const $WSAECONNREFUSED = 10061                                             ; No connection could be made because the target machine actively refused it.
Global Const $WSAELOOP = 10062                                                    ; Cannot translate name.
Global Const $WSAENAMETOOLONG = 10063                                             ; Name component or name was too long.
Global Const $WSAEHOSTDOWN = 10064                                                ; A socket operation failed because the destination host was down.
Global Const $WSAEHOSTUNREACH = 10065                                             ; A socket operation was attempted to an unreachable host.
Global Const $WSAENOTEMPTY = 10066                                                ; Cannot remove a directory that is not empty.
Global Const $WSAEPROCLIM = 10067                                                 ; A Windows Sockets implementation may have a limit on the number of applications that may use it simultaneously.
Global Const $WSAEUSERS = 10068                                                   ; Ran out of quota.
Global Const $WSAEDQUOT = 10069                                                   ; Ran out of disk quota.
Global Const $WSAESTALE = 10070                                                   ; File handle reference is no longer available.
Global Const $WSAEREMOTE = 10071                                                  ; Item is not available locally.
Global Const $WSASYSNOTREADY = 10091                                              ; WSAStartup cannot function at this time because the underlying system it uses to provide network services is currently unavailable.
Global Const $WSAVERNOTSUPPORTED = 10092                                          ; The Windows Sockets version requested is not supported.
Global Const $WSANOTINITIALISED = 10093                                           ; Either the application has not called WSAStartup, or WSAStartup failed.
Global Const $WSAEDISCON = 10101                                                  ; Returned by WSARecv or WSARecvFrom to indicate the remote party has initiated a graceful shutdown sequence.
Global Const $WSAENOMORE = 10102                                                  ; No more results can be returned by WSALookupServiceNext.
Global Const $WSAECANCELLED = 10103                                               ; A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.
Global Const $WSAEINVALIDPROCTABLE = 10104                                        ; The procedure call table is invalid.
Global Const $WSAEINVALIDPROVIDER = 10105                                         ; The requested service provider is invalid.
Global Const $WSAEPROVIDERFAILEDINIT = 10106                                      ; The requested service provider could not be loaded or initialized.
Global Const $WSASYSCALLFAILURE = 10107                                           ; A system call has failed.
Global Const $WSASERVICE_NOT_FOUND = 10108                                        ; No such service is known. The service cannot be found in the specified name space.
Global Const $WSATYPE_NOT_FOUND = 10109                                           ; The specified class was not found.
Global Const $WSA_E_NO_MORE = 10110                                               ; No more results can be returned by WSALookupServiceNext.
Global Const $WSA_E_CANCELLED = 10111                                             ; A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.
Global Const $WSAEREFUSED = 10112                                                 ; A database query failed because it was actively refused.
Global Const $WSAHOST_NOT_FOUND = 11001                                           ; No such host is known.
Global Const $WSATRY_AGAIN = 11002                                                ; This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server.
Global Const $WSANO_RECOVERY = 11003                                              ; A non-recoverable error occurred during a database lookup.
Global Const $WSANO_DATA = 11004                                                  ; The requested name is valid, but no data of the requested type was found.
Global Const $WSA_QOS_RECEIVERS = 11005                                           ; At least one reserve has arrived.
Global Const $WSA_QOS_SENDERS = 11006                                             ; At least one path has arrived.
Global Const $WSA_QOS_NO_SENDERS = 11007                                          ; There are no senders.
Global Const $WSA_QOS_NO_RECEIVERS = 11008                                        ; There are no receivers.
Global Const $WSA_QOS_REQUEST_CONFIRMED = 11009                                   ; Reserve has been confirmed.
Global Const $WSA_QOS_ADMISSION_FAILURE = 11010                                   ; Error due to lack of resources.
Global Const $WSA_QOS_POLICY_FAILURE = 11011                                      ; Rejected for administrative reasons - bad credentials.
Global Const $WSA_QOS_BAD_STYLE = 11012                                           ; Unknown or conflicting style.
Global Const $WSA_QOS_BAD_OBJECT = 11013                                          ; Problem with some part of the filterspec or providerspecific buffer in general.
Global Const $WSA_QOS_TRAFFIC_CTRL_ERROR = 11014                                  ; Problem with some part of the flowspec.
Global Const $WSA_QOS_GENERIC_ERROR = 11015                                       ; General QOS error.
Global Const $WSA_QOS_ESERVICETYPE = 11016                                        ; An invalid or unrecognized service type was found in the flowspec.
Global Const $WSA_QOS_EFLOWSPEC = 11017                                           ; An invalid or inconsistent flowspec was found in the QOS structure.
Global Const $WSA_QOS_EPROVSPECBUF = 11018                                        ; Invalid QOS provider-specific buffer.
Global Const $WSA_QOS_EFILTERSTYLE = 11019                                        ; An invalid QOS filter style was used.
Global Const $WSA_QOS_EFILTERTYPE = 11020                                         ; An invalid QOS filter type was used.
Global Const $WSA_QOS_EFILTERCOUNT = 11021                                        ; An incorrect number of QOS FILTERSPECs were specified in the FLOWDESCRIPTOR.
Global Const $WSA_QOS_EOBJLENGTH = 11022                                          ; An object with an invalid ObjectLength field was specified in the QOS provider-specific buffer.
Global Const $WSA_QOS_EFLOWCOUNT = 11023                                          ; An incorrect number of flow descriptors was specified in the QOS structure.
Global Const $WSA_QOS_EUNKOWNPSOBJ = 11024                                        ; An unrecognized object was found in the QOS provider-specific buffer.
Global Const $WSA_QOS_EPOLICYOBJ = 11025                                          ; An invalid policy object was found in the QOS provider-specific buffer.
Global Const $WSA_QOS_EFLOWDESC = 11026                                           ; An invalid QOS flow descriptor was found in the flow descriptor list.
Global Const $WSA_QOS_EPSFLOWSPEC = 11027                                         ; An invalid or inconsistent flowspec was found in the QOS provider specific buffer.
Global Const $WSA_QOS_EPSFILTERSPEC = 11028                                       ; An invalid FILTERSPEC was found in the QOS provider-specific buffer.
Global Const $WSA_QOS_ESDMODEOBJ = 11029                                          ; An invalid shape discard mode object was found in the QOS provider specific buffer.
Global Const $WSA_QOS_ESHAPERATEOBJ = 11030                                       ; An invalid shaping rate object was found in the QOS provider-specific buffer.
Global Const $WSA_QOS_RESERVED_PETYPE = 11031                                     ; A reserved policy element was found in the QOS provider-specific buffer.
Global Const $WSA_SECURE_HOST_NOT_FOUND = 11032                                   ; No such host is known securely.
Global Const $WSA_IPSEC_NAME_POLICY_ERROR = 11033                                 ; Name based IPSEC policy could not be added.
;Global Const $ERROR_INTERNET_* = 12000 - 12174                                   ; Internet Error Codes
Global Const $ERROR_IPSEC_QM_POLICY_EXISTS = 13000                                ; The specified quick mode policy already exists.
Global Const $ERROR_IPSEC_QM_POLICY_NOT_FOUND = 13001                             ; The specified quick mode policy was not found.
Global Const $ERROR_IPSEC_QM_POLICY_IN_USE = 13002                                ; The specified quick mode policy is being used.
Global Const $ERROR_IPSEC_MM_POLICY_EXISTS = 13003                                ; The specified main mode policy already exists.
Global Const $ERROR_IPSEC_MM_POLICY_NOT_FOUND = 13004                             ; The specified main mode policy was not found.
Global Const $ERROR_IPSEC_MM_POLICY_IN_USE = 13005                                ; The specified main mode policy is being used.
Global Const $ERROR_IPSEC_MM_FILTER_EXISTS = 13006                                ; The specified main mode filter already exists.
Global Const $ERROR_IPSEC_MM_FILTER_NOT_FOUND = 13007                             ; The specified main mode filter was not found.
Global Const $ERROR_IPSEC_TRANSPORT_FILTER_EXISTS = 13008                         ; The specified transport mode filter already exists.
Global Const $ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND = 13009                      ; The specified transport mode filter does not exist.
Global Const $ERROR_IPSEC_MM_AUTH_EXISTS = 13010                                  ; The specified main mode authentication list exists.
Global Const $ERROR_IPSEC_MM_AUTH_NOT_FOUND = 13011                               ; The specified main mode authentication list was not found.
Global Const $ERROR_IPSEC_MM_AUTH_IN_USE = 13012                                  ; The specified main mode authentication list is being used.
Global Const $ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND = 13013                     ; The specified default main mode policy was not found.
Global Const $ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND = 13014                       ; The specified default main mode authentication list was not found.
Global Const $ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND = 13015                     ; The specified default quick mode policy was not found.
Global Const $ERROR_IPSEC_TUNNEL_FILTER_EXISTS = 13016                            ; The specified tunnel mode filter exists.
Global Const $ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND = 13017                         ; The specified tunnel mode filter was not found.
Global Const $ERROR_IPSEC_MM_FILTER_PENDING_DELETION = 13018                      ; The Main Mode filter is pending deletion.
Global Const $ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION = 13019               ; The transport filter is pending deletion.
Global Const $ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION = 13020                  ; The tunnel filter is pending deletion.
Global Const $ERROR_IPSEC_MM_POLICY_PENDING_DELETION = 13021                      ; The Main Mode policy is pending deletion.
Global Const $ERROR_IPSEC_MM_AUTH_PENDING_DELETION = 13022                        ; The Main Mode authentication bundle is pending deletion.
Global Const $ERROR_IPSEC_QM_POLICY_PENDING_DELETION = 13023                      ; The Quick Mode policy is pending deletion.
Global Const $WARNING_IPSEC_MM_POLICY_PRUNED = 13024                              ; The Main Mode policy was successfully added, but some of the requested offers are not supported.
Global Const $WARNING_IPSEC_QM_POLICY_PRUNED = 13025                              ; The Quick Mode policy was successfully added, but some of the requested offers are not supported.
Global Const $ERROR_IPSEC_IKE_NEG_STATUS_BEGIN = 13800                            ; ERROR_IPSEC_IKE_NEG_STATUS_BEGIN
Global Const $ERROR_IPSEC_IKE_AUTH_FAIL = 13801                                   ; IKE authentication credentials are unacceptable.
Global Const $ERROR_IPSEC_IKE_ATTRIB_FAIL = 13802                                 ; IKE security attributes are unacceptable.
Global Const $ERROR_IPSEC_IKE_NEGOTIATION_PENDING = 13803                         ; IKE Negotiation in progress.
Global Const $ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR = 13804                    ; General processing error.
Global Const $ERROR_IPSEC_IKE_TIMED_OUT = 13805                                   ; Negotiation timed out.
Global Const $ERROR_IPSEC_IKE_NO_CERT = 13806                                     ; IKE failed to find valid machine certificate. Contact your Network Security Administrator about installing a valid certificate in the appropriate Certificate Store.
Global Const $ERROR_IPSEC_IKE_SA_DELETED = 13807                                  ; IKE SA deleted by peer before establishment completed.
Global Const $ERROR_IPSEC_IKE_SA_REAPED = 13808                                   ; IKE SA deleted before establishment completed.
Global Const $ERROR_IPSEC_IKE_MM_ACQUIRE_DROP = 13809                             ; Negotiation request sat in Queue too long.
Global Const $ERROR_IPSEC_IKE_QM_ACQUIRE_DROP = 13810                             ; Negotiation request sat in Queue too long.
Global Const $ERROR_IPSEC_IKE_QUEUE_DROP_MM = 13811                               ; Negotiation request sat in Queue too long.
Global Const $ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM = 13812                            ; Negotiation request sat in Queue too long.
Global Const $ERROR_IPSEC_IKE_DROP_NO_RESPONSE = 13813                            ; No response from peer.
Global Const $ERROR_IPSEC_IKE_MM_DELAY_DROP = 13814                               ; Negotiation took too long.
Global Const $ERROR_IPSEC_IKE_QM_DELAY_DROP = 13815                               ; Negotiation took too long.
Global Const $ERROR_IPSEC_IKE_ERROR = 13816                                       ; Unknown error occurred.
Global Const $ERROR_IPSEC_IKE_CRL_FAILED = 13817                                  ; Certificate Revocation Check failed.
Global Const $ERROR_IPSEC_IKE_INVALID_KEY_USAGE = 13818                           ; Invalid certificate key usage.
Global Const $ERROR_IPSEC_IKE_INVALID_CERT_TYPE = 13819                           ; Invalid certificate type.
Global Const $ERROR_IPSEC_IKE_NO_PRIVATE_KEY = 13820                              ; IKE negotiation failed because the machine certificate used does not have a private key. IPsec certificates require a private key. Contact your Network Security administrator about replacing with a certificate that has a private key.
Global Const $ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY = 13821                          ; Simultaneous rekeys were detected.
Global Const $ERROR_IPSEC_IKE_DH_FAIL = 13822                                     ; Failure in Diffie-Hellman computation.
Global Const $ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED = 13823             ; Don't know how to process critical payload.
Global Const $ERROR_IPSEC_IKE_INVALID_HEADER = 13824                              ; Invalid header.
Global Const $ERROR_IPSEC_IKE_NO_POLICY = 13825                                   ; No policy configured.
Global Const $ERROR_IPSEC_IKE_INVALID_SIGNATURE = 13826                           ; Failed to verify signature.
Global Const $ERROR_IPSEC_IKE_KERBEROS_ERROR = 13827                              ; Failed to authenticate using Kerberos.
Global Const $ERROR_IPSEC_IKE_NO_PUBLIC_KEY = 13828                               ; Peer's certificate did not have a public key.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR = 13829                                 ; Error processing error payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_SA = 13830                              ; Error processing SA payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_PROP = 13831                            ; Error processing Proposal payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_TRANS = 13832                           ; Error processing Transform payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_KE = 13833                              ; Error processing KE payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_ID = 13834                              ; Error processing ID payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_CERT = 13835                            ; Error processing Cert payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ = 13836                        ; Error processing Certificate Request payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_HASH = 13837                            ; Error processing Hash payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_SIG = 13838                             ; Error processing Signature payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_NONCE = 13839                           ; Error processing Nonce payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY = 13840                          ; Error processing Notify payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_DELETE = 13841                          ; Error processing Delete Payload.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR = 13842                          ; Error processing VendorId payload.
Global Const $ERROR_IPSEC_IKE_INVALID_PAYLOAD = 13843                             ; Invalid payload received.
Global Const $ERROR_IPSEC_IKE_LOAD_SOFT_SA = 13844                                ; Soft SA loaded.
Global Const $ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN = 13845                           ; Soft SA torn down.
Global Const $ERROR_IPSEC_IKE_INVALID_COOKIE = 13846                              ; Invalid cookie received.
Global Const $ERROR_IPSEC_IKE_NO_PEER_CERT = 13847                                ; Peer failed to send valid machine certificate.
Global Const $ERROR_IPSEC_IKE_PEER_CRL_FAILED = 13848                             ; Certification Revocation check of peer's certificate failed.
Global Const $ERROR_IPSEC_IKE_POLICY_CHANGE = 13849                               ; New policy invalidated SAs formed with old policy.
Global Const $ERROR_IPSEC_IKE_NO_MM_POLICY = 13850                                ; There is no available Main Mode IKE policy.
Global Const $ERROR_IPSEC_IKE_NOTCBPRIV = 13851                                   ; Failed to enabled TCB privilege.
Global Const $ERROR_IPSEC_IKE_SECLOADFAIL = 13852                                 ; Failed to load SECURITY.DLL.
Global Const $ERROR_IPSEC_IKE_FAILSSPINIT = 13853                                 ; Failed to obtain security function table dispatch address from SSPI.
Global Const $ERROR_IPSEC_IKE_FAILQUERYSSP = 13854                                ; Failed to query Kerberos package to obtain max token size.
Global Const $ERROR_IPSEC_IKE_SRVACQFAIL = 13855                                  ; Failed to obtain Kerberos server credentials for ISAKMP/ERROR_IPSEC_IKE service. Kerberos authentication will not function. The most likely reason for this is lack of domain membership. This is normal if your computer is a member of a workgroup.
Global Const $ERROR_IPSEC_IKE_SRVQUERYCRED = 13856                                ; Failed to determine SSPI principal name for ISAKMP/ERROR_IPSEC_IKE service (QueryCredentialsAttributes).
Global Const $ERROR_IPSEC_IKE_GETSPIFAIL = 13857                                  ; Failed to obtain new SPI for the inbound SA from Ipsec driver. The most common cause for this is that the driver does not have the correct filter. Check your policy to verify the filters.
Global Const $ERROR_IPSEC_IKE_INVALID_FILTER = 13858                              ; Given filter is invalid.
Global Const $ERROR_IPSEC_IKE_OUT_OF_MEMORY = 13859                               ; Memory allocation failed.
Global Const $ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED = 13860                       ; Failed to add Security Association to IPSec Driver. The most common cause for this is if the IKE negotiation took too long to complete. If the problem persists, reduce the load on the faulting machine.
Global Const $ERROR_IPSEC_IKE_INVALID_POLICY = 13861                              ; Invalid policy.
Global Const $ERROR_IPSEC_IKE_UNKNOWN_DOI = 13862                                 ; Invalid DOI.
Global Const $ERROR_IPSEC_IKE_INVALID_SITUATION = 13863                           ; Invalid situation.
Global Const $ERROR_IPSEC_IKE_DH_FAILURE = 13864                                  ; Diffie-Hellman failure.
Global Const $ERROR_IPSEC_IKE_INVALID_GROUP = 13865                               ; Invalid Diffie-Hellman group.
Global Const $ERROR_IPSEC_IKE_ENCRYPT = 13866                                     ; Error encrypting payload.
Global Const $ERROR_IPSEC_IKE_DECRYPT = 13867                                     ; Error decrypting payload.
Global Const $ERROR_IPSEC_IKE_POLICY_MATCH = 13868                                ; Policy match error.
Global Const $ERROR_IPSEC_IKE_UNSUPPORTED_ID = 13869                              ; Unsupported ID.
Global Const $ERROR_IPSEC_IKE_INVALID_HASH = 13870                                ; Hash verification failed.
Global Const $ERROR_IPSEC_IKE_INVALID_HASH_ALG = 13871                            ; Invalid hash algorithm.
Global Const $ERROR_IPSEC_IKE_INVALID_HASH_SIZE = 13872                           ; Invalid hash size.
Global Const $ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG = 13873                         ; Invalid encryption algorithm.
Global Const $ERROR_IPSEC_IKE_INVALID_AUTH_ALG = 13874                            ; Invalid authentication algorithm.
Global Const $ERROR_IPSEC_IKE_INVALID_SIG = 13875                                 ; Invalid certificate signature.
Global Const $ERROR_IPSEC_IKE_LOAD_FAILED = 13876                                 ; Load failed.
Global Const $ERROR_IPSEC_IKE_RPC_DELETE = 13877                                  ; Deleted via RPC call.
Global Const $ERROR_IPSEC_IKE_BENIGN_REINIT = 13878                               ; Temporary state created to perform reinit. This is not a real failure.
Global Const $ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY = 13879           ; The lifetime value received in the Responder Lifetime Notify is below the Windows 2000 configured minimum value. Please fix the policy on the peer machine.
Global Const $ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION = 13880                       ; The recipient cannot handle version of IKE specified in the header.
Global Const $ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN = 13881                         ; Key length in certificate is too small for configured security requirements.
Global Const $ERROR_IPSEC_IKE_MM_LIMIT = 13882                                    ; Max number of established MM SAs to peer exceeded.
Global Const $ERROR_IPSEC_IKE_NEGOTIATION_DISABLED = 13883                        ; IKE received a policy that disables negotiation.
Global Const $ERROR_IPSEC_IKE_QM_LIMIT = 13884                                    ; Reached maximum quick mode limit for the main mode. New main mode will be started.
Global Const $ERROR_IPSEC_IKE_MM_EXPIRED = 13885                                  ; Main mode SA lifetime expired or peer sent a main mode delete.
Global Const $ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID = 13886                     ; Main mode SA assumed to be invalid because peer stopped responding.
Global Const $ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH = 13887                  ; Certificate doesn't chain to a trusted root in IPsec policy.
Global Const $ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID = 13888                       ; Received unexpected message ID.
Global Const $ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD = 13889                        ; Received invalid authentication offers.
Global Const $ERROR_IPSEC_IKE_DOS_COOKIE_SENT = 13890                             ; Sent DOS cookie notify to initiator.
Global Const $ERROR_IPSEC_IKE_SHUTTING_DOWN = 13891                               ; IKE service is shutting down.
Global Const $ERROR_IPSEC_IKE_CGA_AUTH_FAILED = 13892                             ; Could not verify binding between CGA address and certificate.
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_NATOA = 13893                           ; Error processing NatOA payload.
Global Const $ERROR_IPSEC_IKE_INVALID_MM_FOR_QM = 13894                           ; Parameters of the main mode are invalid for this quick mode.
Global Const $ERROR_IPSEC_IKE_QM_EXPIRED = 13895                                  ; Quick mode SA was expired by IPsec driver.
Global Const $ERROR_IPSEC_IKE_TOO_MANY_FILTERS = 13896                            ; Too many dynamically added IKEEXT filters were detected.
Global Const $ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL = 13898                       ; NAP reauth succeeded and must delete the dummy NAP IkeV2 tunnel.
Global Const $ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE = 13899                 ; Error in assigning inner IP address to initiator in tunnel mode.
Global Const $ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING = 13900                  ; Require configuration payload missing.
Global Const $ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING = 13901    ; A negotiation running as the security principle who issued the connection is in progress.
Global Const $ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS = 13902                        ; SA was deleted due to IKEv1/AuthIP co-existence suppress check.
Global Const $ERROR_IPSEC_IKE_RATELIMIT_DROP = 13903                              ; Incoming SA request was dropped due to peer IP address rate limiting.
Global Const $ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE = 13904                  ; Peer does not support MOBIKE.
Global Const $ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE = 13905                       ; SA establishment is not authorized.
Global Const $ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END = 13909                     ; ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END
Global Const $ERROR_IPSEC_BAD_SPI = 13910                                         ; The SPI in the packet does not match a valid IPsec SA.
Global Const $ERROR_IPSEC_SA_LIFETIME_EXPIRED = 13911                             ; Packet was received on an IPsec SA whose lifetime has expired.
Global Const $ERROR_IPSEC_WRONG_SA = 13912                                        ; Packet was received on an IPsec SA that doesn't match the packet characteristics.
Global Const $ERROR_IPSEC_REPLAY_CHECK_FAILED = 13913                             ; Packet sequence number replay check failed.
Global Const $ERROR_IPSEC_INVALID_PACKET = 13914                                  ; IPsec header and/or trailer in the packet is invalid.
Global Const $ERROR_IPSEC_INTEGRITY_CHECK_FAILED = 13915                          ; IPsec integrity check failed.
Global Const $ERROR_IPSEC_CLEAR_TEXT_DROP = 13916                                 ; IPsec dropped a clear text packet.
Global Const $ERROR_IPSEC_AUTH_FIREWALL_DROP = 13917                              ; IPsec dropped an incoming ESP packet in authenticated firewall mode. This drop is benign.
Global Const $ERROR_IPSEC_THROTTLE_DROP = 13918                                   ; IPsec dropped a packet due to DOS throttle.
Global Const $ERROR_IPSEC_DOSP_BLOCK = 13925                                      ; IPsec Dos Protection matched an explicit block rule.
Global Const $ERROR_IPSEC_DOSP_RECEIVED_MULTICAST = 13926                         ; IPsec Dos Protection received an IPsec specific multicast packet which is not allowed.
Global Const $ERROR_IPSEC_DOSP_INVALID_PACKET = 13927                             ; IPsec Dos Protection received an incorrectly formatted packet.
Global Const $ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED = 13928                        ; IPsec Dos Protection failed to lookup state.
Global Const $ERROR_IPSEC_DOSP_MAX_ENTRIES = 13929                                ; IPsec Dos Protection failed to create state because there are already maximum number of entries allowed by policy.
Global Const $ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = 13930                         ; IPsec Dos Protection received an IPsec negotiation packet for a keying module which is not allowed by policy.
Global Const $ERROR_IPSEC_DOSP_NOT_INSTALLED = 13931                              ; IPsec Dos Protection has not been enabled.
Global Const $ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = 13932                ; IPsec Dos Protection failed to create per internal IP ratelimit queue because there is already maximum number of queues allowed by policy.
Global Const $ERROR_SXS_SECTION_NOT_FOUND = 14000                                 ; The requested section was not present in the activation context.
Global Const $ERROR_SXS_CANT_GEN_ACTCTX = 14001                                   ; The application has failed to start because its side-by-side configuration is incorrect. Please see the application event log or use the command-line sxstrace.exe tools for more detail.
Global Const $ERROR_SXS_INVALID_ACTCTXDATA_FORMAT = 14002                         ; The application binding data format is invalid.
Global Const $ERROR_SXS_ASSEMBLY_NOT_FOUND = 14003                                ; The referenced assembly is not installed on your system.
Global Const $ERROR_SXS_MANIFEST_FORMAT_ERROR = 14004                             ; The manifest file does not begin with the required tag and format information.
Global Const $ERROR_SXS_MANIFEST_PARSE_ERROR = 14005                              ; The manifest file contains one or more syntax errors.
Global Const $ERROR_SXS_ACTIVATION_CONTEXT_DISABLED = 14006                       ; The application attempted to activate a disabled activation context.
Global Const $ERROR_SXS_KEY_NOT_FOUND = 14007                                     ; The requested lookup key was not found in any active activation context.
Global Const $ERROR_SXS_VERSION_CONFLICT = 14008                                  ; A component version required by the application conflicts with another component version already active.
Global Const $ERROR_SXS_WRONG_SECTION_TYPE = 14009                                ; The type requested activation context section does not match the query API used.
Global Const $ERROR_SXS_THREAD_QUERIES_DISABLED = 14010                           ; Lack of system resources has required isolated activation to be disabled for the current thread of execution.
Global Const $ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET = 14011                       ; An attempt to set the process default activation context failed because the process default activation context was already set.
Global Const $ERROR_SXS_UNKNOWN_ENCODING_GROUP = 14012                            ; The encoding group identifier specified is not recognized.
Global Const $ERROR_SXS_UNKNOWN_ENCODING = 14013                                  ; The encoding requested is not recognized.
Global Const $ERROR_SXS_INVALID_XML_NAMESPACE_URI = 14014                         ; The manifest contains a reference to an invalid URI.
Global Const $ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED = 14015            ; The application manifest contains a reference to a dependent assembly which is not installed.
Global Const $ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED = 14016            ; The manifest for an assembly used by the application has a reference to a dependent assembly which is not installed.
Global Const $ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE = 14017               ; The manifest contains an attribute for the assembly identity which is not valid.
Global Const $ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE = 14018       ; The manifest is missing the required default namespace specification on the assembly element.
Global Const $ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE = 14019       ; The manifest has a default namespace specified on the assembly element but its value is not "urn:schemas-microsoft-com:asm.v1".
Global Const $ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT = 14020    ; The private manifest probed has crossed a path with an unsupported reparse point.
Global Const $ERROR_SXS_DUPLICATE_DLL_NAME = 14021                                ; Two or more components referenced directly or indirectly by the application manifest have files by the same name.
Global Const $ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME = 14022                        ; Two or more components referenced directly or indirectly by the application manifest have window classes with the same name.
Global Const $ERROR_SXS_DUPLICATE_CLSID = 14023                                   ; Two or more components referenced directly or indirectly by the application manifest have the same COM server CLSIDs.
Global Const $ERROR_SXS_DUPLICATE_IID = 14024                                     ; Two or more components referenced directly or indirectly by the application manifest have proxies for the same COM interface IIDs.
Global Const $ERROR_SXS_DUPLICATE_TLBID = 14025                                   ; Two or more components referenced directly or indirectly by the application manifest have the same COM type library TLBIDs.
Global Const $ERROR_SXS_DUPLICATE_PROGID = 14026                                  ; Two or more components referenced directly or indirectly by the application manifest have the same COM ProgIDs.
Global Const $ERROR_SXS_DUPLICATE_ASSEMBLY_NAME = 14027                           ; Two or more components referenced directly or indirectly by the application manifest are different versions of the same component which is not permitted.
Global Const $ERROR_SXS_FILE_HASH_MISMATCH = 14028                                ; A component's file does not match the verification information present in the component manifest.
Global Const $ERROR_SXS_POLICY_PARSE_ERROR = 14029                                ; The policy manifest contains one or more syntax errors.
Global Const $ERROR_SXS_XML_E_MISSINGQUOTE = 14030                                ; Manifest Parse Error : A string literal was expected, but no opening quote character was found.
Global Const $ERROR_SXS_XML_E_COMMENTSYNTAX = 14031                               ; Manifest Parse Error : Incorrect syntax was used in a comment.
Global Const $ERROR_SXS_XML_E_BADSTARTNAMECHAR = 14032                            ; Manifest Parse Error : A name was started with an invalid character.
Global Const $ERROR_SXS_XML_E_BADNAMECHAR = 14033                                 ; Manifest Parse Error : A name contained an invalid character.
Global Const $ERROR_SXS_XML_E_BADCHARINSTRING = 14034                             ; Manifest Parse Error : A string literal contained an invalid character.
Global Const $ERROR_SXS_XML_E_XMLDECLSYNTAX = 14035                               ; Manifest Parse Error : Invalid syntax for an xml declaration.
Global Const $ERROR_SXS_XML_E_BADCHARDATA = 14036                                 ; Manifest Parse Error : An Invalid character was found in text content.
Global Const $ERROR_SXS_XML_E_MISSINGWHITESPACE = 14037                           ; Manifest Parse Error : Required white space was missing.
Global Const $ERROR_SXS_XML_E_EXPECTINGTAGEND = 14038                             ; Manifest Parse Error : The character '>' was expected.
Global Const $ERROR_SXS_XML_E_MISSINGSEMICOLON = 14039                            ; Manifest Parse Error : A semi colon character was expected.
Global Const $ERROR_SXS_XML_E_UNBALANCEDPAREN = 14040                             ; Manifest Parse Error : Unbalanced parentheses.
Global Const $ERROR_SXS_XML_E_INTERNALERROR = 14041                               ; Manifest Parse Error : Internal error.
Global Const $ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE = 14042                       ; Manifest Parse Error : Whitespace is not allowed at this location.
Global Const $ERROR_SXS_XML_E_INCOMPLETE_ENCODING = 14043                         ; Manifest Parse Error : End of file reached in invalid state for current encoding.
Global Const $ERROR_SXS_XML_E_MISSING_PAREN = 14044                               ; Manifest Parse Error : Missing parenthesis.
Global Const $ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE = 14045                         ; Manifest Parse Error : A single or double closing quote character (\' or \") is missing.
Global Const $ERROR_SXS_XML_E_MULTIPLE_COLONS = 14046                             ; Manifest Parse Error : Multiple colons are not allowed in a name.
Global Const $ERROR_SXS_XML_E_INVALID_DECIMAL = 14047                             ; Manifest Parse Error : Invalid character for decimal digit.
Global Const $ERROR_SXS_XML_E_INVALID_HEXIDECIMAL = 14048                         ; Manifest Parse Error : Invalid character for hexadecimal digit.
Global Const $ERROR_SXS_XML_E_INVALID_UNICODE = 14049                             ; Manifest Parse Error : Invalid unicode character value for this platform.
Global Const $ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK = 14050                    ; Manifest Parse Error : Expecting whitespace or '?'.
Global Const $ERROR_SXS_XML_E_UNEXPECTEDENDTAG = 14051                            ; Manifest Parse Error : End tag was not expected at this location.
Global Const $ERROR_SXS_XML_E_UNCLOSEDTAG = 14052                                 ; Manifest Parse Error : The following tags were not closed: %1.
Global Const $ERROR_SXS_XML_E_DUPLICATEATTRIBUTE = 14053                          ; Manifest Parse Error : Duplicate attribute.
Global Const $ERROR_SXS_XML_E_MULTIPLEROOTS = 14054                               ; Manifest Parse Error : Only one top level element is allowed in an XML document.
Global Const $ERROR_SXS_XML_E_INVALIDATROOTLEVEL = 14055                          ; Manifest Parse Error : Invalid at the top level of the document.
Global Const $ERROR_SXS_XML_E_BADXMLDECL = 14056                                  ; Manifest Parse Error : Invalid xml declaration.
Global Const $ERROR_SXS_XML_E_MISSINGROOT = 14057                                 ; Manifest Parse Error : XML document must have a top level element.
Global Const $ERROR_SXS_XML_E_UNEXPECTEDEOF = 14058                               ; Manifest Parse Error : Unexpected end of file.
Global Const $ERROR_SXS_XML_E_BADPEREFINSUBSET = 14059                            ; Manifest Parse Error : Parameter entities cannot be used inside markup declarations in an internal subset.
Global Const $ERROR_SXS_XML_E_UNCLOSEDSTARTTAG = 14060                            ; Manifest Parse Error : Element was not closed.
Global Const $ERROR_SXS_XML_E_UNCLOSEDENDTAG = 14061                              ; Manifest Parse Error : End element was missing the character '>'.
Global Const $ERROR_SXS_XML_E_UNCLOSEDSTRING = 14062                              ; Manifest Parse Error : A string literal was not closed.
Global Const $ERROR_SXS_XML_E_UNCLOSEDCOMMENT = 14063                             ; Manifest Parse Error : A comment was not closed.
Global Const $ERROR_SXS_XML_E_UNCLOSEDDECL = 14064                                ; Manifest Parse Error : A declaration was not closed.
Global Const $ERROR_SXS_XML_E_UNCLOSEDCDATA = 14065                               ; Manifest Parse Error : A CDATA section was not closed.
Global Const $ERROR_SXS_XML_E_RESERVEDNAMESPACE = 14066                           ; Manifest Parse Error : The namespace prefix is not allowed to start with the reserved string "xml".
Global Const $ERROR_SXS_XML_E_INVALIDENCODING = 14067                             ; Manifest Parse Error : System does not support the specified encoding.
Global Const $ERROR_SXS_XML_E_INVALIDSWITCH = 14068                               ; Manifest Parse Error : Switch from current encoding to specified encoding not supported.
Global Const $ERROR_SXS_XML_E_BADXMLCASE = 14069                                  ; Manifest Parse Error : The name 'xml' is reserved and must be lower case.
Global Const $ERROR_SXS_XML_E_INVALID_STANDALONE = 14070                          ; Manifest Parse Error : The standalone attribute must have the value 'yes' or 'no'.
Global Const $ERROR_SXS_XML_E_UNEXPECTED_STANDALONE = 14071                       ; Manifest Parse Error : The standalone attribute cannot be used in external entities.
Global Const $ERROR_SXS_XML_E_INVALID_VERSION = 14072                             ; Manifest Parse Error : Invalid version number.
Global Const $ERROR_SXS_XML_E_MISSINGEQUALS = 14073                               ; Manifest Parse Error : Missing equals sign between attribute and attribute value.
Global Const $ERROR_SXS_PROTECTION_RECOVERY_FAILED = 14074                        ; Assembly Protection Error : Unable to recover the specified assembly.
Global Const $ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT = 14075                   ; Assembly Protection Error : The public key for an assembly was too short to be allowed.
Global Const $ERROR_SXS_PROTECTION_CATALOG_NOT_VALID = 14076                      ; Assembly Protection Error : The catalog for an assembly is not valid, or does not match the assembly's manifest.
Global Const $ERROR_SXS_UNTRANSLATABLE_HRESULT = 14077                            ; An HRESULT could not be translated to a corresponding Win32 error code.
Global Const $ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING = 14078                   ; Assembly Protection Error : The catalog for an assembly is missing.
Global Const $ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE = 14079               ; The supplied assembly identity is missing one or more attributes which must be present in this context.
Global Const $ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME = 14080          ; The supplied assembly identity has one or more attribute names that contain characters not permitted in XML names.
Global Const $ERROR_SXS_ASSEMBLY_MISSING = 14081                                  ; The referenced assembly could not be found.
Global Const $ERROR_SXS_CORRUPT_ACTIVATION_STACK = 14082                          ; The activation context activation stack for the running thread of execution is corrupt.
Global Const $ERROR_SXS_CORRUPTION = 14083                                        ; The application isolation metadata for this process or thread has become corrupt.
Global Const $ERROR_SXS_EARLY_DEACTIVATION = 14084                                ; The activation context being deactivated is not the most recently activated one.
Global Const $ERROR_SXS_INVALID_DEACTIVATION = 14085                              ; The activation context being deactivated is not active for the current thread of execution.
Global Const $ERROR_SXS_MULTIPLE_DEACTIVATION = 14086                             ; The activation context being deactivated has already been deactivated.
Global Const $ERROR_SXS_PROCESS_TERMINATION_REQUESTED = 14087                     ; A component used by the isolation facility has requested to terminate the process.
Global Const $ERROR_SXS_RELEASE_ACTIVATION_CONTEXT = 14088                        ; A kernel mode component is releasing a reference on an activation context.
Global Const $ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = 14089           ; The activation context of system default assembly could not be generated.
Global Const $ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = 14090                  ; The value of an attribute in an identity is not within the legal range.
Global Const $ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = 14091                   ; The name of an attribute in an identity is not within the legal range.
Global Const $ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = 14092                      ; An identity contains two definitions for the same attribute.
Global Const $ERROR_SXS_IDENTITY_PARSE_ERROR = 14093                              ; The identity string is malformed. This may be due to a trailing comma, more than two unnamed attributes, missing attribute name or missing attribute value.
Global Const $ERROR_MALFORMED_SUBSTITUTION_STRING = 14094                         ; A string containing localized substitutable content was malformed. Either a dollar sign ($) was followed by something other than a left parenthesis or another dollar sign or an substitution's right parenthesis was not found.
Global Const $ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN = 14095                        ; The public key token does not correspond to the public key specified.
Global Const $ERROR_UNMAPPED_SUBSTITUTION_STRING = 14096                          ; A substitution string had no mapping.
Global Const $ERROR_SXS_ASSEMBLY_NOT_LOCKED = 14097                               ; The component must be locked before making the request.
Global Const $ERROR_SXS_COMPONENT_STORE_CORRUPT = 14098                           ; The component store has been corrupted.
Global Const $ERROR_ADVANCED_INSTALLER_FAILED = 14099                             ; An advanced installer failed during setup or servicing.
Global Const $ERROR_XML_ENCODING_MISMATCH = 14100                                 ; The character encoding in the XML declaration did not match the encoding used in the document.
Global Const $ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = 14101     ; The identities of the manifests are identical but their contents are different.
Global Const $ERROR_SXS_IDENTITIES_DIFFERENT = 14102                              ; The component identities are different.
Global Const $ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = 14103                      ; The assembly is not a deployment.
Global Const $ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY = 14104                         ; The file is not a part of the assembly.
Global Const $ERROR_SXS_MANIFEST_TOO_BIG = 14105                                  ; The size of the manifest exceeds the maximum allowed.
Global Const $ERROR_SXS_SETTING_NOT_REGISTERED = 14106                            ; The setting is not registered.
Global Const $ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE = 14107                    ; One or more required members of the transaction are not present.
Global Const $ERROR_SMI_PRIMITIVE_INSTALLER_FAILED = 14108                        ; The SMI primitive installer failed during setup or servicing.
Global Const $ERROR_GENERIC_COMMAND_FAILED = 14109                                ; A generic command executable returned a result that indicates failure.
Global Const $ERROR_SXS_FILE_HASH_MISSING = 14110                                 ; A component is missing file verification information in its manifest.
Global Const $ERROR_EVT_INVALID_CHANNEL_PATH = 15000                              ; The specified channel path is invalid.
Global Const $ERROR_EVT_INVALID_QUERY = 15001                                     ; The specified query is invalid.
Global Const $ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND = 15002                      ; The publisher metadata cannot be found in the resource.
Global Const $ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND = 15003                          ; The template for an event definition cannot be found in the resource (error = %1).
Global Const $ERROR_EVT_INVALID_PUBLISHER_NAME = 15004                            ; The specified publisher name is invalid.
Global Const $ERROR_EVT_INVALID_EVENT_DATA = 15005                                ; The event data raised by the publisher is not compatible with the event template definition in the publisher's manifest.
Global Const $ERROR_EVT_CHANNEL_NOT_FOUND = 15007                                 ; The specified channel could not be found. Check channel configuration.
Global Const $ERROR_EVT_MALFORMED_XML_TEXT = 15008                                ; The specified xml text was not well-formed. See Extended Error for more details.
Global Const $ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL = 15009                    ; The caller is trying to subscribe to a direct channel which is not allowed. The events for a direct channel go directly to a logfile and cannot be subscribed to.
Global Const $ERROR_EVT_CONFIGURATION_ERROR = 15010                               ; Configuration error.
Global Const $ERROR_EVT_QUERY_RESULT_STALE = 15011                                ; The query result is stale / invalid. This may be due to the log being cleared or rolling over after the query result was created. Users should handle this code by releasing the query result object and reissuing the query.
Global Const $ERROR_EVT_QUERY_RESULT_INVALID_POSITION = 15012                     ; Query result is currently at an invalid position.
Global Const $ERROR_EVT_NON_VALIDATING_MSXML = 15013                              ; Registered MSXML doesn't support validation.
Global Const $ERROR_EVT_FILTER_ALREADYSCOPED = 15014                              ; An expression can only be followed by a change of scope operation if it itself evaluates to a node set and is not already part of some other change of scope operation.
Global Const $ERROR_EVT_FILTER_NOTELTSET = 15015                                  ; Can't perform a step operation from a term that does not represent an element set.
Global Const $ERROR_EVT_FILTER_INVARG = 15016                                     ; Left hand side arguments to binary operators must be either attributes, nodes or variables and right hand side arguments must be constants.
Global Const $ERROR_EVT_FILTER_INVTEST = 15017                                    ; A step operation must involve either a node test or, in the case of a predicate, an algebraic expression against which to test each node in the node set identified by the preceding node set can be evaluated.
Global Const $ERROR_EVT_FILTER_INVTYPE = 15018                                    ; This data type is currently unsupported.
Global Const $ERROR_EVT_FILTER_PARSEERR = 15019                                   ; A syntax error occurred at position %1!d!
Global Const $ERROR_EVT_FILTER_UNSUPPORTEDOP = 15020                              ; This operator is unsupported by this implementation of the filter.
Global Const $ERROR_EVT_FILTER_UNEXPECTEDTOKEN = 15021                            ; The token encountered was unexpected.
Global Const $ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL = 15022     ; The requested operation cannot be performed over an enabled direct channel. The channel must first be disabled before performing the requested operation.
Global Const $ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE = 15023                    ; Channel property %1!s! contains invalid value. The value has invalid type, is outside of valid range, can't be updated or is not supported by this type of channel.
Global Const $ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE = 15024                  ; Publisher property %1!s! contains invalid value. The value has invalid type, is outside of valid range, can't be updated or is not supported by this type of publisher.
Global Const $ERROR_EVT_CHANNEL_CANNOT_ACTIVATE = 15025                           ; The channel fails to activate.
Global Const $ERROR_EVT_FILTER_TOO_COMPLEX = 15026                                ; The xpath expression exceeded supported complexity. Please simplify it or split it into two or more simple expressions.
Global Const $ERROR_EVT_MESSAGE_NOT_FOUND = 15027                                 ; The message resource is present but the message is not found in the string/message table.
Global Const $ERROR_EVT_MESSAGE_ID_NOT_FOUND = 15028                              ; The message identifier for the desired message could not be found.
Global Const $ERROR_EVT_UNRESOLVED_VALUE_INSERT = 15029                           ; The substitution string for insert index (%1) could not be found.
Global Const $ERROR_EVT_UNRESOLVED_PARAMETER_INSERT = 15030                       ; The description string for parameter reference (%1) could not be found.
Global Const $ERROR_EVT_MAX_INSERTS_REACHED = 15031                               ; The maximum number of replacements has been reached.
Global Const $ERROR_EVT_EVENT_DEFINITION_NOT_FOUND = 15032                        ; The event definition could not be found for the event identifier (%1).
Global Const $ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND = 15033                          ; The locale specific resource for the desired message is not present.
Global Const $ERROR_EVT_VERSION_TOO_OLD = 15034                                   ; The resource is too old to be compatible.
Global Const $ERROR_EVT_VERSION_TOO_NEW = 15035                                   ; The resource is too new to be compatible.
Global Const $ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY = 15036                      ; The channel at index %1!d! of the query cannot be opened.
Global Const $ERROR_EVT_PUBLISHER_DISABLED = 15037                                ; The publisher has been disabled and its resource is not available. This usually occurs when the publisher is in the process of being uninstalled or upgraded.
Global Const $ERROR_EVT_FILTER_OUT_OF_RANGE = 15038                               ; Attempted to create a numeric type that is outside of its valid range.
Global Const $ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE = 15080                       ; The subscription fails to activate.
Global Const $ERROR_EC_LOG_DISABLED = 15081                                       ; The log of the subscription is in disabled state, and cannot be used to forward events. The log must first be enabled before the subscription can be activated.
Global Const $ERROR_EC_CIRCULAR_FORWARDING = 15082                                ; When forwarding events from local machine to itself, the query of the subscription can't contain target log of the subscription.
Global Const $ERROR_EC_CREDSTORE_FULL = 15083                                     ; The credential store that is used to save credentials is full.
Global Const $ERROR_EC_CRED_NOT_FOUND = 15084                                     ; The credential used by this subscription can't be found in credential store.
Global Const $ERROR_EC_NO_ACTIVE_CHANNEL = 15085                                  ; No active channel is found for the query.
Global Const $ERROR_MUI_FILE_NOT_FOUND = 15100                                    ; The resource loader failed to find MUI file.
Global Const $ERROR_MUI_INVALID_FILE = 15101                                      ; The resource loader failed to load MUI file because the file fail to pass validation.
Global Const $ERROR_MUI_INVALID_RC_CONFIG = 15102                                 ; The RC Manifest is corrupted with garbage data or unsupported version or missing required item.
Global Const $ERROR_MUI_INVALID_LOCALE_NAME = 15103                               ; The RC Manifest has invalid culture name.
Global Const $ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME = 15104                     ; The RC Manifest has invalid ultimatefallback name.
Global Const $ERROR_MUI_FILE_NOT_LOADED = 15105                                   ; The resource loader cache doesn't have loaded MUI entry.
Global Const $ERROR_RESOURCE_ENUM_USER_STOP = 15106                               ; User stop resource enumeration.
Global Const $ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED = 15107                 ; UI language installation failed.
Global Const $ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME = 15108                  ; Locale installation failed.
Global Const $ERROR_MCA_INVALID_CAPABILITIES_STRING = 15200                       ; The monitor returned a DDC/CI capabilities string that did not comply with the ACCESS.bus 3.0, DDC/CI 1.1, or MCCS 2 Revision 1 specification.
Global Const $ERROR_MCA_INVALID_VCP_VERSION = 15201                               ; The monitor's VCP Version (0xDF) VCP code returned an invalid version value.
Global Const $ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION = 15202               ; The monitor does not comply with the MCCS specification it claims to supports.
Global Const $ERROR_MCA_MCCS_VERSION_MISMATCH = 15203                             ; The MCCS version in a monitor's mccs_ver capability does not match the MCCS version the monitor reports when the VCP Version (0xDF) VCP code is used.
Global Const $ERROR_MCA_UNSUPPORTED_MCCS_VERSION = 15204                          ; The Monitor Configuration API only works with monitors that support the MCCS 1.0 specification, MCCS 2.0 specification, or the MCCS 2.0 Revision 1 specification.
Global Const $ERROR_MCA_INTERNAL_ERROR = 15205                                    ; An internal Monitor Configuration API error occurred.
Global Const $ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED = 15206                  ; The monitor returned an invalid monitor technology type. CRT, Plasma, and LCD (TFT) are examples of monitor technology types. This error implies that the monitor violated the MCCS 2.0 or the MCCS 2.0 Revision 1 specification.
Global Const $ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE = 15207                     ; The caller of SetMonitorColorTemperature specified a color temperature that the current monitor did not support. This error implies that the monitor violated the MCCS 2.0 or the MCCS 2.0 Revision 1 specification.
Global Const $ERROR_AMBIGUOUS_SYSTEM_DEVICE = 15250                               ; The requested system device cannot be identified due to multiple indistinguishable devices potentially matching the identification criteria.
Global Const $ERROR_SYSTEM_DEVICE_NOT_FOUND = 15299                               ; The requested system device cannot be found.
Global Const $ERROR_HASH_NOT_SUPPORTED = 15300                                    ; Hash generation for the specified version and hash type is not enabled on server.
Global Const $ERROR_HASH_NOT_PRESENT = 15301                                      ; The hash requests is not present or not up to date with the current file contents.

; ===============================================================================================================================
; *Structure constants
; ===============================================================================================================================

Global Const $tagAPPBARAPPBARDATA = "DWORD cbSize;HWND hWnd;UINT uCallbackMessage;UINT uEdge;" & $tagRECT & ";int lParam;"
Global Const $tagBITMAP = 'long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;'
Global Const $tagBITMAPINFOHEADER = 'dword biSize;long biWidth;long biHeight;ushort biPlanes;ushort biBitCount;dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;'
Global Const $tagBITMAPV4HEADER = 'dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPelsPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[3];dword bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;'
Global Const $tagBITMAPV5HEADER = 'dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[3];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;'
;Global Const $tagBITMAPINFO = $tagBITMAPINFOHEADER & 'dword bmiColors[1];'
Global Const $tagDEVMODE_DISPLAY = 'wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;' & $tagPOINT & ';dword DisplayOrientation;dword DisplayFixedOutput;short[5];wchar[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword DisplayFlags;dword DisplayFrequency;'
Global Const $tagDEVMODE_PRINTER = 'wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;short Orientation;short PaperSize;short PaperLength;short PaperWidth;short Scale;short Copies;short DefaultSource;short PrintQuality;short Color;short Duplex;short YResolution;short TTOption;short Collate;wchar FormName[32];ushort;dword[3];dword Nup;dword;dword ICMMethod;dword ICMIntent;dword MediaType;dword DitherType;dword Reserved1;dword Reserved2;dword PanningWidth;dword PanningHeight;'
Global Const $tagDEVNAMES = 'ushort DriverOffset;ushort DeviceOffset;ushort OutputOffset;ushort Default;'
Global Const $tagDIBSECTION = $tagBITMAP & $tagBITMAPINFOHEADER & 'dword dsBitfields[3];ptr dshSection;dword dsOffset;'
Global Const $tagDISK_GEOMETRY = 'int64 Cylinders;dword MediaType;dword TracksPerCylinder;dword SectorsPerTrack;dword BytesPerSector;'
Global Const $tagDISK_GEOMETRY_EX = $tagDISK_GEOMETRY & 'int64 DiskSize;' ; & 'byte Data[n];'
Global Const $tagDRIVERSTATUS = "byte DriverError;byte IDEStatus;byte Reserved1[2];dword Reserved2[2]"
Global Const $tagDTTOPTS = 'dword Size;dword Flags;dword clrText;dword clrBorder;dword clrShadow;int TextShadowType;' & $tagPOINT & ';int BorderSize;int FontPropId;int ColorPropId;int StateId;int ApplyOverlay;int GlowSize;ptr DrawTextCallback;lparam lParam;'
Global Const $tagENHMETAHEADER = 'dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Description;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];'
Global Const $tagEXTLOGPEN = 'dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries' ; & 'dword StyleEntry[n];'
Global Const $tagFINDREPLACE = 'dword Size;hwnd hOwner;ptr hInstance;dword Flags;ptr FindWhat;ptr ReplaceWith;ushort FindWhatLen;ushort ReplaceWithLen;lparam lParam;ptr Hook;ptr TemplateName;'
Global Const $tagHELPWININFO = 'int Size;int X;int Y;int Width;int Height;int wMax;wchar rgchMember[256];'
Global Const $tagHW_PROFILE_INFO = 'dword DockInfo;wchar ProfileGuid[39];wchar ProfileName[80];'
Global Const $tagIDEREGS = "byte Features;byte SectorCount;byte SectorNumber;byte CylLow;byte CylHigh;byte DriveHead;byte Command;byte Reserved"
Global Const $tagICONINFOEX = 'dword Size;int Icon;dword xHotspot;dword yHotspot;ptr hMask;ptr hColor;ushort ResID;wchar ModName[260];wchar ResName[260];'
Global Const $tagIO_COUNTERS = 'uint64 ReadOperationCount;uint64 WriteOperationCount;uint64 OtherOperationCount;uint64 ReadTransferCount;uint64 WriteTransferCount;uint64 OtherTransferCount;'
Global Const $tagJOBOBJECT_ASSOCIATE_COMPLETION_PORT = 'ulong_ptr CompletionKey;ptr CompletionPort;'
Global Const $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = 'int64 TotalUserTime;int64 TotalKernelTime;int64 ThisPeriodTotalUserTime;int64 ThisPeriodTotalKernelTime;dword TotalPageFaultCount;dword TotalProcesses;dword ActiveProcesses;dword TotalTerminatedProcesses;'
Global Const $tagJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION & $tagIO_COUNTERS
Global Const $tagJOBOBJECT_BASIC_LIMIT_INFORMATION = 'int64 PerProcessUserTimeLimit;int64 PerJobUserTimeLimit;dword LimitFlags;ulong_ptr MinimumWorkingSetSize;ulong_ptr MaximumWorkingSetSize;dword ActiveProcessLimit;ulong_ptr Affinity;dword PriorityClass;dword SchedulingClass;'
Global Const $tagJOBOBJECT_BASIC_PROCESS_ID_LIST = 'dword NumberOfAssignedProcesses;dword NumberOfProcessIdsInList' ; & 'ulong_ptr ProcessIdList[n];'
Global Const $tagJOBOBJECT_BASIC_UI_RESTRICTIONS = 'dword UIRestrictionsClass;'
Global Const $tagJOBOBJECT_END_OF_JOB_TIME_INFORMATION = 'dword EndOfJobTimeAction;'
Global Const $tagJOBOBJECT_EXTENDED_LIMIT_INFORMATION = $tagJOBOBJECT_BASIC_LIMIT_INFORMATION & $tagIO_COUNTERS & 'ulong_ptr ProcessMemoryLimit;ulong_ptr JobMemoryLimit;ulong_ptr PeakProcessMemoryUsed;ulong_ptr PeakJobMemoryUsed;'
Global Const $tagJOBOBJECT_GROUP_INFORMATION = '' ; & 'ushort ProcessorGroup[n];'
Global Const $tagJOBOBJECT_SECURITY_LIMIT_INFORMATION = 'dword SecurityLimitFlags;ptr JobToken;ptr SidsToDisable;ptr PrivilegesToDelete;ptr RestrictedSids;'
Global Const $tagLOGBRUSH = 'uint Style;dword Color;ulong_ptr Hatch;'
Global Const $tagLOGPEN = 'uint Style;dword Width;dword Color;'
Global Const $tagMODULEINFO = 'ptr BaseOfDll;dword SizeOfImage;ptr EntryPoint;'
Global Const $tagLUID = 'dword LowPart;long HighPart;'
Global Const $tagMSGBOXPARAMS = 'uint Size;hwnd hOwner;ptr hInstance;int_ptr Text;int_ptr Caption;dword Style;int_ptr Icon;dword_ptr ContextHelpId;ptr MsgBoxCallback;dword LanguageId;'
Global Const $tagNOTIFYICONDATA = 'dword Size;hwnd hWnd;uint ID;uint Flags;uint CallbackMessage;ptr hIcon;wchar Tip[128];dword State;dword StateMask;wchar Info[256];uint Version;wchar InfoTitle[64];dword InfoFlags;'
Global Const $tagNOTIFYICONDATA_XP = $tagNOTIFYICONDATA & 'uint GUID;'
Global Const $tagNOTIFYICONDATA_VISTA = $tagNOTIFYICONDATA_XP & 'ptr hBalloonIcon;'
Global Const $tagOSVERSIONINFO = 'dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];'
Global Const $tagOSVERSIONINFOEX = $tagOSVERSIONINFO & 'ushort ServicePackMajor;ushort ServicePackMinor;ushort SuiteMask;byte ProductType;byte Reserved;'
Global Const $tagPAGESETUPDLG = 'dword Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;dword Flags;long PaperWidth;long PaperHeight;long MarginMinLeft;long MarginMinTop;long MarginMinRight;long MarginMinBottom;long MarginLeft;long MarginTop;long MarginRight;long MarginBottom;ptr hInstance;lparam lParam;ptr PageSetupHook;ptr PagePaintHook;ptr PageSetupTemplateName;ptr hPageSetupTemplate;'
Global Const $tagPAINTSTRUCT = 'hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32];'
Global Const $tagPANOSE = 'byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte bXHeight;'
Global Const $tagPBI = 'ulong_ptr Reserved1;ptr PebBaseAddress;ulong_ptr Reserved2[2];ulong_ptr UniqueProcessId;ulong_ptr Reserved3'
Global Const $tagPROCESS_MEMORY_COUNTERS = 'dword Size;dword PageFaultCount;ulong_ptr PeakWorkingSetSize;ulong_ptr WorkingSetSize;ulong_ptr QuotaPeakPagedPoolUsage;ulong_ptr QuotaPagedPoolUsage;ulong_ptr QuotaPeakNonPagedPoolUsage;ulong_ptr QuotaNonPagedPoolUsage;ulong_ptr PagefileUsage;ulong_ptr PeakPagefileUsage;'
Global Const $tagRASENTRYNAME = "dword dwSize;char szEntryName[260]"
Global Const $tagPRINTDLG = 'align 2;dword_ptr Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;hwnd hDC;dword Flags;ushort FromPage;ushort ToPage;ushort MinPage;ushort MaxPage;' & __Iif(@AutoItX64, 'uint', 'ushort') & ' Copies;ptr hInstance;lparam lParam;ptr PrintHook;ptr SetupHook;ptr PrintTemplateName;ptr SetupTemplateName;ptr hPrintTemplate;ptr hSetupTemplate;'
Global Const $tagPRINTDLGEX = 'dword Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;hwnd hDC;dword Flags;dword Flags2;dword ExclusionFlags;dword NumPageRanges;dword MaxPageRanges;ptr PageRanges;dword MinPage;dword MaxPage;dword Copies;ptr hInstance;ptr PrintTemplateName;lparam lParam;dword NumPropertyPages;ptr hPropertyPages;dword StartPage;dword ResultAction;'
Global Const $tagPRINTPAGERANGE = 'dword FromPage;dword ToPage;'
Global Const $tagRGNDATAHEADER = 'dword Size;dword Type;dword Count;dword RgnSize;' & $tagRECT & ';'
Global Const $tagSENDCMDINPARAMS = "dword Size;" & $tagIDEREGS & ";byte DriveNumber;byte Reserved1[3];dword Reserved2[4];byte Buffer"
Global Const $tagSENDCMDOUTPARAMS = "dword Size;" & $tagDRIVERSTATUS
Global Const $tagSHFILEINFO = 'ptr hIcon;int iIcon;dword Attributes;wchar DisplayName[260];wchar TypeName[80];'
Global Const $tagSHFILEOPSTRUCT = 'hwnd hWnd;uint Func;ptr From;ptr To;dword Flags;int fAnyOperationsAborted;ptr hNameMappings;ptr ProgressTitle;'
Global Const $tagSHFOLDERCUSTOMSETTINGS = 'dword Size;dword Mask;ptr GUID;ptr WebViewTemplate;dword SizeWVT;ptr WebViewTemplateVersion;ptr InfoTip;dword SizeIT;ptr CLSID;dword Flags;ptr IconFile;dword SizeIF;int IconIndex;ptr Logo;dword SizeL;'
;Global Const $tagSTARTUPINFO = 'dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;dword YCountChars;dword FillAttribute;dword Flags;ushort ShowWindow;ushort Reserved2;ptr Reserved3;ptr hStdInput;ptr hStdOutput;ptr hStdError;'
Global Const $tagSHSTOCKICONINFO = 'dword Size;ptr hIcon;int SysImageIndex;int iIcon;wchar Path[260];'
Global Const $tagSTORAGE_DEVICE_NUMBER = 'dword DeviceType;ulong DeviceNumber;ulong PartitionNumber;'
Global Const $tagSTORAGEDEVICEDESCRIPTOR = "ulong Version;ulong Size;byte DeviceType;byte DeviceTypeModifier;byte RemovableMedia;byte CommandQueueing;ulong VendorIdOffset;ulong ProductIdOffset;ulong ProductRevisionOffset;ulong SerialNumberOffset;int BusType;ulong RawPropertiesLength;byte RawDeviceProperties"
Global Const $tagSTORAGEPROPERTYQUERY = "int PropertyId;int QueryType;byte AdditionalParams"
;Global Const $tagTEXTMETRIC = 'long Height;long Ascent;long Descent;long InternalLeading;long ExternalLeading;long AveCharWidth;long MaxCharWidth;long Weight;long Overhang;long DigitizedAspectX;long DigitizedAspectY;wchar FirstChar;wchar LastChar;wchar DefaultChar;wchar BreakChar;byte Italic;byte Underlined;byte StruckOut;byte PitchAndFamily;byte CharSet'
Global Const $tagUSEROBJECTFLAGS = 'int Inherit;int Reserved;dword Flags;'
Global Const $tagVS_FIXEDFILEINFO = 'dword Signature;dword StrucVersion;dword FileVersionMS;dword FileVersionLS;dword ProductVersionMS;dword ProductVersionLS;dword FileFlagsMask;dword FileFlags;dword FileOS;dword FileType;dword FileSubtype;dword FileDateMS;dword FileDateLS;'
;Global Const $tagVS_VERSIONINFO = 'ushort Length;ushort ValueLength;ushort Type;wchar Key;ushort Padding1;' & $tagVS_FIXEDFILEINFO & 'ushort Padding2;ushort Children;'
Global Const $tagWINDOWINFO = 'dword Size;dword rWindow[4];dword rClient[4];dword Style;dword ExStyle;dword WindowStatus;uint cxWindowBorders;uint cyWindowBorders;ushort atomWindowType;ushort CreatorVersion;'
Global Const $tagWNDCLASSEX = 'uint Size;uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName;ptr hIconSm;'
Global Const $tagXFORM = 'float eM11;float eM12;float eM21;float eM22;float eDX;float eDY;'
Global Const $tag_PROCESS_BASIC_INFORMATION = "int ExitStatus;ptr PebBaseAddress;ptr AffinityMask;ptr BasePriority;ulong UniqueProcessId;ulong InheritedFromUniqueProcessId;"
Global $__Data, $__Dlg, $__Dll = 0, $__Ext = 0, $__FR, $__Find, $__Replace, $__Buff = 8192, $__Ver = '3.4', $__RGB = True

#Region Public Functions
; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetConsoleTextAttribute
; Description ...: Changes the text and/or background color of text in the Windows console.
; Syntax.........: _WinAPI_SetConsoleTextAttribute($hConsole, $iColor, $hDLL = "Kernel32.dll")
; Parameters ....: $hConsole    - Handle to the console screen buffer
;                  $iColor      - Color style to apply to the console.
; Return values .: Success      - True
;                  Failure      - False
; Author ........: Ken Piper (Kealper)
; Modified.......:
; Remarks .......:
; Related .......:
; Link ..........: @@MsdnLink@@ SetConsoleTextAttribute
; Example .......:
; ===============================================================================================================================
Func _WinAPI_SetConsoleTextAttribute($hConsole, $iColor)
	Local $Ret = DllCall("Kernel32.dll", "BOOL", "SetConsoleTextAttribute", "HANDLE", $hConsole, "WORD", $iColor)
	If @error Then Return SetError(@error, @extended, False)
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetConsoleTextAttribute

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AbortPath
; Description....: Closes and discards any paths in the specified device context.
; Syntax.........: _WinAPI_AbortPath ( $hDC )
; Parameters.....: $hDC    - Handle to the device context from which a path will be discarded.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ AbortPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AbortPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'AbortPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AbortPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AboutDlg
; Description....: Displays a Windows About dialog box.
; Syntax.........: _WinAPI_AboutDlg ( $sTitle, $sName, $sText [, $hIcon [, $hParent]] )
; Parameters.....: $sTitle  - The title of the Windows About dialog box.
;                  $sName   - The first line after the text "Microsoft".
;                  $sText   - The text to be displayed in the dialog box after the version and copyright information.
;                  $hIcon   - Handle to the icon that the function displays in the dialog box.
;                  $hParent - Handle to a parent window.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ShellAbout
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AboutDlg($sTitle, $sName, $sText, $hIcon = 0, $hParent = 0)

	Local $Ret = DllCall('shell32.dll', 'int', 'ShellAboutW', 'hwnd', $hParent, 'wstr', $sTitle & '#' & $sName, 'wstr', $sText, 'ptr', $hIcon)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AboutDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ActivateKeyboardLayout
; Description....: Sets the input locale identifier for the calling thread or the current process.
; Syntax.........: _WinAPI_ActivateKeyboardLayout ( $hLocale [, $iFlag] )
; Parameters.....: $hLocale - The input locale identifier to be activated. This parameter must be either the handle to a keyboard
;                             layout or one of the following values.
;
;                             $HKL_NEXT
;                             $HKL_PREV
;
;                  $iFlag   - The flag that specifies how the input locale identifier is to be activated. This parameter can be
;                             one of the following values.
;
;                             $KLF_REORDER
;                             $KLF_RESET
;                             $KLF_SETFORPROCESS
;                             $KLF_SHIFTLOCK
;
; Return values..: Success  - The previous input locale identifier.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ActivateKeyboardLayout
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ActivateKeyboardLayout($hLocale, $iFlag = 0)

	Local $Ret = DllCall('user32.dll', 'long', 'ActivateKeyboardLayout', 'long', $hLocale, 'uint', $iFlag)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ActivateKeyboardLayout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AddClipboardFormatListener
; Description....: Places the given window in the system-maintained clipboard format listener list.
; Syntax.........: _WinAPI_AddClipboardFormatListener ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to be placed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ AddClipboardFormatListener
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AddClipboardFormatListener($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'AddClipboardFormatListener', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AddClipboardFormatListener

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AddFontMemResourceEx
; Description....: Adds the font resource from a memory image to the system.
; Syntax.........: _WinAPI_AddFontMemResourceEx ( $pData, $iSize )
; Parameters.....: $pData  - The pointer to a font resource.
;                  $iSize  - The number of bytes in the font resource.
; Return values..: Success - The handle uniquely identifies the fonts that were installed on the system, @extended flag will contain
;                            a number of fonts added to the system as a result of this call.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function allows an application to get a font that is embedded in a document or a Web page. A font that is
;                  added by this is always private to the process that made the call and is not enumerable.
;
;                  When the function succeeds, the caller of this function can free the memory pointed to by $pData because the system
;                  has made its own copy of the memory. To remove the fonts that were installed, call _WinAPI_RemoveFontMemResourceEx().
;                  However, when the process goes away, the system will unload the fonts.
; Related........:
; Link...........: @@MsdnLink@@ AddFontMemResourceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AddFontMemResourceEx($pData, $iSize)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'AddFontMemResourceEx', 'ptr', $pData, 'dword', $iSize, 'ptr', 0, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $Ret[4], $Ret[0])
EndFunc   ;==>_WinAPI_AddFontMemResourceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AddFontResourceEx
; Description....: Adds the font resource from the specified file to the system font table.
; Syntax.........: _WinAPI_AddFontResourceEx ( $sFont [, $iFlag [, $fNotify]] )
; Parameters.....: $sFont   - String that contains a valid font file name. This parameter can specify any of the following files:
;
;                             .fon - Font resource file.
;                             .fnt - Raw bitmap font file.
;                             .ttf - Raw TrueType file.
;                             .ttc - East Asian Windows: TrueType font collection.
;                             .fot - TrueType resource file.
;                             .otf - PostScript OpenType font.
;                             .mmm - Multiple master Type1 font resource file. It must be used with .pfm and .pfb files.
;                             .pfb - Type 1 font bits file. It is used with a .pfm file.
;                             .pfm - Type 1 font metrics file. It is used with a .pfb file.
;
;                             To add a font whose information comes from several resource files, they must be separated by a "|".
;                             For example, abcxxxxx.pfm|abcxxxxx.pfb.
;
;                  $iFlag   - The characteristics of the font to be added to the system. This parameter can be one of the following values.
;
;                             $FR_PRIVATE
;                             $FR_NOT_ENUM
;
;                  $fNotify - Specifies whether sends a WM_FONTCHANGE message, valid values:
;                  |TRUE    - Send the WM_FONTCHANGE message to all top-level windows after changing the pool of font resources.
;                  |FALSE   - Don`t send. (Default)
; Return values..: Success  - The value that specifies the number of fonts added.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function installs the font only for the current session. When the system restarts, the font will not be present.
;                  To have the font installed even after restarting the system, the font must be listed in the registry.
; Related........:
; Link...........: @@MsdnLink@@ AddFontResourceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AddFontResourceEx($sFont, $iFlag = 0, $fNotify = 0)

	Local $Ret = DllCall('gdi32.dll', 'int', 'AddFontResourceExW', 'wstr', $sFont, 'dword', $iFlag, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	If $fNotify Then
		DllCall('user32.dll', 'int', 'SendMessage', 'hwnd', 0xFFFF, 'uint', 0x001D, 'int', 0, 'int', 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_AddFontResourceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AddIconOverlay
; Description....: Creates an icon by merging the source icon and overlay mask.
; Syntax.........: _WinAPI_AddIconOverlay ( $hIcon, $hOverlay )
; Parameters.....: $hIcon    - Handle to the source icon.
;                  $hOverlay - Handle to the icon to use as an overlay mask.
; Return values..: Success   - Handle to the newly created icon.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The source icon and overlay mask must be the same size but can have different bit depth. When you are finished
;                  using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AddIconOverlay($hIcon, $hOverlay)

	Local $tSIZE, $Ret, $hIL, $hResult = 0

	$tSIZE = _WinAPI_GetIconDimension($hIcon)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$hIL = DllCall('comctl32.dll', 'ptr', 'ImageList_Create', 'int', DllStructGetData($tSIZE, 1), 'int', DllStructGetData($tSIZE, 2), 'uint', 0x0021, 'int', 2, 'int', 2)
	If (@error) Or (Not $hIL[0]) Then
		Return SetError(2, 0, 0)
	EndIf
	Do
		$Ret = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'ptr', $hIL[0], 'int', -1, 'ptr', $hIcon)
		If (@error) Or ($Ret[0] = -1) Then
			ExitLoop
		EndIf
		$Ret = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'ptr', $hIL[0], 'int', -1, 'ptr', $hOverlay)
		If (@error) Or ($Ret[0] = -1) Then
			ExitLoop
		EndIf
		$Ret = DllCall('comctl32.dll', 'int', 'ImageList_SetOverlayImage', 'ptr', $hIL[0], 'int', 1, 'int', 1)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('comctl32.dll', 'ptr', 'ImageList_GetIcon', 'ptr', $hIL[0], 'int', 0, 'uint', 0x00000100)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$hResult = $Ret[0]
	Until 1
	DllCall('comctl32.dll', 'int', 'ImageList_Destroy', 'ptr', $hIL[0])
	If Not $hResult Then
		Return SetError(3, 0, 0)
	EndIf
	Return $hResult
EndFunc   ;==>_WinAPI_AddIconOverlay

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AddIconTransparency
; Description....: Adds a transparency to the specified 32 bits-per-pixel icon.
; Syntax.........: _WinAPI_AddIconTransparency ( $hIcon [, $iPercent [, $fDelete]] )
; Parameters.....: $hIcon    - Handle to the icon.
;                  $iPercent - A value (in percent) that specifies how much to decrease the values of the alpha channel for the specified icon.
;                  $fDelete  - Specifies whether delete the icon after the function is successful, valid values:
;                  |TRUE     - Icon will be deleted if the function succeeds.
;                  |FALSE    - Don't delete, you must release the icon when you are finished using it. (Default)
; Return values..: Success   - Handle to the newly created icon.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function only works with 32 bits-per-pixel (RGB + Alpha) icons. When you are finished using the icon,
;                  destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AddIconTransparency($hIcon, $iPercent = 50, $fDelete = 0)

	Local $tICONINFO, $tBITMAP, $W, $H, $Ret, $iByte, $tBits, $pBits, $hBitmap[2], $hResult = 0

	$tICONINFO = DllStructCreate($tagICONINFO)
	$Ret = DllCall('user32.dll', 'int', 'GetIconInfo', 'ptr', $hIcon, 'ptr', DllStructGetPtr($tICONINFO))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = 0 To 1
		$hBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
	Next
	Do
		$tBITMAP = DllStructCreate($tagBITMAP)
		If Not _WinAPI_GetObject($hBitmap[1], DllStructGetSize($tBITMAP), DllStructGetPtr($tBITMAP)) Then
			ExitLoop
		EndIf
		$W = DllStructGetData($tBITMAP, 'bmWidth')
		$H = DllStructGetData($tBITMAP, 'bmHeight')
		$iByte = $W * $H * 4
		$tBits = DllStructCreate('byte[' & $iByte & ']')
		$pBits = DllStructGetPtr($tBits)
		If _WinAPI_GetBitmapBits($hBitmap[1], $iByte, $pBits) <> $iByte Then
			ExitLoop
		EndIf
		For $i = 1 To $iByte Step 4
			DllStructSetData($tBits, 1, DllStructGetData($tBits, 1, $i + 3) * $iPercent / 100, $i + 3)
		Next
		_WinAPI_DeleteObject($hBitmap[1])
		$hBitmap[1] = _WinAPI_CreateBitmap($W, $H, 1, 32, $pBits)
		If $hBitmap[1] Then
			$hResult = _WinAPI_CreateIconIndirect($hBitmap[1], $hBitmap[0])
		EndIf
	Until 1
	For $i = 0 To 1
		If $hBitmap[$i] Then
			_WinAPI_DeleteObject($hBitmap[$i])
		EndIf
	Next
	If Not $hResult Then
		Return SetError(1, 0, 0)
	EndIf
	If $fDelete Then
		_WinAPI_DestroyIcon($hIcon)
	EndIf
	Return $hResult
EndFunc   ;==>_WinAPI_AddIconTransparency

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AddMRUString
; Description....: Adds a string to the top of the most recently used (MRU) list.
; Syntax.........: _WinAPI_AddMRUString ( $hMRU, $sStr )
; Parameters.....: $hMRU   - Handle of the MRU list.
;                  $sStr   - The string be added.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ AddMRUStringW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AddMRUString($hMRU, $sStr)

	Local $Ret = DllCall('comctl32.dll ', 'int', 'AddMRUStringW', 'ptr', $hMRU, 'wstr', $sStr)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AddMRUString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AdjustTokenPrivileges
; Description....: Enables or disables privileges in the specified access token.
; Syntax.........: _WinAPI_AdjustTokenPrivileges ( $hToken, $aPrivileges, $iAttributes, ByRef $aAdjust )
; Parameters.....: $hToken      - Handle to the access token that contains the privileges to be modified. The handle must have
;                                 $TOKEN_ADJUST_PRIVILEGES and $TOKEN_QUERY accesses to the token.
;                  $aPrivileges - The variable that specifies a privileges. If this parameter is (-1), the function disables of the token's
;                                 privileges and ignores the $iAttributes parameter. $aPrivileges can be one of the following types.
;
;                                 One of the privilege constants ($SE_*).
;                                 1D array of $SE_* constants.
;                                 2D array of $SE_* constants and their attributes (see below).
;
;                                 [0][0] - Privilege
;                                 [0][1] - Attributes
;                                 [n][0] - Privilege
;                                 [n][1] - Attributes
;
;                  $iAttributes - The privilege attributes. If $aPrivileges parameter is 1D array, $iAttributes applied to the entire
;                                 array. If $aPrivileges parameter is (-1) or 2D array, the function ignores this parameter and will
;                                 use the attributes that specified in this array. This parameter can be 0 (disables privilege)
;                                 or any combination of the following values.
;
;                                 $SE_PRIVILEGE_ENABLED
;                                 $SE_PRIVILEGE_ENABLED_BY_DEFAULT
;                                 $SE_PRIVILEGE_REMOVED
;                                 $SE_PRIVILEGE_USED_FOR_ACCESS
;
;                  $aAdjust     - 2D array of the previous state of any privileges that the function modifies. That is, if a privilege has
;                                 been modified by this function, the privilege and its previous state are contained in this array.
; Return values..: Success      - 1 and sets the @extended flag to the following values.
;
;                                 0 - The function adjusted all specified privileges.
;                                 1 - The token does not have one or more of the privileges specified in the $aPrivileges parameter.
;
;                                 To determine whether the function success and adjusted all of the specified privileges, check the
;                                 @error and @extended flags both, for example:
;
;                                 If Not (@error Or @extended) Then
;                                     ...
;                                 EndIf
;
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function cannot add new privileges to the access token. It can only enable or disable the token's
;                  existing privileges.
; Related........:
; Link...........: @@MsdnLink@@ AdjustTokenPrivileges
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AdjustTokenPrivileges($hToken, $aPrivileges, $iAttributes, ByRef $aAdjust)

	Local $tTP1 = 0, $tTP2, $tData, $Count, $Result, $Ret, $Struct, $Disable = 0, $Prev = 0

	If (Not $aPrivileges) And (IsNumber($aPrivileges)) Then
		Return 0
	EndIf
	$aAdjust = 0
	If $aPrivileges =-1 Then
		$tTP2 = DllStructCreate('dword')
		$Ret = DllCall('advapi32.dll', 'int', 'AdjustTokenPrivileges', 'ptr', $hToken, 'int', 1, 'ptr', 0, 'dword', 0, 'ptr', DllStructGetPtr($tTP2), 'dword*', 0)
		If @error Then
			Return SetError(1, 0, 0)
		Else
			Switch _WinAPI_GetLastError()
				Case 122 ; ERROR_INSUFFICIENT_BUFFER
					$tTP2 = DllStructCreate('dword;dword[' & ($Ret[6] / 4 - 1) & ']')
					If @error Then
						ContinueCase
					EndIf
				Case Else
					Return SetError(1, 0, 0)
			EndSwitch
		EndIf
		$Disable = 1
	Else
		If Not IsArray($aPrivileges) Then
			Dim $Prev[1][2]
			$Prev[0][0] = $aPrivileges
			$Prev[0][1] = $iAttributes
		Else
			If Not UBound($aPrivileges, 2) Then
				$Count = UBound($aPrivileges)
				Dim $Prev[$Count][2]
				For $i = 0 To $Count - 1
					$Prev[$i][0] = $aPrivileges[$i]
					$Prev[$i][1] = $iAttributes
				Next
			EndIf
		EndIf
		If IsArray($Prev) Then
			$aPrivileges = $Prev
		EndIf
		$Struct = 'dword;dword[' & (3 * UBound($aPrivileges)) & ']'
		$tTP1 = DllStructCreate($Struct)
		$tTP2 = DllStructCreate($Struct)
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
		DllStructSetData($tTP1, 1, UBound($aPrivileges))
		For $i = 0 To UBound($aPrivileges) - 1
			DllStructSetData($tTP1, 2, $aPrivileges[$i][1], 3 * $i + 3)
			$Ret = DllCall('advapi32.dll', 'int', 'LookupPrivilegeValueW', 'ptr', 0, 'wstr', $aPrivileges[$i][0], 'ptr', DllStructGetPtr($tTP1, 2) + 12 * $i)
			If (@error) Or (Not $Ret[0]) Then
				Return SetError(1, 0, 0)
			EndIf
		Next
	EndIf
	$Ret = DllCall('advapi32.dll', 'int', 'AdjustTokenPrivileges', 'ptr', $hToken, 'int', $Disable, 'ptr', DllStructGetPtr($tTP1), 'dword', DllStructGetSize($tTP2), 'ptr', DllStructGetPtr($tTP2), 'dword*', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Switch _WinAPI_GetLastError()
		Case 1300 ; ERROR_NOT_ALL_ASSIGNED
			$Result = 1
		Case Else
			$Result = 0
	EndSwitch
	$Count = DllStructGetData($tTP2, 1)
	If $Count Then
		$tData = DllStructCreate('wchar[128]')
		Dim $aPrivileges[$Count][2]
		For $i = 0 To $Count - 1
			$Ret = DllCall('advapi32.dll', 'int', 'LookupPrivilegeNameW', 'ptr', 0, 'ptr', DllStructGetPtr($tTP2, 2) + 12 * $i, 'ptr', DllStructGetPtr($tData), 'dword*', 128)
			If (@error) Or (Not $Ret[0]) Then
				Return SetError(1, 0, 0)
			EndIf
			$aPrivileges[$i][1] = DllStructGetData($tTP2, 2, 3 * $i + 3)
			$aPrivileges[$i][0] = DllStructGetData($tData, 1)
		Next
		$aAdjust = $aPrivileges
	EndIf
	Return SetError(0, $Result, 1)
EndFunc   ;==>_WinAPI_AdjustTokenPrivileges

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AdjustWindowRectEx
; Description....: Calculates the required size of the window rectangle, based on the desired size of the client rectangle.
; Syntax.........: _WinAPI_AdjustWindowRectEx ( ByRef $tRECT, $iStyle [, $iExStyle [, $fMenu] )
; Parameters.....: $tRECT    - $tagRECT structure that contains the coordinates of the desired client area.
;                  $iStyle   - The window style of the window whose required size is to be calculated. Note that you cannot
;                              specify the $WS_OVERLAPPED style.
;                  $iExStyle - The extended window style of the window whose required size is to be calculated.
;                  $fMenu    - Specifies whether the window has a menu, valid values:
;                  |TRUE     - The window has a menu, valid values:
;                  |FALSE    - The window does not has a menu. (Default)
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ AdjustWindowRectEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AdjustWindowRectEx(ByRef $tRECT, $iStyle, $iExStyle = 0, $fMenu = 0)

	Local $Ret = DllCall('user32.dll', 'int', 'AdjustWindowRectEx', 'ptr', DllStructGetPtr($tRECT), 'dword', $iStyle, 'int', $fMenu, 'dword', $iExStyle)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AdjustWindowRectEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AlphaBlend
; Description....: Displays bitmaps that have transparent or semitransparent pixels.
; Syntax.........: _WinAPI_AlphaBlend ( $hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iAlpha [, $fAlpha] )
; Parameters.....: $hDestDC     - Handle to the destination device context.
;                  $iXDest      - The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iYDest      - The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iWidthDest  - The width, in logical units, of the destination rectangle.
;                  $iHeightDest - The height, in logical units, of the destination rectangle.
;                  $hSrcDC      - Handle to the source device context.
;                  $iXSrc       - The x-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iYSrc       - The y-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iWidthSrc   - The width, in logical units, of the source rectangle.
;                  $iHeightSrc  - The height, in logical units, of the source rectangle.
;                  $iAlpha      - The alpha transparency value to be used on the entire source bitmap. This value is combined with
;                                 any per-pixel alpha values in the source bitmap. If you set $iAlpha to 0, it is assumed that
;                                 your image is transparent. Set $iAlpha value to 255 (opaque) when you only want to use per-pixel
;                                 alpha values.
;                  $fAlpha      - Specifies whether uses an Alpha channel from the source bitmap, valid values:
;                  |TRUE        - Use the Alpha channel (that is, per-pixel alpha). Note that the APIs use premultiplied alpha,
;                                 which means that the red, green and blue channel values in the bitmap must be premultiplied with the
;                                 alpha channel value. For example, if the alpha channel value is x, the red, green and blue channels
;                                 must be multiplied by x and divided by 255 prior to the call.
;                  |FALSE       - Do not use the Alpha channel. (Default)
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the source rectangle and destination rectangle are not the same size, the source bitmap is stretched to
;                  match the destination rectangle. If the _WinAPI_SetStretchBltMode() function is used, the stretching mode value
;                  is automatically converted to $COLORONCOLOR for this function (that is, $BLACKONWHITE, $WHITEONBLACK, and
;                  $HALFTONE are changed to $COLORONCOLOR).
;
;                  If destination and source bitmaps do not have the same color format, _WinAPI_AlphaBlend() function converts
;                  the source bitmap to match the destination bitmap.
; Related........:
; Link...........: @@MsdnLink@@ GdiAlphaBlend
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AlphaBlend($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iAlpha, $fAlpha = 0)

	Local $iBlend = BitOR(BitShift(Not ($fAlpha = 0), -24), BitShift(BitAND($iAlpha, 0xFF), -16))
	Local $Ret = DllCall('gdi32.dll', 'int', 'GdiAlphaBlend', 'hwnd', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidthDest, 'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', $iBlend)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AlphaBlend

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AngleArc
; Description....: Draws a line segment and an arc.
; Syntax.........: _WinAPI_AngleArc ( $hDC, $iX, $iY, $iRadius, $nStartAngle, $nSweepAngle )
; Parameters.....: $hDC         - Handle to a device context.
;                  $iX          - The x-coordinate, in logical units, of the center of the circle.
;                  $iY          - The y-coordinate, in logical units, of the center of the circle.
;                  $iRadius     - The radius, in logical units, of the circle.
;                  $nStartAngle - The start angle, in degrees, relative to the x-axis.
;                  $nSweepAngle - The sweep angle, in degrees, relative to the starting angle.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_AngleArc() function draws lines by using the current pen. The figure is not filled. This function
;                  moves the current position to the ending point of the arc.
; Related........:
; Link...........: @@MsdnLink@@ AngleArc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AngleArc($hDC, $iX, $iY, $iRadius, $nStartAngle, $nSweepAngle)

	Local $Ret = DllCall('gdi32.dll', 'int', 'AngleArc', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'dword', $iRadius, 'float', $nStartAngle, 'float', $nSweepAngle)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AngleArc

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AnimateWindow
; Description....: Enables you to produce special effects when showing or hiding windows.
; Syntax.........: _WinAPI_AnimateWindow ( $hWnd, $iFlags [, $iDuration] )
; Parameters.....: $hWnd      - Handle to the window to animate.
;                  $iFlags    - The flags that specify the type of animation. This parameter can be one or more of the following
;                               values. Note that, by default, these flags take effect when showing a window. To take effect when
;                               hiding a window, use AW_HIDE and a logical OR operator with the appropriate flags.
;
;                               $AW_SLIDE
;                               $AW_ACTIVATE
;                               $AW_BLEND
;                               $AW_HIDE
;                               $AW_CENTER
;                               $AW_HOR_POSITIVE
;                               $AW_HOR_NEGATIVE
;                               $AW_VER_POSITIVE
;                               $AW_VER_NEGATIVE
;
;                  $iDuration - Specifies how long it takes to play the animation, in milliseconds. Default is 1000.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ AnimateWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AnimateWindow($hWnd, $iFlags, $iDuration = 1000)

	Local $Ret = DllCall('user32.dll', 'int', 'AnimateWindow', 'hwnd', $hWnd, 'dword', $iDuration, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AnimateWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Arc
; Description....: Draws an elliptical arc.
; Syntax.........: _WinAPI_Arc ( $hDC, $tRECT, $iXStartArc, $iYStartArc, $iXEndArc, $iYEndArc )
; Parameters.....: $hDC         - Handle to the device context.
;                  $tRECT       - $tagRECT structure that contains the the logical coordinates of the bounding rectangle.
;                  $iXStartArc  - The x-coordinate, in logical units, of the ending point of the radial line defining the starting point of the arc.
;                  $iYStartArc  - The y-coordinate, in logical units, of the ending point of the radial line defining the starting point of the arc.
;                  $iXEndArc    - The x-coordinate, in logical units, of the ending point of the radial line defining the ending point of the arc.
;                  $iYEndArc    - The y-coordinate, in logical units, of the ending point of the radial line defining the ending point of the arc.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The arc is drawn using the current pen; it is not filled. The current position is neither used nor updated by
;                  _WinAPI_Arc() function.
;
;                  Use the _WinAPI_GetArcDirection() and _WinAPI_SetArcDirection() functions to get and set the current drawing
;                  direction for a device context. The default drawing direction is counterclockwise.
; Related........:
; Link...........: @@MsdnLink@@ Arc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Arc($hDC, $tRECT, $iXStartArc, $iYStartArc, $iXEndArc, $iYEndArc)

	Local $Ret = DllCall('gdi32.dll', 'int', 'Arc', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4), 'int', $iXStartArc, 'int', $iYStartArc, 'int', $iXEndArc, 'int', $iYEndArc)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_Arc

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ArcTo
; Description....: Draws an elliptical arc.
; Syntax.........: _WinAPI_ArcTo ( $hDC, $tRECT, $iXRadial1, $iYRadial1, $iXRadial2, $iYRadial2 )
; Parameters.....: $hDC       - Handle to the device context.
;                  $tRECT     - $tagRECT structure that contains the the logical coordinates of the bounding rectangle.
;                  $iXRadial1 - The x-coordinate, in logical units, of the endpoint of the radial defining the starting point of the arc.
;                  $iYRadial1 - The y-coordinate, in logical units, of the endpoint of the radial defining the starting point of the arc.
;                  $iXRadial2 - The x-coordinate, in logical units, of the endpoint of the radial defining the ending point of the arc.
;                  $iYRadial2 - The y-coordinate, in logical units, of the endpoint of the radial defining the ending point of the arc.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The arc is drawn using the current pen; it is not filled. _WinAPI_ArcTo() is similar to the _WinAPI_Arc() function,
;                  except that the current position is updated.
; Related........:
; Link...........: @@MsdnLink@@ ArcTo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ArcTo($hDC, $tRECT, $iXRadial1, $iYRadial1, $iXRadial2, $iYRadial2)

	Local $Ret = DllCall('gdi32.dll', 'int', 'ArcTo', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4), 'int', $iXRadial1, 'int', $iYRadial1, 'int', $iXRadial2, 'int', $iYRadial2)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ArcTo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ArrayToStruct
; Description....: Converts an array of strings to the structure.
; Syntax.........: _WinAPI_ArrayToStruct ( $aData [, $iStart [, $iEnd]] )
; Parameters.....: $aData  - The array to convert.
;                  $iStart - The index of array to start converting at.
;                  $iEnd   - The index of array to stop converting at.
; Return values..: Success - The structure of the type "string1;{0};string2;{0}; ... ;stringN;{0};{0}".
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function works for Unicode strings only.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ArrayToStruct($aData, $iStart = 0, $iEnd = -1)

	If Not IsArray($aData) Then
		Return SetError(2, 0, 0)
	EndIf

	Local $tData, $Count, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aData) - 1) Then
		$iEnd = UBound($aData) - 1
	EndIf
	For $i = $iStart To $iEnd
		$Struct &= 'wchar[' & (StringLen($aData[$i]) + 1) & '];'
	Next
	$tData = DllStructCreate($Struct & 'wchar[1]')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = 1
	For $i = $iStart To $iEnd
		DllStructSetData($tData, $Count, $aData[$i])
		$Count += 1
	Next
	DllStructSetData($tData, $Count, ChrW(0))
	Return $tData
EndFunc   ;==>_WinAPI_ArrayToStruct

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AssignProcessToJobObject
; Description....: Assigns a process to an existing job object.
; Syntax.........: _WinAPI_AssignProcessToJobObject ( $hJob, $hProcess )
; Parameters.....: $hJob     - Handle to the job object to which the process will be associated. The handle must have the
;                              $JOB_OBJECT_ASSIGN_PROCESS access right.
;                  $hProcess - Handle to the process to associate with the job object. The process must not already be assigned to a job.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After you associate a process with a job object, the process is subject to the limits set for the job. To set
;                  limits for a job, use the _WinAPI_SetInformationJobObject() function.
;
;                  The process can be associated only with a single job. The process inherits limits from the job it is associated
;                  with and adds its accounting information to the job. If a process is associated with a job, all processes it
;                  creates are associated with that job by default.
; Related........:
; Link...........: @@MsdnLink@@ AssignProcessToJobObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AssignProcessToJobObject($hJob, $hProcess)

	Local $Ret = DllCall('kernel32.dll', 'int', 'AssignProcessToJobObject', 'ptr', $hJob, 'ptr', $hProcess)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_AssignProcessToJobObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AssocGetPerceivedType
; Description....: Retrieves a file's perceived type based on its extension.
; Syntax.........: _WinAPI_AssocGetPerceivedType ( $sExt )
; Parameters.....: $sExt   - The file's extension. This should include the leading period, for example ".txt".
; Return values..: Success - The array containing the following parameters:
;
;                            [0] - The perceived type ($PERCEIVED_TYPE_*).
;                            [1] - The source of the perceived type information ($PERCEIVEDFLAG_*).
;                            [2] - The perceived type string, for instance "text" or "video".
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ AssocGetPerceivedType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AssocGetPerceivedType($sExt)

	Local $Ret = DllCall('shlwapi.dll', 'uint', 'AssocGetPerceivedType', 'wstr', $sExt, 'int*', 0, 'dword*', 0, 'wstr*', '')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[3]

	For $i = 0 To 2
		$Result[$i] = $Ret[$i + 2]
	Next
	Return $Result
EndFunc   ;==>_WinAPI_AssocGetPerceivedType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AssocQueryString
; Description....: Searches for and retrieves a file or protocol association-related string from the registry.
; Syntax.........: _WinAPI_AssocQueryString ( $sAssoc, $iType [, $iFlags [, $sExtra]] )
; Parameters.....: $sAssoc - The string that is used to determine the root key. The following four types of strings can be used.
;
;                            The file name extension, such as ".txt".
;                            The class identifier (CLSID) GUID in the standard "{GUID}" format.
;                            The application's ProgID, such as Word.Document.8.
;                            The name of an application's .exe file. The $ASSOCF_OPEN_BYEXENAME flag must be set.
;
;                  $iType  - The value that specifies the type of string that is to be returned. This parameter can be one of the
;                            following values.
;
;                            $ASSOCSTR_COMMAND
;                            $ASSOCSTR_EXECUTABLE
;                            $ASSOCSTR_FRIENDLYDOCNAME
;                            $ASSOCSTR_FRIENDLYAPPNAME
;                            $ASSOCSTR_NOOPEN
;                            $ASSOCSTR_SHELLNEWVALUE
;                            $ASSOCSTR_DDECOMMAND
;                            $ASSOCSTR_DDEIFEXEC
;                            $ASSOCSTR_DDEAPPLICATION
;                            $ASSOCSTR_DDETOPIC
;                            $ASSOCSTR_INFOTIP
;                            $ASSOCSTR_QUICKTIP
;                            $ASSOCSTR_TILEINFO
;                            $ASSOCSTR_CONTENTTYPE
;                            $ASSOCSTR_DEFAULTICON
;                            $ASSOCSTR_SHELLEXTENSION
;
;                  $iFlags - The flags that can be used to control the search. It can be any combination of the following
;                            values, except that only one $ASSOCF_INIT_* value can be included.
;
;                            $ASSOCF_INIT_NOREMAPCLSID
;                            $ASSOCF_INIT_BYEXENAME
;                            $ASSOCF_OPEN_BYEXENAME
;                            $ASSOCF_INIT_DEFAULTTOSTAR
;                            $ASSOCF_INIT_DEFAULTTOFOLDER
;                            $ASSOCF_NOUSERSETTINGS
;                            $ASSOCF_NOTRUNCATE
;                            $ASSOCF_VERIFY
;                            $ASSOCF_REMAPRUNDLL
;                            $ASSOCF_NOFIXUPS
;                            $ASSOCF_IGNOREBASECLASS
;                            $ASSOCF_INIT_IGNOREUNKNOWN
;
;                  $sExtra - The optional string with additional information about the location of the string. It is typically
;                            set to a Shell verb such as open.
; Return values..: Success - The string that contains the requested ($ASSOCSTR_*) information.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ AssocQueryString
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AssocQueryString($sAssoc, $iType, $iFlags = 0, $sExtra = '')

	Local $TypeOfExtra = 'wstr'

	If Not StringStripWS($sExtra, 3) Then
		$TypeOfExtra = 'ptr'
		$sExtra = 0
	EndIf

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('shlwapi.dll', 'uint', 'AssocQueryStringW', 'dword', $iFlags, 'dword', $iType, 'wstr', $sAssoc, $TypeOfExtra, $sExtra, 'ptr', DllStructGetPtr($tData), 'dword*', 1024)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_AssocQueryString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BeginBufferedPaint
; Description....: Begins a buffered paint operation.
; Syntax.........: _WinAPI_BeginBufferedPaint ( $hDC, $tTarget, ByRef $hNewDC [, $iFormat [, $iFlags [, $tExclude [, $iAlpha]]]] )
; Parameters.....: $hDC      - Handle of the target DC on which the buffer will be painted.
;                  $tTarget  - $tagRECT structure that specifies the area of the target DC in which to paint.
;                  $hNewDC   - Handle of the new device context.
;                  $iFormat  - The format of the buffer. This parameter can be one of the following values.
;
;                              $BPBF_COMPATIBLEBITMAP
;                              $BPBF_DIB
;                              $BPBF_TOPDOWNDIB
;                              $BPBF_TOPDOWNMONODIB
;
;                  $iFlags   - The additional flags, one or more of the following values.
;
;                              $BPPF_ERASE
;                              $BPPF_NOCLIP
;                              $BPPF_NONCLIENT
;
;                  $tExclude - $tagRECT structure that specifies the area which is excluded from the clipping region.
;                  $iAlpha   - The alpha transparency value to be used on the entire source bitmap. If this parameter is not
;                              specified or (-1), the source buffer is copied to the destination with no blending.
; Return values..: Success   - The handle to the buffered paint context.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ BeginBufferedPaint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BeginBufferedPaint($hDC, $tTarget, ByRef $hNewDC, $iFormat = 0, $iFlags = 0, $tExclude = 0, $iAlpha = -1)

	Local $tPP = DllStructCreate('dword;dword;ptr;ptr')
	Local $tBF = 0

	If $iAlpha <> -1 Then
		$tBF = DllStructCreate($tagBLENDFUNCTION)
		DllStructSetData($tBF, 1, 0)
		DllStructSetData($tBF, 2, 0)
		DllStructSetData($tBF, 3, $iAlpha)
		DllStructSetData($tBF, 4, 1)
	EndIf

	DllStructSetData($tPP, 1, DllStructGetSize($tPP))
	DllStructSetData($tPP, 2, $iFlags)
	DllStructSetData($tPP, 3, DllStructGetPtr($tExclude))
	DllStructSetData($tPP, 4, DllStructGetPtr($tBF))

	Local $Ret = DllCall('uxtheme.dll', 'ptr', 'BeginBufferedPaint', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tTarget), 'dword', $iFormat, 'ptr', DllStructGetPtr($tPP), 'hwnd*', 0)

	If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
		$hNewDC = 0
		Return SetError(1, 0, 0)
	EndIf
	$hNewDC = $Ret[5]
	Return $Ret[0]
EndFunc   ;==>_WinAPI_BeginBufferedPaint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BeginDeferWindowPos
; Description....: Allocates memory for a multiple-window-position structure.
; Syntax.........: _WinAPI_BeginDeferWindowPos ( [$iAmount] )
; Parameters.....: $iAmount - The initial number of windows for which to store position information.
; Return values..: Success  - The value identifies the multiple-window-position structure.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ BeginDeferWindowPos
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BeginDeferWindowPos($iAmount = 1)

	Local $Ret = DllCall('user32.dll', 'ptr', 'BeginDeferWindowPos', 'int', $iAmount)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_BeginDeferWindowPos

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BeginPaint
; Description....: Prepares the specified window for painting.
; Syntax.........: _WinAPI_BeginPaint ( $hWnd, ByRef $tPAINTSTRUCT )
; Parameters.....: $hWnd         - Handle to the window to be repainted.
;                  $tPAINTSTRUCT - $tagPAINTSTRUCT structure that will receive painting information.
; Return values..: Success       - Handle to a display device context for the specified window.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function automatically sets the clipping region of the device context to exclude any area outside the
;                  update region. The update region is set by the _WinAPI_InvalidateRect() or _WinAPI_InvalidateRgn() function and
;                  by the system after sizing, moving, creating, scrolling, or any other operation that affects the client area.
;                  If the update region is marked for erasing, _WinAPI_BeginPaint() sends a WM_ERASEBKGND message to the window.
;
;                  An application should not call _WinAPI_BeginPaint() except in response to a WM_PAINT message. Each call to
;                  _WinAPI_BeginPaint() must have a corresponding call to the _WinAPI_EndPaint() function.
; Related........:
; Link...........: @@MsdnLink@@ BeginPaint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BeginPaint($hWnd, ByRef $tPAINTSTRUCT)

	$tPAINTSTRUCT = DllStructCreate($tagPAINTSTRUCT)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'BeginPaint', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tPAINTSTRUCT))

	If (@error) Or (Not $Ret[0]) Then
		$tPAINTSTRUCT = 0
	EndIf
	Return SetError(Number(IsDllStruct($tPAINTSTRUCT)), 0, $Ret[0])
EndFunc   ;==>_WinAPI_BeginPaint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BeginPath
; Description....: Opens a path bracket in the specified device context.
; Syntax.........: _WinAPI_BeginPath ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After a path bracket is open, an application can begin calling GDI drawing functions to define the points that
;                  lie in the path. An application can close an open path bracket by calling the _WinAPI_EndPath() function.
;
;                  When an application calls _WinAPI_BeginPath() for a device context, any previous paths are discarded from that
;                  device context.
; Related........:
; Link...........: @@MsdnLink@@ BeginPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BeginPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'BeginPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_BeginPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BeginUpdateResource
; Description....: Retrieves a handle that can be used to add, delete, or replace resources in a binary module.
; Syntax.........: _WinAPI_BeginUpdateResource ( $sFile [, $fDelete] )
; Parameters.....: $sFile   - The binary file in which to update resources. An application must be able to obtain write-access to
;                             this file; the file referenced by $sFile cannot be currently executing.
;                  $fDelete - Specifies whether to delete existing resources, valid values:
;                  |TRUE    - The resources are deleted and the updated file includes only resources added with the _WinAPI_UpdateResource().
;                  |FALSE   - The updated file includes existing resources. (Default)
; Return values..: Success  - Handle that can be used by the _WinAPI_UpdateResource() and _WinAPI_EndUpdateResource() functions.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: It is recommended that the resource file is not loaded before this function is called. However, if that file
;                  is already loaded, it will not cause an error to be returned.
; Related........:
; Link...........: @@MsdnLink@@ BeginUpdateResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BeginUpdateResource($sFile, $fDelete = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'BeginUpdateResourceW', 'wstr', $sFile, 'int', $fDelete)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_BeginUpdateResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BringWindowToTop
; Description....: Brings the specified window to the top of the Z order.
; Syntax.........: _WinAPI_BringWindowToTop ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to bring to the top of the Z order.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ BringWindowToTop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BringWindowToTop($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'BringWindowToTop', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_BringWindowToTop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BroadcastSystemMessage
; Description....: Sends a message to the specified recipients.
; Syntax.........: _WinAPI_BroadcastSystemMessage ( $iMessage [, $wParam [, $lParam [, $iFlags [, $iRecipients]]]] )
; Parameters.....: $iMessage    - The message to be sent.
;                  $wParam      - Additional message-specific information.
;                  $lParam      - Additional message-specific information.
;                  $iFlags      - The broadcast option. This parameter can be one or more of the following values.
;
;                                 $BSF_ALLOWSFW
;                                 $BSF_FLUSHDISK
;                                 $BSF_FORCEIFHUNG
;                                 $BSF_IGNORECURRENTTASK
;                                 $BSF_NOHANG
;                                 $BSF_NOTIMEOUTIFNOTHUNG
;                                 $BSF_POSTMESSAGE
;                                 $BSF_QUERY
;                                 $BSF_SENDNOTIFYMESSAGE
;
;                  $iRecipients - The recipients of the message. This parameter can be one or more of the following values.
;
;                                 $BSM_ALLCOMPONENTS
;                                 $BSM_ALLDESKTOPS
;                                 $BSM_APPLICATIONS
;                                 $BSM_INSTALLABLEDRIVERS
;                                 $BSM_NETDRIVER
;                                 $BSM_VXDS
;
; Return values..: Success      - 1 or 0 (see below), @extended flag receives a combination of $BSM_* values identifying which
;                                 recipients actually received the message.
;                  Failure      - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the $iFlags parameter is $BSF_QUERY and at least one recipient returned BROADCAST_QUERY_DENY to the corresponding
;                  message, the return value is 0.
;
;                  The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages
;                  (those >= WM_USER) to another process, you must do custom marshalling.
; Related........:
; Link...........: @@MsdnLink@@ BroadcastSystemMessage
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BroadcastSystemMessage($iMessage, $wParam = 0, $lParam = 0, $iFlags = 0, $iRecipients = 0)

	Local $Ret = DllCall('user32.dll', 'long', 'BroadcastSystemMessageW', 'dword', $iFlags, 'dword*', $iRecipients, 'uint', $iMessage, 'wparam', $wParam, 'lparam', $lParam)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, -1)
	EndIf
	Return SetError(0, $Ret[2], $Ret[0])
EndFunc   ;==>_WinAPI_BroadcastSystemMessage

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BrowseForFolderDlg
; Description....: Displays a dialog box that enables the user to select a Shell folder.
; Syntax.........: _WinAPI_BrowseForFolderDlg ( [$sRoot [, $sText [, $iFlags [, $pBrowseProc [, $lParam [, $hParent] )
; Parameters.....: $sRoot       - The root folder from which to start browsing. Only the specified folder and its subfolders in the
;                                 namespace hierarchy appear in the dialog box. If this parameter is 0, the namespace root
;                                 (the Desktop folder) is used.
;                  $sText       - The string that is displayed above the tree view control in the dialog box.
;                  $iFlags      - Flags that specify the options for the dialog box. This parameter can a combination of the
;                                 following values.
;
;                                 $BIF_RETURNONLYFSDIRS
;                                 $BIF_DONTGOBELOWDOMAIN
;                                 $BIF_STATUSTEXT
;                                 $BIF_RETURNFSANCESTORS
;                                 $BIF_EDITBOX
;                                 $BIF_VALIDATE
;                                 $BIF_NEWDIALOGSTYLE
;                                 $BIF_BROWSEINCLUDEURLS
;                                 $BIF_USENEWUI
;                                 $BIF_UAHINT
;                                 $BIF_NONEWFOLDERBUTTON
;                                 $BIF_NOTRANSLATETARGETS
;                                 $BIF_BROWSEFORCOMPUTER
;                                 $BIF_BROWSEFORPRINTER
;                                 $BIF_BROWSEINCLUDEFILES
;                                 $BIF_SHAREABLE
;
;                  $pBrowseProc - Pointer to a callback function that the dialog box calls when an event occurs. This function will
;                                 receive one of the following event messages.
;
;                                 $BFFM_INITIALIZED
;                                 $BFFM_IUNKNOWN
;                                 $BFFM_SELCHANGED
;                                 $BFFM_VALIDATEFAILED
;
;                                 (See MSDN for more information)
;
;                  $lParam      - The value that the dialog box passes to the callback function.
;                  $hParent     - Handle to the parent window for the dialog box.
; Return values..: Success      - The full path for chosen folder, or empty string if user cancels/closes the dialog.
;                  Failure      - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHBrowseForFolder
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BrowseForFolderDlg($sRoot = '', $sText = '', $iFlags = 0, $pBrowseProc = 0, $lParam = 0, $hParent = 0)

	Local $tBROWSEINFO = DllStructCreate('hwnd;ptr;ptr;ptr;int;ptr;uint_ptr;int')
	Local $tText = DllStructCreate('wchar[1024]')
	Local $tName = DllStructCreate('wchar[260]')
	Local $PIDL = 0, $Result = ''

	If _WinAPI_PathIsDirectory($sRoot) Then
		$PIDL = _WinAPI_ShellILCreateFromPath(_WinAPI_PathSearchAndQualify($sRoot))
	EndIf

	DllStructSetData($tBROWSEINFO, 1, $hParent)
	DllStructSetData($tBROWSEINFO, 2, $PIDL)
	DllStructSetData($tBROWSEINFO, 3, DllStructGetPtr($tName))
	DllStructSetData($tBROWSEINFO, 4, DllStructGetPtr($tText))
	DllStructSetData($tBROWSEINFO, 5, $iFlags)
	DllStructSetData($tBROWSEINFO, 6, $pBrowseProc)
	DllStructSetData($tBROWSEINFO, 7, $lParam)
	DllStructSetData($tBROWSEINFO, 8, 0)

	DllStructSetData($tText, 1, $sText)

	Local $Ret = DllCall('shell32.dll', 'ptr', 'SHBrowseForFolderW', 'ptr', DllStructGetPtr($tBROWSEINFO))

	If @error Then
		Return SetError(1, 0, '')
	Else
		If Not $Ret[0] Then
			Return ''
		EndIf
	EndIf
	$Result = _WinAPI_ShellGetPathFromIDList($Ret[0])
	_WinAPI_CoTaskMemFree($Ret[0])
	If $PIDL Then
		_WinAPI_CoTaskMemFree($PIDL)
	EndIf
	If Not $Result Then
		Return SetError(1, 0, '')
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_BrowseForFolderDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BufferedPaintClear
; Description....: Clears a specified rectangle in the buffer to ARGB = {0,0,0,0}.
; Syntax.........: _WinAPI_BufferedPaintClear ( $hBP [, $tRECT] )
; Parameters.....: $hBP    - Handle of the buffered paint context.
;                  $tRECT  - $tagRECT structure that specifies the rectangle to clear. If this parameter is 0, the entire buffer is used.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ BufferedPaintClear
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BufferedPaintClear($hBP, $tRECT = 0)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'BufferedPaintClear', 'ptr', $hBP, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_BufferedPaintClear

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BufferedPaintInit
; Description....: Initialize buffered painting for the current thread.
; Syntax.........: _WinAPI_BufferedPaintInit ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Each call to _WinAPI_BufferedPaintInit() should be matched with a call to _WinAPI_BufferedPaintUnInit() when
;                  calls to buffered paint APIs are no longer needed.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ BufferedPaintInit
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BufferedPaintInit()

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'BufferedPaintInit')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_BufferedPaintInit

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BufferedPaintSetAlpha
; Description....: Sets the alpha to a specified value in a given rectangle.
; Syntax.........: _WinAPI_BufferedPaintSetAlpha ( $hBP [, $iAlpha [, $tRECT]] )
; Parameters.....: $hBP    - Handle of the buffered paint context.
;                  $iAlpha - The alpha value to set. The alpha value can range from zero (fully transparent) to 255 (fully opaque).
;                  $tRECT  - $tagRECT structure that specifies the rectangle in which to set the alpha. If this parameter is 0,
;                            the entire buffer is used.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ BufferedPaintSetAlpha
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BufferedPaintSetAlpha($hBP, $iAlpha = 255, $tRECT = 0)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'BufferedPaintSetAlpha', 'ptr', $hBP, 'ptr', DllStructGetPtr($tRECT), 'byte', $iAlpha)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_BufferedPaintSetAlpha

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BufferedPaintUnInit
; Description....: Closes down buffered painting for the current thread.
; Syntax.........: _WinAPI_BufferedPaintUnInit ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ BufferedPaintUnInit
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BufferedPaintUnInit()

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'BufferedPaintUnInit')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_BufferedPaintUnInit

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CalculatePopupWindowPosition
; Description....: Calculates an appropriate pop-up window position.
; Syntax.........: _WinAPI_CalculatePopupWindowPosition ( $iX, $iY, $iWidth, $iHeight [, $iFlags [, $tExclude]] )
; Parameters.....: $iX       - The x-coordinate, in logical units, of the specified anchor point.
;                  $iY       - The y-coordinate, in logical units, of the specified anchor point.
;                  $iWidth   - The width, in logical units, of the specified window.
;                  $iHeight  - The height, in logical units, of the specified window.
;                  $iFlags   - The flags that specify how the function positions the pop-up window horizontally and vertically.
;
;                              $TPM_CENTERALIGN
;                              $TPM_LEFTALIGN
;                              $TPM_RIGHTALIGN
;
;                              $TPM_BOTTOMALIGN
;                              $TPM_TOPALIGN
;                              $TPM_VCENTERALIGN
;
;                              $TPM_HORIZONTAL
;                              $TPM_VERTICAL
;
;                              $TPM_WORKAREA
;
;                  $tExclude - $tagRECT structure that specifies the exclude rectangle.
; Return values..: Success   - $tagRECT structure that specifies the pop-up window position.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ CalculatePopupWindowPosition
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CalculatePopupWindowPosition($iX, $iY, $iWidth, $iHeight, $iFlags = 0, $tExclude = 0)

	Local $tAnchor = DllStructCreate($tagPOINT), $tSIZE = DllStructCreate($tagSIZE), $tPos = DllStructCreate($tagRECT)

	DllStructSetData($tAnchor, 1, $iX)
	DllStructSetData($tAnchor, 2, $iY)

	DllStructSetData($tSIZE, 1, $iWidth)
	DllStructSetData($tSIZE, 2, $iHeight)

	Local $Ret = DllCall('user32.dll', 'int', 'CalculatePopupWindowPosition', 'ptr', DllStructGetPtr($tAnchor), 'ptr', DllStructGetPtr($tSIZE), 'uint', $iFlags, 'ptr', DllStructGetPtr($tExclude), 'ptr', DllStructGetPtr($tPos))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tPos
EndFunc   ;==>_WinAPI_CalculatePopupWindowPosition

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CascadeWindows
; Description....: Cascades the specified child windows of the specified parent window.
; Syntax.........: _WinAPI_CascadeWindows ( $aWnds [, $tRECT [, $hParent [, $iFlags [, $iStart [, $iEnd]]]]] )
; Parameters.....: $aWnds   - The array of handles to the child windows to arrange. If a specified child window is a top-level window
;                             with the style $WS_EX_TOPMOST or $WS_EX_TOOLWINDOW, the child window is not arranged. If this parameter
;                             is 0, all child windows of the specified parent window (or of the desktop window) are arranged.
;                  $tRECT   - $tagRECT structure that specifies the rectangular area, in client coordinates, within which the windows
;                             are arranged. This parameter can be 0, in which case the client area of the parent window is used.
;                  $hParent - Handle to the parent window. If this parameter is 0, the desktop window is assumed.
;                  $iFlags  - A cascade flag. This parameter can be one or more of the following values.
;
;                             $MDITILE_SKIPDISABLED
;                             $MDITILE_ZORDER
;
;                  $iStart  - The index of array to start arranging at.
;                  $iEnd    - The index of array to stop arranging at.
; Return values..: Success  - The value is the number of windows arranged.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CascadeWindows
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CascadeWindows($aWnds, $tRECT = 0, $hParent = 0, $iFlags = 0, $iStart = 0, $iEnd = -1)

	Local $Count, $tWnds

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aWnds) - 1) Then
		$iEnd = UBound($aWnds) - 1
	EndIf
	$Count = $iEnd - $iStart + 1
	If $Count < 1 Then
		Return SetError(1, 0, 0)
	EndIf
	$tWnds = DllStructCreate('hwnd[' & $Count & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = 1
	For $i = $iStart To $iEnd
		DLLStructSetData($tWnds, 1, $aWnds[$i], $Count)
		$Count += 1
	Next

	Local $Ret = DllCall('user32.dll', 'ushort', 'CascadeWindows', 'hwnd', $hParent, 'uint', $iFlags, 'ptr', DllStructGetPtr($tRECT), 'uint', $Count - 1, 'ptr', DllStructGetPtr($tWnds))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CascadeWindows

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ChangeWindowMessageFilterEx
; Description....: Modifies the User Interface Privilege Isolation (UIPI) message filter for a specified window.
; Syntax.........: _WinAPI_ChangeWindowMessageFilterEx ( $hWnd, $iMsg, $iAction )
; Parameters.....: $hWnd    - Handle to the window whose UIPI message filter is to be modified. If this parameter is 0, the UIPI
;                             message filter will be modified in a process-wide manner. Moreover, under Windows Vista this parameter
;                             is not used and should be set to 0.
;                  $iMsg    - The message that the message filter allows through or blocks.
;                  $iAction - The action to be performed. This parameter can be one of the following values.
;
;                             $MSGFLT_ALLOW
;                             $MSGFLT_DISALLOW
;
;                             Windows 7 or later
;
;                             $MSGFLT_RESET
;
; Return values..: Success  - 1 and sets the @extended flag to 0 or one of the following values (only under Windows 7 and later).
;
;                             $MSGFLTINFO_ALLOWED_HIGHER
;                             $MSGFLTINFO_ALREADYALLOWED_FORWND
;                             $MSGFLTINFO_ALREADYDISALLOWED_FORWND
;                             $MSGFLTINFO_NONE
;
;                             (See MSDN for more information)
;
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: UIPI is a security feature that prevents messages from being received from a lower-integrity-level sender.
;                  You can use this function to allow specific messages to be delivered to a window even if the message originates
;                  from a process at a lower integrity level.
;
;                  Certain messages whose value is smaller than WM_USER are required to be passed through the filter, regardless
;                  of the filter setting. There will be no effect when you attempt to use this function to allow or block such
;                  messages.
;
;                  This function requires Windows Vista or later.
;
; Related........:
; Link...........: @@MsdnLink@@ ChangeWindowMessageFilterEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ChangeWindowMessageFilterEx($hWnd, $iMsg, $iAction)

	Local $tCFS, $Ret

	If ($hWnd) And ($__WINVER > 0x0600) Then
		$tCFS = DllStructCreate('dword;dword')
		DllStructSetData($tCFS, 1, 4)
		$Ret = DllCall('user32.dll', 'int', 'ChangeWindowMessageFilterEx', 'hwnd', $hWnd, 'uint', $iMsg, 'dword', $iAction, 'ptr', DllStructGetPtr($tCFS))
	Else
		$tCFS = 0
		$Ret = DllCall('user32.dll', 'int', 'ChangeWindowMessageFilter', 'uint', $iMsg, 'dword', $iAction)
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, DllStructGetData($tCFS, 2), 1)
EndFunc   ;==>_WinAPI_ChangeWindowMessageFilterEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CharToOem
; Description....: Converts a string into the OEM-defined character set.
; Syntax.........: _WinAPI_CharToOem ( $sStr )
; Parameters.....: $sStr   - The string that must be converted.
; Return values..: Success - The converted string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CharToOem
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CharToOem($sStr)

	Local $tData = DllStructCreate('char[' & StringLen($sStr) + 1 & ']')
	Local $Ret = DllCall('user32.dll', 'int', 'CharToOem', 'str', $sStr, 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_CharToOem

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ChildWindowFromPointEx
; Description....: Determines which, if any, of the child windows belonging to the specified parent window contains the specified point.
; Syntax.........: _WinAPI_ChildWindowFromPointEx ( $hWnd, $tPOINT [, $iFlags] )
; Parameters.....: $hWnd   - Handle to the parent window.
;                  $tPOINT - $tagPOINT structure that defines the client coordinates (relative to hwndParent) of the point to
;                            be checked.
;                  $iFlags - The flags that specify which child windows to skip. This parameter can be one or more of the
;                            following values.
;
;                            $CWP_ALL
;                            $CWP_SKIPINVISIBLE
;                            $CWP_SKIPDISABLED
;                            $CWP_SKIPTRANSPARENT
;
; Return values..: Success - Handle to the first child window. If the point is within the parent window but not within any child
;                            window that meets the criteria, the return value is a handle to the parent window. If the point lies
;                            outside the parent window, the return value is 0.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The system maintains an internal list that contains the handles of the child windows associated with a
;                  parent window. The order of the handles in the list depends on the Z order of the child windows. If more than
;                  one child window contains the specified point, the system returns a handle to the first window in the list
;                  that contains the point and meets the criteria specified by $iFlags.
; Related........:
; Link...........: @@MsdnLink@@ ChildWindowFromPointEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ChildWindowFromPointEx($hWnd, $tPOINT, $iFlags = 0)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'ChildWindowFromPointEx', 'hwnd', $hWnd, 'int', DllStructGetData($tPOINT, 1), 'int', DllStructGetData($tPOINT, 2), 'uint', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ChildWindowFromPointEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ClipCursor
; Description....: Confines the cursor to a rectangular area on the screen.
; Syntax.........: _WinAPI_ClipCursor ( $tRECT )
; Parameters.....: $tRECT  - $tagRECT structure that contains the screen coordinates of the confining rectangle. If this parameter is 0,
;                            the cursor is free to move anywhere on the screen.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The cursor is a shared resource. If an application confines the cursor, it must release the cursor by using
;                  _WinAPI_ClipCursor() before relinquishing control to another application.
; Related........:
; Link...........: @@MsdnLink@@ ClipCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ClipCursor($tRECT)

	Local $Ret = DllCall('user32.dll', 'int', 'ClipCursor', 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ClipCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CloseDesktop
; Description....: Closes an open handle to a desktop object.
; Syntax.........: _WinAPI_CloseDesktop ( $hDesktop )
; Parameters.....: $hDesktop - Handle to the desktop to be closed.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CloseDesktop() function will fail if any thread in the calling process is using the specified desktop
;                  handle or if the handle refers to the initial desktop of the calling process.
; Related........:
; Link...........: @@MsdnLink@@ CloseDesktop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CloseDesktop($hDesktop)

	Local $Ret = DllCall('user32.dll', 'int', 'CloseDesktop', 'ptr', $hDesktop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CloseDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CloseEnhMetaFile
; Description....: Closes an enhanced-metafile device context and returns a handle that identifies an enhanced-format metafile.
; Syntax.........: _WinAPI_CloseEnhMetaFile ( $hDC )
; Parameters.....: $hDC    - Handle to an enhanced-metafile device context.
; Return values..: Success - Handle to an enhanced metafile.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the
;                  _WinAPI_DeleteEnhMetaFile() function.
; Related........:
; Link...........: @@MsdnLink@@ CloseEnhMetaFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CloseEnhMetaFile($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'CloseEnhMetaFile', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CloseEnhMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CloseFigure
; Description....: Closes an open figure in a path.
; Syntax.........: _WinAPI_CloseFigure ( $hDC )
; Parameters.....: $hDC    - Handle to the device context in which the figure will be closed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CloseFigure() function closes the figure by drawing a line from the current position to the first
;                  point of the figure (usually, the point specified by the most recent call to the _WinAPI_MoveToEx() function)
;                  and then connects the lines by using the line join style.
; Related........:
; Link...........: @@MsdnLink@@ CloseFigure
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CloseFigure($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'CloseFigure', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CloseFigure

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CloseThemeData
; Description....: Closes the theme data handle.
; Syntax.........: _WinAPI_CloseThemeData ( $hTheme )
; Parameters.....: $hTheme - Handle to a window's specified theme data.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CloseThemeData
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CloseThemeData($hTheme)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'CloseThemeData', 'ptr', $hTheme)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CloseThemeData

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CloseWindow
; Description....: Minimizes (but does not destroy) the specified window.
; Syntax.........: _WinAPI_CloseWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to be minimized.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CloseWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CloseWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'CloseWindow', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CloseWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CloseWindowStation
; Description....: Closes an open window station handle.
; Syntax.........: _WinAPI_CloseWindowStation ( $hStation )
; Parameters.....: $hStation - Handle to the window station to be closed.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CloseWindowStation() function will fail if the handle being closed is for the window station
;                  assigned to the calling process.
; Related........:
; Link...........: @@MsdnLink@@ CloseWindowStation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CloseWindowStation($hStation)

	Local $Ret = DllCall('user32.dll', 'int', 'CloseWindowStation', 'ptr', $hStation)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CloseWindowStation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CoInitialize
; Description....: Initializes the COM library for use by the calling process.
; Syntax.........: _WinAPI_CoInitialize ( [$iFlags] )
; Parameters.....: $iFlags - This parameter can be one or more of the following values.
;
;                            $COINIT_APARTMENTTHREADED
;                            $COINIT_DISABLE_OLE1DDE
;                            $COINIT_MULTITHREADED
;                            $COINIT_SPEED_OVER_MEMORY
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CoInitializeEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CoInitialize($iFlags = 0)

	Local $Ret = DllCall('ole32.dll', 'uint', 'CoInitializeEx', 'ptr', 0, 'dword', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CoInitialize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ColorHLSToRGB
; Description....: Converts colors from hue-luminance-saturation (HLS) to RGB format.
; Syntax.........: _WinAPI_ColorHLSToRGB ( $iHue, $iLuminance, $iSaturation )
; Parameters.....: $iHue        - HLS hue value.
;                  $iLuminance  - HLS luminance value.
;                  $iSaturation - HLS saturation value.
; Return values..: Success      - Returns the RGB value.
;                  Failure      - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ColorHLSToRGB
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ColorHLSToRGB($iHue, $iLuminance, $iSaturation)

	If Not $iSaturation Then
		$iHue = 160
	EndIf

	Local $Ret = DllCall('shlwapi.dll', 'dword', 'ColorHLSToRGB', 'dword', $iHue, 'dword', $iLuminance, 'dword', $iSaturation)

	If @error Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_ColorHLSToRGB

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ColorRGBToHLS
; Description....: Converts colors from RGB to hue-luminance-saturation (HLS) format.
; Syntax.........: _WinAPI_ColorRGBToHLS ( $iRGB, ByRef $iHue, ByRef $iLuminance, ByRef $iSaturation )
; Parameters.....: $iRGB        - RGB color.
;                  $iHue        - HLS hue value.
;                  $iLuminance  - HLS luminance value.
;                  $iSaturation - HLS saturation value.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ColorRGBToHLS
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ColorRGBToHLS($iRGB, ByRef $iHue, ByRef $iLuminance, ByRef $iSaturation)

	Local $Ret = DllCall('shlwapi.dll', 'none', 'ColorRGBToHLS', 'dword', __RGB($iRGB), 'dword*', 0, 'dword*', 0, 'dword*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$iHue = $Ret[2]
	$iLuminance = $Ret[3]
	$iSaturation = $Ret[4]
	Return 1
EndFunc   ;==>_WinAPI_ColorRGBToHLS

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CombineTransform
; Description....: Concatenates two world-space to page-space transformations.
; Syntax.........: _WinAPI_CombineTransform ( $tXFORM1, $tXFORM2 )
; Parameters.....: $tXFORM1 - $tagXFORM structure that specifies the first transformation.
;                  $tXFORM2 - $tagXFORM structure that specifies the second transformation.
; Return values..: Success  - $tagXFORM structure that contains the combined transformation.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Applying the combined transformation has the same effect as applying the first transformation and then
;                  applying the second transformation.
; Related........:
; Link...........: @@MsdnLink@@ CombineTransform
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CombineTransform($tXFORM1, $tXFORM2)

	Local $tXFORM = DllStructCreate($tagXFORM)
	Local $Ret = DllCall('gdi32.dll', 'int', 'CombineTransform', 'ptr', DllStructGetPtr($tXFORM), 'ptr', DllStructGetPtr($tXFORM1), 'ptr', DllStructGetPtr($tXFORM2))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tXFORM
EndFunc   ;==>_WinAPI_CombineTransform

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CommandLineToArgv
; Description....: Parses a command-line string and returns an array of the command-line arguments.
; Syntax.........: _WinAPI_CommandLineToArgv ( $sCmd )
; Parameters.....: $sCmd   - The string that contains the full command line. If this parameter is an empty string the function returns
;                            an empty array (zeroth element is 0).
; Return values..: Success - The array of the command-line arguments. The zeroth array element contains the number of arguments.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CommandLineToArgvW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CommandLineToArgv($sCmd)

	Local $Result[1] = [0]

	$sCmd = StringStripWS($sCmd, 3)
	If Not $sCmd Then
		Return $Result
	EndIf

	Local $Ret, $Struct, $tArg, $tCmd, $tPtr

	$Struct = 'wchar[' & (StringLen($sCmd) + 1) & ']'
	$tCmd = DllStructCreate($Struct)
	DllStructSetData($tCmd, 1, $sCmd)
	$Ret = DllCall('shell32.dll', 'ptr', 'CommandLineToArgvW', 'ptr', DllStructGetPtr($tCmd), 'int*', 0)
	If (@error) Or (Not $Ret[0]) Or (Not $Ret[2]) Then
		Return SetError(1, 0, 0)
	EndIf
	$tPtr = DllStructCreate('ptr[' & $Ret[2] & ']', $Ret[0])
	Dim $Result[$Ret[2] + 1] = [$Ret[2]]
	For $i = 1 To $Ret[2]
		$tArg = DllStructCreate($Struct, DllStructGetData($tPtr, 1, $i))
		If Not @error Then
			$Result[$i] = DllStructGetData($tArg, 1)
		Else
			$Result = 0
			ExitLoop
		EndIf
	Next
	_WinAPI_LocalFree($Ret[0])
	If Not IsArray($Result) Then
		Return SetError(2, 0, 0)
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_CommandLineToArgv

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CommDlgExtendedErrorEx
; Description....: Returns a common dialog box error code.
; Syntax.........: _WinAPI_CommDlgExtendedErrorEx ( )
; Parameters.....: None
; Return values..: The general error codes for any of the common dialog box functions ($CDERR_*, $PDERR_*, $CFERR_*, $FNERR_*, and $FRERR_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CommDlgExtendedError
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CommDlgExtendedErrorEx()

	Local $Ret = DllCall('comdlg32.dll', 'dword', 'CommDlgExtendedError')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CommDlgExtendedErrorEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CompressBitmapBits
; Description....: Creates a compressed data block from the specified bitmap.
; Syntax.........: _WinAPI_CompressBitmapBits ( $hBitmap, ByRef $tBuffer [, $iCompression [, $iQuality]] )
; Parameters.....: $hBitmap      - Handle to the bitmap to be compressed.
;                  $tBuffer      - The any valid variable that receives the compressed data. If the function succeeds, this
;                                  variable will contain "byte[n]" structure with compressed data, or 0 otherwise.
;                  $iCompression - The compression method. This parameter can be one of the following values.
;
;                                  $COMPRESSION_BITMAP_PNG
;                                  $COMPRESSION_BITMAP_JPEG
;
;                  $iQuality     - The quality of JPEG image, in percent. This value is ignored for non JPEG compression.
; Return values..: Success       - The length of the compressed data that was stored in $tBuffer parameter, in bytes.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: In fact, the data that returns this function represent .jpeg or .png image file in binary form. You can use the
;                  _WinAPI_WriteFile() function to create the appropriate image file directly from this data.
;
;                  The returned data always represent a 24-bit color depth .jpeg image, or 32-bit color depth (with or without
;                  alpha chanel) .png image independent on the color depth of the source bitmap.
;
;                  This function internally uses the GDI+ DLL library.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CompressBitmapBits($hBitmap, ByRef $tBuffer, $iCompression = 0, $iQuality = 100)

	Local $tDIB, $Size[2], $Count, $Format, $Lenght, $Mime, $Ret, $hDll, $hDC, $hSv, $hMem, $tBits, $tInfo, $tData, $pData
	Local $hSource = 0, $hImage = 0, $hToken = 0, $pEncoder = 0, $pStream = 0, $tParam = 0
	Local $tDIB = DllStructCreate($tagDIBSECTION)

	$tBuffer = 0

	$hDll = DllOpen('gdiplus.dll')
	If $hDll = -1 Then
		Return SetError(4, 0, 0)
	EndIf
	Do
		Switch $iCompression
			Case 0
				$Mime = 'image/png'
			Case 1
				$Mime = 'image/jpeg'
			Case Else
				ExitLoop
		EndSwitch
		While $hBitmap
			If Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), DllStructGetPtr($tDIB)) Then
				ExitLoop 2
			EndIf
			If (DllStructGetData($tDIB, 'bmBitsPixel') = 32) And (Not DllStructGetData($tDIB, 'biCompression')) Then
				ExitLoop
			EndIf
			If $hSource Then
				ExitLoop 2
			EndIf
			$hSource = _WinAPI_CreateDIB(DllStructGetData($tDIB, 'bmWidth'), DllStructGetData($tDIB, 'bmHeight'))
			If @error Then
				ExitLoop 2
			EndIf
			$hDC = _WinAPI_CreateCompatibleDC(0)
			$hSv = _WinAPI_SelectObject($hDC, $hSource)
			If _WinAPI_DrawBitmap($hDC, 0, 0, $hBitmap) Then
				$hBitmap = $hSource
			Else
				$hBitmap = 0
			EndIf
			_WinAPI_SelectObject($hDC, $hSv)
			_WinAPI_DeleteDC($hDC)
		WEnd
		If Not $hBitmap Then
			ExitLoop
		EndIf
		For $i = 0 To 1
			$Size[$i] = DllStructGetData($tDIB, $i + 2)
		Next
		$tBits = DllStructCreate('byte[' & ($Size[0] * $Size[1] * 4) & ']')
		If Not _WinAPI_GetBitmapBits($hBitmap, DllStructGetSize($tBits), DllStructGetPtr($tBits)) Then
			ExitLoop
		EndIf
		$tData = DllStructCreate('uint;ptr;int;int')
		DllStructSetData($tData, 1, 1)
		$Ret = DllCall($hDll, 'uint', 'GdiplusStartup', 'ptr*', 0, 'ptr', DllStructGetPtr($tData), 'ptr', 0)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		If _WinAPI_IsAlphaBitmap($hBitmap) Then
			$Format = 0x0026200A
		Else
			$Format = 0x00022009
		EndIf
		$hToken = $Ret[1]
		$Ret = DllCall($hDll, 'uint', 'GdipCreateBitmapFromScan0', 'int', $Size[0], 'int', $Size[1], 'uint', $Size[0] * 4, 'uint', $Format, 'ptr', DllStructGetPtr($tBits), 'ptr*', 0)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		$hImage = $Ret[6]
		$Ret = DllCall($hDll, 'uint', 'GdipGetImageEncodersSize', 'uint*', 0, 'uint*', 0)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		$Count = $Ret[1]
		$tData = DllStructCreate('byte[' & $Ret[2] & ']')
		If @error Then
			ExitLoop
		EndIf
		$pData = DllStructGetPtr($tData)
		$Ret = DllCall($hDll, 'uint', 'GdipGetImageEncoders', 'uint', $Count, 'uint', $Ret[2], 'ptr', $pData)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		For $i = 1 To $Count
			$tInfo = DllStructCreate('byte[16];byte[16];ptr[5];dword[4];ptr[2]', $pData)
			If Not StringInStr(_WinAPI_WideCharToMultiByte(DllStructGetData($tInfo, 3, 5)), $Mime) Then
				$pData += DllStructGetSize($tInfo)
			Else
				$pEncoder = $pData
				ExitLoop
			EndIf
		Next
		If Not $pEncoder Then
			ExitLoop
		EndIf
		Switch $iCompression
			Case 0
				; Nothing
			Case 1
				$tParam = DllStructCreate('dword;byte[16];dword;dword;ptr;ulong')
				DllStructSetData($tParam, 1, 1)
				DllStructSetData($tParam, 3, 1)
				DllStructSetData($tParam, 4, 4)
				DllStructSetData($tParam, 5, DllStructGetPtr($tParam, 6))
				DllStructSetData($tParam, 6, $iQuality)
				$Ret = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', '{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}', 'ptr', DllStructGetPtr($tParam, 2))
				If (@error) Or ($Ret[0]) Then
					$tParam = 0
				EndIf
		EndSwitch
		$pStream = _WinAPI_CreateStreamOnHGlobal(0)
		$Ret = DllCall($hDll, 'uint', 'GdipSaveImageToStream', 'ptr', $hImage, 'ptr', $pStream, 'ptr', $pEncoder, 'ptr', DllStructGetPtr($tParam))
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		$hMem = _WinAPI_GetHGlobalFromStream($pStream)
		$Ret = DllCall('kernel32.dll', 'ulong_ptr', 'GlobalSize', 'ptr', $hMem)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Lenght = $Ret[0]
		$Ret = DllCall('kernel32.dll', 'ptr', 'GlobalLock', 'ptr', $hMem)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$tBuffer = DllStructCreate('byte[' & $Lenght & ']')
		If Not @error Then
			_WinAPI_MoveMemory(DllStructGetPtr($tBuffer), $Ret[0], $Lenght)
		EndIf
	Until 1
	If $pStream Then
		_WinAPI_ReleaseStream($pStream)
	EndIf
	If $hImage Then
		DllCall($hDll, 'uint', 'GdipDisposeImage', 'ptr', $hImage)
	EndIf
	If $hToken Then
		DllCall($hDll, 'none', 'GdiplusShutdown', 'ptr', $hToken)
	EndIf
	DllClose($hDll)
	If $hSource Then
		_WinAPI_DeleteObject($hSource)
	EndIf
	If Not IsDllStruct($tBuffer) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Lenght
EndFunc   ;==>_WinAPI_CompressBitmapBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ComputeCrc32
; Description....: Calculates the CRC32 checksum of a block of memory.
; Syntax.........: _WinAPI_ComputeCrc32 ( $pMemory, $iLenght )
; Parameters.....: $pMemory - A pointer to the memory to calculate the checksum.
;                  $iLenght - The number of bytes to be calculated.
; Return values..: Success  - The CRC32 checksum (DWORD).
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlComputeCrc32
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ComputeCrc32($pMemory, $iLenght)

	Local $Ret = DllCall('ntdll.dll', 'dword', 'RtlComputeCrc32', 'dword', 0, 'ptr', $pMemory, 'int', $iLenght)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ComputeCrc32

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyBitmap
; Description....: Creates a duplicate of a specified bitmap with a device-independent bitmap (DIB) section.
; Syntax.........: _WinAPI_CopyBitmap ( $hBitmap )
; Parameters.....: $hBitmap - Handle to the bitmap to be duplicated.
; Return values..: Success  - Handle to the new bitmap that was created.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the bitmap, destroy it using the _WinAPI_DeleteObject() function.
; Related........:
; Link...........: @@MsdnLink@@ CopyImage
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyBitmap($hBitmap)
	Return _WinAPI_CopyImage($hBitmap, 0, 0, 0, 0x2000)
EndFunc   ;==>_WinAPI_CopyBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyCursor
; Description....: Creates a duplicate of a specified cursor.
; Syntax.........: _WinAPI_CopyCursor ( $hCursor )
; Parameters.....: $hCursor - Handle to the cursor to be duplicated.
; Return values..: Success  - Handle to the new cursor that was created.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the cursor, destroy it using the _WinAPI_DestroyCursor() function.
; Related........:
; Link...........: @@MsdnLink@@ CopyIcon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyCursor($hCursor)
	Return _WinAPI_CopyIcon($hCursor)
EndFunc   ;==>_WinAPI_CopyCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyEnhMetaFile
; Description....: Copies the contents of an enhanced-format metafile to a specified file.
; Syntax.........: _WinAPI_CopyEnhMetaFile ( $hEmf [, $sFile] )
; Parameters.....: $hEmf   - Handle to the enhanced metafile to be copied.
;                  $sFile  - The name of the destination file (.emf). If this parameter is 0, the source metafile is copied to memory.
; Return values..: Success - Handle to the copy of the enhanced metafile.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the
;                  _WinAPI_DeleteEnhMetaFile() function.
; Related........:
; Link...........: @@MsdnLink@@ CopyEnhMetaFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyEnhMetaFile($hEmf, $sFile = '')

	Local $TypeOfFile = 'wstr'

	If Not StringStripWS($sFile, 3) Then
		$TypeOfFile = 'ptr'
		$sFile = 0
	EndIf

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CopyEnhMetaFileW', 'ptr', $hEmf, $TypeOfFile, $sFile)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CopyEnhMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyFileEx
; Description....: Copies an existing file to a new file, notifying the application of its progress through a callback function.
; Syntax.........: _WinAPI_CopyFileEx ( $sExistingFile, $sNewFile [, $iFlags [, $pProgressProc [, $pData] )
; Parameters.....: $sExistingFile - The name of an existing file.
;                  $sNewFile      - The name of the new file.
;                  $iFlags        - The flags that specify how the file is to be copied. This parameter can be a combination
;                                   of the following values.
;
;                                   $COPY_FILE_ALLOW_DECRYPTED_DESTINATION
;                                   $COPY_FILE_COPY_SYMLINK
;                                   $COPY_FILE_FAIL_IF_EXISTS
;                                   $COPY_FILE_NO_BUFFERING
;                                   $COPY_FILE_OPEN_SOURCE_FOR_WRITE
;                                   $COPY_FILE_RESTARTABLE
;
;                  $pProgressProc - The address of a callback function that is called each time another portion of the file
;                                   has been copied.
;
;                                   (See MSDN for more information)
;
;                  $pData         - The argument to be passed to the callback function.
; Return values..: Success        - 1.
;                  Failure        - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CopyFileEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyFileEx($sExistingFile, $sNewFile, $iFlags = 0, $pProgressProc = 0, $pData = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'CopyFileExW', 'wstr', $sExistingFile, 'wstr', $sNewFile, 'ptr', $pProgressProc, 'long_ptr', $pData, 'ptr', 0, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CopyFileEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyImage
; Description....: Creates a new image (icon, cursor, or bitmap) and copies the attributes of the specified image to the new one.
; Syntax.........: _WinAPI_CopyImage ( $hImage [, $iType [, $xDesired [, $yDesired [, $iFlags]]]] )
; Parameters.....: $hImage   - Handle to the image to be copied.
;                  $iType    - Specifies the type of image to be copied. This parameter can be one of the following values.
;
;                              $IMAGE_BITMAP
;                              $IMAGE_CURSOR
;                              $IMAGE_ICON
;
;                  $xDesired - Specifies the desired width, in pixels, of the image. If this is zero, then the returned image will
;                              have the same width as the original $hImage.
;                  $yDesired - Specifies the desired height, in pixels, of the image. If this is zero, then the returned image will
;                              have the same height as the original $hImage.
;                  $iFlags   - This parameter can be one or more of the following values.
;
;                              $LR_COPYDELETEORG
;                              $LR_COPYFROMRESOURCE
;                              $LR_COPYRETURNORG
;                              $LR_CREATEDIBSECTION
;                              $LR_DEFAULTSIZE
;                              $LR_MONOCHROME
;
; Return values..: Success   - Handle to the newly created image.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the resource, you can release its associated memory by calling _WinAPI_DeleteObject()
;                  function respectively for bitmaps, cursors, or icons. The system automatically deletes the resource when its
;                  process terminates, however, calling the appropriate function saves memory and decreases the size of the
;                  process's working set.
; Related........:
; Link...........: @@MsdnLink@@ CopyImage
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyImage($hImage, $iType = 0, $xDesired = 0, $yDesired = 0, $iFlags = 0)

	Local $Ret = DllCall('user32.dll', 'ptr', 'CopyImage', 'ptr', $hImage, 'int', $iType, 'int', $xDesired, 'int', $yDesired, 'int', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CopyImage

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyRect
; Description....: Copies the coordinates of one rectangle to another.
; Syntax.........: _WinAPI_CopyRect ( $tRECT )
; Parameters.....: $tRECT  - $tagRECT structure whose coordinates are to be copied in logical units.
; Return values..: Success - $tagRECT structure that contains the logical coordinates of the source rectangle.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CopyRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyRect($tRECT)

	Local $tData = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'CopyRect ', 'ptr', DllStructGetPtr($tData), 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tData
EndFunc   ;==>_WinAPI_CopyRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyStruct
; Description....: Creates a duplicate of a specified structure.
; Syntax.........: _WinAPI_CopyStruct (ByRef $tStruct [, $sStruct] )
; Parameters.....: $tStruct - The structure to be duplicated.
;                  $sStruct - The string representing the structure (same as for the DllStructCreate()).
; Return values..: Success  - "byte[n]" or $sStruct structure that was created.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyStruct(ByRef $tStruct, $sStruct = '')

	Local $Size = DllStructGetSize($tStruct)

	If Not $Size Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSrc, $tDst, $tResult

	If Not StringStripWS($sStruct, 7) Then
		$sStruct = 'byte[' & $Size & ']'
	EndIf
	$tResult = DllStructCreate($sStruct)
	$tDst = DllStructCreate('byte[' & $Size & ']', DllStructGetPtr($tResult))
	$tSrc = DllStructCreate('byte[' & $Size & ']', DllStructGetPtr($tStruct))
	If (Not IsDllStruct($tResult)) Or (Not IsDllStruct($tDst)) Or (Not IsDllStruct($tSrc)) Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = 1 To $Size
		DllStructSetData($tDst, 1, DllStructGetData($tSrc, 1, $i), $i)
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
	Next
	Return $tResult
EndFunc   ;==>_WinAPI_CopyStruct

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CoTaskMemAlloc
; Description....: Allocates a block of task memory.
; Syntax.........: _WinAPI_CoTaskMemAlloc ( $iSize )
; Parameters.....: $iSize  - The size of the memory block to be allocated, in bytes.
; Return values..: Success - The allocated memory block.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If $iSize is 0, _WinAPI_CoTaskMemAlloc() allocates a zero-length item and returns a valid pointer to that item.
;                  The allocated block may be larger than $iSize bytes because of the space required for alignment and for
;                  maintenance information.
; Related........:
; Link...........: @@MsdnLink@@ CoTaskMemAlloc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CoTaskMemAlloc($iSize)

	Local $Ret = DllCall('ole32.dll', 'ptr', 'CoTaskMemAlloc', 'uint_ptr', $iSize)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CoTaskMemAlloc

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CoTaskMemFree
; Description....: Frees a block of task memory.
; Syntax.........: _WinAPI_CoTaskMemFree ( $hMemory )
; Parameters.....: $hMemory - The pointer to the memory block to be freed.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CoTaskMemFree
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CoTaskMemFree($hMemory)
	DllCall('ole32.dll', 'int', 'CoTaskMemFree', 'ptr', $hMemory)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CoTaskMemFree

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CoTaskMemRealloc
; Description....: Changes the size of a previously allocated block of task memory.
; Syntax.........: _WinAPI_CoTaskMemRealloc ( $hMemory, $iSize )
; Parameters.....: $hMemory - The pointer to the memory block to be reallocated.
;                  $iSize   - The size of the memory block to be reallocated, in bytes.
; Return values..: Success  - The reallocated memory block.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If $hMemory is 0, function allocates a new memory block in the same way as the _WinAPI_CoTaskMemAlloc() function.
;                  If $hMemory is not 0, it should be a pointer returned by a prior call to _WinAPI_CoTaskMemAlloc().
;
;                  The contents of the block are unchanged up to the shorter of the new and old sizes, although the new block
;                  can be in a different location. If $hMemory is not 0 and $iSize is 0, then the memory pointed to by
;                  $hMemory is freed.
; Related........:
; Link...........: @@MsdnLink@@ CoTaskMemRealloc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CoTaskMemRealloc($hMemory, $iSize)

	Local $Ret = DllCall('ole32.dll', 'ptr', 'CoTaskMemRealloc', 'ptr', $hMemory, 'uint_ptr', $iSize)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CoTaskMemRealloc

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CoUninitialize
; Description....: Closes the COM library on the current process.
; Syntax.........: _WinAPI_CoUninitialize ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CoUninitialize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CoUninitialize()
	DllCall('ole32.dll', 'none', 'CoUninitialize')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CoUninitialize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Create32BitHBITMAP
; Description....: Creates a 32 bits-per-pixel bitmap from the specified icon.
; Syntax.........: _WinAPI_Create32BitHBITMAP ( $hIcon [, $fDelete] )
; Parameters.....: $hIcon   - Handle to the source icon.
;                  $fDelete - Specifies whether delete the icon after the function is successful, valid values:
;                  |TRUE    - Icon will be deleted if the function succeeds.
;                  |FALSE   - Don't delete, you must release the icon when you are finished using it. (Default)
; Return values..: Success  - Handle to the created bitmap.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the bitmap, destroy it using the _WinAPI_DeleteObject() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Create32BitHBITMAP($hIcon, $fDelete = 0)

	Local $tBIHDR, $tSIZE, $hIL, $hDC, $hMemDC, $hSv, $hBitmap, $pBits, $Ret, $Error = 1

	$tSIZE = _WinAPI_GetIconDimension($hIcon)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$hIL = DllCall('comctl32.dll', 'ptr', 'ImageList_Create', 'int', DllStructGetData($tSIZE, 1), 'int', DllStructGetData($tSIZE, 2), 'uint', 0x0021, 'int', 1, 'int', 1)
	If (@error) Or (Not $hIL[0]) Then
		Return SetError(2, 0, 0)
	EndIf
	$tBIHDR = DllStructCreate($tagBITMAPINFOHEADER)
	DllStructSetData($tBIHDR, 1, DllStructGetSize($tBIHDR))
	DllStructSetData($tBIHDR, 2, DllStructGetData($tSIZE, 1))
	DllStructSetData($tBIHDR, 3, DllStructGetData($tSIZE, 2))
	DllStructSetData($tBIHDR, 4, 1)
	DllStructSetData($tBIHDR, 5, 32)
	DllStructSetData($tBIHDR, 6, $BI_RGB)
	$hDC = _WinAPI_GetDC(0)
	Do
		$hBitmap = _WinAPI_CreateDIBSection($hDC, $tBIHDR, $DIB_RGB_COLORS, $pBits)
		If @error Then
			ExitLoop
		EndIf
		$Ret = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'ptr', $hIL[0], 'int', -1, 'ptr', $hIcon)
		If (@error) Or ($Ret[0] = -1) Then
			ExitLoop
		EndIf
		$hMemDC = _WinAPI_CreateCompatibleDC($hDC)
		$hSv = _WinAPI_SelectObject($hMemDC, $hBitmap)
		$Ret = DllCall('comctl32.dll', 'int', 'ImageList_Draw', 'ptr', $hIL[0], 'int', 0, 'hwnd', $hMemDC, 'int', 0, 'int', 0, 'uint', 1)
		If (Not @error) And ($Ret[0]) Then
			$Error = 0
		EndIf
		_WinAPI_SelectObject($hMemDC, $hSv)
		_WinAPI_DeleteDC($hMemDC)
	Until 1
	_WinAPI_ReleaseDC(0, $hDC)
	DllCall('comctl32.dll', 'int', 'ImageList_Destroy', 'ptr', $hIL[0])
	If $Error Then
		If $hBitmap Then
			_WinAPI_DeleteObject($hBitmap)
		EndIf
		Return SetError(3, 0, 0)
	EndIf
	If $fDelete Then
		_WinAPI_DestroyIcon($hIcon)
	EndIf
	Return $hBitmap
EndFunc   ;==>_WinAPI_Create32BitHBITMAP

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Create32BitHICON
; Description....: Converts an icon to 32 bits-per-pixel format and copies to the new icon.
; Syntax.........: _WinAPI_Create32BitHICON ( $hIcon [, $fDelete] )
; Parameters.....: $hIcon   - Handle to the icon to convert.
;                  $fDelete - Specifies whether delete the icon after the function is successful, valid values:
;                  |TRUE    - Icon will be deleted if the function succeeds.
;                  |FALSE   - Don't delete, you must release the icon when you are finished using it. (Default)
; Return values..: Success  - Handle to the newly created icon.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Create32BitHICON
; Description....: Converts an icon to a 32 bits-per-pixel format and copies to the new icon.
; Syntax.........: _WinAPI_Create32BitHICON ( $hIcon [, $fDelete] )
; Parameters.....: $hIcon   - Handle to the icon to be converted.
;                  $fDelete - Specifies whether to delete the icon after the function is successful, valid values:
;                  |TRUE    - Icon will be deleted if the function succeeds.
;                  |FALSE   - Don't delete, you must release the icon themselves when you are finished using it. (Default)
; Return values..: Success  - Handle to the newly created icon.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function converts an icon with any color depth into an icon with 32 bits-per-pixel (RGB + Alpha) format.
;                  If the source icon already is a 32 bits-per-pixel icon, and has an alpha chanel, the function generates the new
;                  AND bitmask bitmap, and copies it to a new icon. If the source icon has a 32 bits-per-pixel color depth, and
;                  do not have an alpha chanel, the function creates an alpha chanel from its AND bitmask. If the source icon is
;                  non 32 bits-per-pixel icon, it will be converted into a 32 bits-per-pixel format with alpha chanel.
;                  The _WinAPI_Create32BitHICON() always creates an icon with alpha channel and AND bitmask, although it
;                  is not used to display icons that contain an alpha channel.
;
;                  Note that to display the fully transparent icons used only its AND bitmask, not the alpha channel. Therefore,
;                  its XOR and AND bitmasks will remain unchanged.
;
;                  When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Create32BitHICON($hIcon, $fDelete = 0)

	Local $tICONINFO, $tSIZE, $hBitmap[2], $Size[2], $Ret, $hSrcDC, $hSrcSv, $hDstDC, $hDstSv, $hResult = 0
	Local $DIB[2][2] = [[0, 0], [0, 0]]

	$tICONINFO = DllStructCreate($tagICONINFO)
	$Ret = DllCall('user32.dll', 'int', 'GetIconInfo', 'ptr', $hIcon, 'ptr', DllStructGetPtr($tICONINFO))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = 0 To 1
		$hBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
	Next
	If _WinAPI_IsAlphaBitmap($hBitmap[1]) Then
		$DIB[0][0] = _WinAPI_CreateANDBitmap($hBitmap[1])
		If Not @error Then
			$hResult = _WinAPI_CreateIconIndirect($hBitmap[1], $DIB[0][0])
		EndIf
	Else
		$tSIZE = _WinAPI_GetBitmapDimension($hBitmap[1])
		For $i = 0 To 1
			$Size[$i] = DllStructGetData($tSIZE, $i + 1)
		Next
		$hSrcDC = _WinAPI_CreateCompatibleDC(0)
		$hDstDC = _WinAPI_CreateCompatibleDC(0)
		For $i = 0 To 1
			$DIB[$i][0] = _WinAPI_CreateDIB($Size[0], $Size[1])
			$DIB[$i][1] = $__Ext
			$hSrcSv = _WinAPI_SelectObject($hSrcDC, $hBitmap[$i])
			$hDstSv = _WinAPI_SelectObject($hDstDC, $DIB[$i][0])
			_WinAPI_BitBlt($hDstDC, 0, 0, $Size[0], $Size[1], $hSrcDC, 0, 0, 0x00C000CA)
			_WinAPI_SelectObject($hSrcDC, $hSrcSv)
			_WinAPI_SelectObject($hDstDC, $hDstSv)
		Next
		_WinAPI_DeleteDC($hSrcDC)
		_WinAPI_DeleteDC($hDstDC)
		$Ret = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __XORProc(), 'ptr', 0, 'uint', $Size[0] * $Size[1] * 4, 'ptr', $DIB[0][1], 'ptr', $DIB[1][1])
		If (Not @error) And ($Ret[0]) Then
			$hResult = _WinAPI_CreateIconIndirect($DIB[1][0], $hBitmap[0])
		EndIf
	EndIf
	For $i = 0 To 1
		_WinAPI_DeleteObject($hBitmap[$i])
		If $DIB[$i][0] Then
			_WinAPI_DeleteObject($DIB[$i][0])
		EndIf
	Next
	If Not $hResult Then
		Return SetError(1, 0, 0)
	EndIf
	If $fDelete Then
		_WinAPI_DestroyIcon($hIcon)
	EndIf
	Return $hResult
EndFunc   ;==>_WinAPI_Create32BitHICON

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateANDBitmap
; Description....: Creates an AND bitmask device-independent bitmap (DIB) from the specified bitmap.
; Syntax.........: _WinAPI_CreateANDBitmap ( $hBitmap )
; Parameters.....: $hBitmap - Handle to the bitmap from which to create an AND bitmask DIB.
; Return values..: Success  - Handle to the DIB.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CreateANDBitmap() creates a 1 bits-per-pixel AND bitmask DIB from the 32 bits-per-pixel DIB or DDB.
;                  If the source bitmap is non 32 bits-per-pixel bitmap, or is a compressed bitmap, the function fails.
;
;                  You can use the bitmap returned by this function to create icon by using the _WinAPI_CreateIconIndirect().
;
;                  When you are finished using the bitmap, destroy it using the _WinAPI_DeleteObject() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateANDBitmap($hBitmap)

	Local $tDIB[2], $Ret, $Error, $hDib = 0

	$hBitmap = _WinAPI_CopyBitmap($hBitmap)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Do
		$Error = 1
		$tDIB[0] = DllStructCreate($tagDIBSECTION)
		If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB[0]), DllStructGetPtr($tDIB[0]))) Or (DllStructGetData($tDIB[0], 'bmBitsPixel') <> 32) Or (DllStructGetData($tDIB[0], 'biCompression')) Then
			ExitLoop
		EndIf
		$tDIB[1] = DllStructCreate($tagBITMAP)
		$hDib = _WinAPI_CreateDIB(DllStructGetData($tDIB[0], 'bmWidth'), DllStructGetData($tDIB[0], 'bmHeight'), 1)
		If Not _WinAPI_GetObject($hDib, DllStructGetSize($tDIB[1]), DllStructGetPtr($tDIB[1])) Then
			ExitLoop
		EndIf
		$Ret = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __ANDProc(), 'ptr', 0, 'uint', 0, 'ptr', DllStructGetPtr($tDIB[0]), 'ptr', DllStructGetPtr($tDIB[1]))
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	_WinAPI_DeleteObject($hBitmap)
	If $Error Then
		If $hDib Then
			_WinAPI_DeleteObject($hDib)
		EndIf
		$hDib = 0
	EndIf
	Return SetError($Error, 0, $hDib)
EndFunc   ;==>_WinAPI_CreateANDBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateBitmapIndirect
; Description....: Creates a bitmap with the specified width, height, and color format (color planes and bits-per-pixel).
; Syntax.........: _WinAPI_CreateBitmapIndirect ( $tBITMAP )
; Parameters.....: $tBITMAP - $tagBITMAP structure that contains information about the bitmap. If an application sets the "bmWidth"
;                             or "bmHeight" members to zero, _WinAPI_CreateBitmapIndirect() returns the handle to a 1-by-1 pixel,
;                             monochrome bitmap.
; Return values..: Success  - Handle to the device-dependent (DDB) bitmap.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the bitmap, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreateBitmapIndirect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateBitmapIndirect($tBITMAP)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateBitmapIndirect', 'ptr', DllStructGetPtr($tBITMAP))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateBitmapIndirect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateBrushIndirect
; Description....: Creates a logical brush that has the specified style, color, and pattern.
; Syntax.........: _WinAPI_CreateBrushIndirect ( $iStyle, $iRGB, $iHatch )
; Parameters.....: $iStyle - The brush style. This parameter can be one of the following styles.
;
;                            $BS_DIBPATTERN
;                            $BS_DIBPATTERN8X8
;                            $BS_DIBPATTERNPT
;                            $BS_HATCHED
;                            $BS_HOLLOW
;                            $BS_NULL
;                            $BS_PATTERN
;                            $BS_PATTERN8X8
;                            $BS_SOLID
;
;                  $iRGB   - The color of a brush, in RGB, or one of the following values.
;
;                            $DIB_PAL_COLORS
;                            $DIB_RGB_COLORS
;
;                  $iHatch - A hatch style. The meaning depends on the brush style defined by $iStyle parameter.
;
;                            $BS_DIBPATTERN
;                            Contains a handle to a packed DIB.
;
;                            $BS_DIBPATTERNPT
;                            Contains a pointer to a packed DIB.
;
;                            $BS_HATCHED
;                            Specifies the orientation of the lines used to create the hatch. It can be one of the orientation constants ($HS_*).
;
;                            $BS_PATTERN
;                            Contains a handle to the bitmap that defines the pattern. The bitmap cannot be a DIB section bitmap.
;
;                            $BS_HOLLOW, $BS_SOLID
;                            Ignored.
;
; Return values..: Success - The value identifies a logical brush.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After an application creates a brush by calling _WinAPI_CreateBrushIndirect(), it can select it into any
;                  device context by calling the _WinAPI_SelectObject() function. When you no longer need the brush,
;                  call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreateBrushIndirect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateBrushIndirect($iStyle, $iRGB, $iHatch = 0)

	Local $tLOGBRUSH = DllStructCreate($tagLOGBRUSH)

	DllStructSetData($tLOGBRUSH, 1, $iStyle)
	DllStructSetData($tLOGBRUSH, 2, __RGB($iRGB))
	DllStructSetData($tLOGBRUSH, 3, $iHatch)

	Local $Ret = DllCall('gdi32.dll', 'int', 'CreateBrushIndirect', 'ptr', DllStructGetPtr($tLOGBRUSH))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateBrushIndirect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateCaret
; Description....: Creates a new shape for the system caret and assigns ownership of the caret to the specified window.
; Syntax.........: _WinAPI_CreateCaret ( $hWnd, $hBitmap [, $iWidth [, $iHeight]] )
; Parameters.....: $hWnd    - Handle to the window that owns the caret.
;                  $hBitmap - Handle to the bitmap that defines the caret shape. If this parameter is 0, the caret is solid.
;                             If this parameter is 1, the caret is gray. If this parameter is a bitmap handle, the caret is
;                             the specified bitmap.
;                  $iWidth  - The width of the caret in logical units. If this parameter is 0, the width is set to the system-defined
;                             window border width. If $hBitmap is a bitmap handle, _WinAPI_CreateCaret() ignores this parameter.
;                  $iHeight - The height of the caret in logical units. If this parameter is 0, the height is set to the system-defined
;                             window border height. If $hBitmap  is a bitmap handle, _WinAPI_CreateCaret() ignores this parameter.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_CreateCaret() automatically destroys the previous caret shape, if any, regardless of the window that owns the caret.
;                  The caret is hidden until the application calls the _WinAPI_ShowCaret() function to make the caret visible.
;
;                  The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active.
;                  The window should destroy the caret before losing the keyboard focus or becoming inactive.
;
;                  You can retrieve the width or height of the system's window border by using the _WinAPI_GetSystemMetrics() function,
;                  specifying the $SM_CXBORDER and $SM_CYBORDER values. Using the window border width or height guarantees that the
;                  caret will be visible on a high-resolution screen.
; Related........:
; Link...........: @@MsdnLink@@ CreateCaret
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateCaret($hWnd, $hBitmap, $iWidth = 0, $iHeight = 0)

	Local $Ret = DllCall('user32.dll', 'int', 'CreateCaret', 'hwnd', $hWnd, 'ptr', $hBitmap, 'int', $iWidth, 'int', $iHeight)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CreateCaret

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateCompatibleBitmapEx
; Description....: Creates a bitmap compatible with the device and fills it the specified color.
; Syntax.........: _WinAPI_CreateSolidBitmapEx ( $hDC, $iWidth, $iHeight, $iRGB )
; Parameters.....: $hDC     - Handle to a device context.
;                  $iWidht  - The bitmap width, in pixels.
;                  $iHeight - The bitmap height, in pixels.
;                  $iRGB    - The bitmap color, in RGB.
; Return values..: Success  - Handle to the compatible solid bitmap (DDB).
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The color format of the bitmap created by the _WinAPI_CreateCompatibleBitmapEx() function matches the color
;                  format of the device identified by the hdc parameter. This bitmap can be selected into any memory device context
;                  that is compatible with the original device.
;
;                  When you no longer need the bitmap, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateCompatibleBitmapEx($hDC, $iWidth, $iHeight, $iRGB)

	Local $Ret, $tRECT, $hBmp, $hBrush, $hDestDC, $hDestSv

	$hBrush = _WinAPI_CreateBrushIndirect($BS_SOLID, $iRGB)
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleDC', 'hwnd', $hDC)
	$hDestDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleBitmap', 'hwnd', $hDC, 'int', $iWidth, 'int', $iHeight)
	$hBmp = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'SelectObject', 'hwnd', $hDestDC, 'ptr', $hBmp)
	$hDestSv = $Ret[0]
	$tRECT = _WinAPI_CreateRectEx(0, 0, $iWidth, $iHeight)
	$Ret = DllCall('user32.dll', 'int', 'FillRect', 'hwnd', $hDestDC, 'ptr', DllStructGetPtr($tRECT), 'ptr', $hBrush)
	If (@error) Or (Not $Ret[0]) Then
		_WinAPI_DeleteObject($hBmp)
		$Ret = 0
	EndIf
	_WinAPI_DeleteObject($hBrush)
	DllCall('gdi32.dll', 'ptr', 'SelectObject', 'hwnd', $hDestDC, 'ptr', $hDestSv)
	DllCall('gdi32.dll', 'int', 'DeleteDC', 'hwnd', $hDestDC)
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $hBmp
EndFunc   ;==>_WinAPI_CreateCompatibleBitmapEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDesktop
; Description....: Creates a new desktop, associates it with the current window station of the calling process.
; Syntax.........: _WinAPI_CreateDesktop ( $sName [, $iAccess [, $iFlags [, $iHeap [, $tSecurity]]]] )
; Parameters.....: $sName     - The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).
;                  $iAccess   - The requested access to the desktop. This parameter can be one or more of the following values.
;
;                               $DESKTOP_ALL_ACCESS
;                               $DESKTOP_CREATEMENU
;                               $DESKTOP_CREATEWINDOW
;                               $DESKTOP_ENUMERATE
;                               $DESKTOP_HOOKCONTROL
;                               $DESKTOP_JOURNALPLAYBACK
;                               $DESKTOP_JOURNALRECORD
;                               $DESKTOP_READOBJECTS
;                               $DESKTOP_SWITCHDESKTOP
;                               $DESKTOP_WRITEOBJECTS
;
;                  $iFlags    - The optional flags. It can be zero or the following value.
;
;                               $DF_ALLOWOTHERACCOUNTHOOK
;
;                  $iHeap     - The size of the desktop heap, in kilobytes.
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by
;                               child processes. If this parameter is 0, the handle cannot be inherited.
; Return values..: Success    - Handle to the newly created desktop. If the specified desktop already exists, the function succeeds and
;                               returns a handle to the existing desktop.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The number of desktops that can be created is limited by the size of the system desktop heap. You can increase the
;                  number of desktops that can be created by increasing the size of the desktop heap or by reducing the default heap
;                  reserved for each desktop in the interactive window station. The default size of the desktop heap depends on factors
;                  such as hardware architecture. To retrieve the size of the heap, call the _WinAPI_GetUserObjectInformation()
;                  function with $UOI_HEAPSIZE.
;
;                  When you are finished using the desktop, call the _WinAPI_CloseDesktop() function to close it.
; Related........:
; Link...........: @@MsdnLink@@ CreateDesktopEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDesktop($sName, $iAccess = 0x0002, $iFlags = 0, $iHeap = 0, $tSecurity = 0)

	Local $Ret

	If $iHeap Then
		$Ret = DllCall('user32.dll', 'ptr', 'CreateDesktopExW', 'wstr', $sName, 'ptr', 0, 'ptr', 0, 'dword', $iFlags, 'dword', $iAccess, 'ptr', DllStructGetPtr($tSecurity), 'ulong', $iHeap, 'ptr', 0)
	Else
		$Ret = DllCall('user32.dll', 'ptr', 'CreateDesktopW', 'wstr', $sName, 'ptr', 0, 'ptr', 0, 'dword', $iFlags, 'dword', $iAccess, 'ptr', DllStructGetPtr($tSecurity))
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDIB
; Description....: Creates an uncompressed device-independent bitmap (DIB) with the specified width, height, and color depth.
; Syntax.........: _WinAPI_CreateDIB ( $iWidth, $iHeight [, $iBitsPerPel [, $tColorTable [, $iColorCount]]] )
; Parameters.....: $iWidth      - The width of the bitmap, in pixels.
;                  $iHeight     - The height of the bitmap, in pixels. If this value is positive, the bitmap is a bottom-up DIB
;                                 and its origin is the lower-left corner, otherwise, the bitmap is a top-down DIB and its origin
;                                 is the upper-left corner.
;                  $iBitsPerPel - The number of bits that define each pixel and the maximum number of colors in the bitmap.
;                  $tColorTable - "dword[n]" structure that represents a DIB color table. The number of colors in this table
;                                 depends on the values of the $iBitsPerPel parameters.
;                  $iColorCount - The number of color indexes in the DIB color table that are actually used by the bitmap.
;                                 The value of this parameter should not exceed the number of colors in the color table pointed
;                                 to by the $pColorTable parameter.
; Return values..: Success      - Handle to the DIB.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the bitmap is monochrome (1 bits-per-pixel), the color table should contain two entries. If the color table
;                  is not specified, the function creates a monochrome bitmap with black and white colors. If the bitmap use 4 or
;                  8 bits-per-pixel, the color table should contain up to 16 or 256 entries respectively. In this case, if the
;                  color table is not specified, the function creates an empty color table (all colors is black) with the maximum
;                  possible number of entries for the specified color depth. You can fill out this color table later by using the
;                  _WinAPI_SetDIBColorTable() function. If the bitmap use 16, 24, or 32 bits-per-pixel, the color table is not
;                  used, and $tColorTable parameter is ignored.
;
;                  This function does not create a compressed 16, 24, or 32 bits-per-pixel bitmaps, that is the "biCompression"
;                  member of $tagBITMAPINFO structure is always 0 ($BI_RGB).
;
;                  When you are finished using the bitmap, destroy it using the _WinAPI_DeleteObject() function.
;
;                  Call _WinAPI_GetExtended() to retrieve a pointer to the location of the DIB bit values.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel = 32, $tColorTable = 0, $iColorCount = 0)

	Local $tBITMAPINFO, $RGBQ[2], $hBitmap, $Colors

	Switch $iBitsPerPel
		Case 1
			$Colors = 2
		Case 4
			$Colors = 16
		Case 8
			$Colors = 256
		Case Else
			$Colors = 0
	EndSwitch
	If $Colors Then
		If Not IsDllStruct($tColorTable) Then
			Switch $iBitsPerPel
				Case 1
					$RGBQ[0] = 0
					$RGBQ[1] = 0xFFFFFF
					$tColorTable = _WinAPI_CreateDIBColorTable($RGBQ)
				Case Else

			EndSwitch
		Else
			If $Colors > $iColorCount Then
				$Colors = $iColorCount
			EndIf
			If (Not $Colors) Or ((4 * $Colors) > DllStructGetSize($tColorTable)) Then
				Return SetError(1, 0, 0)
			EndIf
		EndIf
		$RGBQ = 'dword[' & $Colors & ']'
	Else
		$RGBQ = ''
	EndIf
	$tBITMAPINFO = DllStructCreate($tagBITMAPINFOHEADER & $RGBQ)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	DllStructSetData($tBITMAPINFO, 'biSize', 40)
	DllStructSetData($tBITMAPINFO, 'biWidth', $iWidth)
	DllStructSetData($tBITMAPINFO, 'biHeight', $iHeight)
	DllStructSetData($tBITMAPINFO, 'biPlanes', 1)
	DllStructSetData($tBITMAPINFO, 'biBitCount', $iBitsPerPel)
	DllStructSetData($tBITMAPINFO, 'biCompression', 0)
	DllStructSetData($tBITMAPINFO, 'biSizeImage', 0)
	DllStructSetData($tBITMAPINFO, 'biXPelsPerMeter', 0)
	DllStructSetData($tBITMAPINFO, 'biYPelsPerMeter', 0)
	DllStructSetData($tBITMAPINFO, 'biClrUsed', $Colors)
	DllStructSetData($tBITMAPINFO, 'biClrImportant', 0)
	If $Colors Then
		If IsDllStruct($tColorTable) Then
			_WinAPI_MoveMemory(DllStructGetPtr($tBITMAPINFO) + 40, DllStructGetPtr($tColorTable), 4 * $Colors)
		Else
			_WinAPI_ZeroMemory(DllStructGetPtr($tBITMAPINFO) + 40, 4 * $Colors)
		EndIf
	EndIf
	$hBitmap = _WinAPI_CreateDIBSection(0, $tBITMAPINFO, 0, $__Ext)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $hBitmap
EndFunc   ;==>_WinAPI_CreateDIB

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDIBColorTable
; Description....: Creates RGB color table from the specified array of colors.
; Syntax.........: _WinAPI_CreateDIBColorTable ( Const ByRef $aColorTable [, $iStart [, $iEnd]] )
; Parameters.....: $aColorTable - The array of colors, in RGB, that to be make up the DIB color table.
;                  $iStart      - The index of array to start creating at.
;                  $iEnd        - The index of array to stop creating at.
; Return values..: Success      - "dword[n]" structure that represents a DIB color table.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The color table created by this function is typically used in _WinAPI_CreateDIB() or _WinAPI_CreateDIBSection()
;                  function to create 1, 4, or 8 bits-per-pixel device-independent bitmap (DIB).
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDIBColorTable(Const ByRef $aColorTable, $iStart = 0, $iEnd = -1)

	If Not IsArray($aColorTable) Then
		Return SetError(2, 0, 0)
	EndIf

	Local $tColorTable, $Count = 1

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aColorTable) - 1) Then
		$iEnd = UBound($aColorTable) - 1
	EndIf
	$tColorTable = DllStructCreate('dword[' & ($iEnd - $iStart + 1) & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		DllStructSetData($tColorTable, 1, _WinAPI_SwitchColor(__RGB($aColorTable[$i])), $Count)
		$Count += 1
	Next
	Return $tColorTable
EndFunc   ;==>_WinAPI_CreateDIBColorTable

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDIBitmap
; Description....: Creates a compatible bitmap (DDB) from a DIB and, optionally, sets the bitmap bits.
; Syntax.........: _WinAPI_CreateDIBitmap ( $hDC, $tBITMAPINFOHEADER, $fInit, $pBits, ByRef $tBITMAPINFO, $iUsage )
; Parameters.....: $hDC               - Handle to a device context.
;                  $tBITMAPINFOHEADER - A bitmap information header structure. If $fInit is TRUE, the function uses this structure
;                                       to obtain the desired width and height of the bitmap as well as other information. Note that
;                                       a positive value for the height indicates a bottom-up DIB while a negative value for the
;                                       height indicates a top-down DIB.
;                  $fInit             - Specifies how the system initializes the bitmap bits, valid values:
;                  |TRUE  - The system uses the $pBits and $tBITMAPINFO parameters to initialize the bitmap bits.
;                  |FALSE - The data pointed to by those parameters is not used.
;                  $pBits             - A pointer to an array of bytes containing the initial bitmap data.
;                  $tBITMAPINFO       - $tagBITMAPINFO structure that describes the dimensions and color format of the array
;                                       pointed to by the $pBits parameter.
;                  $iUsage            - The type of colors used. This parameter must be one of the following values.
;
;                                       $DIB_PAL_COLORS
;                                       $DIB_RGB_COLORS
;
; Return values..: Success            - Handle to the compatible bitmap that will be whatever bit depth your reference DC is.
;                  Failure            - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the bitmap, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreateDIBitmap
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDIBitmap($hDC, $tBITMAPINFOHEADER, $fInit, $pBits, ByRef $tBITMAPINFO, $iUsage)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateDIBitmap', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tBITMAPINFOHEADER), 'dword', $fInit, 'ptr', $pBits, 'ptr', DllStructGetPtr($tBITMAPINFO), 'uint', $iUsage)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateDIBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDIBSection
; Description....: Creates a DIB that applications can write to directly.
; Syntax.........: _WinAPI_CreateDIBSection ( $hDC, ByRef $tBITMAPINFO, $iUsage, ByRef $pBits [, $hSection [, $iOffset]] )
; Parameters.....: $hDC         - Handle to a device context. If the value of $iUsage is $DIB_PAL_COLORS, the function uses this
;                                 device context's logical palette to initialize the DIB colors.
;                  $tBITMAPINFO - $tagBITMAPINFO structure that specifies various attributes of the DIB, including the bitmap
;                                 dimensions and colors.
;                  $iUsage      - The type of colors used (either logical palette indexes or literal RGB values). The following
;                                 values are defined.
;
;                                 $DIB_PAL_COLORS
;                                 $DIB_RGB_COLORS
;
;                  $pBits       - A pointer to the location of the DIB bit values.
;                  $hSection    - Handle to a file-mapping object that the function will use to create the DIB.
;                  $iOffset     - The offset from the beginning of the file-mapping object referenced by $hSection where storage
;                                 for the bitmap bit values is to begin. This value is ignored if $hSection is 0.
; Return values..: Success      - Handle to the newly created DIB, and $pBits points to the bitmap bit values. You can create the
;                                 structure by using $pBits pointer to further its filling. For example,
;                                 DllStructCreate('dword[256]', $pBits).
;                  Failure      - 0 and sets the @error flag to non-zero, $pBits also is 0.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the bitmap, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreateDIBSection
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDIBSection($hDC, ByRef $tBITMAPINFO, $iUsage, ByRef $pBits, $hSection = 0, $iOffset = 0)

	$pBits = 0

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateDIBSection', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tBITMAPINFO), 'uint', $iUsage, 'ptr*', 0, 'ptr', $hSection, 'dword', $iOffset)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$pBits = $Ret[4]
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateDIBSection

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDirectoryEx
; Description....: Creates a new directory with the attributes of a specified template directory.
; Syntax.........: _WinAPI_CreateDirectoryEx ( $sNewDir, $sTemplateDir [, $tSecurity] )
; Parameters.....: $sNewDir      - The path of the directory to be created.
;                  $sTemplateDir - The path of the directory to use as a template when creating the new directory.
;                  $tSecurity    - $tagSECURITY_ATTRIBUTES structure that specifies a security descriptor for the new directory.
;                                  If this parameter is 0, the directory gets a default security descriptor. The access control lists
;                                  (ACL) in the default security descriptor for a directory are inherited from its parent directory.
; Return values..: Success       - 1.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CreateDirectoryEx() function allows you to create directories that inherit stream information
;                  from other directories. This function is useful, for example, when you are using Macintosh directories, which have
;                  a resource stream that is needed to properly identify directory contents as an attribute.
; Related........:
; Link...........: @@MsdnLink@@ CreateDirectoryEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDirectoryEx($sNewDir, $sTemplateDir, $tSecurity = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'CreateDirectoryExW', 'wstr', $sTemplateDir, 'wstr', $sNewDir, 'ptr', DllStructGetPtr($tSecurity))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CreateDirectoryEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateEllipticRgn
; Description....: Creates an elliptical region.
; Syntax.........: _WinAPI_CreateEllipticRgn ( $tRECT )
; Parameters.....: $tRECT  - $tagRECT structure that contains the coordinates of the upper-left and lower-right corners of the
;                            bounding rectangle of the ellipse in logical units.
; Return values..: Success - The handle to the region.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: A bounding rectangle defines the size, shape, and orientation of the region: The long sides of the rectangle
;                  define the length of the ellipse's major axis; the short sides define the length of the ellipse's minor axis;
;                  and the center of the rectangle defines the intersection of the major and minor axes.
;
;                  When you no longer need the HRGN object, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreateEllipticRgnIndirect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateEllipticRgn($tRECT)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateEllipticRgnIndirect', 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateEllipticRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateEmptyIcon
; Description....: Creates a fully transparent icon with the specified width, height, and color depth.
; Syntax.........: _WinAPI_CreateEmptyIcon ( $iWidth, $iHeight [, $iBitsPerPel] )
; Parameters.....: $iWidth      - The width, in pixels, of the icon.
;                  $iHeight     - The height, in pixels, of the icon.
;                  $iBitsPerPel - The number of bits-per-pixel in the XOR bitmask of the icon.
; Return values..: Success      - Handle to the created icon.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function creates an icon with black XOR, and white AND bitmask bitmaps. This icon has no alpha channel,
;                  it will be displayed only by using its AND bitmask.
;
;                  When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateEmptyIcon($iWidth, $iHeight, $iBitsPerPel = 32)

	Local $tRECT, $hDC, $hSv, $hBrush, $hXOR, $hAND, $hIcon

	$hXOR = _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel)
	$hAND = _WinAPI_CreateDIB($iWidth, $iHeight, 1)
	$hDC = _WinAPI_CreateCompatibleDC(0)
	$hSv = _WinAPI_SelectObject($hDC, $hAND)
	$hBrush = _WinAPI_CreateSolidBrush(0xFFFFFF)
	$tRECT = _WinAPI_CreateRect(0, 0, $iWidth, $iHeight)
	_WinAPI_FillRect($hDC, DllStructGetPtr($tRECT), $hBrush)
	_WinAPI_DeleteObject($hBrush)
	_WinAPI_SelectObject($hDC, $hSv)
	_WinAPI_DeleteDC($hDC)
	$hIcon = _WinAPI_CreateIconIndirect($hXOR, $hAND)
	If $hXOR Then
		_WinAPI_DeleteObject($hXOR)
	EndIf
	If $hAND Then
		_WinAPI_DeleteObject($hAND)
	EndIf
	If Not $hIcon Then
		Return SetError(1, 0, 0)
	EndIf
	Return $hIcon
EndFunc   ;==>_WinAPI_CreateEmptyIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateEnhMetaFile
; Description....: Creates a device context for an enhanced-format metafile.
; Syntax.........: _WinAPI_CreateEnhMetaFile ( [$hDC [, $tRECT [, $fPixels [, $sFile [, $sDescription]]]]] )
; Parameters.....: $hDC          - Handle to a reference device for the enhanced metafile. The system uses this device context to
;                                  record the resolution and units of the device on which a picture originally appeared.
;                                  If this parameter is 0, it uses the current display device for reference.
;                  $tRECT        - $tagRECT structure that specifies the dimensions of the picture to be stored in the enhanced metafile.
;                                  If this parameter is 0, the graphics device interface computes
;                                  the dimensions of the smallest rectangle that surrounds the picture drawn by the application.
;                  $fPixels      - Specifies whether the $tRECT structure defined in pixels, valid values:
;                  |TRUE         - In logical units (pixels).
;                  |FALSE        - In .01-millimeter units. (Default)
;                  $sFile        - The file name for the enhanced metafile to be created. If this parameter is 0, the enhanced
;                                  metafile is memory based and its contents are lost when it is deleted by using the
;                                  _WinAPI_DeleteEnhMetaFile() function.
;                  $sDescription - The string that specifies the name of the application that created the picture, as well as the
;                                  picture's title. This string must be an empty string or represented as follows:
;
;                                  "application name|picture name"
;
; Return values..: Success       - Handle to the device context for the enhanced metafile.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Applications use the device context created by this function to store a graphics picture in an enhanced metafile.
;                  The handle identifying this device context can be passed to any GDI function.
;
;                  After an application stores a picture in an enhanced metafile, it can display the picture on any output device by
;                  calling the _WinAPI_PlayEnhMetaFile() function. When displaying the picture, the system uses the rectangle pointed
;                  to by the $tRECT parameter and the resolution data from the reference device to position and scale the picture.
;
;                  The file name for the enhanced metafile should use the .emf extension.
; Related........:
; Link...........: @@MsdnLink@@ CreateEnhMetaFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateEnhMetaFile($hDC = 0, $tRECT = 0, $fPixels = 0, $sFile = '', $sDescription = '')

	Local $TypeOfFile = 'wstr'

	If Not StringStripWS($sFile, 3) Then
		$TypeOfFile = 'ptr'
		$sFile = 0
	EndIf

	Local $tData = 0, $aData = StringSplit($sDescription, '|', 2)

	If UBound($aData) < 2 Then
		ReDim $aData[2]
		$aData[1] = ''
	EndIf
	For $i = 0 To 1
		$aData[$i] = StringStripWS($aData[$i], 3)
	Next
	If ($aData[0]) Or ($aData[1]) Then
		$tData = _WinAPI_ArrayToStruct($aData)
	EndIf

	Local $Xp, $Yp, $Xm, $Ym, $hRef = 0

	If ($fPixels) And (IsDllStruct($tRECT)) Then
		If Not $hDC Then
			$hRef = _WinAPI_GetDC(0)
		EndIf
		$Xp = _WinAPI_GetDeviceCaps($hRef, 8)
		$Yp = _WinAPI_GetDeviceCaps($hRef, 10)
		$Xm = _WinAPI_GetDeviceCaps($hRef, 4)
		$Ym = _WinAPI_GetDeviceCaps($hRef, 6)
		If $hRef Then
			_WinAPI_ReleaseDC(0, $hRef)
		EndIf
		For $i = 1 To 3 Step 2
			DllStructSetData($tRECT, $i, Round(DllStructGetData($tRECT, $i) * $Xm / $Xp * 100))
		Next
		For $i = 2 To 4 Step 2
			DllStructSetData($tRECT, $i, Round(DllStructGetData($tRECT, $i) * $Ym / $Yp * 100))
		Next
	EndIf

	Local $Ret = DllCall('gdi32.dll', 'hwnd', 'CreateEnhMetaFileW', 'hwnd', $hDC, $TypeOfFile, $sFile, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateEnhMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateFileEx
; Description....: Creates or opens a file or I/O device.
; Syntax.........: _WinAPI_CreateFileEx ( $sFile, $iCreation, $iAccess, $iShare [, $iFlagsAndAttributes [, $tSecurity [, $hTemplate]]] )
; Parameters.....: $sFile               - The name of the file or device to be created or opened.
;                  $iCreation           - The action to take on a file or device that exists or does not exist. This parameter must be
;                                         one of the following values, which cannot be combined.
;
;                                         $CREATE_NEW
;                                         $CREATE_ALWAYS
;                                         $OPEN_EXISTING
;                                         $OPEN_ALWAYS
;                                         $TRUNCATE_EXISTING
;
;                  $iAccess             - The requested access to the file or device, which can be summarized as read, write, both
;                                         or neither (zero).
;
;                                         $GENERIC_READ
;                                         $GENERIC_WRITE
;
;                                         (See MSDN for more information)
;
;                  $iShare              - The requested sharing mode of the file or device, which can be read, write, both,
;                                         delete, all of these, or none. If this parameter is 0 and _WinAPI_CreateFileEx() succeeds,
;                                         the file or device cannot be shared and cannot be opened again until the handle to
;                                         the file or device is closed.
;
;                                         $FILE_SHARE_READ
;                                         $FILE_SHARE_WRITE
;                                         $FILE_SHARE_DELETE
;
;                  $iFlagsAndAttributes - The file or device attributes and flags. This parameter can be one or more of the
;                                         following values.
;
;                                         $FILE_ATTRIBUTE_READONLY
;                                         $FILE_ATTRIBUTE_HIDDEN
;                                         $FILE_ATTRIBUTE_SYSTEM
;                                         $FILE_ATTRIBUTE_DIRECTORY
;                                         $FILE_ATTRIBUTE_ARCHIVE
;                                         $FILE_ATTRIBUTE_DEVICE
;                                         $FILE_ATTRIBUTE_NORMAL
;                                         $FILE_ATTRIBUTE_TEMPORARY
;                                         $FILE_ATTRIBUTE_SPARSE_FILE
;                                         $FILE_ATTRIBUTE_REPARSE_POINT
;                                         $FILE_ATTRIBUTE_COMPRESSED
;                                         $FILE_ATTRIBUTE_OFFLINE
;                                         $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
;                                         $FILE_ATTRIBUTE_ENCRYPTED
;
;                                         $FILE_FLAG_BACKUP_SEMANTICS
;                                         $FILE_FLAG_DELETE_ON_CLOSE
;                                         $FILE_FLAG_NO_BUFFERING
;                                         $FILE_FLAG_OPEN_NO_RECALL
;                                         $FILE_FLAG_OPEN_REPARSE_POINT
;                                         $FILE_FLAG_OVERLAPPED
;                                         $FILE_FLAG_POSIX_SEMANTICS
;                                         $FILE_FLAG_RANDOM_ACCESS
;                                         $FILE_FLAG_SEQUENTIAL_SCAN
;                                         $FILE_FLAG_WRITE_THROUGH
;
;                                         $SECURITY_ANONYMOUS
;                                         $SECURITY_CONTEXT_TRACKING
;                                         $SECURITY_DELEGATION
;                                         $SECURITY_EFFECTIVE_ONLY
;                                         $SECURITY_IDENTIFICATION
;                                         $SECURITY_IMPERSONATION
;
;                  $tSecurity           - $tagSECURITY_ATTRIBUTES structure that contains two separate but related data members:
;                                         an optional security descriptor, and a Boolean value that determines whether the returned
;                                         handle can be inherited by child processes. If this parameter is 0, the handle cannot
;                                         be inherited by any child processes the application may create and the file or device
;                                         associated with the returned handle gets a default security descriptor.
;                  $hTemplate           - Handle to a template file with the $GENERIC_READ access right. The template file supplies
;                                         file attributes and extended attributes for the file that is being created.
; Return values..: Success              - Handle to the specified file, device, named pipe, or mail slot.
;                  Failure              - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When an application is finished using the object handle returned by this function, use the _WinAPI_CloseHandle()
;                  function to close the handle. This not only frees up system resources, but can have wider influence on things
;                  like sharing the file or device and committing data to disk.
; Related........:
; Link...........: @@MsdnLink@@ CreateFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateFileEx($sFile, $iCreation, $iAccess, $iShare, $iFlagsAndAttributes = 0, $tSecurity = 0, $hTemplate = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'CreateFileW', 'wstr', $sFile, 'dword', $iAccess, 'dword', $iShare, 'ptr', DllStructGetPtr($tSecurity), 'dword', $iCreation, 'dword', $iFlagsAndAttributes, 'ptr', $hTemplate)

	If (@error) Or ($Ret[0] = Ptr(-1)) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateFileEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateFileMapping
; Description....: Creates or opens a named or unnamed file mapping object for a specified file.
; Syntax.........: _WinAPI_CreateFileMapping ( $hFile [, $iSize [, $sName [, $iProtect [, $tSecurity]]]] )
; Parameters.....: $hFile     - Handle to the file from which to create a file mapping object. If this parameter is (-1), the calling
;                               process must also specify a size for the file mapping object in the $iSize parameters. In this scenario,
;                               _WinAPI_CreateFileMapping() creates a file mapping object of a specified size that is backed by the
;                               system paging file instead of by a file in the file system.
;                  $iSize     - The maximum size of the file mapping object. If this parameter is 0, the maximum size of the file
;                               mapping object is equal to the current size of the file that $hFile identifies.
;                  $sName     - The name of the file mapping object.
;                  $iProtect  - Specifies the page protection of the file mapping object and can be one of the following values.
;
;                               $PAGE_EXECUTE_READ
;                               $PAGE_EXECUTE_READWRITE
;                               $PAGE_EXECUTE_WRITECOPY
;                               $PAGE_READONLY
;                               $PAGE_READWRITE
;                               $PAGE_WRITECOPY
;
;                               An application can specify one or more of the following attributes for the file mapping object
;                               by combining them with one of the preceding page protection values.
;
;                               $SEC_COMMIT
;                               $SEC_IMAGE
;                               $SEC_LARGE_PAGES
;                               $SEC_NOCACHE
;                               $SEC_RESERVE
;                               $SEC_WRITECOMBINE
;
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that determines whether a returned handle can be inherited by
;                               child processes. If this parameter is 0, the handle cannot be inherited and the file mapping object
;                               gets a default security descriptor.
; Return values..: Success    - Handle to the newly created file mapping object. If the object exists before the function call,
;                               the function returns a handle to the existing object (with its current size, not the specified
;                               size), and sets the @extended flag to 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After a file mapping object is created, the size of the file must not exceed the size of the file mapping object;
;                  if it does, not all of the file contents are available for sharing.
;
;                  Multiple processes can share a view of the same file by either using a single shared file mapping object or creating
;                  separate file mapping objects backed by the same file. A single file mapping object can be shared by multiple processes
;                  through inheriting the handle at process creation, duplicating the handle, or opening the file mapping object by name.
;
;                  A file mapping object does not actually map the view into a process address space. The _WinAPI_MapViewOfFile()
;                  functions map a view of a file into a process address space.
;
;                  Mapped views of a file mapping object maintain internal references to the object, and a file mapping object does
;                  not close until all references to it are released. Therefore, to fully close a file mapping object, an application
;                  must unmap all mapped views of the file mapping object by calling _WinAPI_UnmapViewOfFile() and close the file
;                  mapping object handle by calling _WinAPI_CloseHandle(). These functions can be called in any order.
; Related........:
; Link...........: @@MsdnLink@@ CreateFileMapping
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateFileMapping($hFile, $iSize = 0, $sName = '', $iProtect = 0x0004, $tSecurity = 0)

	Local $TypeOfName = 'wstr'

	If Not StringStripWS($sName, 3) Then
		$TypeOfName = 'ptr'
		$sName = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'CreateFileMappingW', 'ptr', $hFile, 'ptr', DllStructGetPtr($tSecurity), 'dword', $iProtect, 'dword', _WinAPI_HiDWord($iSize), 'dword', _WinAPI_LoDWord($iSize), $TypeOfName, $sName)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, Number(_WinAPI_GetLastError() = 183), $Ret[0])
EndFunc   ;==>_WinAPI_CreateFileMapping

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateGUID
; Description....: Creates a globally unique identifier (GUID).
; Syntax.........: _WinAPI_CreateGUID ( )
; Parameters.....: None
; Return values..: Success - The string representation of the GUID.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateGUID()

	Local $tData = DllStructCreate('wchar[39]')
	Local $tGUID = DllStructCreate($tagGUID)
	Local $Ret

	$Ret = DllCall('ole32.dll', 'uint', 'CoCreateGuid', 'ptr', DllStructGetPtr($tGUID))
	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	$Ret = DllCall('ole32.dll', 'int', 'StringFromGUID2', 'ptr', DllStructGetPtr($tGUID), 'ptr', DllStructGetPtr($tData), 'int', 39)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_CreateGUID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateIcon
; Description....: Creates an icon that has the specified size, colors, and bit patterns.
; Syntax.........: _WinAPI_CreateIcon ( $hInstance, $iWidth, $iHeight, $iPlanes, $iBitsPixel, $pANDBits, $pXORBits )
; Parameters.....: $hInstance  - Handle to the instance of the module creating the icon.
;                  $iWidth     - The width, in pixels, of the icon.
;                  $iHeight    - The height, in pixels, of the icon.
;                  $iPlanes    - The number of planes in the XOR bitmask of the icon.
;                  $iBitsPixel - The number of bits-per-pixel in the XOR bitmask of the icon.
;                  $pANDBits   - An array of bytes that contains the bit values for the AND bitmask of the icon. This bitmask describes
;                                a monochrome bitmap.
;                  $pXORBits   - An array of bytes that contains the bit values for the XOR bitmask of the icon. This bitmask describes
;                                a monochrome or device-dependent color bitmap.
; Return values..: Success     - Handle to the icon that is created.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: @@MsdnLink@@ CreateIcon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateIcon($hInstance, $iWidth, $iHeight, $iPlanes, $iBitsPixel, $pANDBits, $pXORBits)

	Local $Ret = DllCall('user32.dll', 'ptr', 'CreateIcon', 'ptr', $hInstance, 'int', $iWidth, 'int', $iHeight, 'byte', $iPlanes, 'byte', $iBitsPixel, 'ptr', $pANDBits, 'ptr', $pXORBits)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateIconFromResourceEx
; Description....: Creates an icon or cursor from resource bits describing the icon.
; Syntax.........: _WinAPI_CreateIconFromResourceEx ( $pData, $iSize [, $fIcon [, $xDesired [, $yDesired [, $iFlags]]]] )
; Parameters.....: $pData    - The icon or cursor resource bits. These bits are typically loaded by calls to the _WinAPI_LookupIconIdFromDirectoryEx()
;                              and _WinAPI_LoadResource() functions.
;                  $iSize    - The size, in bytes, of the set of bits pointed to by the $pData parameter.
;                  $fIcon    - Specifies whether an icon or a cursor is to be created, valid values:
;                  |TRUE     - An icon is to be created. (Default)
;                  |FALSE    - A cursor is to be created.
;                  $xDesired - The desired width, in pixels, of the icon or cursor. If this parameter is zero, the function uses the
;                              system metric value to set the width.
;                  $yDesired - The desired height, in pixels, of the icon or cursor. If this parameter is zero, the function uses the
;                              system metric value to set the height.
;                  $iFlags   - This parameter can be one or more of the following values.
;
;                              $LR_DEFAULTCOLOR
;                              $LR_DEFAULTSIZE
;                              $LR_MONOCHROME
;                              $LR_SHARED
;
; Return values..: Success   - Handle to the icon or cursor.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: You should call _WinAPI_DestroyIcon() for icons created with _WinAPI_CreateIconFromResourceEx().
; Related........:
; Link...........: @@MsdnLink@@ CreateIconFromResourceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateIconFromResourceEx($pData, $iSize, $fIcon = 1, $xDesired = 0, $yDesired = 0, $iFlags = 0)

	Local $Ret = DllCall('user32.dll', 'ptr', 'CreateIconFromResourceEx', 'ptr', $pData, 'dword', $iSize, 'int', $fIcon, 'dword', 0x00030000, 'int', $xDesired, 'int', $yDesired, 'uint', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateIconFromResourceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateIconIndirect
; Description....: Creates an icon or cursor that has the specified size, colors, and bit patterns.
; Syntax.........: _WinAPI_CreateIconIndirect ( $hBitmap, $hMask [, $XHotspot [, $YHotspot [, $fIcon]]] )
; Parameters.....: $hBitmap  - Handle to the icon color bitmap.
;                  $hMask    - Handle to the icon bitmask bitmap.
;                  $XHotspot - Specifies the x-coordinate of a cursor's hot spot. If creates an icon, the hot spot is always in
;                              the center of the icon, and this member is ignored.
;                  $YHotspot - Specifies the y-coordinate of the cursor's hot spot. If creates an icon, the hot spot is always in
;                              the center of the icon, and this member is ignored.
;                  $fIcon    - Specifies whether creates an icon or a cursor, valid values:
;                  |TRUE     - Creates an icon. (Default)
;                  |FALSE    - Creates a cursor.
; Return values..: Success   - Handle to the icon or cursor that is created.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The system copies the bitmaps before creating the icon or cursor. Because the system may temporarily
;                  select the bitmaps in a device context, $hBitmap and $hMask should not already be selected into a device context.
;                  The application must continue to manage the original bitmaps and delete them by _WinAPI_DeleteObject() when they
;                  are no longer necessary.
; Related........:
; Link...........: @@MsdnLink@@ CreateIconIndirect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateIconIndirect($hBitmap, $hMask, $XHotspot = 0, $YHotspot = 0, $fIcon = 1)

	Local $tICONINFO = DllStructCreate($tagICONINFO)

	DllStructSetData($tICONINFO, 1, $fIcon)
	DllStructSetData($tICONINFO, 2, $XHotspot)
	DllStructSetData($tICONINFO, 3, $YHotspot)
	DllStructSetData($tICONINFO, 4, $hMask)
	DllStructSetData($tICONINFO, 5, $hBitmap)

	Local $Ret = DllCall('user32.dll', 'ptr', 'CreateIconIndirect', 'ptr', DllStructGetPtr($tICONINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateIconIndirect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateJobObject
; Description....: Creates or opens a job object.
; Syntax.........: _WinAPI_CreateJobObject ( [$sName [, $tSecurity] )
; Parameters.....: $sName     - The name of the job. Name comparison is case-sensitive. If this parameter is 0, the job is
;                               created without a name.
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that specifies the security descriptor for the job object
;                               and determines whether child processes can inherit the returned handle. If this parameter is 0,
;                               the job object gets a default security descriptor and the handle cannot be inherited.
; Return values..: Success    - Handle to the job object. If the object existed before the function call, the function
;                               returns a handle to the existing job object.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When a job is created, its accounting information is initialized to zero, all limits are inactive, and there
;                  are no associated processes. To assign a process to a job object, use the _WinAPI_AssignProcessToJobObject()
;                  function. To set limits for a job, use the _WinAPI_SetInformationJobObject() function. To query accounting
;                  information, use the _WinAPI_QueryInformationJobObject() function.
;
;                  All processes associated with a job must run in the same session. A job is associated with the session of the
;                  first process to be assigned to the job.
;
;                  To close a job object handle, use the _WinAPI_CloseHandle() function. The job is destroyed when its last
;                  handle has been closed and all associated processes have exited.
; Related........:
; Link...........: @@MsdnLink@@ CreateJobObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateJobObject($sName = '', $tSecurity = 0)

	Local $TypeOfName = 'wstr'

	If Not StringStripWS($sName, 3) Then
		$TypeOfName = 'ptr'
		$sName = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'CreateJobObjectW', 'ptr', $tSecurity, $TypeOfName, $sName)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateJobObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateMargins
; Description....: Creates $tagMARGINS structure with specified left, right, top, and bottom retaining borders.
; Syntax.........: _WinAPI_CreateMargins ( $iLeftWidth, $iRightWidth, $iTopHeight, $iBottomHeight )
; Parameters.....: $iLeftWidth    - The width of the left border that retains its size.
;                  $iRightWidth   - The width of the right border that retains its size.
;                  $iTopHeight    - The height of the top border that retains its size.
;                  $iBottomHeight - The height of the bottom border that retains its size.
; Return values..: Success        - $tagMARGINS structure that contains the specified retaining borders.
;                  Failure        - 0.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateMargins($iLeftWidth, $iRightWidth, $iTopHeight, $iBottomHeight)

	Local $tMARGINS = DllStructCreate($tagMARGINS)

	DllStructSetData($tMARGINS, 1, $iLeftWidth)
	DllStructSetData($tMARGINS, 2, $iRightWidth)
	DllStructSetData($tMARGINS, 3, $iTopHeight)
	DllStructSetData($tMARGINS, 4, $iBottomHeight)

	Return $tMARGINS
EndFunc   ;==>_WinAPI_CreateMargins

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateMRUList
; Description....: Creates a new most recently used (MRU) list.
; Syntax.........: _WinAPI_CreateMRUList ( $hKey, $sSubKey [, $iMax]] )
; Parameters.....: $hKey     - Handle to the currently open key, or one of the following predefined values under which to store the MRU data.
;
;                              $HKEY_CURRENT_USER
;                              $HKEY_LOCAL_MACHINE
;
;                  $sSubKey  - The subkey under which to store the MRU data.
;                  $iMax     - The maximum number of entries in the MRU list. Default is 26 (A..Z).
; Return values..: Success   - Handle to the new MRU list.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CreateMRUListW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateMRUList($hKey, $sSubKey, $iMax = 26)

	Local $tMRUINFO = DllStructCreate('dword;uint;uint;ulong_ptr;ptr;ptr')
	Local $tSubKey = DllStructCreate('wchar[' & (StringLen($sSubKey) + 1) & ']')

	DllStructSetData($tMRUINFO, 1, DllStructGetSize($tMRUINFO))
	DllStructSetData($tMRUINFO, 2, $iMax)
	DllStructSetData($tMRUINFO, 3, 0)
	DllStructSetData($tMRUINFO, 4, $hKey)
	DllStructSetData($tMRUINFO, 5, DllStructGetPtr($tSubKey))
	DllStructSetData($tMRUINFO, 6, 0)

	DllStructSetData($tSubKey, 1, $sSubKey)

	Local $Ret = DllCall('comctl32.dll ', 'int', 'CreateMRUListW', 'ptr', DllStructGetPtr($tMRUINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateMRUList

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateMutex
; Description....: Creates or opens a named or unnamed mutex object.
; Syntax.........: _WinAPI_CreateMutex ($sMutex [, $fInitial [, $tSecurity]] )
; Parameters.....: $sMutex    - The name of the mutex object. Name comparisons are case sensitive.
;                  $fInitial  - Specifies whether the calling process obtains the initial ownership of the mutex object, valid values:
;                  |TRUE      - The calling thread obtains initial ownership of the mutex object. (Default)
;                  |FALSE     - The calling thread does not obtain ownership of the mutex object.
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that specifies a security descriptor for the new mutex. If this
;                               parameter is 0, the mutex gets a default security descriptor.
; Return values..: Success    - The handle to the newly created mutex object.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the mutex is a named mutex and the object existed before this function call, the return value is a handle to
;                  the existing object, _WinAPI_GetLastError() returns ERROR_ALREADY_EXISTS, $fInitial is ignored, and the calling
;                  thread is not granted ownership. However, if the caller has limited access rights, the function will fail with
;                  ERROR_ACCESS_DENIED and the caller should use the _WinAPI_OpenMutex() function.
;
;                  Any process can specify the mutex-object handle in a call to one of the wait functions. The single-object wait
;                  functions return when the state of the specified object is signaled. The multiple-object wait functions can be
;                  instructed to return either when any one or when all of the specified objects are signaled. When a wait function
;                  returns, the waiting thread is released to continue its execution.
;
;                  Two or more processes can call _WinAPI_CreateMutex() to create the same named mutex. The first process actually
;                  creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing
;                  mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility
;                  of ensuring that the creating process is started first. When using this technique, you should set the $fInitial
;                  parameter to FALSE; otherwise, it can be difficult to be certain which process has initial ownership.
;
;                  Use the _WinAPI_CloseHandle() function to close the handle. The system closes the handle automatically when the
;                  process terminates. The mutex object is destroyed when its last handle has been closed.
; Related........:
; Link...........: @@MsdnLink@@ CreateMutex
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateMutex($sMutex, $fInitial = 1, $tSecurity = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'CreateMutexW', 'ptr', DllStructGetPtr($tSecurity), 'int', $fInitial, 'wstr', $sMutex)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateMutex

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateNullRgn
; Description....: Creates an empty region.
; Syntax.........: _WinAPI_CreateNullRgn ( )
; Parameters.....: None
; Return values..: Success - The handle to the region.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the HRGN object, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateNullRgn()

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateRectRgn', 'int', 0, 'int', 0, 'int', 0, 'int', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateNullRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateObjectID
; Description....: Creates or retrieves the object identifier for the specified file or directory.
; Syntax.........: _WinAPI_CreateObjectID ( $sPath )
; Parameters.....: $sPath  - Path to the file or directory to create or retrieve object identifier.
; Return values..: Success - $tagGUID structure that contains the object identifier for the file or directory within the volume on which it resides.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the object identifier of a file or directory does not already have one, the _WinAPI_CreateObjectID() creates it.
;                  If the object identifier already exists, the function just returns it.
; Related........:
; Link...........: @@MsdnLink@@ FSCTL_CREATE_OR_GET_OBJECT_ID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateObjectID($sPath)

	Local $hFile, $Flags

	If _WinAPI_PathIsDirectory($sPath) Then
		$Flags = 0x02000000
	Else
		$Flags = 0
	EndIf
	$hFile = _WinAPI_CreateFileEx($sPath, 3, 0, 0x06, $Flags)
	If Not $hFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tGUID, $tFOID = DllStructCreate('byte[16];byte[48]')
	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x000900C0, 'ptr', 0, 'dword', 0, 'ptr', DllStructGetPtr($tFOID), 'dword', DllStructGetSize($tFOID), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	$tGUID = DllStructCreate($tagGUID)
	_WinAPI_MoveMemory(DllStructGetPtr($tGUID), DllStructGetPtr($tFOID), 16)
	Return $tGUID
EndFunc   ;==>_WinAPI_CreateObjectID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreatePoint
; Description....: Creates $tagPOINT structure with the x- and y-coordinates of the specified point.
; Syntax.........: _WinAPI_CreatePoint ( $iX, $iY )
; Parameters.....: $iX     - The x-coordinate of the point.
;                  $iY     - The y-coordinate of the point.
; Return values..: Success - $tagPOINT structure that contains the specified point.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreatePoint($iX, $iY)

	Local $tPOINT = DllStructCreate($tagPOINT)

	DllStructSetData($tPOINT, 1, $iX)
	DllStructSetData($tPOINT, 2, $iY)

	Return $tPOINT
EndFunc   ;==>_WinAPI_CreatePoint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreatePolygonRgn
; Description....: Creates a polygonal region.
; Syntax.........: _WinAPI_CreatePolygonRgn ( $aPoint [, $iStart [, $iEnd [, $iMode]]] )
; Parameters.....: $aPoint - The 2D array ([x1, y1], [x2, y2], ... [xN, yN]) that contains the vertices of the polygon in logical
;                            units. The polygon is presumed closed. Each vertex can be specified only once.
;                  $iStart - The index of array to start creating at.
;                  $iEnd   - The index of array to stop creating at.
;                  $iMode  - The fill mode used to determine which pixels are in the region. This parameter can be one of the
;                            following values.
;
;                            $ALTERNATE
;                            $WINDING
;
; Return values..: Success - The handle to the region.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the HRGN object, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreatePolygonRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreatePolygonRgn($aPoint, $iStart = 0, $iEnd = -1, $iMode = 1)

	If UBound($aPoint, 2) < 2 Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Count, $tData, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	For $i = $iStart To $iEnd
		$Struct &= 'int[2];'
	Next
	$tData = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = 1
	For $i = $iStart To $iEnd
		For $j = 0 To 1
			DllStructSetData($tData, $Count, $aPoint[$i][$j], $j + 1)
		Next
		$Count += 1
	Next

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreatePolygonRgn', 'ptr', DllStructGetPtr($tData), 'int', $Count - 1, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreatePolygonRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateRect
; Description....: Creates $tagRECT structure with the coordinates of the specified rectangle.
; Syntax.........: _WinAPI_CreateRect ( $iLeft, $iTop, $iRight, $iBottom )
; Parameters.....: $iLeft   - The x-coordinate of the upper-left corner of the rectangle.
;                  $iTop    - The y-coordinate of the upper-left corner of the rectangle.
;                  $iRight  - The x-coordinate of the lower-right corner of the rectangle.
;                  $iBottom - The y-coordinate of the lower-right corner of the rectangle.
; Return values..: Success  - $tagRECT structure that contains the specified rectangle.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)

	Local $tRECT = DllStructCreate($tagRECT)

	DllStructSetData($tRECT, 1, $iLeft)
	DllStructSetData($tRECT, 2, $iTop)
	DllStructSetData($tRECT, 3, $iRight)
	DllStructSetData($tRECT, 4, $iBottom)

	Return $tRECT
EndFunc   ;==>_WinAPI_CreateRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateRectEx
; Description....: Creates $tagRECT structure with the coordinates of the specified rectangle.
; Syntax.........: _WinAPI_CreateRectEx ( $iX, $iY, $iWidth, $iHeight )
; Parameters.....: $iX      - The x-coordinate of the upper-left corner of the rectangle.
;                  $iY      - The y-coordinate of the upper-left corner of the rectangle.
;                  $iWidth  - The width of the rectangle.
;                  $iHeight - The height of the rectangle.
; Return values..: Success  - $tagRECT structure that contains the specified rectangle.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateRectEx($iX, $iY, $iWidth, $iHeight)

	Local $tRECT = DllStructCreate($tagRECT)

	DllStructSetData($tRECT, 1, $iX)
	DllStructSetData($tRECT, 2, $iY)
	DllStructSetData($tRECT, 3, $iX + $iWidth)
	DllStructSetData($tRECT, 4, $iY + $iHeight)

	Return $tRECT
EndFunc   ;==>_WinAPI_CreateRectEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateRectRgnIndirect
; Description....: Creates a rectangular region.
; Syntax.........: _WinAPI_CreateRectRgnIndirect ( $tRECT )
; Parameters.....: $tRECT  - $tagRECT structure that contains the coordinates of the upper-left and lower-right corners of the
;                            rectangle that defines the region in logical units.
; Return values..: Success - The handle to the region.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the HRGN object, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreateRectRgnIndirect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateRectRgnIndirect($tRECT)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateRectRgnIndirect', 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateRectRgnIndirect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateSemaphore
; Description....: Creates or opens a named or unnamed semaphore object.
; Syntax.........: _WinAPI_CreateSemaphore ( $sSemaphore, $iInitial, $iMaximum [, $tSecurity] )
; Parameters.....: $sSemaphore - The name of the semaphore to be opened. Name comparisons are case sensitive.
;                  $iInitial   - The initial count for the semaphore object. This value must be greater than or equal to zero and
;                                less than or equal to $iMaximum.
;                  $iMaximum   - The maximum count for the semaphore object. This value must be greater than zero.
;                  $tSecurity  - $tagSECURITY_ATTRIBUTES structure that specifies a security descriptor for the new semaphore.
;                                If this parameter is 0, the semaphore gets a default security descriptor.
; Return values..: Success     - The handle to the newly created semaphore object.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the named semaphore object existed before the function call, the function returns a handle to the existing object.
;
;                  Any process can specify the semaphore-object handle in a call to _WinAPI_WaitFor... functions. The single-object
;                  wait functions return when the state of the specified object is signaled. The multiple-object wait functions can
;                  be instructed to return either when any one or when all of the specified objects are signaled. When a wait function
;                  returns, the waiting process is released to continue its execution.
;
;                  The state of a semaphore object is signaled when its count is greater than zero, and nonsignaled when its count
;                  is equal to zero. The $iInitial parameter specifies the initial count. Each time a waiting process is released
;                  because of the semaphore's signaled state, the count of the semaphore is decreased by one. Use the _WinAPI_ReleaseSemaphore()
;                  function to increment a semaphore's count by a specified amount. The count can never be less than zero or greater
;                  than the value specified in the $iMaximum parameter.
;
;                  Use the _WinAPI_CloseHandle() function to close the handle. The system closes the handle automatically when the
;                  process terminates. The semaphore object is destroyed when its last handle has been closed.
; Related........:
; Link...........: @@MsdnLink@@ CreateSemaphore
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateSemaphore($sSemaphore, $iInitial, $iMaximum, $tSecurity = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'CreateSemaphoreW', 'ptr', DllStructGetPtr($tSecurity), 'int', $iInitial, 'int', $iMaximum, 'wstr', $sSemaphore)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateSemaphore

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateSize
; Description....: Creates $tagSIZE structure with the width and height of the specified rectangle.
; Syntax.........: _WinAPI_CreateSize ( $iWidth, $iHeight )
; Parameters.....: $iWidth  - The width of the rectangle.
;                  $iHeight - The height of the rectangle.
; Return values..: Success  - $tagSIZE structure that contains the specified rectangle.
;                  Failure  - 0.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateSize($iWidth, $iHeight)

	Local $tSIZE = DllStructCreate($tagSIZE)

	DllStructSetData($tSIZE, 1, $iWidth)
	DllStructSetData($tSIZE, 2, $iHeight)

	Return $tSIZE
EndFunc   ;==>_WinAPI_CreateSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateStreamOnHGlobal
; Description....: Creates a stream object that uses a memory handle to store the stream contents.
; Syntax.........: _WinAPI_CreateStreamOnHGlobal ( $hGlobal [, $fDeleteOnRelease] )
; Parameters.....: $hGlobal          - The memory handle, or if 0 a new handle is to be allocated instead. The handle must be
;                                      allocated as moveable and nondiscardable.
;                  $fDeleteOnRelease - Specifies whether the underlying handle for this stream object should be automatically
;                                      freed when the stream object is released, valid values:
;                  |TRUE             - The final release will automatically free the $hGlobal parameter. (Default)
;                  |FALSE            - The user must free the $hGlobal after the final release.
; Return values..: Success           - The pointer to the new stream object.
;                  Failure           - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If $hGlobal is 0, the function allocates a new memory handle and the stream is initially empty, otherwise, the
;                  initial contents of the stream are the current contents of the memory block. Thus, _WinAPI_CreateStreamOnHGlobal()
;                  can be used to open an existing stream in memory. The memory handle and its contents are undisturbed by the
;                  creation of the new stream object.
;
;                  After creating the stream object with _WinAPI_CreateStreamOnHGlobal(), call _WinAPI_GetHGlobalFromStream() to
;                  retrieve the memory handle associated with the stream object.
; Related........:
; Link...........: @@MsdnLink@@ CreateStreamOnHGlobal
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateStreamOnHGlobal($hGlobal, $fDeleteOnRelease = 1)

	Local $Ret = DllCall('ole32.dll', 'uint', 'CreateStreamOnHGlobal', 'ptr', $hGlobal, 'int', $fDeleteOnRelease, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_CreateStreamOnHGlobal

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateString
; Description....: Copies a specified string to the memory and returns its pointer.
; Syntax.........: _WinAPI_CreateString ( $sString, ByRef $tString [, $iLenght [, $fUnicode]] )
; Parameters.....: $sString  - The source string to be copied.
;                  $tString  - "wchar[n]" or "char[n]" structure that will contain a specified string. You should not use this structure
;                              until the string is used. To release allocated memory just set this variable to 0.
;                  $iLenght  - The required buffer length without null-terminating character, in TCHARs. If this parameter is omitted
;                              or 0, the buffer length will be equal to the length of the source string. If $iLenght is less than
;                              the source string, the string will be truncated to the specified length.
;                  $fUnicode - Specifies whether a string is Unicode or ASCII code of a character, valid values:
;                  |TRUE     - Unicode. (Default)
;                  |FALSE    - ASCII.
; Return values..: Success   - A pointer to a specified null-terminated string. @extended returns the lenght of the string buffer,
;                              in TCHARs (not including the null-terminating character).
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: To get back a string, use the _WinAPI_GetString() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateString($sString, ByRef $tString, $iLenght = 0, $fUnicode = 1)
	If Not $iLenght Then
		$iLenght = StringLen($sString) + 1
	EndIf
	$tString = DllStructCreate(__Iif($fUnicode, 'wchar', 'char') & '[' & $iLenght & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	DllStructSetData($tString, 1, $sString)
	Return SetError(0, $iLenght, DllStructGetPtr($tString))
EndFunc   ;==>_WinAPI_CreateString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateTransform
; Description....: Ceates $tagXFORM structure specifies a world-space to page-space transformation.
; Syntax.........: _WinAPI_CreateTransform ( [$nM11 [, $nM12 [, $nM21 [, $nM22 [, $nDX [, $nDY]]]]]] )
; Parameters.....: $nM11   - The following.
;
;                            Rotation   - Cosine of rotation angle.
;                            Scaling    - Horizontal scaling component.
;                            Shear      - Not used.
;                            Reflection - Horizontal component.
;
;                  $nM12   - The following.
;
;                            Rotation   - Sine of the rotation angle.
;                            Scaling    - Not used.
;                            Shear      - Horizontal proportionality constant.
;                            Reflection - Not used.
;
;                  $nM21   - The following.
;
;                            Rotation   - Negative sine of the rotation angle.
;                            Scaling    - Not used.
;                            Shear      - Vertical proportionality constant.
;                            Reflection - Not used.
;
;                  $nM22   - The following.
;
;                            Rotation   - Cosine of rotation angle.
;                            Scaling    - Vertical scaling component.
;                            Shear      - Not used.
;                            Reflection - Vertical reflection component.
;
;                  $nDx    - The horizontal translation component, in logical units.
;                  $nDy    - The vertical translation component, in logical units.
; Return values..: Success - $tagXFORM structure that contains the transformation data.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateTransform($nM11 = 1, $nM12 = 0, $nM21 = 0, $nM22 = 1, $nDx = 0, $nDy = 0)

	Local $tXFORM = DllStructCreate($tagXFORM)

	DllStructSetData($tXFORM, 1, $nM11)
	DllStructSetData($tXFORM, 2, $nM12)
	DllStructSetData($tXFORM, 3, $nM21)
	DllStructSetData($tXFORM, 4, $nM22)
	DllStructSetData($tXFORM, 5, $nDX)
	DllStructSetData($tXFORM, 6, $nDY)
	Return $tXFORM
EndFunc   ;==>_WinAPI_CreateTransform

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateWindowStation
; Description....: Creates a window station object, associates it with the calling process, and assigns it to the current session.
; Syntax.........: _WinAPI_CreateWindowStation ( [$sName [, $iAccess [, $iFlags [, $tSecurity]]]] )
; Parameters.....: $sName     - The name of the window station to be created. Window station names are case-insensitive and cannot
;                               contain backslash characters (\). Only members of the Administrators group are allowed to  specify
;                               a name. If lthis parameter is empty string, the system forms a window station name using the logon
;                               session identifier for the calling process.
;                  $iAccess   - The type of access the returned handle has to the window station. This parameter can be one or
;                               more of the following values.
;
;                               $WINSTA_ALL_ACCESS
;                               $WINSTA_ACCESSCLIPBOARD
;                               $WINSTA_ACCESSGLOBALATOMS
;                               $WINSTA_CREATEDESKTOP
;                               $WINSTA_ENUMDESKTOPS
;                               $WINSTA_ENUMERATE
;                               $WINSTA_EXITWINDOWS
;                               $WINSTA_READATTRIBUTES
;                               $WINSTA_READSCREEN
;                               $WINSTA_WRITEATTRIBUTES
;
;                  $iFlags    - The optional flags. It can be zero or the following value.
;
;                               $CWF_CREATE_ONLY
;
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by
;                               child processes. If this parameter is 0, the handle cannot be inherited.
; Return values..: Success    - Handle to the newly created window station. If the specified window station already exists,
;                               the function succeeds and returns a handle to the existing window station.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After you are done with the handle, you must call _WinAPI_CloseWindowStation() to free the handle.
; Related........:
; Link...........: @@MsdnLink@@ CreateWindowStation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateWindowStation($sName = '', $iAccess = 0, $iFlags = 0, $tSecurity = 0)

	Local $Ret = DllCall('user32.dll', 'ptr', 'CreateWindowStationW', 'wstr', $sName, 'dword', $iFlags, 'dword', $iAccess, 'ptr', DllStructGetPtr($tSecurity))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateWindowStation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeferWindowPos
; Description....: Updates the specified multiple-window-position structure for the specified window.
; Syntax.........: _WinAPI_DeferWindowPos ( $hInfo, $hWnd, $hAfter, $iX, $iY, $iWidth, $iHeight, $iFlags )
; Parameters.....: $hInfo   - Handle to a multiple-window-position structure that contains size and position information for one
;                             or more windows. This structure is returned by _WinAPI_BeginDeferWindowPos() or by the most recent
;                             call to _WinAPI_DeferWindowPos().
;                  $hWnd    - Handle to the window for which update information is stored in the structure. All windows in a
;                             multiple-window-position structure must have the same parent.
;                  $hAfter  - Handle to the window that precedes the positioned window in the Z order. This parameter must be a
;                             window handle or one of the following values. This parameter is ignored if the $SWP_NOZORDER flag
;                             is set in the $iFlags parameter.
;
;                             $HWND_BOTTOM
;                             $HWND_NOTOPMOST
;                             $HWND_TOP
;                             $HWND_TOPMOST
;
;                  $iX      - The x-coordinate of the window's upper-left corner.
;                  $iY      - The y-coordinate of the window's upper-left corner.
;                  $iWidth  - The window's new width, in pixels.
;                  $iHeight - The window's new height, in pixels.
;                  $iFlags  - A combination of the following values that affect the size and position of the window.
;
;                             $SWP_DRAWFRAME
;                             $SWP_FRAMECHANGED
;                             $SWP_HIDEWINDOW
;                             $SWP_NOACTIVATE
;                             $SWP_NOCOPYBITS
;                             $SWP_NOMOVE
;                             $SWP_NOOWNERZORDER
;                             $SWP_NOREDRAW
;                             $SWP_NOREPOSITION
;                             $SWP_NOSENDCHANGING
;                             $SWP_NOSIZE
;                             $SWP_NOZORDER
;                             $SWP_SHOWWINDOW
;
; Return values..: Success  - The return value identifies the updated multiple-window-position structure.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DeferWindowPos
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeferWindowPos($hInfo, $hWnd, $hAfter, $iX, $iY, $iWidth, $iHeight, $iFlags)

	Local $Ret = DllCall('user32.dll', 'ptr', 'DeferWindowPos', 'ptr', $hInfo, 'hwnd', $hWnd, 'hwnd', $hAfter, 'int', $iX, 'int', $iY, 'int', $iWidth, 'int', $iHeight, 'uint', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_DeferWindowPos

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DefineDosDevice
; Description....: Defines, redefines, or deletes MS-DOS device names.
; Syntax.........: _WinAPI_DefineDosDevice ( $sDevice, $iFlags [, $sPath] )
; Parameters.....: $sDevice - The name of the MS-DOS device.
;                  $iFlags  - This parameter can be one or more of the following values.
;
;                             $DDD_EXACT_MATCH_ON_REMOVE
;                             $DDD_NO_BROADCAST_SYSTEM
;                             $DDD_RAW_TARGET_PATH
;                             $DDD_REMOVE_DEFINITION
;
;                  $sPath   - The path that will implement device.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DefineDosDevice
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DefineDosDevice($sDevice, $iFlags, $sPath = '')

	Local $TypeOfPath = 'wstr'

	If Not StringStripWS($sPath, 3) Then
		$TypeOfPath = 'ptr'
		$sPath = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'DefineDosDeviceW', 'dword', $iFlags, 'wstr', $sDevice, $TypeOfPath, $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DefineDosDevice

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DefSubclassProc
; Description....: Calls the next handler in a window's subclass chain.
; Syntax.........: _WinAPI_DefSubclassProc ( $hWnd, $iMsg, $wParam, $lParam )
; Parameters.....: $hWnd   - Handle to the window being subclassed.
;                  $iMsg   - The message to be sent.
;                  $wParam - The message-specific information.
;                  $lParam - The message-specific information.
; Return values..: Success - The returned value is specific to the message sent.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The last handler in the subclass chain is the original window procedure for the specified window. You do not
;                  need  to call the default window procedure; this function calls it automatically.
; Related........:
; Link...........: @@MsdnLink@@ DefSubclassProc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DefSubclassProc($hWnd, $iMsg, $wParam, $lParam)

	Local $Ret = DllCall('comctl32.dll', 'lresult', 'DefSubclassProc', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_DefSubclassProc

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeleteEnhMetaFile
; Description....: Deletes an enhanced-format metafile or an enhanced-format metafile handle.
; Syntax.........: _WinAPI_DeleteEnhMetaFile ( $hEmf )
; Parameters.....: $hEmf   - Handle to an enhanced metafile.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the $hEmf parameter identifies an enhanced metafile stored in memory, the _WinAPI_DeleteEnhMetaFile() function
;                  deletes the metafile. If $hEmf identifies a metafile stored on a disk, the function deletes the metafile handle but
;                  does not destroy the actual metafile. An application can retrieve the file by calling the _WinAPI_GetEnhMetaFile()
;                  function.
; Related........:
; Link...........: @@MsdnLink@@ DeleteEnhMetaFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeleteEnhMetaFile($hEmf)

	Local $Ret = DllCall('gdi32.dll', 'int', 'DeleteEnhMetaFile', 'ptr', $hEmf)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DeleteEnhMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeleteFile
; Description....: Deletes an existing file.
; Syntax.........: _WinAPI_DeleteFile ( $sFile )
; Parameters.....: $sFile  - The name of the file to be deleted.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DeleteFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeleteFile($sFile)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeleteFileW', 'wstr', $sFile)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DeleteFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeleteObjectID
; Description....: Removes the object identifier from a specified file or directory.
; Syntax.........: _WinAPI_DeleteObjectID ( $sPath )
; Parameters.....: $sPath  - Path to the file or directory from the object identifier that is to be deleted.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The calling process must have restore privilege, otherwise, the function fails, and _WinAPI_GetLastError()
;                  returns ERROR_ACCESS_DENIED (5).
; Related........:
; Link...........: @@MsdnLink@@ FSCTL_DELETE_OBJECT_ID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeleteObjectID($sPath)

	Local $hToken, $Adjust, $Error, $Flags,  $hFile = 0, $Ret = 1

	$hToken = _WinAPI_OpenProcessToken(0x0028)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	_WinAPI_AdjustTokenPrivileges($hToken, 'SeRestorePrivilege', 0x00000002, $Adjust)
	If _WinAPI_PathIsDirectory($sPath) Then
		$Flags = 0x02000000
	Else
		$Flags = 0
	EndIf
	$hFile = _WinAPI_CreateFileEx($sPath, 3, 0x40000000, 0x06, $Flags)
	If $hFile Then
		$Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x000900A0, 'ptr', 0, 'dword', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
		If (@error) Or (Not $Ret[0]) Then
			$Ret = 2
		EndIf
	EndIf
	If Not IsArray($Ret) Then
		$Error = _WinAPI_GetLastError()
	EndIf
	_WinAPI_AdjustTokenPrivileges($hToken, $Adjust, 0, $Adjust)
	_WinAPI_CloseHandle($hToken)
	If $hFile Then
		_WinAPI_CloseHandle($hFile)
	EndIf
	If Not IsArray($Ret) Then
		Return SetError($Ret, _WinAPI_SetLastError($Error), 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DeleteObjectID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeleteMetaFile
; Description ...: Deletes a Windows-format metafile or Windows-format metafile handle
; Syntax.........: _WinAPI_DeleteMetaFile($hMetaFile)
; Parameters ....: $hMetaFile - A handle to a Windows-format metafile
; Return values .: Success      - True
;                  Failure      - False
; Remarks .......: None
; Related .......: None
; Link ..........; @@MsdnLink@@ DeleteMetaFile
; Example .......; No
; ===============================================================================================================================
Func _WinAPI_DeleteMetaFile($hMetaFile)
	Local $aResult = DllCall("gdi32.dll", "int", "DeleteMetaFile", "hwnd", $hMetaFile)

	If (@error) Or (Not $aResult[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DeleteMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeleteVolumeMountPoint
; Description....: Deletes a drive letter or mounted folder.
; Syntax.........: _WinAPI_DeleteVolumeMountPoint ( $sPath )
; Parameters.....: $sPath  - The drive letter or mounted folder to be deleted (for example, X:\ or Y:\MountX\).
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Deleting a mounted folder does not cause the underlying directory to be deleted.
; Related........:
; Link...........: @@MsdnLink@@ DeleteVolumeMountPoint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeleteVolumeMountPoint($sPath)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeleteVolumeMountPointW', 'wstr', $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DeleteVolumeMountPoint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeregisterShellHookWindow
; Description....: Unregisters a specified Shell window that is registered to receive Shell hook messages.
; Syntax.........: _WinAPI_DeregisterShellHookWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to unregister from receiving Shell hook messages.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DeregisterShellHookWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeregisterShellHookWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'DeregisterShellHookWindow', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DeregisterShellHookWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DestroyCaret
; Description....: Destroys the caret's current shape, frees the caret from the window, and removes the caret from the screen.
; Syntax.........: _WinAPI_DestroyCaret ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_DestroyCaret() destroys the caret only if a window in the current task owns the caret. If a window that
;                  is not in the current task owns the caret, _WinAPI_DestroyCaret() does nothing and returns 0.
;
;                  The window should destroy the caret before losing the keyboard focus or becoming inactive.
; Related........:
; Link...........: @@MsdnLink@@ DestroyCaret
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DestroyCaret()

	Local $Ret = DllCall('user32.dll', 'int', 'DestroyCaret')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DestroyCaret

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DestroyCursor
; Description....: Destroys a cursor and frees any memory the cursor occupied.
; Syntax.........: _WinAPI_DestroyCursor ( $hCursor )
; Parameters.....: $hCursor - Handle to the cursor to be destroyed. The cursor must not be in use.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared cursor
;                  is valid as long as the module from which it was loaded remains in memory.
; Related........:
; Link...........: @@MsdnLink@@ DestroyCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DestroyCursor($hCursor)

	Local $Ret = DllCall('user32.dll', 'int', 'DestroyCursor', 'ptr', $hCursor)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DestroyCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeviceIoControl
; Description....: Sends a control code directly to a specified device driver.
; Syntax.........: _WinAPI_DeviceIoControl ( $hDevice, $iControlCode [, $pInBuffer [, $iInBufferSize [, $pOutBuffer [, $iOutBufferSize]]]] )
; Parameters.....: $hDevice        - Handle to the device on which the operation is to be performed. The device is typically a volume,
;                                    directory, file, or stream. To retrieve a device handle, use the _WinAPI_CreateFileEx function.
;                                    To specify a device name, use the following format:
;
;                                    _WinAPI_CreateFileEx("\\.\DeviceName", ...)
;
;                  $iControlCode   - The control code for the operation. This value identifies the specific operation to be performed
;                                    and the type of device on which to perform it.
;                  $pInBuffer      - A pointer to the input buffer that contains the data required to perform the operation.
;                  $iInBufferSize  - The size of the input buffer, in bytes.
;                  $pOutBuffer     - A pointer to the output buffer that is to receive the data returned by the operation.
;                  $iOutBufferSize - The size of the output buffer, in bytes.
; Return values..: Success - 1 and @extended flag contains the size of the data stored in the output buffer, in bytes.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DeviceIoControl
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeviceIoControl($hDevice, $iControlCode, $pInBuffer = 0, $iInBufferSize = 0, $pOutBuffer = 0, $iOutBufferSize = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hDevice, 'dword', $iControlCode, 'ptr', $pInBuffer, 'dword', $iInBufferSize, 'ptr', $pOutBuffer, 'dword', $iOutBufferSize, 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $Ret[7], 1)
EndFunc   ;==>_WinAPI_DeviceIoControl

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DevicePowerSetDeviceState
; Description....: Modifies the specified Power set on the specified device.
; Syntax.........: _WinAPI_DevicePowerSetDeviceState ( $DeviceDescription[, $iFlag] )
; Parameters.....: $DeviceDescription - The name or hardware identifier string of the device to be modified.
;                  $iFlag - The properties of the device that are to be modified.
;
;
;                  $SET_WAKEENABLED (default)
;                  $CLEAR_WAKEENABLED
;
;
; Return values..: Success  - 1
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DevicePowerSetDeviceState
; Example........: Yes
; ===================================================================================================
Func _WinAPI_DevicePowerSetDeviceState($DeviceDescription, $iFlag = $DEVICEPOWER_SET_WAKEENABLED)

	Local $Ret = DllCall('PowrProf.dll', "dword", "DevicePowerSetDeviceState", "wstr", $DeviceDescription, "uint", $iFlag, "ptr", 0)

	If Not ($Ret[0]) Then SetError(-1, 0, 1)

EndFunc   ;==>_WinAPI_DevicePowerSetDeviceState

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DisplayStruct
; Description....: Displays data from the specified structure or memory address as a list.
; Syntax.........: _WinAPI_DisplayStruct (ByRef $tStruct [, $sStruct [, $sTitle [, $iItem [, $iSubItem [, $iFlags [, $fTop [, $hParent]]]]]]] )
; Parameters.....: $tStruct  - A structure that was created by DllStructCreate(), or memory address to be display its data.
;                  $sStruct  - A string representing the structure. If $tStruct is a structure, This parameter can be omitted or be
;                              an empty string. In this case, the structure will display as "byte[n]" structure. If $tStruct is a
;                              memory address, $sStruct should be a string representing the structure, otherwise, the function
;                              fail, and @error set to 1.
;                  $sTitle   - The title of the window, deault is "Structure: ListView Display".
;                  $iItem    - The 1-based index or name of the structure member to be selected in the list. If this parameter is 0,
;                              or an incorrect index or name, the first element of the structure will be selected.
;                  $iSubItem - The 1-based index of the array in the structure member pointed to by the $iItem parameter to be
;                              selected. If $iItem was not defined as an array in the $sStruct, or invalid array index, the
;                              itself element will be selected.
;                  $iFlags   - A set of bit flags that that specifies an additional displaying options. This parameter can be zero,
;                              or any combination of the following values.
;
;                              1 - Prevent display "<struct>" and "<endstruct>" fields at the beginning and end of the list.
;                              2 - Prevent display "<alignment>" fields.
;                              4 - Prevent display "<unnamed>" in "Member" column of the list if the structure element has no name.
;                              8 - Prevent highlighting structure elements that are defined as an array.
;                             16 - Prevent perceiving structure elements named "Reserved*" as unused elements.
;                             32 - Prevent using double-click to copy values of the structure elements to the clipboard.
;                             64 - Forced to expand structure elements of BYTE[n] and BOOLEAN[n] types (elements of CHAR[n] and WCHAR[n] types always displays as a string).
;                            128 - Forced to display the values of the structure elements as hexadecimal representation, if possibly.
;                            256 - Forced to return error code instead of displaying a message box if a memory access error occurred.
;                            512 - Forced to disable checking the read access memory allocated to a given structure.
;
;                  $fTop     - Specifies whether create a window with "Always On Top" attribute, valid values:
;                  |TRUE     - The window is created with the $WS_EX_TOPMOST extended style. (Default)
;                  |FALSE    - The window will not have the "TOPMOST" flag set.
;                  $hParent  - Handle to a parent window.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to the one of the following values:
;
;                              1 - The $sStruct parameter is not a string.
;                              2 - There is an unknown data type in the string passed.
;                              3 - Failed to allocate the memory needed for the structure, or invalid pointer.
;                              4 - Unspecified error.
;                              5 - Error accessing memory to read data.
;
; Author.........: Yashied
; Modified.......:
; Remarks........: This function is intended primarily for debugging and should not be used in the final script, since no useful
;                  information for the end user does not carry.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DisplayStruct(ByRef $tStruct, $sStruct = '', $sTitle = '', $iItem = 0, $iSubItem = 0, $iFlags = 0, $fTop = 1, $hParent = 0)

	Local $aData, $iData, $tData, $pData

	If Not StringStripWS($sTitle, 3) Then
		$sTitle = 'Structure: ListView Display'
	EndIf
	$sStruct = StringRegExpReplace(StringStripWS($sStruct, 7), ';+\Z', '')
	If IsDllStruct($tStruct) Then
		$pData = DllStructGetPtr($tStruct)
		If Not $sStruct Then
			$sStruct = 'byte[' & DllStructGetSize($tStruct) & ']'
			$iFlags = BitOR($iFlags, 64)
		EndIf
	Else
		$pData = $tStruct
		If Not $sStruct Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	$tData = DllStructCreate($sStruct, $pData)
	If @error Then
		Return SetError(@error, 0, 0)
	EndIf
	$iData = DllStructGetSize($tData)
	If (Not BitAND($iFlags, 512)) And (_WinAPI_IsBadReadPtr($pData, $iData)) Then
		If Not BitAND($iFlags, 256) Then
			_WinAPI_MsgBox(0x00040010, $sTitle, 'The memory range allocated to a given structure could not be read.' & @CR & @CR & Ptr($pData) & ' - ' & Ptr($pData + $iData - 1) & @CR & @CR & 'Press OK to exit.')
			Exit -1073741819
		EndIf
		Return SetError(5, 0, 0)
	EndIf

	Local $LV, $hLV, $ID, $Init, $Dummy
	Local $pDll, $aItem, $rItem, $sItem, $iMode, $iSize, $Index, $Offset, $Pattern, $Count = 0, $Prev = 0
	Local $tParam = DllStructCreate('ptr;uint')
	Local $Opt1 = Opt('GUIDataSeparatorChar', '|')
	Local $Opt2 = Opt('GUIOnEventMode', 0)
	Local $Opt3 = Opt('GUICloseOnESC', 1)
	Local $iStyle = 0x00000001
	Local $Width[6] = [30, 130, 76, 100, 50, 167]
	Local $Sel[2] = [0, 0]
	Local $Val[101] = [0]
	Local $Type[28][2] = _
		   [['BYTE',      1], _
			['BOOLEAN',   1], _
			['CHAR',      1], _
			['WCHAR',     2], _
			['short',     2], _
			['USHORT',    2], _
			['WORD',      2], _
			['int',       4], _
			['long',      4], _
			['BOOL',      4], _
			['UINT',      4], _
			['ULONG',     4], _
			['DWORD',     4], _
			['INT64',     8], _
			['UINT64',    8], _
			['ptr',       __Iif(@AutoItX64, 8, 4)], _
			['HWND',      __Iif(@AutoItX64, 8, 4)], _
			['HANDLE',    __Iif(@AutoItX64, 8, 4)], _
			['float',     4], _
			['double',    8], _
			['INT_PTR',   __Iif(@AutoItX64, 8, 4)], _
			['LONG_PTR',  __Iif(@AutoItX64, 8, 4)], _
			['LRESULT',   __Iif(@AutoItX64, 8, 4)], _
			['LPARAM',    __Iif(@AutoItX64, 8, 4)], _
			['UINT_PTR',  __Iif(@AutoItX64, 8, 4)], _
			['ULONG_PTR', __Iif(@AutoItX64, 8, 4)], _
			['DWORD_PTR', __Iif(@AutoItX64, 8, 4)], _
			['WPARAM',    __Iif(@AutoItX64, 8, 4)]]

	If $fTop Then
		$iStyle = BitOR($iStyle, 0x00000008)
	EndIf
	GUISetState(@SW_DISABLE, $hParent)
	$__Dlg = GUICreate($sTitle, 570, 620, -1, -1, 0x80C70000, $iStyle, $hParent)
	$LV = GUICtrlCreateListView('#|Member|Offset|Type|Size|Value', 0, 0, 570, 620, 0x0000000D, __Iif($__WINVER < 0x0600, 0x00010031, 0x00010030))
	$hLV = GUICtrlGetHandle($LV)
	If $__WINVER >= 0x0600 Then
		_WinAPI_SetWindowTheme($hLV, 'Explorer')
	EndIf
	GUICtrlSetResizing(-1, 0x0066)
	GUICtrlSetFont(-1, 8.5, 400, 0, 'Tahoma')
	GUICtrlSetState(-1, 0x0100)
	If Not BitAND($iFlags, 1) Then
		__Inc($Val)
		$Val[$Val[0]] = ''
		GUICtrlCreateListViewItem('-|-|' & $pData & '|<struct>|0|-', $LV)
		GUICtrlSetColor(-1, 0x9C9C9C)
	EndIf
	$aData = StringSplit($sStruct, ';')
	For $i = 1 To $aData[0]
		$aItem = StringSplit(StringStripWS($aData[$i], 3), ' ')
		Switch $aItem[1]
			Case 'ALIGN', 'STRUCT', 'ENDSTRUCT'
				ContinueLoop
			Case Else

		EndSwitch
		$Count+= 1
		$iMode = 1
		$sItem = $Count & '|'
		If $aItem[0] > 1 Then
			$rItem = StringRegExpReplace($aItem[2], '\[.*\Z', '')
			$sItem &= $rItem & '|'
			If (Not BitAND($iFlags, 16)) And (Not StringCompare(StringRegExpReplace($rItem, '[0-9]+\Z', ''), 'RESERVED')) Then
				$iMode = 0
			EndIf
			If Not IsString($iItem) Then
				$rItem = $Count
			EndIf
			$Index = 2
		Else
			If Not BitAND($iFlags, 4) Then
				$sItem &= '<unnamed>|'
			Else
				$sItem &= '|'
			EndIf
			If Not IsString($iItem) Then
				$rItem = $Count
			Else
				$rItem = 0
			EndIf
			$Index = 1
		EndIf
		If (Not $Sel[0]) And ($rItem) And ($iItem) And ($rItem = $iItem) Then
			$Sel[0] = $Count
		EndIf
		$Offset = Number(DllStructGetPtr($tData, $Count) - $pData)
		$Index = StringRegExp($aItem[$Index], '\[(\d+)\]', 3)
		Do
			ReDim $aItem[3]
			$rItem = StringRegExpReplace($aItem[1], '\[.*\Z', '')
			For $j = 0 To UBound($Type) - 1
				If Not StringCompare($Type[$j][0], $rItem) Then
					$aItem[1] = $Type[$j][0]
					$aItem[2] = $Type[$j][1]
					$iSize = $aItem[2]
					ExitLoop 2
				EndIf
			Next
			$aItem[1] = '?'
			$aItem[2] = '?'
			$iSize = 0
		Until 1
		$sItem &= $Offset & '|'
		If (IsArray($Index)) And ($Index[0] > '1') Then
			If $iSize Then
				$aItem[2] = $aItem[2] * $Index[0]
			EndIf
			Do
				Switch $aItem[1]
					Case 'BYTE', 'BOOLEAN'
						If Not BitAND($iFlags, 64) Then
							ContinueCase
						EndIf
					Case 'CHAR', 'WCHAR'
						$sItem &= $aItem[1] & '[' & $Index[0] & ']|' & $aItem[2] & '|'
						$Index = 0
						ExitLoop
					Case Else

				EndSwitch
				If ($iSize) And ($iMode) Then
					$sItem &= $aItem[1] & '[' & $Index[0] & ']|' & $aItem[2] & ' (' & $iSize & ')' & '|'
				Else
					$sItem &= $aItem[1] & '[' & $Index[0] & ']|' & $aItem[2] & '|'
				EndIf
				If $iMode Then
					$Index = $Index[0]
				Else
					$Index = 0
				EndIf
			Until 1
		Else
			$sItem &= $aItem[1] & '|' & $aItem[2] & '|'
			$Index = 0
		EndIf
		If (Not BitAND($iFlags, 2)) And ($Prev) And ($Offset > $Prev) Then
			__Inc($Val)
			$Val[$Val[0]] = ''
			GUICtrlCreateListViewItem('-|-|-|<alignment>|' & ($Offset - $Prev) & '|-', $LV)
			GUICtrlSetColor(-1, 0xFF0000)
		EndIf
		If $iSize Then
			$Prev = $Offset + $aItem[2]
		Else
			$Prev = 0
		EndIf
		If $Index Then
			$Pattern = '[%0' & StringLen($Index) & 'd] '
			For $j = 1 To $Index
				__Inc($Val)
				$Val[$Val[0]] = DllStructGetData($tData, $Count, $j)
				If BitAND($iFlags, 128) Then
					$Val[$Val[0]] = __Hex($Val[$Val[0]], $aItem[1])
				EndIf
				$ID = GUICtrlCreateListViewItem($sItem & StringFormat($Pattern, $j) & $Val[$Val[0]], $LV)
				If ($Sel[0] = $Count) And (Not $Sel[1]) Then
					If ($iSubItem < 1) Or ($iSubItem > $Index) Or ($iSubItem = $j) Then
						$Sel[1] = $ID
					EndIf
				EndIf
				If (Not $Init) And ($Count = 1) Then
					$Init = $ID
				EndIf
				If Not BitAND($iFlags, 8) Then
					GUICtrlSetBkColor(-1, 0xF5F5F5)
				EndIf
				If $iSize Then
					$sItem = '-|-|' & ($Offset + $j * $iSize) & '|-|-|'
				Else
					GUICtrlSetColor(-1, 0xFF8800)
					$sItem = '-|-|-|-|-|'
				EndIf
			Next
		Else
			__Inc($Val)
			If $iMode Then
				$Val[$Val[0]] = DllStructGetData($tData, $Count)
				If BitAND($iFlags, 128) Then
					$Val[$Val[0]] = __Hex($Val[$Val[0]], $aItem[1])
				EndIf
				$ID = GUICtrlCreateListViewItem($sItem & $Val[$Val[0]], $LV)
			Else
				$Val[$Val[0]] = ''
				$ID = GUICtrlCreateListViewItem($sItem & '-', $LV)
			EndIf
			If ($Sel[0] = $Count) And (Not $Sel[1]) Then
				$Sel[1] = $ID
			EndIf
			If (Not $Init) And ($Count = 1) Then
				$Init = $ID
			EndIf
			If Not $iSize Then
				GUICtrlSetColor(-1, 0xFF8800)
			EndIf
		EndIf
		If (Not BitAND($iFlags, 2)) And (Not $iSize) Then
			__Inc($Val)
			$Val[$Val[0]] = ''
			GUICtrlCreateListViewItem('-|-|-|<alignment>|?|-', $LV)
			GUICtrlSetColor(-1, 0xFF8800)
		EndIf
	Next
	If (Not BitAND($iFlags, 2)) And ($Prev) And ($iData > $Prev) Then
		__Inc($Val)
		$Val[$Val[0]] = ''
		GUICtrlCreateListViewItem('-|-|-|<alignment>|' & ($iData - $Prev) & '|-', $LV)
		GUICtrlSetColor(-1, 0xFF0000)
	EndIf
	If Not BitAND($iFlags, 1) Then
		__Inc($Val)
		$Val[$Val[0]] = ''
		GUICtrlCreateListViewItem('-|-|' & ($pData + $iData - 0) & '|<endstruct>|' & $iData & '|-', $LV)
		GUICtrlSetColor(-1, 0x9C9C9C)
	EndIf
	If $Sel[1] Then
		GUICtrlSetState($Sel[1], 0x0100)
	Else
		GUICtrlSetState($Init, 0x0100)
	EndIf
	$Dummy = GUICtrlCreateDummy()
	For $i = 0 To UBound($Width) - 1
		GUICtrlSendMsg($LV, 0x101E, $i, $Width[$i])
	Next
	DllStructSetData($tParam, 1, $hLV)
	If Not BitAND($iFlags, 32) Then
		DllStructSetData($tParam, 2, $Dummy)
	Else
		DllStructSetData($tParam, 2, 0)
	EndIf
	$__Dll = DllCallbackRegister('__DlgSubclassProc', 'lresult', 'hwnd;uint;wparam;lparam;uint;ptr')
	$pDll = DllCallbackGetPtr($__Dll)
	If _WinAPI_SetWindowSubclass($__Dlg, $pDll, 1000, DllStructGetPtr($tParam)) Then
		OnAutoItExitRegister('__Quit')
	Else
		DllCallbackFree($__Dll)
		$__Dll = 0
	EndIf
	GUISetState()
	While 1
		Switch GUIGetMsg()
			Case  0
				ContinueLoop
			Case -3
				ExitLoop
			Case $Dummy
				$Index = GUICtrlRead($Dummy)
				If ($Index >= 0) And ($Index < $Val[0]) Then
					ClipPut($Val[$Index + 1])
				EndIf
		EndSwitch
	WEnd
	If $__Dll Then
		OnAutoItExitUnregister('__Quit')
	EndIf
	__Quit()
	GUISetState(@SW_ENABLE, $hParent)
	GUIDelete()
	Opt('GUIDataSeparatorChar', $Opt1)
	Opt('GUIOnEventMode', $Opt2)
	Opt('GUICloseOnESC', $Opt3)
	Return 1
EndFunc   ;==>_WinAPI_DisplayStruct

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DllGetVersion
; Description....: Retrieves a DLL-specific version information.
; Syntax.........: _WinAPI_DllGetVersion ( $sPath )
; Parameters.....: $sPath  - The path to the DLL file from which information is retrieved.
; Return values..: Success - The array containing the following information:
;
;                            [0] - The major version.
;                            [1] - The minor version.
;                            [2] - The build number.
;                            [3] - The platform for which the DLL was built ($DLLVER_PLATFORM_*).
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function is not an API. It is exported by name from each DLL that implements it. Currently, most of the Windows Shell
;                  and common controls DLLs implement DllGetVersion. These include, but are not limited to, shell32.dll, comctl32.dll,
;                  shdocvw.dll, and shlwapi.dll.
; Related........:
; Link...........: @@MsdnLink@@ DllGetVersion
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DllGetVersion($sPath)

	Local $tVersion = DllStructCreate('dword[5]')

	DllStructSetData($tVersion, 1, DllStructGetSize($tVersion), 1)

	Local $Ret = DllCall($sPath, 'uint', 'DllGetVersion', 'ptr', DllStructGetPtr($tVersion))

	If @error Then
		Return SetError(@error, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[4]

	For $i = 0 To 3
		$Result[$i] = DllStructGetData($tVersion, 1, $i + 2)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_DllGetVersion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DPtoLP
; Description....: Converts device coordinates into logical coordinates.
; Syntax.........: _WinAPI_DPtoLP( $hDC, $tPOINT [, $iCount = 1] )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tPoint - $tagPOINT structure or structure of points ("long x1;long y1;...long xN;long yN") containing the
;                            x- and y-coordinates to be transformed.
;                  $iCount - The number of points.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_DPtoLP() function fails if the device coordinates exceed 27 bits, or if the converted logical coordinates
;                  exceed 32 bits. In the case of such an overflow, the results for all the points are undefined.
; Related........:
; Link...........: @@MsdnLink@@ DPtoLP
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DPtoLP($hDC, ByRef $tPoint, $iCount = 1)

	Local $Ret = DllCall('gdi32.dll', 'int', 'DPtoLP', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPoint), 'int', $iCount)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DPtoLP

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DragAcceptFiles
; Description....: Registers whether a window accepts dropped files.
; Syntax.........: _WinAPI_DragAcceptFiles ( $hWnd [, $fAccept] )
; Parameters.....: $hWnd    - Handle to the window that is registering whether it will accept dropped files.
;                  $fAccept - Specifies whether a window accepts dropped files, valid values:
;                  |TRUE    - Accept dropped files. (Default)
;                  |FALSE   - Discontinue accepting dropped files.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DragAcceptFiles
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DragAcceptFiles($hWnd, $fAccept = 1)
	DllCall('shell32.dll', 'none', 'DragAcceptFiles', 'hwnd', $hWnd, 'int', $fAccept)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DragAcceptFiles

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DragFinish
; Description....: Releases memory that the system allocated for use in transferring file names to the application.
; Syntax.........: _WinAPI_DragFinish ( $hDrop )
; Parameters.....: $hDrop  - Handle of the drop structure that describes the dropped file. This parameter is passed to
;                            WM_DROPFILES message with WPARAM parameter.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DragFinish
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DragFinish($hDrop)
	DllCall('shell32.dll', 'none', 'DragFinish', 'ptr', $hDrop)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DragFinish

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DragQueryFileEx
; Description....: Retrieves the names of dropped files that result from a successful drag-and-drop operation.
; Syntax.........: _WinAPI_DragQueryFileEx ( $hDrop [, $iFlag] )
; Parameters.....: $hDrop  - Handle of the drop structure that describes the dropped file. This parameter is passed to
;                            WM_DROPFILES message with WPARAM parameter.
;                  $iFlag  - The flag that specifies whether to return files folders or both, valid values:
;                  |0 - Return both files and folders. (Default)
;                  |1 - Return files only.
;                  |2 - Return folders only.
; Return values..: Success - The array of the names of a dropped files. The zeroth array element contains the number of file names.
;                            If no files that satisfy the condition ($iFlag), the function fails.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DragQueryFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DragQueryFileEx($hDrop, $iFlag = 0)

	Local $Ret, $Count, $Dir, $File, $tData, $aData[1] = [0]

	$Ret = DllCall('shell32.dll', 'int', 'DragQueryFileW', 'ptr', $hDrop, 'uint', -1, 'ptr', 0, 'uint', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = $Ret[0]
	ReDim $aData[$Count + 1]
	For $i = 0 To $Count - 1
		$tData = DllStructCreate('wchar[1024]')
		$Ret = DllCall('shell32.dll', 'int', 'DragQueryFileW', 'ptr', $hDrop, 'uint', $i, 'ptr', DllStructGetPtr($tData), 'uint', 1024)
		If Not $Ret[0] Then
			Return SetError(1, 0, 0)
		EndIf
		$File = DllStructGetData($tData, 1)
		$tData = 0
		If $iFlag Then
			$Dir = _WinAPI_PathIsDirectory($File)
			If Not @error Then
				If (($iFlag = 1) And ($Dir)) Or (($iFlag = 2) And (Not $Dir)) Then
					ContinueLoop
				EndIf
			EndIf
		EndIf
		$aData[$i + 1] = $File
		$aData[0] += 1
	Next
	If Not $aData[0] Then
		Return SetError(1, 0, 0)
	EndIf
	ReDim $aData[$aData[0] + 1]
	Return $aData
EndFunc   ;==>_WinAPI_DragQueryFileEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DragQueryPoint
; Description....: Retrieves the position of the mouse pointer at the time a file was dropped during a drag-and-drop operation.
; Syntax.........: _WinAPI_DragQueryPoint ( $hDrop )
; Parameters.....: $hDrop  - Handle of the drop structure that describes the dropped file. This parameter is passed to
;                            WM_DROPFILES message with WPARAM parameter.
; Return values..: Success - $tagPOINT structure that contains the coordinates of the mouse pointer at the time the
;                            file was dropped.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DragQueryPoint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DragQueryPoint($hDrop)

	Local $tPOINT = DllStructCreate($tagPOINT)
	Local $Ret = DllCall('shell32.dll', 'int', 'DragQueryPoint', 'ptr', $hDrop, 'ptr', DllStructGetPtr($tPOINT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tPOINT
EndFunc   ;==>_WinAPI_DragQueryPoint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawAnimatedRects
; Description....: Animates the caption of a window to indicate the opening of an icon or the minimizing or maximizing of a window.
; Syntax.........: _WinAPI_DrawAnimatedRects ( $hWnd, $tRectFrom, $tRectTo )
; Parameters.....: $hWnd      - Handle to the window whose caption should be animated on the screen.
;                  $tRectFrom - $tagRECT structure specifying the location and size of the icon or minimized window.
;                  $tRectTo   - $tagRECT structure specifying the location and size of the restored window.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The window caption will animate from the position specified by $tRectFrom to the position specified by $tRectTo.
;                  The effect is similar to minimizing or maximizing a window.
; Related........:
; Link...........: @@MsdnLink@@ DrawAnimatedRects
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawAnimatedRects($hWnd, $tRectFrom, $tRectTo)

	Local $Ret = DllCall('user32.dll', 'int', 'DrawAnimatedRects', 'hwnd', $hWnd, 'int', 3, 'ptr', DllStructGetPtr($tRectFrom), 'ptr', DllStructGetPtr($tRectTo))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawAnimatedRects

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawBitmap
; Description....: Draws a bitmap into the specified device context.
; Syntax.........: _WinAPI_DrawBitmap ( $hDC, $iX, $iY, $hBitmap [, $iRop] )
; Parameters.....: $hDC     - Handle to the device context into which the bitmap will be drawn.
;                  $iX      - Specifies the logical x-coordinate of the upper-left corner of the bitmap.
;                  $iY      - Specifies the logical y-coordinate of the upper-left corner of the bitmap.
;                  $hBitmap - Handle to the bitmap to be drawn.
;                  $iRop    - The raster-operation code (same as for _WinAPI_BitBlt()).
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not support bitmaps with Alpha channel, use _WinAPI_AlphaBlend() to work with them.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawBitmap($hDC, $iX, $iY, $hBitmap, $iRop = 0x00CC0020)

	Local $Ret, $tObj, $_hDC, $hSrcDC, $hSrcSv

	$tObj = DllStructCreate($tagBITMAP)
	$Ret = DllCall('gdi32.dll', 'int', 'GetObject', 'int', $hBitmap, 'int', DllStructGetSize($tObj), 'ptr', DllStructGetPtr($tObj))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$Ret = DllCall('user32.dll', 'hwnd', 'GetDC', 'hwnd', 0)
	$_hDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleDC', 'hwnd', $_hDC)
	$hSrcDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'SelectObject', 'hwnd', $hSrcDC, 'ptr', $hBitmap)
	$hSrcSv = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'int', 'BitBlt', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'int', DllStructGetData($tObj, 'bmWidth'), 'int', DllStructGetData($tObj, 'bmHeight'), 'hwnd', $hSrcDC, 'int', 0, 'int', 0, 'int', $iRop)
	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', 0, 'hwnd', $_hDC)
	DllCall('gdi32.dll', 'ptr', 'SelectObject', 'hwnd', $hSrcDC, 'ptr', $hSrcSv)
	DllCall('gdi32.dll', 'int', 'DeleteDC', 'hwnd', $hSrcDC)
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawShadowText
; Description....: Draws formatted text in the specified rectangle with a drop shadow.
; Syntax.........: _WinAPI_DrawShadowText ( $hDC, $sText, $rgbText, $rgbShadow [, $iXOffset [, $iYOffset [, $tRECT [, $iFlags]]]] )
; Parameters.....: $hDC       - Handle to a device context.
;                  $sText     - The string that contains the text to be drawn.
;                  $rgbText   - The color of the text, in RGB.
;                  $rgbShadow - The color of the shadow, in RGB.
;                  $iXOffset  - The x-coordinate of where the text should begin.
;                  $iYOffset  - The y-coordinate of where the text should begin.
;                  $tRECT     - $tagRECT structure that contains, in logical coordinates, the rectangle in which the text is to
;                               be drawn. If this parameter is 0, the size will be equal size of the device context ($hDC).
;                  $iFlags    - The flags that specifies how the text is to be drawn. This parameter can be a combination of
;                               the formatting text constants ($DT_*).
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Rover
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DrawShadowText
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawShadowText($hDC, $sText, $rgbText, $rgbShadow, $iXOffset = 0, $iYOffset = 0, $tRECT = 0, $iFlags = 0)

	Local $Ret

	If Not IsDllStruct($tRECT) Then
		$tRECT = DllStructCreate($tagRECT)
		$Ret = DllCall('user32.dll', 'int', 'GetClientRect', 'hwnd', _WinAPI_WindowFromDC($hDC), 'ptr', DllStructGetPtr($tRECT))
		If (@error) Or (Not $Ret[0]) Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	$Ret = DllCall('comctl32.dll', 'int', 'DrawShadowText', 'hwnd', $hDC, 'wstr', $sText, 'uint', -1, 'ptr', DllStructGetPtr($tRECT), 'dword', $iFlags, 'int', __RGB($rgbText), 'int', __RGB($rgbShadow), 'int', $iXOffset, 'int', $iYOffset)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawShadowText

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawThemeBackground
; Description....: Draws the border and fill defined by the visual style for the specified control part.
; Syntax.........: _WinAPI_DrawThemeBackground ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT [, $tCLIP] )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part to draw.
;                  $iStateId - The state of the part to draw.
;                  $hDC      - Handle to the device context for drawing the theme-defined background image.
;                  $tRECT    - $tagRECT structure that contains the rectangle in which the background image is drawn.
;                  $tCLIP    - $tagRECT structure that contains a clipping rectangle.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DrawThemeBackground
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawThemeBackground($hTheme, $iPartId, $iStateId, $hDC, $tRECT, $tCLIP = 0)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'DrawThemeBackground', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tCLIP))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawThemeBackground

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawThemeEdge
; Description....: Draws one or more edges defined by the visual style of a rectangle.
; Syntax.........: _WinAPI_DrawThemeEdge ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT, $iEdge, $iFlags [, $tAREA] )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the rectangle.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context.
;                  $tRECT    - $tagRECT structure that contains the rectangle.
;                  $iEdge    - The type of inner and outer edges to draw. This parameter must be a combination of one inner-border
;                              flag and one outer-border flag ($BDR_*), or one of the combination flags ($EDGE_*).
;                  $iFlags   - The type of border to draw. It can be a combination of the BF_* constants.
;                  $tAREA    - $tagRECT structure that contains the rectangle that receives the interior rectangle, if $BF_ADJUST is used.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DrawThemeEdge
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawThemeEdge($hTheme, $iPartId, $iStateId, $hDC, $tRECT, $iEdge, $iFlags, $tAREA = 0)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'DrawThemeEdge', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'uint', $iEdge, 'uint', $iFlags, 'ptr', DllStructGetPtr($tAREA))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawThemeEdge

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawThemeIcon
; Description....: Draws an image from an image list with the icon effect defined by the visual style.
; Syntax.........: _WinAPI_DrawThemeIcon ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT, $hIL, $iIndex )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part in which the image is drawn.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context.
;                  $tRECT    - $tagRECT structure that contains the rectangle in which the image is drawn.
;                  $hIL      - Handle to an image list that contains the image to draw.
;                  $iIndex   - The index of the image to draw.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DrawThemeIcon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawThemeIcon($hTheme, $iPartId, $iStateId, $hDC, $tRECT, $hIL, $iIndex)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'DrawThemeIcon', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'ptr', $hIL, 'int', $iIndex)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawThemeIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawThemeParentBackground
; Description....: Draws the part of a parent control that is covered by a partially-transparent or alpha-blended child control.
; Syntax.........: _WinAPI_DrawThemeParentBackground ( $hWnd, $hDC [, $tRECT] )
; Parameters.....: $hWnd   - Handle of the child control.
;                  $hDC    - Handle to the child control's DC.
;                  $tRECT  - $tagRECT structure that defines the area, in the child window's coordinates, to be drawn.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DrawThemeParentBackground
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawThemeParentBackground($hWnd, $hDC, $tRECT = 0)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'DrawThemeParentBackground', 'hwnd', $hWnd, 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawThemeParentBackground

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawThemeText
; Description....: Draws text using the color and font defined by the visual style.
; Syntax.........: _WinAPI_DrawThemeText ( $hTheme, $iPartId, $iStateId, $hDC, $sText, $tRECT, $iFlags )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that has the desired text appearance. If this value is 0, the text is drawn in the
;                              default font, or a font selected into the device context.
;                  $iStateId - The state that has the desired text appearance.
;                  $hDC      - Handle to the device context to use for drawing.
;                  $sText    - The string that contains the text to draw.
;                  $tRECT    - $tagRECT structure that contains the rectangle in which the text is to be drawn.
;                  $iFlags   - The string's formatting flags. This parameter can be one or more of the $DT_* values.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DrawThemeText
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawThemeText($hTheme, $iPartId, $iStateId, $hDC, $sText, $tRECT, $iFlags)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'DrawThemeText', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'wstr', $sText, 'int', -1, 'dword', $iFlags, 'dword', 0, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawThemeText

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawThemeTextEx
; Description....: Draws text using the color and font defined by the visual style.
; Syntax.........: _WinAPI_DrawThemeTextEx ( $hTheme, $iPartId, $iStateId, $hDC, $sText, $tRECT, $iFlags, $tDTTOPTS )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that has the desired text appearance. If this value is 0, the text is drawn in the
;                              default font, or a font selected into the device context.
;                  $iStateId - The state that has the desired text appearance.
;                  $hDC      - Handle to the device context to use for drawing.
;                  $sText    - The string that contains the text to draw.
;                  $tRECT    - $tagRECT structure that contains the rectangle in which the text is to be drawn.
;                  $iFlags   - The string's formatting flags. This parameter can be one or more of the $DT_* values.
;                  $tDTTOPTS - $tagDTTOPTS structure that defines additional formatting options.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DrawThemeTextEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawThemeTextEx($hTheme, $iPartId, $iStateId, $hDC, $sText, $tRECT, $iFlags, $tDTTOPTS)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'DrawThemeTextEx', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'wstr', $sText, 'int', -1, 'dword', $iFlags, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tDTTOPTS))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawThemeTextEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DuplicateHandle
; Description....: Duplicates an object handle.
; Syntax.........: _WinAPI_DuplicateHandle ( $hProcess, $hSource, $hTarget [, $iAccess [, $iOptions [, $fInherit]]] )
; Parameters.....: $hProcess - Handle to the process with the handle to be duplicated. The handle must have the $PROCESS_DUP_HANDLE access right.
;                  $hSource  - Handle to be duplicated. This is an open object handle that is valid in the context of the source process.
;                  $hTarget  - Handle to the process that is to receive the duplicated handle. The handle must have the
;                              $PROCESS_DUP_HANDLE access right.
;                  $iAccess  - The access requested for the new handle.
;                  $iOptions - Optional actions. This parameter can be zero, or any combination of the following values.
;
;                              $DUPLICATE_CLOSE_SOURCE
;                              $DUPLICATE_SAME_ACCESS
;
;                  $fInherit - Specifies whether the handle is inheritable, valid values:
;                  |TRUE     - The duplicate handle can be inherited by new processes created by the target process.
;                  |FALSE    - The new handle cannot be inherited. (Default)
; Return values..: Success   - The duplicate handle. This handle is valid in the context of the target process.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The duplicate handle refers to the same object as the original handle. Therefore, any changes to the object are
;                  reflected through both handles. For example, if you duplicate a file handle, the current file position is always
;                  the same for both handles. For file handles to have different file positions, use the _WinAPI_CreateFile()
;                  function to create file handles that share access to the same file.
; Related........:
; Link...........: @@MsdnLink@@ DuplicateHandle
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DuplicateHandle($hProcess, $hSource, $hTarget, $iAccess = 0, $iOptions = 2, $fInherit = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DuplicateHandle', 'ptr', $hProcess, 'ptr', $hSource, 'ptr', $hTarget, 'ptr*', 0, 'dword', $iAccess, 'int', $fInherit, 'dword', $iOptions)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[4]
EndFunc   ;==>_WinAPI_DuplicateHandle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmEnableBlurBehindWindow
; Description....: Enables the blur effect on a specified window.
; Syntax.........: _WinAPI_DwmEnableBlurBehindWindow ( $hWnd [, $fEnable [, $fTransition [, $hRgn]]] )
; Parameters.....: $hWnd        - Handle to the window on which the blur behind data is applied.
;                  $fEnable     - Specifies whether register or unregister the window handle to DWM blur behind, valid values:
;                  |TRUE        - Register.
;                  |FALSE       - Unregister.
;                  $fTransition - Specifies whether colorize transition to match the maximized windows, valid values:
;                  |TRUE        - The window's should be colorized.
;                  |FALSE       - Otherwise.
;                  $hRgn        - The region within the client area to apply the blur behind. A zeroth value will apply the blur
;                                 behind the entire client area.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The alpha values in the window are honored and the rendering atop the blur will use these alpha values.
;                  It is the application's responsibility for ensuring that the alpha values of all pixels in the window are correct.
;                  Some Windows Graphics Device Interface (GDI) operations do not preserve alpha values, so care must be taken when
;                  presenting child windows because the alpha values they contribute are unpredictable.
;
;                  This function must be called whenever Desktop Window Manager (DWM) composition is toggled. Handle the
;                  WM_DWMCOMPOSITIONCHANGED message for composition change notification.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmEnableBlurBehindWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmEnableBlurBehindWindow($hWnd, $fEnable = 1, $fTransition = 0, $hRgn = 0)

	Local $tBLURBEHIND = DllStructCreate('dword;int;ptr;int')
	Local $Flags = 0

	If $hRgn Then
		$Flags += 2
		DllStructSetData($tBLURBEHIND, 3, $hRgn)
	EndIf

	DllStructSetData($tBLURBEHIND, 1, BitOR($Flags, 0x05))
	DllStructSetData($tBLURBEHIND, 2, $fEnable)
	DllStructSetData($tBLURBEHIND, 4, $fTransition)

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmEnableBlurBehindWindow', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tBLURBEHIND))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmEnableBlurBehindWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmEnableComposition
; Description....: Enables or disables Desktop Window Manager (DWM) composition.
; Syntax.........: _WinAPI_DwmEnableComposition ( $fEnable )
; Parameters.....: $fEnable  - Specifies whether enable or disable DWM composition, valid values:
;                  |TRUE     - Enable.
;                  |FALSE    - Disable.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Disabling DWM composition disables it for the entire desktop. DWM composition will be automatically enabled
;                  when all processes that have disabled composition have called _WinAPI_DwmEnableComposition() to enable it or have
;                  been terminated. The WM_DWMCOMPOSITIONCHANGED notification is sent when DWM composition has enabled or disabled.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmEnableComposition
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmEnableComposition($fEnable)

	If $fEnable Then
		$fEnable = 1
	EndIf

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmEnableComposition', 'uint', $fEnable)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmEnableComposition

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmExtendFrameIntoClientArea
; Description....: Extends the window frame behind the client area.
; Syntax.........: _WinAPI_DwmExtendFrameIntoClientArea ( $hWnd [, $tMARGINS] )
; Parameters.....: $hWnd     - Handle to the window for which the frame is extended into the client area.
;                  $tMARGINS - $tagMARGINS structure that describes the margins to use when extending the frame into the client area.
;                              Negative margins are used to create the "sheet of glass" effect where the client area is rendered as
;                              a solid surface with no window border.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function must be called whenever Desktop Window Manager (DWM) composition is toggled. Handle the
;                  WM_DWMCOMPOSITIONCHANGED message for composition change notification.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmExtendFrameIntoClientArea
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmExtendFrameIntoClientArea($hWnd, $tMARGINS = 0)

	If Not IsDllStruct($tMARGINS) Then
		$tMARGINS = DllStructCreate('int;int;int;int')
		For $i = 1 To 4
			DllStructSetData($tMARGINS, $i, -1)
		Next
	EndIf

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmExtendFrameIntoClientArea', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tMARGINS))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmExtendFrameIntoClientArea

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmGetColorizationColor
; Description....: Retrieves the current color used for Desktop Window Manager (DWM) glass composition.
; Syntax.........: _WinAPI_DwmGetColorizationColor ( )
; Parameters.....: None
; Return values..: Success - The current color (0xAARRGGBB) used for glass composition, @extended flag indicates whether the
;                            color is an opaque blend:
;                            1 - The color is an opaque blend.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmGetColorizationColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmGetColorizationColor()

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmGetColorizationColor', 'dword*', 0, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return SetError(0, $Ret[2], $Ret[1])
EndFunc   ;==>_WinAPI_DwmGetColorizationColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmGetWindowAttribute
; Description....: Retrieves the current value of a specified attribute applied to the window.
; Syntax.........: _WinAPI_DwmGetWindowAttribute ( $hWnd, $iAttribute )
; Parameters.....: $hWnd       - Handle to the window for which the attribute data is retrieved.
;                  $iAttribute - The attribute to retrieve. This parameter can be one of the following values.
;
;                                $DWMWA_NCRENDERING_ENABLED
;                                $DWMWA_CAPTION_BUTTON_BOUNDS
;                                $DWMWA_EXTENDED_FRAME_BOUNDS
;
; Return values..: Success     - The value that contains the current value of the attribute. The type of the returned value depends
;                                on the value of the $iAttribute parameter.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmGetWindowAttribute
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmGetWindowAttribute($hWnd, $iAttribute)

	Local $Struct

	Switch $iAttribute
		Case $DWMWA_CAPTION_BUTTON_BOUNDS, $DWMWA_EXTENDED_FRAME_BOUNDS
			$Struct = $tagRECT
		Case $DWMWA_NCRENDERING_ENABLED
			$Struct = 'uint'
		Case Else
			Return SetError(1, 0, 0)
	EndSwitch

	Local $tData = DllStructCreate($Struct)
	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmGetWindowAttribute', 'hwnd', $hWnd, 'dword', $iAttribute, 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Switch $iAttribute
		Case $DWMWA_NCRENDERING_ENABLED
			Return DllStructGetData($tData, 1)
		Case Else
			Return $tData
	EndSwitch
EndFunc   ;==>_WinAPI_DwmGetWindowAttribute

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmInvalidateIconicBitmaps
; Description....: Indicates that all previously provided iconic bitmaps from a window, both thumbnails and peek representations, should be refreshed.
; Syntax.........: _WinAPI_DwmInvalidateIconicBitmaps ( $hWnd )
; Parameters.....: $hWnd    - Handle to the window or tab whose bitmaps are being invalidated through this call.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Calling this function causes the Desktop Window Manager (DWM) to invalidate its current bitmaps for the window
;                  and request new bitmaps from the window when they are next needed. _WinAPI_DwmInvalidateIconicBitmaps() should
;                  not be called frequently. Doing so can lead to poor performance as new bitmaps are created and retrieved.
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmInvalidateIconicBitmaps
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmInvalidateIconicBitmaps($hWnd)

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmInvalidateIconicBitmaps', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmInvalidateIconicBitmaps

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmIsCompositionEnabled
; Description....: Determines whether Desktop Window Manager (DWM) composition is enabled.
; Syntax.........: _WinAPI_DwmIsCompositionEnabled ( )
; Parameters.....: None
; Return values..: Success - 1 - DWM composition is enabled.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmIsCompositionEnabled
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmIsCompositionEnabled()

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmIsCompositionEnabled', 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_DwmIsCompositionEnabled

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmQueryThumbnailSourceSize
; Description....: Returns the source size of the Desktop Window Manager (DWM) thumbnail.
; Syntax.........: _WinAPI_DwmUnregisterThumbnail ( $hThumbnail )
; Parameters.....: $hThumbnail - Handle of the thumbnail to retrieve the source window size from.
; Return values..: Success     - $tagSIZE structure that contains the size of the source thumbnail.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmQueryThumbnailSourceSize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)

	Local $tSIZE = DllStructCreate($tagSIZE)
	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmQueryThumbnailSourceSize', 'ptr', $hThumbnail, 'ptr', DllStructGetPtr($tSIZE))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tSIZE
EndFunc   ;==>_WinAPI_DwmQueryThumbnailSourceSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmRegisterThumbnail
; Description....: Creates a Desktop Window Manager (DWM) thumbnail relationship between the destination and source windows.
; Syntax.........: _WinAPI_DwmRegisterThumbnail ( $hDestination, $hSource )
; Parameters.....: $hDestination - Handle to the window that will use the DWM thumbnail.
;                  $hSource      - Handle to the window to use as the thumbnail source.
; Return values..: Success       - Handle that represents the registration of the DWM thumbnail.
;                  Failure       - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The window designated by $hDestination must either be the desktop window itself or be owned by the process that
;                  is calling _WinAPI_DwmRegisterThumbnail().
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmRegisterThumbnail
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmRegisterThumbnail($hDestination, $hSource)

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmRegisterThumbnail', 'hwnd', $hDestination, 'hwnd', $hSource, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_DwmRegisterThumbnail

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmSetIconicLivePreviewBitmap
; Description....: Sets a static, iconic bitmap to display a live preview (also known as a Peek preview) of a window or tab.
; Syntax.........: _WinAPI_DwmSetIconicLivePreviewBitmap ( $hWnd, $hBitmap [, $fFrame [, $tClient]] )
; Parameters.....: $hWnd    - Handle to the window or tab.
;                  $hBitmap - Handle to the device-independent bitmap (DIB) to represent the specified window.
;                  $fFrame  - Specifies whether display a frame around the provided bitmap, valid values:
;                  |TRUE    - Display frame.
;                  |FALSE   - Do not display frame. (Default)
;                  $tClient - $tagPOINT structure that contains The offset of a tab window's client region from the host window's
;                             frame. This offset enables the tab window's contents to be drawn correctly in a live preview when
;                             it is drawn without its frame.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: A window typically calls the _WinAPI_DwmSetIconicLivePreviewBitmap() function in response to a
;                  WM_DWMSENDICONICLIVEPREVIEWBITMAP message. The returned bitmap must not be larger than the client area of the
;                  window or frame and must have 32-bit color depth.
;
;                  The DWM uses a copy of the bitmap, but the caller retains ownership of the original bitmap and is responsible
;                  for freeing the resources that it uses when it is no longer needed. The DWM does not keep its copy of the
;                  bitmap when the DWM stops displaying the live preview representation.
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmSetIconicLivePreviewBitmap
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmSetIconicLivePreviewBitmap($hWnd, $hBitmap, $fFrame = 0, $tClient = 0)

	Local $Flags

	If $fFrame Then
		$Flags = 0x00000001
	Else
		$Flags = 0
	EndIf

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmSetIconicLivePreviewBitmap', 'hwnd', $hWnd, 'ptr', $hBitmap, 'ptr', DllStructGetPtr($tClient), 'dword', $Flags)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmSetIconicLivePreviewBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmSetIconicThumbnail
; Description....: Sets a static, iconic bitmap on a window or tab to use as a thumbnail representation.
; Syntax.........: _WinAPI_DwmSetIconicThumbnail ( $hWnd, $hBitmap [, $fFrame] )
; Parameters.....: $hWnd    - Handle to the window or tab.
;                  $hBitmap - Handle to the device-independent bitmap (DIB) to represent the specified window.
;                  $fFrame  - Specifies whether display a frame around the provided thumbnail, valid values:
;                  |TRUE    - Display frame.
;                  |FALSE   - Do not display frame. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: A window typically calls the _WinAPI_DwmSetIconicThumbnail() function after it receives a WM_DWMSENDICONICTHUMBNAIL
;                  message. The thumbnail should not exceed the maximum x-coordinate and y-cordinate that are specified in the
;                  WM_DWMSENDICONICTHUMBNAIL. The thumbnail must also have a 32-bit color depth.
;
;                  The DWM uses a copy of the bitmap, but the application can release this copy at any time because of memory
;                  constraints. If this occurs, the window is not notified but it might receive a subsequent WM_DWMSENDICONICTHUMBNAIL
;                  request when its thumbnail is needed again. The caller retains ownership of the original bitmap and is responsible
;                  for freeing the resources that it uses when it is no longer needed.
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmSetIconicThumbnail
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmSetIconicThumbnail($hWnd, $hBitmap, $fFrame = 0)

	Local $Flags

	If $fFrame Then
		$Flags = 0x00000001
	Else
		$Flags = 0
	EndIf

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmSetIconicThumbnail', 'hwnd', $hWnd, 'ptr', $hBitmap, 'dword', $Flags)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmSetIconicThumbnail

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmSetWindowAttribute
; Description....: Sets the value of the specified attributes for non-client rendering to apply to the window.
; Syntax.........: _WinAPI_DwmSetWindowAttribute ( $hWnd, $iAttribute, $iData )
; Parameters.....: $hWnd       - The window handle to apply the given attribute.
;                  $iAttribute - The attribute to apply to the window. This parameter can be one of the following values.
;
;                                $DWMWA_NCRENDERING_POLICY
;                                $DWMWA_TRANSITIONS_FORCEDISABLED
;                                $DWMWA_ALLOW_NCPAINT
;                                $DWMWA_NONCLIENT_RTL_LAYOUT
;                                $DWMWA_FORCE_ICONIC_REPRESENTATION
;                                $DWMWA_FLIP3D_POLICY
;
;                                *Windows 7 or later
;
;                                $DWMWA_HAS_ICONIC_BITMAP
;                                $DWMWA_DISALLOW_PEEK
;                                $DWMWA_EXCLUDED_FROM_PEEK
;
;                  $iData      - The value of the attribute.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmSetWindowAttribute
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmSetWindowAttribute($hWnd, $iAttribute, $iData)
	Switch $iAttribute
		Case $DWMWA_NCRENDERING_POLICY, $DWMWA_TRANSITIONS_FORCEDISABLED, $DWMWA_ALLOW_NCPAINT, $DWMWA_NONCLIENT_RTL_LAYOUT, $DWMWA_FORCE_ICONIC_REPRESENTATION, $DWMWA_FLIP3D_POLICY, $DWMWA_HAS_ICONIC_BITMAP, $DWMWA_DISALLOW_PEEK, $DWMWA_EXCLUDED_FROM_PEEK

		Case Else
			Return SetError(1, 0, 0)
	EndSwitch

	Local $tData = DllStructCreate('uint')

	DllStructSetData($tData, 1, $iData)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmSetWindowAttribute', 'hwnd', $hWnd, 'dword', $iAttribute, 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmSetWindowAttribute

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmUnregisterThumbnail
; Description....: Removes a Desktop Window Manager (DWM) thumbnail relationship.
; Syntax.........: _WinAPI_DwmUnregisterThumbnail ( $hThumbnail )
; Parameters.....: $hThumbnail - Handle to the thumbnail relationship to be removed.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmUnregisterThumbnail
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmUnregisterThumbnail($hThumbnail)

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmUnregisterThumbnail', 'ptr', $hThumbnail)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmUnregisterThumbnail

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmUpdateThumbnailProperties
; Description....: Specifies Desktop Window Manager (DWM) thumbnail properties.
; Syntax.........: _WinAPI_DwmUpdateThumbnailProperties ( $hThumbnail [, $fVisible [, $fClientAreaOnly [, $iOpacity [, $tRectDest [, $tRectSrc]]]]] )
; Parameters.....: $hThumbnail      - Handle of the thumbnail to retrieve the source window size from.
;                  $fVisible        - Specifies whether make the thumbnail visible or invisible, valid values:
;                  |TRUE            - Visible.
;                  |FALSE           - Invisible.
;                  $fClientAreaOnly - Specifies whether use only the thumbnail source's client area or entire window, valid values:
;                  |TRUE            - Use only source's client area.
;                  |FALSE           - Use entire window.
;                  $iOpacity        - The opacity with which to render the thumbnail. 0 is fully transparent while 255 is fully opaque.
;                  $tRectDest       - $tagRECT structure containing the rectangle in the destination window the thumbnail will be
;                                     rendered. By default, the size of this rectangle equal to the source size of the DWM thumbnail
;                                     which returns the _WinAPI_DwmQueryThumbnailSourceSize() function.
;                  $tRectSrc        - $tagRECT structure containing the rectangle that specifies the region of the source window
;                                     to use as the thumbnail. By default, the entire window is used as the thumbnail.
; Return values..: Success          - 1.
;                  Failure          - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Thumbnail relationships created by _WinAPI_DwmRegisterThumbnail() will not be rendered to the destination window
;                  until this function is called. Subsequent calls will update the thumbnail according to the properties.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmUpdateThumbnailProperties
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmUpdateThumbnailProperties($hThumbnail, $fVisible = 1, $fClientAreaOnly = 0, $iOpacity = 255, $tRectDest = 0, $tRectSrc = 0)

	Local $tTHUMBNAIL = DllStructCreate('dword;int[4];int[4];byte;int;int')
	Local $tSIZE, $Flags = 0

	If Not IsDllStruct($tRectDest) Then
		$tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
		$tRectDest = _WinAPI_CreateRectEx(0, 0, DllStructGetData($tSIZE, 1), DllStructGetData($tSIZE, 2))
	EndIf
	For $i = 1 To 4
		DllStructSetData($tTHUMBNAIL, 2, DllStructGetData($tRectDest, $i), $i)
	Next
	If IsDllStruct($tRectSrc) Then
		$Flags += 2
		For $i = 1 To 4
			DllStructSetData($tTHUMBNAIL, 3, DllStructGetData($tRectSrc, $i), $i)
		Next
	EndIf

	DllStructSetData($tTHUMBNAIL, 1, BitOR($Flags, 0x1D))
	DllStructSetData($tTHUMBNAIL, 4, $iOpacity)
	DllStructSetData($tTHUMBNAIL, 5, $fVisible)
	DllStructSetData($tTHUMBNAIL, 6, $fClientAreaOnly)

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmUpdateThumbnailProperties', 'ptr', $hThumbnail, 'ptr', DllStructGetPtr($tTHUMBNAIL))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmUpdateThumbnailProperties

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DWordToFloat
; Description....: Converts a value of type DWORD to a value of type FLOAT.
; Syntax.........: _WinAPI_DWordToFloat ( $iValue )
; Parameters.....: $iValue - The value to be converted.
; Return values..: The converted (FLOAT) value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DWordToFloat($iValue)

	Local $tDWord = DllStructCreate('dword')
	Local $tFloat = DllStructCreate('float', DllStructGetPtr($tDWord))

	DllStructSetData($tDWord, 1, $iValue)

	Return DllStructGetData($tFloat, 1)
EndFunc   ;==>_WinAPI_DWordToFloat


; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DWordToInt
; Description....: Converts a value of type DWORD to a value of type INT.
; Syntax.........: _WinAPI_DWordToInt ( $iValue )
; Parameters.....: $iValue - The value to be converted.
; Return values..: The converted (INT) value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DWordToInt($iValue)

	Local $tData = DllStructCreate('int')

	DllStructSetData($tData, 1, $iValue)

	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_DWordToInt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EjectMedia
; Description....: Ejects media from a device.
; Syntax.........: _WinAPI_EjectMedia ( $sDrive )
; Parameters.....: $sDrive - The drive letter of the CD tray to eject, in the format D:, E:, etc.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_STORAGE_EJECT_MEDIA
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EjectMedia($sDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0x80000000, 0x01)

	If Not $hFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', $IOCTL_STORAGE_EJECT_MEDIA, 'ptr', 0, 'dword', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EjectMedia

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Ellipse
; Description....: Draws an ellipse.
; Syntax.........: _WinAPI_Ellipse ( $hDC, $tRECT )
; Parameters.....: $hDC     - Handle to the device context.
;                  $tRECT   - $tagRECT structure that contains the logical coordinates of the bounding rectangle.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The ellipse is outlined by using the current pen and is filled by using the current brush.
; Related........:
; Link...........: @@MsdnLink@@ Ellipse
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Ellipse($hDC, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'Ellipse', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_Ellipse

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EmptyWorkingSet
; Description....: Removes as many pages as possible from the working set of the specified process.
; Syntax.........: _WinAPI_EmptyWorkingSet ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EmptyWorkingSet
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EmptyWorkingSet($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', 0x001F0FFF, 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EmptyWorkingSet', 'ptr', $hProcess[0])

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EmptyWorkingSet

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EndBufferedPaint
; Description....: Completes a buffered paint operation and frees the associated buffered paint handle.
; Syntax.........: _WinAPI_EndBufferedPaint ( $hBP [, $fUpdate] )
; Parameters.....: $hBP     - Handle of the buffered paint context.
;                  $fUpdate - Specifies whether copy the buffer to the target DC, valid values:
;                  |TRUE    - The target DC will be updated from the buffer. (Default)
;                  |FALSE   - The target DC remains unchanged.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ EndBufferedPaint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EndBufferedPaint($hBP, $fUpdate = 1)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'EndBufferedPaint', 'ptr', $hBP, 'int', $fUpdate)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EndBufferedPaint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EndDeferWindowPos
; Description....: Simultaneously updates the position and size of one or more windows in a single screen-refreshing cycle.
; Syntax.........: _WinAPI_EndDeferWindowPos ( $hInfo )
; Parameters.....: $hInfo  - Handle to a multiple-window-position structure that contains size and position information for one or
;                            more windows. This internal structure is returned by the _WinAPI_BeginDeferWindowPos() function or by
;                            the most recent call to the _WinAPI_DeferWindowPos() function.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: The _WinAPI_EndDeferWindowPos() function sends the WM_WINDOWPOSCHANGING and WM_WINDOWPOSCHANGED messages to
;                  each window identified in the internal structure.
; Related........:
; Link...........: @@MsdnLink@@ EndDeferWindowPos
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EndDeferWindowPos($hInfo)

	Local $Ret = DllCall('user32.dll', 'int', 'EndDeferWindowPos', 'ptr', $hInfo)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EndDeferWindowPos

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EndPaint
; Description....: Marks the end of painting in the specified window.
; Syntax.........: _WinAPI_EndPaint ( $hWnd, ByRef $tPAINTSTRUCT )
; Parameters.....: $hWnd         - Handle to the window that has been repainted.
;                  $tPAINTSTRUCT - $tagPAINTSTRUCT structure that contains the painting information retrieved by _WinAPI_BeginPaint().
; Return values..: Success       - 1.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function is required for each call to the _WinAPI_BeginPaint() function, but only after painting is complete.
; Related........:
; Link...........: @@MsdnLink@@ EndPaint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EndPaint($hWnd, ByRef $tPAINTSTRUCT)

	Local $Ret = DllCall('user32.dll', 'int', 'EndPaint', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tPAINTSTRUCT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EndPaint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EndPath
; Description....: Closes a path bracket and selects the path defined by the bracket into the specified device context.
; Syntax.........: _WinAPI_EndPath ( $hDC )
; Parameters.....: $hDC    - Handle to the device context into which the new path is selected.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EndPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EndPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'EndPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EndPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EndUpdateResource
; Description....: Commits or discards changes of the resources within module.
; Syntax.........: _WinAPI_EndUpdateResource ( $hUpdate [, $fDiscard] )
; Parameters.....: $hUpdate  - A module handle returned by the _WinAPI_BeginUpdateResource(), and used by _WinAPI_UpdateResource(),
;                              referencing the file to be updated.
;                  $fDiscard - Specifies whether to write the resource updates to the file, valid values:
;                  |TRUE     - The changes are discarded.
;                  |FALSE    - The changes are made: the resource updates will take effect. (Default)
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EndUpdateResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EndUpdateResource($hUpdate, $fDiscard = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'EndUpdateResourceW', 'ptr', $hUpdate, 'int', $fDiscard)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EndUpdateResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumChildProcess
; Description....: Enumerates the child processes that belong to the specified process.
; Syntax.........: _WinAPI_EnumChildProcess ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The 2D array of the PIDs and process names.
;
;                            [0][0] - Number of rows in array (n)
;                            [0][1] - Unused
;                            [1][0] - PID
;                            [1][1] - Process name
;                            [n][0] - PID
;                            [n][1] - Process name
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumChildProcess($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $hSnapshot = DllCall('kernel32.dll', 'ptr', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)

	If (@error) Or (Not $hSnapshot[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tPROCESSENTRY32 = DllStructCreate('dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]')
	Local $pPROCESSENTRY32 = DllStructGetPtr($tPROCESSENTRY32)
	Local $Ret, $Result[101][2] = [[0]]

	$hSnapshot = $hSnapshot[0]
	DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
	$Ret = DllCall('kernel32.dll', 'int', 'Process32FirstW', 'ptr', $hSnapshot, 'ptr', $pPROCESSENTRY32)
	While (Not @error) And ($Ret[0])
		If DllStructGetData($tPROCESSENTRY32, 'ParentProcessID') = $PID Then
			$Result[0][0] += 1
			If $Result[0][0] > UBound($Result) - 1 Then
				ReDim $Result[$Result[0][0] + 100][2]
			EndIf
			$Result[$Result[0][0]][0] = DllStructGetData($tPROCESSENTRY32, 'ProcessID')
			$Result[$Result[0][0]][1] = DllStructGetData($tPROCESSENTRY32, 'ExeFile')
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'Process32NextW', 'ptr', $hSnapshot, 'ptr', $pPROCESSENTRY32)
	WEnd
	_WinAPI_CloseHandle($hSnapshot)
	If $Result[0][0] Then
		ReDim $Result[$Result[0][0] + 1][2]
	Else
		Return SetError(1, 0, 0)
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_EnumChildProcess

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumChildWindows
; Description....: Enumerates the child windows that belong to the specified parent window.
; Syntax.........: _WinAPI_EnumChildWindows ( $hWnd [, $fVisible] )
; Parameters.....: $hWnd     - Handle to the parent window whose child windows are to be enumerated. If this parameter is 0,
;                              this function is equivalent to _WinAPI_EnumWindows().
;                  $fVisible - Specifies whether enumerates the invisible window, valid values:
;                  |TRUE     - Enumerate only visible windows. (Default)
;                  |FALSE    - Enumerate all windows.
; Return values..: Success   - The 2D array of the handles to the child windows and classes for the specified parent window.
;
;                              [0][0] - Number of rows in array (n)
;                              [0][1] - Unused
;                              [1][0] - Window handle
;                              [1][1] - Window class name
;                              [n][0] - Window handle
;                              [n][1] - Window class name
;
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumChildWindows
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumChildWindows($hWnd, $fVisible = 1)

	If Not _WinAPI_GetWindow($hWnd, 5) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'int', 'hwnd;lparam')
	Local $Error = 1

	Dim $__Data[101][2] = [[0]]
	DllCall('user32.dll', 'int', 'EnumChildWindows', 'hwnd', $hWnd, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $fVisible)
	If @error Then
		$__Data = 0
	Else
		$Error = 0
		If $__Data[0][0] Then
			ReDim $__Data[$__Data[0][0] + 1][2]
		Else
			$__Data = 0
		EndIf
	EndIf
	DllCallbackFree($hEnumProc)
	Return SetError($Error, 0, $__Data)
EndFunc   ;==>_WinAPI_EnumChildWindows

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumDesktops
; Description....: Enumerates all desktops associated with the specified window station of the calling process.
; Syntax.........: _WinAPI_EnumDesktops ( $hStation )
; Parameters.....: $hStation - Handle to the window station whose desktops are to be enumerated. This handle must have the
;                              $WINSTA_ENUMDESKTOPS access right.
; Return values..: Success   - The array of the desktop names. The zeroth array element contains the number of desktop.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_EnumDesktops() enumerates only those desktops for which the calling process has the
;                  $DESKTOP_ENUMERATE access right.
; Related........:
; Link...........: @@MsdnLink@@ EnumDesktops
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumDesktops($hStation)

	If _WinAPI_GetUserObjectInformation($hStation, 3) <> 'WindowStation' Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hEnumProc = DllCallbackRegister('__EnumDefaultProc','int','hwnd;lparam')
	Local $Ret, $Error = 1

	Dim $__Data[101] = [0]
	$Ret = DllCall('user32.dll', 'int', 'EnumDesktopsW', 'ptr', $hStation, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
	If (@error) Or (Not $Ret[0]) Then
		$__Data = 0
	Else
		$Error = 0
		If $__Data[0] Then
			ReDim $__Data[$__Data[0] + 1]
		Else
			$__Data = 0
		EndIf
	EndIf
	DllCallbackFree($hEnumProc)
	Return SetError($Error, 0, $__Data)
EndFunc   ;==>_WinAPI_EnumDesktops

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumDesktopWindows
; Description....: Enumerates all top-level windows associated with the specified desktop.
; Syntax.........: _WinAPI_EnumDesktopWindows ( $hDesktop [, $fVisible] )
; Parameters.....: $hDesktop - Handle to the desktop whose top-level windows are to be enumerated. This handle must have the
;                              $DESKTOP_READOBJECTS access right.
;                  $fVisible - Specifies whether enumerates the invisible window, valid values:
;                  |TRUE     - Enumerate only visible windows. (Default)
;                  |FALSE    - Enumerate all windows.
; Return values..: Success   - The 2D array of the handles to the window and its class associated with the specified desktop.
;
;                              [0][0] - Number of rows in array (n)
;                              [0][1] - Unused
;                              [n][0] - Window handle
;                              [n][1] - Window class name
;
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumDesktopWindows
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumDesktopWindows($hDesktop, $fVisible = 1)

	If _WinAPI_GetUserObjectInformation($hDesktop, 3) <> 'Desktop' Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc','int','hwnd;lparam')
	Local $Ret, $Error = 1

	Dim $__Data[101][2] = [[0]]
	$Ret = DllCall('user32.dll', 'int', 'EnumDesktopWindows', 'ptr', $hDesktop, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $fVisible)
	If (@error) Or (Not $Ret[0]) Then
		$__Data = 0
	Else
		$Error = 0
		If $__Data[0][0] Then
			ReDim $__Data[$__Data[0][0] + 1][2]
		Else
			$__Data = 0
		EndIf
	EndIf
	DllCallbackFree($hEnumProc)
	Return SetError($Error, 0, $__Data)
EndFunc   ;==>_WinAPI_EnumDesktopWindows

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumDeviceDrivers
; Description....: Retrieves the load address for each device driver in the system.
; Syntax.........: _WinAPI_EnumDeviceDrivers ( )
; Parameters.....: None
; Return values..: Success - The array of device driver addresses. The zeroth array element contains the number of addresses.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumDeviceDrivers
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumDeviceDrivers()

	Local $tData, $Size, $Ret, $Result

	$Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EnumDeviceDrivers', 'ptr', 0, 'dword', 0, 'dword*', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	If @AutoItX64 Then
		$Size = $Ret[3] / 8
	Else
		$Size = $Ret[3] / 4
	EndIf
	$tData = DllStructCreate('ptr[' & $Size & ']')
	$Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EnumDeviceDrivers', 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData), 'dword*', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Dim $Result[$Size + 1] = [$Size]
	For $i = 1 To $Size
		$Result[$i] = DllStructGetData($tData, 1, $i)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_EnumDeviceDrivers
;===============================================================================
; Function Name:    _ChangeScreenResEx()
; Description:    Changes the current screen geometry, colour and refresh rate.
; Version:        1.0.0.0
; Parameter(s):  $i_DisplayNum - Display to change, starting at 1
;                  $i_Width - Width of the desktop screen in pixels. (horizontal resolution)
;                  $i_Height - Height of the desktop screen in pixels. (vertical resolution)
;                   $i_BitsPP - Depth of the desktop screen in bits per pixel.
;                   $i_RefreshRate - Refresh rate of the desktop screen in hertz.
; Requirement(s):   AutoIt Beta > 3.1
; Return Value(s):  On Success - Screen is adjusted, @ERROR = 0
;                  On Failure - sets @ERROR = 1
; Forum(s):      
; Author(s):        Original code - psandu.ro, PartyPooper
;                  Modifications - bobchernow
;===============================================================================
Func _winapi_ChangeScreenResEx($i_DisplayNum = 1, $i_Width = @DesktopWidth, $i_Height = @DesktopHeight, $i_BitsPP = @DesktopDepth, $i_RefreshRate = @DesktopRefresh)
    If $i_Width = "" Or $i_Width = -1 Then $i_Width = @DesktopWidth; default to current setting
    If $i_Height = "" Or $i_Height = -1 Then $i_Height = @DesktopHeight; default to current setting
    If $i_BitsPP = "" Or $i_BitsPP = -1 Then $i_BitsPP = @DesktopDepth; default to current setting
    If $i_RefreshRate = "" Or $i_RefreshRate = -1 Then $i_RefreshRate = @DesktopRefresh; default to current setting
    Local $DEVMODE = DllStructCreate("byte[32];int[10];byte[32];int[6]")
    Local $s_Display
    
    $s_Display = "\\.\Display" & $i_DisplayNum
     Local $B = DllCall("user32.dll", "int", "EnumDisplaySettings", "ptr", 0, "int", 0, "ptr", DllStructGetPtr($DEVMODE))
    
    If @error Then
        $B = 0
        SetError(1)
        Return $B
    Else
        $B = $B[0]
    EndIf
    If $B <> 0 Then
        DllStructSetData($DEVMODE, 2, BitOR($DM_PELSWIDTH, $DM_PELSHEIGHT, $DM_BITSPERPEL, $DM_DISPLAYFREQUENCY), 5)
        DllStructSetData($DEVMODE, 4, $i_Width, 2)
        DllStructSetData($DEVMODE, 4, $i_Height, 3)
        DllStructSetData($DEVMODE, 4, $i_BitsPP, 1)
        DllStructSetData($DEVMODE, 4, $i_RefreshRate, 5)
    
        $B = DllCall("user32.dll", "int", "ChangeDisplaySettingsEx","str", $s_Display, "ptr", DllStructGetPtr($DEVMODE), "hwnd", 0, "dword", $CDS_TEST, "lparam", 0)
        If @error Then
            $B = -1
        Else
            $B = $B[0]
        EndIf
        Select
            Case $B = $DISP_CHANGE_RESTART
                $DEVMODE = ""
                Return 2
            Case $B = $DISP_CHANGE_SUCCESSFUL
                DllCall("user32.dll", "int", "ChangeDisplaySettingsEx","str", $s_Display, "ptr", DllStructGetPtr($DEVMODE), "hwnd", 0, "dword", $CDS_UPDATEREGISTRY, "lparam", 0)
                DllCall("user32.dll", "int", "SendMessage", "hwnd", $HWND_BROADCAST, "int", 0x007E, "int", $i_BitsPP, "int", $i_Height * 2 ^ 16 + $i_Width)
                $DEVMODE = ""
                Return 1
            Case Else
                $DEVMODE = ""
                SetError(1)
                Return $B
        EndSelect
    EndIf
EndFunc;==>_ChangeScreenResEx
; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumDisplaySettings
; Description....: Retrieves information about one of the graphics modes for a display device.
; Syntax.........: _WinAPI_EnumDisplaySettings ( $sDevice, $iMode )
; Parameters.....: $sDevice - The display device about whose graphics mode the function will obtain information. An empty string
;                             specifies the current display device on the computer on which the calling process is running.
;                  $iMode   - The type of information to be retrieved. This value can be a graphics mode index or one of the
;                             following values.
;
;                             $ENUM_CURRENT_SETTINGS
;                             $ENUM_REGISTRY_SETTINGS
;
;                             Graphics mode indexes start at zero. To obtain information for all of a display device's graphics
;                             modes, make a series of calls to _WinAPI_EnumDisplaySettings(), as follows: Set $iMode to zero for
;                             the first call, and increment $iMode by one for each subsequent call. Continue calling the function
;                             until the return value is zero.
;
;                             When you call _WinAPI_EnumDisplaySettings() with $iMode set to zero, the operating system initializes
;                             and caches information about the display device. When you call _WinAPI_EnumDisplaySettings() with
;                             $iMode set to a non-zero value, the function returns the information that was cached the last time
;                             the function was called with $iMode set to zero.
;
; Return values..: Success  - The array containing the following parameters:
;
;                             [0] - The width, in pixels, of the visible device surface.
;                             [1] - The height, in pixels, of the visible device surface.
;                             [2] - The color resolution, in bits per pixel, of the display device.
;                             [3] - The frequency, in hertz (cycles per second), of the display device in a particular mode.
;                             [4] - The device's display mode ($DM_*).
;
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumDisplaySettings
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumDisplaySettings($sDevice, $iMode)

	Local $TypeOfDevice = 'wstr'

	If Not StringStripWS($sDevice, 3) Then
		$TypeOfDevice = 'ptr'
		$sDevice = 0
	EndIf

	Local $tDEVMODE = DllStructCreate('wchar[32];ushort;ushort;ushort;ushort;dword;dword[2];dword;dword;short;short;short;short;short;wchar[32];ushort;dword;dword;dword;dword;dword')

	DllStructSetData($tDEVMODE, 4, DllStructGetSize($tDEVMODE))
	DllStructSetData($tDEVMODE, 5, 0)

	Local $Ret = DllCall('user32.dll', 'int', 'EnumDisplaySettingsW', $TypeOfDevice, $sDevice, 'dword', $iMode, 'ptr', DllStructGetPtr($tDEVMODE))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[5]

	$Result[0] = DllStructGetData($tDEVMODE, 18)
	$Result[1] = DllStructGetData($tDEVMODE, 19)
	$Result[2] = DllStructGetData($tDEVMODE, 17)
	$Result[3] = DllStructGetData($tDEVMODE, 21)
	$Result[4] = DllStructGetData($tDEVMODE, 20)

	Return $Result
EndFunc   ;==>_WinAPI_EnumDisplaySettings

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumDllProc
; Description....: Enumerates exported functions of the specified dynamic-link library (DLL).
; Syntax.........: _WinAPI_EnumDllProc ( $sPath [, $sMask [, $iFlags]] )
; Parameters.....: $sPath  - The path to the library. Although this function searches for a file path when it specified as the relative
;                            path or the name without a path, will better to specify a fully qualified path to the library for an
;                            unequivocal result.
;                  $sMask  - A wildcard string that indicates the function names to be enumerated. This string can optionally
;                            contain the wildcards, "*" and "?". If this parameter is an empty string or omitted, all the exported
;                            functions will be enumerated.
;                  $iFlags - The optional flags. This parameter can be one or more of the following values.
;
;                            $SYMOPT_CASE_INSENSITIVE
;                            $SYMOPT_UNDNAME
;
; Return values..: Success - The array containing the following information:
;
;                            [0][0] - Number of rows in array (n)
;                            [0][1] - Unused
;                            [n][0] - The function address relative to the library base address (UINT64).
;                            [n][1] - The function name.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function works with 32- and 64-bit DLLs regardless of the system (32- or 64-bit), although 64-bit executables
;                  cannot load 32-bit DLLs and vice-versa.
;
;                  Call _WinAPI_GetExtended() to retrieve a fully qualified path to the found library that was used to enumerate.
; Related........:
; Link...........: @@MsdnLink@@ SymEnumSymbols
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumDllProc($sPath, $sMask = '', $iFlags = 0)

	Local $Ret, $hDll, $hEnumProc, $hLibrary, $hProcess, $hProcess, $pAddress = 0, $Error = 1, $Init = False, $Options = Default
	Local $TypeOfMask = 'wstr'

	$__Ext = _WinAPI_PathSearchAndQualify($sPath, 1)
	If @error Then
		Return SetError(2, 0, 0)
	EndIf
	$hDll = DllOpen('dbghelp.dll')
	If $hDll = -1 Then
		Return SetError(4, 0, 0)
	EndIf
	Do
		$__Data = 0
		$hLibrary = _WinAPI_LoadLibraryEx($__Ext, 0x00000003)
		If Not $hLibrary Then
			ExitLoop
		EndIf
		$Ret = DllCall($hDll, 'dword', 'SymGetOptions')
		If @error Then
			ExitLoop
		EndIf
		$Options = $Ret[0]
		$Ret = DllCall($hDll, 'dword', 'SymSetOptions', 'dword', BitOR(BitAND($iFlags, 0x00000003), 0x00000204))
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$hProcess = _WinAPI_GetCurrentProcess()
		$Ret = DllCall($hDll, 'int', 'SymInitializeW', 'ptr', $hProcess, 'ptr', 0, 'int', 1)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Init = 1
		$Ret = DllCall($hDll, 'uint64', 'SymLoadModuleExW', 'ptr', $hProcess, 'ptr', 0, 'wstr', $__Ext, 'ptr', 0, 'uint64', $hLibrary, 'dword', 0, 'ptr', 0, 'dword', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$pAddress = $Ret[0]
		If Not StringStripWS($sMask, 3) Then
			$TypeOfMask = 'ptr'
			$sMask = 0
		EndIf
		Dim $__Data[501][2] = [[0]]
		$hEnumProc = DllCallbackRegister('__EnumSymbolsProc','int','ptr;ulong;lparam')
		$Ret = DllCall($hDll, 'int', 'SymEnumSymbolsW', 'ptr', $hProcess, 'uint64', $pAddress, $TypeOfMask, $sMask, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
		If (@error) Or (Not $Ret[0]) Then
			$__Data = 0
		Else
			$Error = 0
			If $__Data[0][0] Then
				ReDim $__Data[$__Data[0][0] + 1][2]
			Else
				$__Data = 0
			EndIf
		EndIf
		DllCallbackFree($hEnumProc)
	Until 1
	If $pAddress Then
		DllCall($hDll, 'int', 'SymUnloadModule64', 'ptr', $hProcess, 'uint64', $pAddress)
	EndIf
	If $Init Then
		DllCall($hDll, 'int', 'SymCleanup', 'ptr', $hProcess)
	EndIf
	If Not IsKeyword($Options) Then
		DllCall($hDll, 'dword', 'SymSetOptions', 'dword', $Options)
	EndIf
	DllClose($hDll)
	If $hLibrary Then
		_WinAPI_FreeLibrary($hLibrary)
	EndIf
	Return SetError($Error, __Binary($__Ext), $__Data)
EndFunc   ;==>_WinAPI_EnumDllProc

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumMRUList
; Description....: Enumerates the contents of the most recently used (MRU) list.
; Syntax.........: _WinAPI_EnumMRUList ( $hMRU, $iItem )
; Parameters.....: $hMRU    - Handle of the MRU list, obtained when the list was created.
;                  $iItem   - The item to return. If this value is (-1), the function returns the number of items in the MRU list.
; Return values..: Success  - The item requested in $iItem. If $iItem is (-1) - the number of items in the MRU list.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumMRUListW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumMRUList($hMRU, $iItem)

	Local $tData = DllStructCreate('wchar[4096]')
	Local $Ret = DllCall('comctl32.dll ', 'int', 'EnumMRUListW', 'ptr', $hMRU, 'int', $iItem, 'ptr', DllStructGetPtr($tData), 'uint', 4096)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, 0)
	EndIf
	If $iItem < 0 Then
		Return $Ret[0]
	Else
		If Not $Ret[0] Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_EnumMRUList

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumPageFiles
; Description....: Retrieves information for each installed pagefile in the system.
; Syntax.........: _WinAPI_EnumPageFiles ( )
; Parameters.....: None
; Return values..: Success - The 2D array containing pagefile's information.
;
;                            [0][0] - Number of rows in array (n)
;                            [0][i] - Unused
;                            [n][0] - The path to pagefile.
;                            [n][1] - The total size of the pagefile, in bytes.
;                            [n][2] - The current pagefile usage, in bytes.
;                            [n][3] - The peak pagefile usage, in bytes.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumPageFiles
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumPageFiles()

	Local $Info = _WinAPI_GetSystemInfo()

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hEnumProc = DllCallbackRegister('__EnumPageFilesProc','int','lparam;ptr;ptr')
	Local $Ret, $Error = 1

	Dim $__Data[101][4] = [[0]]
	$Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EnumPageFilesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $Info[1])
	If (@error) Or (Not $Ret[0]) Then
		$__Data = 0
	Else
		$Error = 0
		If $__Data[0][0] Then
			ReDim $__Data[$__Data[0][0] + 1][4]
		Else
			$__Data = 0
		EndIf
	EndIf
	DllCallbackFree($hEnumProc)
	Return SetError($Error, 0, $__Data)
EndFunc   ;==>_WinAPI_EnumPageFiles

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumProcessModules
; Description....: Retrieves a handle and name for each module in the specified process.
; Syntax.........: _WinAPI_EnumProcessModules ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array containing the following information:
;
;                            [0][0] - Number of rows in array (n)
;                            [0][1] - Unused
;                            [1][0] - Handle to the module
;                            [1][1] - The path to the file that contains the module
;                            [n][0] - Handle to the module
;                            [n][1] - The path to the file that contains the module
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not retrieve handles for modules that were loaded with the $LOAD_LIBRARY_AS_DATAFILE flag.
;                  For more information, see _WinAPI_LoadLibraryEx().
;
;                  Do not call _WinAPI_CloseHandle() on any of the handles returned by this function. The information comes
;                  from a snapshot, so there are no resources to be freed.
;
;                  If _WinAPI_EnumProcessModules() function is called from a 32-bit application running on WOW64, it can only
;                  enumerate the modules of a 32-bit process. If the process is a 64-bit process, this function fails and the
;                  last error code is ERROR_PARTIAL_COPY (299).
; Related........:
; Link...........: @@MsdnLink@@ EnumProcessModules
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumProcessModules($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $hProcess, $tPtr, $Access, $Count, $Ret, $Result = 0

	If _WinAPI_GetVersion() < '6.0' Then
		$Access = 0x00000410
	Else
		$Access = 0x00001010
	EndIf
	$hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', $Access, 'int', 0, 'dword', $PID)
	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Do
		$Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EnumProcessModules', 'ptr', $hProcess[0], 'ptr', 0, 'dword', 0, 'dword*', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		If @AutoItX64 Then
			$Count = $Ret[4] / 8
		Else
			$Count = $Ret[4] / 4
		EndIf
		$tPtr = DllStructCreate('ptr[' & $Count & ']')
		If Not IsDllStruct($tPtr) Then
			ExitLoop
		EndIf
		$Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EnumProcessModules', 'ptr', $hProcess[0], 'ptr', DllStructGetPtr($tPtr), 'dword', DllStructGetSize($tPtr), 'dword*', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Result = 1
	Until 1
	_WinAPI_CloseHandle($hProcess[0])
	If Not $Result Then
		Return SetError(1, 0, 0)
	EndIf
	Dim $Result[$Count + 1][2] = [[$Count]]
	For $i = 1 To $Count
		$Result[$i][0] = DllStructGetData($tPtr, 1, $i)
		$Result[$i][1] = _WinAPI_GetModuleFileName($Result[$i][0])
	Next
	Return $Result
EndFunc   ;==>_WinAPI_EnumProcessModules

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumProcessThreads
; Description....: Enumerates the threads that belong to the specified process.
; Syntax.........: _WinAPI_EnumProcessThreads ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array of threads identifiers (ID). The zeroth array element contains the number of threads.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumProcessThreads($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $hSnapshot = DllCall('kernel32.dll', 'ptr', 'CreateToolhelp32Snapshot', 'dword', 0x00000004, 'dword', 0)

	If (@error) Or (Not $hSnapshot[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tTHREADENTRY32 = DllStructCreate('dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags')
	Local $pTHREADENTRY32 = DllStructGetPtr($tTHREADENTRY32)
	Local $Ret, $Result[101] = [0]

	$hSnapshot = $hSnapshot[0]
	DllStructSetData($tTHREADENTRY32, 'Size', DllStructGetSize($tTHREADENTRY32))
	$Ret = DllCall('kernel32.dll', 'int', 'Thread32First', 'ptr', $hSnapshot, 'ptr', $pTHREADENTRY32)
	While (Not @error) And ($Ret[0])
		If DllStructGetData($tTHREADENTRY32, 'OwnerProcessID') = $PID Then
			$Result[0] += 1
			If $Result[0] > UBound($Result) - 1 Then
				ReDim $Result[$Result[0] + 100]
			EndIf
			$Result[$Result[0]] = DllStructGetData($tTHREADENTRY32, 'ThreadID')
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'Thread32Next', 'ptr', $hSnapshot, 'ptr', $pTHREADENTRY32)
	WEnd
	_WinAPI_CloseHandle($hSnapshot)
	If $Result[0] Then
		ReDim $Result[$Result[0] + 1]
	Else
		Return SetError(1, 0, 0)
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_EnumProcessThreads

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumProcessWindows
; Description....: Enumerates the windows that belong to the specified process.
; Syntax.........: _WinAPI_EnumProcessWindows ( [$PID [, $fVisible]] )
; Parameters.....: $PID      - The PID of the process. Default (0) is the current process.
;                  $fVisible - Specifies whether enumerates the invisible window, valid values:
;                  |TRUE     - Enumerate only visible windows. (Default)
;                  |FALSE    - Enumerate all windows.
; Return values..: Success   - The 2D array of the handles to the windows and classes for the specified process.
;
;                              [0][0] - Number of rows in array (n)
;                              [0][1] - Unused
;                              [1][0] - Window handle
;                              [1][1] - Window class name
;                              [n][0] - Window handle
;                              [n][1] - Window class name
;
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumProcessWindows($PID = 0, $fVisible = 1)

	Local $Threads = _WinAPI_EnumProcessThreads($PID)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'int', 'hwnd;lparam')
	Local $Error = 1

	Dim $__Data[101][2] = [[0]]
	For $i = 1 To $Threads[0]
		DllCall('user32.dll', 'int', 'EnumThreadWindows', 'dword', $Threads[$i], 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $fVisible)
		If @error Then
			$__Data = 0
			ExitLoop
		EndIf
	Next
	If IsArray($__Data) Then
		$Error = 0
		If $__Data[0][0] Then
			ReDim $__Data[$__Data[0][0] + 1][2]
		Else
			$__Data = 0
		EndIf
	EndIf
	DllCallbackFree($hEnumProc)
	Return SetError($Error, 0, $__Data)
EndFunc   ;==>_WinAPI_EnumProcessWindows

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumResourceLanguages
; Description....: Enumerates language-specific resources, of the specified type and name, associated with a binary module.
; Syntax.........: _WinAPI_EnumResourceLanguages ( $sModule, $sType, $sName )
; Parameters.....: $sModule - Handle to a module to search.
;                  $sType   - The type of the resource. This parameter can be string or integer type.
;                  $sName   - The name of the resource. This parameter can be string or integer type.
; Return values..: Success  - The array of the LCIDs for specified resource type and name.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumResourceLanguages
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumResourceLanguages($sModule, $sType, $sName)

	Local $Ret, $hModule, $hEnumProc, $TypeOfType = 'int', $TypeOfName = 'int'

	If IsString($sModule) Then
		If Not StringStripWS($sModule, 3) Then
			$hModule = DllCall('kernel32.dll', 'ptr', 'GetModuleHandle', 'ptr', 0)
		Else
			$hModule = DllCall('kernel32.dll', 'ptr', 'LoadLibraryW', 'wstr', $sModule)
		EndIf
		If (@error) Or (Not $hModule[0]) Then
			Return SetError(1, 0, 0)
		EndIf
		$hModule = $hModule[0]
	Else
		$hModule = $sModule
	EndIf
	If IsString($sType) Then
		$TypeOfType = 'wstr'
	EndIf
	If IsString($sName) Then
		$TypeOfName = 'wstr'
	EndIf
	Dim $__Data[101] = [0]
	$hEnumProc = DllCallbackRegister('__EnumResLanguagesProc', 'int', 'ptr;ptr;ptr;ushort;long_ptr')
	$Ret = DllCall('kernel32.dll', 'int', 'EnumResourceLanguagesW', 'ptr', $hModule, $TypeOfType, $sType, $TypeOfName, $sName, 'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		$__Data = 0
	Else
		ReDim $__Data[$__Data[0] + 1]
	EndIf
	DllCallbackFree($hEnumProc)
	If IsString($sModule) Then
		_WinAPI_FreeLibrary($hModule)
	EndIf
	Return SetError(Number(Not $__Data), 0, $__Data)
EndFunc   ;==>_WinAPI_EnumResourceLanguages

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumResourceNames
; Description....: Enumerates resources of a specified type within a binary module.
; Syntax.........: _WinAPI_EnumResourceNames ( $sModule, $sType )
; Parameters.....: $sModule - Handle to a module to search.
;                  $sType   - The type of the resource. This parameter can be string or integer type.
; Return values..: Success  - The array of the names for the specified resource type.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumResourceNames
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumResourceNames($sModule, $sType)

	Local $Ret, $hModule, $hEnumProc, $TypeOfType = 'int'

	If IsString($sModule) Then
		If Not StringStripWS($sModule, 3) Then
			$hModule = DllCall('kernel32.dll', 'ptr', 'GetModuleHandle', 'ptr', 0)
		Else
			$hModule = DllCall('kernel32.dll', 'ptr', 'LoadLibraryW', 'wstr', $sModule)
		EndIf
		If (@error) Or (Not $hModule[0]) Then
			Return SetError(1, 0, 0)
		EndIf
		$hModule = $hModule[0]
	Else
		$hModule = $sModule
	EndIf
	If IsString($sType) Then
		$TypeOfType = 'wstr'
	EndIf
	Dim $__Data[101] = [0]
	$hEnumProc = DllCallbackRegister('__EnumResNamesProc', 'int', 'ptr;ptr;ptr;long_ptr')
	$Ret = DllCall('kernel32.dll', 'int', 'EnumResourceNamesW', 'ptr', $hModule, $TypeOfType, $sType, 'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		$__Data = 0
	Else
		ReDim $__Data[$__Data[0] + 1]
	EndIf
	DllCallbackFree($hEnumProc)
	If IsString($sModule) Then
		_WinAPI_FreeLibrary($hModule)
	EndIf
	Return SetError(Number(Not $__Data), 0, $__Data)
EndFunc   ;==>_WinAPI_EnumResourceNames

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumResourceTypes
; Description....: Enumerates resource types within a binary module.
; Syntax.........: _WinAPI_EnumResourceTypes ( $sModule )
; Parameters.....: $sModule - Handle to a module to search.
; Return values..: Success  - The array of the types of the resources for the specified module.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumResourceTypes
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumResourceTypes($sModule)

	Local $Ret, $hModule, $hEnumProc

	If IsString($sModule) Then
		If Not StringStripWS($sModule, 3) Then
			$hModule = DllCall('kernel32.dll', 'ptr', 'GetModuleHandle', 'ptr', 0)
		Else
			$hModule = DllCall('kernel32.dll', 'ptr', 'LoadLibraryW', 'wstr', $sModule)
		EndIf
		If (@error) Or (Not $hModule[0]) Then
			Return SetError(1, 0, 0)
		EndIf
		$hModule = $hModule[0]
	Else
		$hModule = $sModule
	EndIf
	Dim $__Data[101] = [0]
	$hEnumProc = DllCallbackRegister('__EnumResTypesProc', 'int', 'ptr;ptr;long_ptr')
	$Ret = DllCall('kernel32.dll', 'int', 'EnumResourceTypesW', 'ptr', $hModule, 'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		$__Data = 0
	Else
		ReDim $__Data[$__Data[0] + 1]
	EndIf
	DllCallbackFree($hEnumProc)
	If IsString($sModule) Then
		_WinAPI_FreeLibrary($hModule)
	EndIf
	Return SetError(Number(Not $__Data), 0, $__Data)
EndFunc   ;==>_WinAPI_EnumResourceTypes

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumSystemLocales
; Description....: Enumerates the locales that are either installed on or supported by an operating system.
; Syntax.........: _WinAPI_EnumSystemLocales ( $iFlag )
; Parameters.....: $iFlag  - Flags specifying the locale identifiers to enumerate. This parameter can have one of the
;                            following values.
;
;                            $LCID_INSTALLED
;                            $LCID_SUPPORTED
;
; Return values..: Success - The array of the locale identifiers.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumSystemLocales
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumSystemLocales($iFlag)

	Local $Ret, $hEnumProc

	Dim $__Data[101] = [0]
	$hEnumProc = DllCallbackRegister('__EnumLocalesProc', 'int', 'ptr')
	$Ret = DllCall('kernel32.dll', 'int', 'EnumSystemLocalesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'dword', $iFlag)
	If (@error) Or (Not $Ret[0]) Or (Not IsArray($__Data)) Then
		$__Data = 0
	Else
		ReDim $__Data[$__Data[0] + 1]
	EndIf
	DllCallbackFree($hEnumProc)
	Return SetError(Number(Not $__Data), 0, $__Data)
EndFunc   ;==>_WinAPI_EnumSystemLocales

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumWindowStations
; Description....: Enumerates all window stations in the current session.
; Syntax.........: _WinAPI_EnumWindowStations ( )
; Parameters.....: None
; Return values..: Success - The array of the window station names. The zeroth array element contains the number of window station.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_EnumWindowStations() enumerates only those window stations for which the calling process has the
;                  $WINSTA_ENUMERATE access right.
; Related........:
; Link...........: @@MsdnLink@@ EnumWindowStations
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumWindowStations()

	Local $hEnumProc = DllCallbackRegister('__EnumDefaultProc','int','ptr;lparam')
	Local $Ret, $Error = 1

	Dim $__Data[101] = [0]
	$Ret = DllCall('user32.dll', 'int', 'EnumWindowStationsW', 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
	If (@error) Or (Not $Ret[0]) Then
		$__Data = 0
	Else
		$Error = 0
		If $__Data[0] Then
			ReDim $__Data[$__Data[0] + 1]
		Else
			$__Data = 0
		EndIf
	EndIf
	DllCallbackFree($hEnumProc)
	Return SetError($Error, 0, $__Data)
EndFunc   ;==>_WinAPI_EnumWindowStations

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EqualMemory
; Description....: Compares two blocks of memory to determine whether the specified number of bytes are identical.
; Syntax.........: _WinAPI_EqualMemory ( $pSource1, $pSource2, $iLenght )
; Parameters.....: $pSource1 - A pointer to the block of memory to compare.
;                  $pSource2 - A pointer to the block of memory that is compared to the block of memory to which $pSource1 points.
;                  $iLenght  - The number of bytes to be compared.
; Return values..: Success   - 1 - The two memory blocks are equivalent.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlCompareMemory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EqualMemory($pSource1, $pSource2, $iLenght)

	Local $Ret = DllCall('ntdll.dll', 'ulong_ptr', 'RtlCompareMemory', 'ptr', $pSource1, 'ptr', $pSource2, 'ulong_ptr', $iLenght)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return Number($Ret[0] = $iLenght)
EndFunc   ;==>_WinAPI_EqualMemory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EqualRect
; Description....: Determines whether the two specified rectangles are equal.
; Syntax.........: _WinAPI_EqualRect ( $tRECT1, $tRECT2 )
; Parameters.....: $tRECT1 - $tagRECT structure that contains the logical coordinates of the first rectangle.
;                  $tRECT2 - $tagRECT structure that contains the logical coordinates of the second rectangle.
; Return values..: Success - 1 - The two rectangles are identical.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not treat empty rectangles as equal if their coordinates are different.
; Related........:
; Link...........: @@MsdnLink@@ EqualRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EqualRect($tRECT1, $tRECT2)

	Local $Ret = DllCall('user32.dll', 'int', 'EqualRect', 'ptr', DllStructGetPtr($tRECT1), 'ptr', DllStructGetPtr($tRECT2))

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_EqualRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EqualRgn
; Description....: Checks the two specified regions to determine whether they are identical.
; Syntax.........: _WinAPI_EqualRgn ( $hRgn1, $hRgn2 )
; Parameters.....: $hRgn1  - Handle to a region.
;                  $hRgn2  - Handle to a region.
; Return values..: Success - 1 - The two regions are equal.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EqualRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EqualRgn($hRgn1, $hRgn2)

	Local $Ret = DllCall('gdi32.dll', 'int', 'EqualRgn', 'ptr', $hRgn1, 'ptr', $hRgn2)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_EqualRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EqualStruct
; Description....: Determines whether the two specified structures are equal.
; Syntax.........: _WinAPI_EqualStruct (ByRef $tStruct1, ByRef $tStruct2)
; Parameters.....: $tStruct1 - The structure that contains the first source data.
;                  $tStruct2 - The structure that contains the second source data.
; Return values..: Success   - 1 - The two structures are identical.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EqualStruct(ByRef $tStruct1, ByRef $tStruct2)

	Local $Size1 = DllStructGetSize($tStruct1)
	Local $Size2 = DllStructGetSize($tStruct2)

	If (Not $Size1) Or (Not $Size2) Then
		Return SetError(1, 0, 0)
	Else
		If $Size1 <> $Size2 Then
			Return 0
		EndIf
	EndIf

	Local $tData1 = DllStructCreate('byte[' & $Size1 & ']', DllStructGetPtr($tStruct1))
	Local $tData2 = DllStructCreate('byte[' & $Size2 & ']', DllStructGetPtr($tStruct2))

	If (Not IsDllStruct($tData1)) Or (Not IsDllStruct($tData2)) Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = 1 To $Size1
		If DllStructGetData($tData1, 1, $i) <> DllStructGetData($tData2, 1, $i) Then
			Return 0
		EndIf
	Next
	Return 1
EndFunc   ;==>_WinAPI_EqualStruct

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ExcludeClipRect
; Description....: Creates a new clipping region that consists of the existing clipping region minus the specified rectangle.
; Syntax.........: _WinAPI_ExcludeClipRect ( $hDC, $tRECT )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tRECT  - $tagRECT structure that contains the logical coordinates of the specified rectangle.
; Return values..: Success - The value that specifies the new clipping region's complexity; it can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ExcludeClipRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ExcludeClipRect($hDC, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'ExcludeClipRect', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ExcludeClipRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ExtCreatePen
; Description....: Creates a logical cosmetic or geometric pen that has the specified style, width, and brush attributes.
; Syntax.........: _WinAPI_ExtCreatePen ( $iPenStyle, $iWidth, $iBrushStyle, $iRGB [, $iHatch [, $aUserStyle [, $iStart [, $iEnd]]]] )
; Parameters.....: $iPenStyle   - A combination of type, style, end cap, and join attributes. The values from each category are
;                                 combined by using the bitwise operation.
;
;                                 The pen type can be one of the following values.
;
;                                 $PS_GEOMETRIC
;                                 $PS_COSMETIC
;
;                                 The pen style can be one of the following values.
;
;                                 $PS_SOLID
;                                 $PS_DASH
;                                 $PS_DOT
;                                 $PS_DASHDOT
;                                 $PS_DASHDOTDOT
;                                 $PS_NULL
;                                 $PS_INSIDEFRAME
;                                 $PS_USERSTYLE
;                                 $PS_ALTERNATE
;
;                                 The end cap is only specified for geometric pens and can be one of the following values.
;
;                                 $PS_ENDCAP_ROUND
;                                 $PS_ENDCAP_SQUARE
;                                 $PS_ENDCAP_FLAT
;
;                                 The join is only specified for geometric pens and can be one of the following values.
;
;                                 $PS_JOIN_BEVEL
;                                 $PS_JOIN_MITER
;                                 $PS_JOIN_ROUND
;
;                  $iWidth      - The width of the pen. If $PS_GEOMETRIC type is specified, the width is given in logical units,
;                                 otherwise, the width must be set to 1.
;                  $iBrushStyle - A brush style. This parameter can be one of the $BS_* constants.
;                  $iRGB        - The color of a pen, in RGB.
;                  $iHatch      - A hatch style. For more information, see _WinAPI_CreateBrushIndirect().
;                  $aUserStyle  - The array (dash1, space1, dash2, space2, ... dashN, spaceN) that contains the length of the dashes
;                                 and spaces in a user-defined style. The first value specifies the length of the first dash,
;                                 the second value specifies the length of the first space, and so on. This parameter must be set
;                                 to zero if $PS_USERSTYLE style is not specified. The style count is limited to 16.
;                  $iStart      - The index of array to start filling at.
;                  $iEnd        - The index of array to stop filling at.
; Return values..: Success      - Handle to the logical pen.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After an application creates a pen by calling _WinAPI_ExtCreatePen(), it can select it into any device context by
;                  calling the _WinAPI_SelectObject() function. When an application no longer requires a specified pen, it should
;                  call the _WinAPI_DeleteObject() function to delete the pen.
; Related........:
; Link...........: @@MsdnLink@@ ExtCreatePen
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ExtCreatePen($iPenStyle, $iWidth, $iBrushStyle, $iRGB, $iHatch = 0, $aUserStyle = 0, $iStart = 0, $iEnd = -1)

	Local $Count = 0, $tStyle = 0

	If BitAND($iPenStyle, 0xFF) = 7 Then
		If $iStart < 0 Then
			$iStart = 0
		EndIf
		If ($iEnd < 0) Or ($iEnd > UBound($aUserStyle) - 1) Then
			$iEnd = UBound($aUserStyle) - 1
		EndIf
		$tStyle = DllStructCreate('dword[' & ($iEnd - $iStart + 1) & ']')
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
		For $i = $iStart To $iEnd
			DllStructSetData($tStyle, 1, $aUserStyle[$i], $Count + 1)
			$Count += 1
		Next
	EndIf

    Local $tLOGBRUSH = DllStructCreate($tagLOGBRUSH)

	DllStructSetData($tLOGBRUSH, 1, $iBrushStyle)
	DllStructSetData($tLOGBRUSH, 2, __RGB($iRGB))
	DllStructSetData($tLOGBRUSH, 3, $iHatch)

    Local $Ret = DllCall('gdi32.dll', 'ptr', 'ExtCreatePen', 'dword', $iPenStyle, 'dword', $iWidth, 'ptr', DllStructGetPtr($tLOGBRUSH), 'dword', $Count, 'ptr', DllStructGetPtr($tStyle))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ExtCreatePen

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ExtCreateRegion
; Description....: Creates a region from the specified region and transformation data.
; Syntax.........: _WinAPI_ExtCreateRegion ( ByRef $tRGNDATA [, $tXFORM] )
; Parameters.....: $tRGNDATA - $tagRGNDATA structure that contains the region data in logical units.
;                  $tXFORM   - $tagXFORM structure that defines the transformation to be performed on the region.
; Return values..: Success   - The handle to the region.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ExtCreateRegion
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ExtCreateRegion(ByRef $tRGNDATA, $tXFORM = 0)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'ExtCreateRegion', 'ptr', DllStructGetPtr($tXFORM), 'dword', DllStructGetSize($tRGNDATA), 'ptr', DllStructGetPtr($tRGNDATA))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ExtCreateRegion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ExtFloodFill
; Description....: Fills an area of the display surface with the current brush.
; Syntax.........: _WinAPI_ExtFloodFill ( $hDC, $iX, $iY, $iRGB [, $iType] )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical units, of the point where filling is to start.
;                  $iY     - The y-coordinate, in logical units, of the point where filling is to start.
;                  $iRGB   - The color of the boundary or of the area to be filled, in RGB. The interpretation of color depends on
;                            the value of the $iType parameter.
;                  $iType  - The type of fill operation to be performed. This parameter must be one of the following values.
;
;                            $FLOODFILLBORDER
;                            $FLOODFILLSURFACE
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ExtFloodFill
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ExtFloodFill($hDC, $iX, $iY, $iRGB, $iType = 0)

	Local $Ret = DllCall('gdi32.dll', 'int', 'ExtFloodFill', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'dword', __RGB($iRGB), 'uint', $iType)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ExtFloodFill

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ExtractIcon
; Description....: Extracts an icon from the specified executable file, DLL, or icon file.
; Syntax.........: _WinAPI_ExtractIcon ( $sIcon, $iIndex [, $fSmall] )
; Parameters.....: $sIcon  - The name of an executable file, DLL, or icon file from which icons will be extracted.
;                  $iIndex - The zero-based index of the icon to extract. If this value is a negative number, the function extracts
;                            the icon whose resource identifier is equal to the absolute value of $iIndex.
;                  $fSmall - Specifies whether extract a small icon, valid values:
;                  |TRUE   - Extract a small icon.
;                  |FALSE  - Extract a large icon. (Default)
; Return values..: Success - Handle to the extracted icon.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: @@MsdnLink@@ ExtractIconEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ExtractIcon($sIcon, $iIndex, $fSmall = 0)

	Local $pLarge, $pSmall, $tPtr = DllStructCreate('ptr')

	If $fSmall Then
		$pLarge = 0
		$pSmall = DllStructGetPtr($tPtr)
	Else
		$pLarge = DllStructGetPtr($tPtr)
		$pSmall = 0
	EndIf

	Local $Ret = DllCall('shell32.dll', 'uint', 'ExtractIconExW', 'wstr', $sIcon, 'int', $iIndex, 'ptr', $pLarge, 'ptr', $pSmall, 'uint', 1)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return DllStructGetData($tPtr, 1)
EndFunc   ;==>_WinAPI_ExtractIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ExtSelectClipRgn
; Description....: Combines the specified region with the current clipping region.
; Syntax.........: _WinAPI_ExtSelectClipRgn ( $hDC, $hRgn [, $iMode] )
; Parameters.....: $hDC    - Handle to the device context.
;                  $hRgn   - Handle to the region to be selected. This handle can only be 0 when the $RGN_COPY mode is specified.
;                  $iMode  - The operation to be performed. It must be one of the following values.
;
;                            $RGN_AND
;                            $RGN_COPY
;                            $RGN_DIFF
;                            $RGN_OR
;                            $RGN_XOR
;
; Return values..: Success - The value that specifies the new clipping region's complexity; it can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ExtSelectClipRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ExtSelectClipRgn($hDC, $hRgn, $iMode = 5)

	Local $Ret = DllCall('gdi32.dll', 'int', 'ExtSelectClipRgn', 'hwnd', $hDC, 'ptr', $hRgn, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ExtSelectClipRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FatalExit
; Description....: Transfers execution control to the debugger.
; Syntax.........: _WinAPI_FatalExit ( $iCode )
; Parameters.....: $iCode  - The error code associated with the exit.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FatalExit
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FatalExit($iCode)
	DllCall('kernel32.dll', 'none', 'FatalExit', 'int', $iCode)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FatalExit

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FileInUse
; Description....: Tests whether the specified file in use by another application.
; Syntax.........: _WinAPI_FileInUse ( $sFile )
; Parameters.....: $sFile  - The name of the file to test.
; Return values..: Success - 1 - File in use by another application.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None


; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FileInUse($sFile)

	Local $hFile = _WinAPI_CreateFile($sFile, 2, 2, 0)


	If $hFile Then
		_WinAPI_CloseHandle($hFile)
		Return 0
	EndIf

	Local $Error = _WinAPI_GetLastError()

	Switch $Error
		Case 32 ; ERROR_SHARING_VIOLATION
			Return 1
		Case Else
			Return SetError($Error, 0, 0)
	EndSwitch
EndFunc   ;==>_WinAPI_FileInUse

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FillMemory
; Description....: Fills a cblock of memory with the given value.
; Syntax.........: _WinAPI_FillMemory ( $pDestination, $iLenght [, $iValue] )
; Parameters.....: $pDestination - A pointer to the memory to be filled.
;                  $iLenght      - The number of bytes to be filled.
;                  $iValue       - The value to fill the memory.
; Return values..: Success       - 1.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlFillMemory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FillMemory($pDestination, $iLenght, $iValue = 0)
	DllCall('ntdll.dll', 'none', 'RtlFillMemory', 'ptr', $pDestination, 'ulong_ptr', $iLenght, 'byte', $iValue)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FillMemory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FileTimeToLocalFileTime
; Description....: Converts a file time to a local file time.
; Syntax.........: _WinAPI_FileTimeToLocalFileTime ( $tFILETIME )
; Parameters.....: $tFILETIME - $tagFILETIME structure containing the UTC-based file time to be converted into a local file time.
; Return values..: Success    - $tagFILETIME structure that contains the converted local file time.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This functions uses the current settings for the time zone and daylight saving time. Therefore, if it is daylight
;                  saving time, this function will take daylight saving time into account, even if the time you are converting is
;                  in standard time.
; Related........:
; Link...........: @@MsdnLink@@ FileTimeToLocalFileTime
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FileTimeToLocalFileTime($tFILETIME)

	Local $tFILETIMELOCAL = DllStructCreate($tagFILETIME)
	Local $Ret = DllCall('kernel32.dll', 'int', 'FileTimeToLocalFileTime', 'ptr', DllStructGetPtr($tFILETIME), 'ptr', DllStructGetPtr($tFILETIMELOCAL))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tFILETIMELOCAL
EndFunc   ;==>_WinAPI_FileTimeToLocalFileTime

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FileTimeToSystemTime
; Description....: Converts a file time to system time format.
; Syntax.........: _WinAPI_FileTimeToSystemTime ( $tFILETIME )
; Parameters.....: $tFILETIME - $tagFILETIME structure containing he file time to convert to system date and time format.
; Return values..: Success    - $tagSYSTEMTIME structure that contains the converted file time.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FileTimeToSystemTime
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FileTimeToSystemTime($tFILETIME)

	Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
	Local $Ret = DllCall('kernel32.dll', 'int', 'FileTimeToSystemTime', 'ptr', DllStructGetPtr($tFILETIME), 'ptr', DllStructGetPtr($tSYSTEMTIME))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tSYSTEMTIME
EndFunc   ;==>_WinAPI_FileTimeToSystemTime

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FillPath
; Description....: Closes any open figures in the current path and fills the path's interior by using the current brush.
; Syntax.........: _WinAPI_FillPath ( $hDC )
; Parameters.....: $hDC    - Handle to a device context that contains a valid path.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After its interior is filled, the path is discarded from the DC identified by the $hDC parameter.
; Related........:
; Link...........: @@MsdnLink@@ FillPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FillPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'FillPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FillPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FillRgn
; Description....: Fills a region by using the specified brush.
; Syntax.........: _WinAPI_FillRgn ( $hDC, $hRgn, $hBrush )
; Parameters.....: $hDC    - Handle to the device context.
;                  $hRgn   - Handle to the region to be filled. The region's coordinates are presumed to be in logical units.
;                  $hBrush - Handle to the brush to be used to fill the region.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FillRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FillRgn($hDC, $hRgn, $hBrush)

	Local $Ret = DllCall('gdi32.dll', 'int', 'FillRgn', 'hwnd', $hDC, 'ptr', $hRgn, 'ptr', $hBrush)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FillRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FillStruct
; Description....: Fills the structure with a specified value in the specified range.
; Syntax.........: _WinAPI_FillStruct ( ByRef $tStruct, $iValue [, $iBytes [, $iStart [, $iEnd]]] )
; Parameters.....: $tStruct - The structure to be filled that returned by DllStructCreate() function. It should contain a single
;                             element or element is an array. For example, "byte[32]", "int[8]", "int64[4]", etc.
;                  $iValue  - The value to be used to fill the structure. $iValue must be an integer, the chars are not allowed.
;                             To fill with a character use the Asc() or AscW() functions.
;                  $iBytes  - The number of bytes for each element required. It can be one of the following values: 1, 2, 4,
;                             or 8. For other values of this parameter the function is fails.
;                  $iStart  - The index of element in the structure to start filling at.
;                  $iEnd    - The index of element in the structure to stop filling at.
; Return values..: Success  - The number of elements that has been filled. If successful, the same ($iEnd - $iStart + 1).
;                  Failure  - 0 and sets the @error flag to one of the following values:
;                  |1 - $tStruct not a correct structure returned by DllStructCreate().
;                  |2 - $iByte value is incorrect.
;                  |3 - $iStart or $iEnd values outside of the structure.
;                  |4 - Failed to allocate the memory.
;                  |5 - Error filling structure.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FillStruct(ByRef $tStruct, $iValue, $iBytes = 1, $iStart = 1, $iEnd = -1)

	Local $tData, $sData, $Count, $Size = DllStructGetSize($tStruct)

	If Not IsDllStruct($tStruct) Then
		Return SetError(1, 0, 0)
	EndIf

	Switch $iBytes
		Case 1
			$sData = 'byte'
		Case 2
			$sData = 'short'
		Case 4
			$sData = 'int'
		Case 8
			$sData = 'int64'
		Case Else
			Return SetError(2, 0, 0)
	EndSwitch
	$Count = Int($Size / $iBytes)
	If $iStart < 1 Then
		$iStart = 1
	EndIf
	If $iEnd < 0 Then
		$iEnd = $Count
	EndIf
	If ($iStart > $iEnd) Or ($iEnd > $Count) Then
		Return SetError(3, 0, 0)
	EndIf
	$tData = DllStructCreate($sData & '[' & $Count & ']', DllStructGetPtr($tStruct))
	If @error Then
		Return SetError(4, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		DllStructSetData($tData, 1, $iValue, $i)
		If @error Then
			Return SetError(5, 0, $i - $iStart)
		EndIf
	Next
	Return $iEnd - $iStart + 1
EndFunc   ;==>_WinAPI_FillStruct

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindResource
; Description....: Determines the location of a resource with the specified type and name in the specified module.
; Syntax.........: _WinAPI_FindResource ( $hInstance, $sType, $sName )
; Parameters.....: $hInstance - Handle to the module whose executable file contains the resource. A value of 0 specifies the module
;                               handle associated with the image file that the operating system used to create the current process.
;                  $sType     - The type of the resource. This parameter can be string or integer type.
;                  $sName     - The name of the resource. This parameter can be string or integer type.
; Return values..: Success    - Handle to the specified resource's information block. To obtain a handle to the resource, pass this
;                               handle to the _WinAPI_LoadResource() function.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the first character of the string of the $sName or $sType parameter is a pound sign (#), the remaining
;                  characters represent a decimal number that specifies the integer identifier of the resource's name or type.
;                  For example, the string "#258" represents the integer identifier 258.
;
;                  To reduce the amount of memory required for a resource, an application should refer to it by integer identifier
;                  instead of by name.
;
;                  An application can use _WinAPI_FindResource() to find any type of resource, but this function should be used
;                  only if the application must access the binary resource data when making subsequent calls to _WinAPI_LockResource().
; Related........:
; Link...........: @@MsdnLink@@ FindResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindResource($hInstance, $sType, $sName)

	Local $TypeOfType = 'int', $TypeOfName = 'int'

	If IsString($sType) Then
		$TypeOfType = 'wstr'
	EndIf
	If IsString($sName) Then
		$TypeOfName = 'wstr'
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'FindResourceW', 'ptr', $hInstance, $TypeOfName, $sName, $TypeOfType, $sType)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_FindResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindResourceEx
; Description....: Determines the location of the resource with the specified type, name, and language in the specified module.
; Syntax.........: _WinAPI_FindResourceEx ( $hInstance, $sType, $sName, $iLanguage )
; Parameters.....: $hInstance - Handle to the module whose executable file contains the resource. A value of 0 specifies the module
;                               handle associated with the image file that the operating system used to create the current process.
;                  $sType     - The type of the resource. This parameter can be string or integer type.
;                  $sName     - The name of the resource. This parameter can be string or integer type.
;                  $iLanguage - The language of the resource (LCID).
; Return values..: Success    - Handle to the specified resource's information block. To obtain a handle to the resource, pass this
;                               handle to the _WinAPI_LoadResource() function.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the first character of the string of the $sName or $sType parameter is a pound sign (#), the remaining
;                  characters represent a decimal number that specifies the integer identifier of the resource's name or type.
;                  For example, the string "#258" represents the integer identifier 258.
;
;                  To reduce the amount of memory required for a resource, an application should refer to it by integer identifier
;                  instead of by name.
;
;                  An application can use _WinAPI_FindResource() to find any type of resource, but this function should be used
;                  only if the application must access the binary resource data when making subsequent calls to _WinAPI_LockResource().
; Related........:
; Link...........: @@MsdnLink@@ FindResourceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindResourceEx($hInstance, $sType, $sName, $iLanguage)

	Local $TypeOfType = 'int', $TypeOfName = 'int'

	If IsString($sType) Then
		$TypeOfType = 'wstr'
	EndIf
	If IsString($sName) Then
		$TypeOfName = 'wstr'
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'FindResourceExW', 'ptr', $hInstance, $TypeOfType, $sType, $TypeOfName, $sName, 'ushort', $iLanguage)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_FindResourceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindTextDlg
; Description....: Creates a system-defined modeless Find dialog box to search for text in a document.
; Syntax.........: _WinAPI_FindTextDlg ( $hOwner [, $sFindWhat [, $iFlags [, $pFindProc [, $lParam]]]] )
; Parameters.....: $hOwner    - A handle to the window that owns the dialog box. The window procedure of the specified window
;                               receives FINDMSGSTRING messages from the dialog box. This parameter can be any valid window handle,
;                               but it must not be 0.
;                  $sFindWhat - The search string that is displayed when you initialize the dialog box.
;                  $iFlags    - A set of bit flags that used to initialize the dialog box. The dialog box sets these flags when it
;                               sends the FINDMSGSTRING registered message to indicate the user's input. This parameter can be one
;                               or more of the following values.
;
;                               $FR_DIALOGTERM
;                               $FR_DOWN
;                               $FR_ENABLEHOOK
;                               $FR_ENABLETEMPLATE
;                               $FR_ENABLETEMPLATEHANDLE
;                               $FR_FINDNEXT
;                               $FR_HIDEUPDOWN
;                               $FR_HIDEMATCHCASE
;                               $FR_HIDEWHOLEWORD
;                               $FR_MATCHCASE
;                               $FR_NOMATCHCASE
;                               $FR_NOUPDOWN
;                               $FR_NOWHOLEWORD
;                               $FR_REPLACE
;                               $FR_REPLACEALL
;                               $FR_SHOWHELP
;                               $FR_WHOLEWORD
;
;                  $pFindProc - Pointer to an hook procedure that can process messages intended for the dialog box. This parameter is
;                               ignored unless the $FR_ENABLEHOOK flag is not set.
;
;                               (See MSDN for more information)
;
;                  $lParam    - Application-defined data that the system passes to the hook procedure.
; Return values..: Success    - The window handle to the dialog box.
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the dialog box error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_FindText() does not perform a search operation. Instead, the dialog box sends FINDMSGSTRING registered
;                  messages to the window procedure of the owner window of the dialog box.
;
;                  Before calling _WinAPI_FindText(), you must call the _WinAPI_RegisterWindowMessage() function to get the identifier
;                  for the FINDMSGSTRING message. The dialog box procedure uses this identifier to send messages when the user clicks the
;                  "Find Next" button, or when the dialog box is closing. The "lParam" parameter of the FINDMSGSTRING message contains
;                  a pointer to a $tagFINDREPLACE structure. The "Flags" member of this structure indicates the event that caused the
;                  message. Other members of the structure indicate the user's input.
;
;                  The _WinAPI_FindText() uses an internal buffer to hold the string that the user typed in the "Find What" edit
;                  controls. You can increase the size of this buffer by using the _WinAPI_SetFRBuffer() function. In addition to free
;                  the memory allocated for the internal buffer, you must call the _WinAPI_FlushFRBuffer() in response to the
;                  FINDMSGSTRING message with $FR_DIALOGTERM flag set.
; Related........:
; Link...........: @@MsdnLink@@ FindText
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindTextDlg($hOwner, $sFindWhat = '', $iFlags = 0, $pFindProc = 0, $lParam = 0)

	If StringLen($sFindWhat) + 1 > $__Buff Then
		Return SetError(1, 0x4001, 0)
	EndIf

	$__Find = DllStructCreate('wchar[' & $__Buff & ']')
	$__FR = DllStructCreate($tagFINDREPLACE)
	DllStructSetData($__Find, 1, $sFindWhat)
	DllStructSetData($__FR, 'Size', DllStructGetSize($__FR))
	DllStructSetData($__FR, 'hOwner', $hOwner)
	DllStructSetData($__FR, 'hInstance', 0)
	DllStructSetData($__FR, 'Flags', $iFlags)
	DllStructSetData($__FR, 'FindWhat', DllStructGetPtr($__Find))
	DllStructSetData($__FR, 'ReplaceWith', 0)
	DllStructSetData($__FR, 'FindWhatLen', 2 * $__Buff)
	DllStructSetData($__FR, 'ReplaceWithLen', 0)
	DllStructSetData($__FR, 'lParam', $lParam)
	DllStructSetData($__FR, 'Hook', $pFindProc)
	DllStructSetData($__FR, 'TemplateName', 0)

	Local $Ret = DllCall('comdlg32.dll', 'hwnd', 'FindTextW', 'ptr', DllStructGetPtr($__FR))

	If (@error) Or (Not $Ret[0]) Then
		$__Find = 0
		$__FR = 0
		If @error Then
			Return SetError(1, 0, 0)
		Else
			Return SetError(1, _WinAPI_CommDlgExtendedErrorEx(), 0)
		EndIf
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_FindTextDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FlattenPath
; Description....: Transforms any curves in the path that is selected into the current DC, turning each curve into a sequence of lines.
; Syntax.........: _WinAPI_FlattenPath ( $hDC )
; Parameters.....: $hDC    - Handle to a device context that contains a valid path.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FlattenPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FlattenPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'FlattenPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FlattenPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FlushFRBuffer
; Description....: Destroys the internal buffer that used the _WinAPI_FindTextDlg() and _WinAPI_ReplaceTextDlg() functions.
; Syntax.........: _WinAPI_FlushFRBuffer ( )
; Parameters.....: None
; Return values..: None
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_FlushFRBuffer() can be called only in response to the FINDMSGSTRING message with $FR_DIALOGTERM flag set.
;                  For more information, see _WinAPI_FindTextDlg() and _WinAPI_ReplaceTextDlg() functions.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FlushFRBuffer()
	$__Find = 0
	$__Replace = 0
	$__FR = 0
EndFunc   ;==>_WinAPI_FlushFRBuffer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FlushViewOfFile
; Description....: Writes to the disk a byte range within a mapped view of a file.
; Syntax.........: _WinAPI_FlushViewOfFile ( $pAddress [, $iBytes] )
; Parameters.....: $pAddress - A pointer to the base address of the byte range to be flushed to the disk representation of the mapped file.
;                  $iBytes   - The number of bytes to be flushed. If $iBytes is 0, the file is flushed from the base address to the
;                              end of the mapping.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FlushViewOfFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FlushViewOfFile($pAddress, $iBytes = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'FlushViewOfFile', 'ptr', $pAddress, 'dword', $iBytes)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FlushViewOfFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FormatDriveDlg
; Description....: Opens the Shell's Format dialog.
; Syntax.........: _WinAPI_FormatDriveDlg ( $sDrive [, $iOption [, $hParent]] )
; Parameters.....: $sDrive  - The drive to format, in the format D:, E:, etc.
;                  $iOption - This parameter must be 0 or one of the following values that alter the default format options in the dialog.
;
;                             $SHFMT_OPT_FULL
;                             $SHFMT_OPT_QUICKFORMAT
;                             $SHFMT_OPT_SYSONLY
;
;                  $hParent - Handle of the parent window of the dialog.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to one of the following constant.
;
;                             $SHFMT_ERROR
;                             $SHFMT_CANCEL
;                             $SHFMT_NOFORMAT
;
; Author.........: Yashied
; Modified.......:
; Remarks........: The format is controlled by the dialog interface. That is, the user must click the OK button to actually begin the
;                  formatthe format cannot be started programmatically.
; Related........:
; Link...........: @@MsdnLink@@ SHFormatDrive
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FormatDriveDlg($sDrive, $iOption = 0, $hParent = 0)

	If Not IsString($sDrive) Then
		Return SetError(-1, 0, 0)
	EndIf
	$sDrive = StringLeft(StringUpper(StringStripWS($sDrive, 1)), 1)
	If Not $sDrive Then
		Return SetError(-1, 0, 0)
	EndIf
	$sDrive = Asc($sDrive) - 65
	If ($sDrive < 0) Or ($sDrive > 25) Then
		Return SetError(-1, 0, 0)
	EndIf

	Local $Ret = DllCall('shell32.dll', 'int', 'SHFormatDrive', 'hwnd', $hParent, 'uint', $sDrive, 'uint', $SHFMT_ID_DEFAULT, 'uint', $iOption)

	If @error Then
		Return SetError(-1, 0, 0)
	Else
		If $Ret[0] < 0 Then
			Return SetError($Ret[0], 0, 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FormatDriveDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FrameRgn
; Description....: Draws a border around the specified region by using the specified brush.
; Syntax.........: _WinAPI_FrameRgn ( $hDC, $hRgn, $hBrush, $iWidth, $iHeight )
; Parameters.....: $hDC     - Handle to the device context.
;                  $hRgn    - Handle to the region to be enclosed in a border. The region's coordinates are presumed to be in
;                             logical units.
;                  $hBrush  - Handle to the brush to be used to draw the border.
;                  $iWidth  - The width, in logical units, of vertical brush strokes.
;                  $iHeight - The height, in logical units, of horizontal brush strokes.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FrameRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FrameRgn($hDC, $hRgn, $hBrush, $iWidth, $iHeight)

	Local $Ret = DllCall('gdi32.dll', 'int', 'FrameRgn', 'hwnd', $hDC, 'ptr', $hRgn, 'ptr', $hBrush, 'int', $iWidth, 'int', $iHeight)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FrameRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FreeCursor
; Description....: Destroys a cursor and frees any memory the cursor occupied.
; Syntax.........: _WinAPI_FreeCursor ( $hCursor )
; Parameters.....: $hCursor - Handle to the cursor to be destroyed. The cursor must not be in use.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared cursor
;                  is valid as long as the module from which it was loaded remains in memory.
; Related........:
; Link...........: @@MsdnLink@@ DestroyCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FreeCursor($hCursor)

	Local $Ret = DllCall('user32.dll', 'int', 'DestroyCursor', 'ptr', $hCursor)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FreeCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FreeHandle
; Description....: Closes an open object handle.
; Syntax.........: _WinAPI_FreeHandle ( $hObject )
; Parameters.....: $hObject - Handle to an open object.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_FreeHandle() function closes handles to the following objects:
;
;                  Access token
;                  Communications device
;                  Console input
;                  Console screen buffer
;                  Event
;                  File
;                  File mapping
;                  I/O completion port
;                  Job
;                  Mailslot
;                  Memory resource notification
;                  Mutex
;                  Named pipe
;                  Pipe
;                  Process
;                  Semaphore
;                  Thread
;                  Transaction
;                  Waitable timer
;
; Related........:
; Link...........: @@MsdnLink@@ CloseHandle
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FreeHandle($hObject)

	Local $Ret = DllCall('kernel32.dll', 'int', 'CloseHandle', 'ptr', $hObject)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FreeHandle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FreeIcon
; Description....: Destroys an icon and frees any memory the icon occupied.
; Syntax.........: _WinAPI_FreeIcon ( $hIcon )
; Parameters.....: $hIcon  - Handle to the icon to be destroyed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it
;                  was loaded remains in memory.
; Related........:
; Link...........: @@MsdnLink@@ DestroyIcon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FreeIcon($hIcon)

	Local $Ret = DllCall('user32.dll', 'int', 'DestroyIcon', 'ptr', $hIcon)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FreeIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FreeMRUList
; Description....: Frees the handle associated with the most recently used (MRU) list and writes cached data to the registry.
; Syntax.........: _WinAPI_FreeMRUList ( $hMRU )
; Parameters.....: $hMRU   - Handle of the MRU list to free.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FreeMRUList
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FreeMRUList($hMRU)

	Local $Ret = DllCall('comctl32.dll ', 'int', 'FreeMRUList', 'ptr', $hMRU)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FreeMRUList

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FreeObject
; Description....: Deletes a logical pen, brush, font, bitmap, region, or palette.
; Syntax.........: _WinAPI_FreeObject ( $hObject )
; Parameters.....: $hObject - Handle to a logical pen, brush, font, bitmap, region, or palette.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Do not delete a drawing object (pen or brush) while it is still selected into a DC. When a pattern brush is deleted,
;                  the bitmap associated with the brush is not deleted. The bitmap must be deleted independently.
; Related........:
; Link...........: @@MsdnLink@@ DeleteObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FreeObject($hObject)

	Local $Ret = DllCall('gdi32.dll', 'int', 'DeleteObject', 'int', $hObject)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FreeObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FreeResource
; Description....: Decrements (decreases by one) the reference count of a loaded resource.
; Syntax.........: _WinAPI_FreeResource ( $hData )
; Parameters.....: $hData  - Handle of the resource was created by _WinAPI_LoadResource().
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The reference count for a resource is incremented (increased by one) each time an application calls the
;                  _WinAPI_LoadResource() function for the resource. This function is obsolete and is only supported for backward
;                  compatibility with 16-bit Microsoft Windows. For 32-bit Windows applications, it is not necessary to free the
;                  resources loaded using function _WinAPI_LoadResource().
; Related........:
; Link...........: @@MsdnLink@@ FreeResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FreeResource($hData)

	Local $Ret = DllCall('kernel32.dll', 'int', 'FreeResource', 'ptr', $hData)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FreeResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GdiComment
; Description....: Copies a comment from a buffer into a specified enhanced-format metafile.
; Syntax.........: _WinAPI_GdiComment ( $hDC, $pBuffer, $iSize )
; Parameters.....: $hDC     - Handle to an enhanced-metafile device context.
;                  $pBuffer - A pointer to the buffer that contains the comment.
;                  $iSize   - The length of the comment buffer, in bytes.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GdiComment
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GdiComment($hDC, $pBuffer, $iSize)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GdiComment', 'hwnd', $hDC, 'uint', $iSize, 'ptr', $pBuffer)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_GdiComment

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetActiveWindow
; Description....: Retrieves the window handle to the active window attached to the calling process's message queue.
; Syntax.........: _WinAPI_GetActiveWindow ( )
; Parameters.....: None
; Return values..: Success - Handle to the active window attached to the calling process's message queue.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetActiveWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetActiveWindow()

	Local $Ret = DllCall('user32.dll', 'hwnd', 'GetActiveWindow')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetActiveWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetAllUsersProfileDirectory
; Description....: Retrieves the path to the root of the directory that contains program data shared by all users.
; Syntax.........: _WinAPI_GetAllUsersProfileDirectory ( )
; Parameters.....: None
; Return values..: Success - The path to the directory.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetAllUsersProfileDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetAllUsersProfileDirectory()

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('userenv.dll', 'int', 'GetAllUsersProfileDirectoryW', 'ptr', DllStructGetPtr($tData), 'dword*', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetAllUsersProfileDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetApplicationRestartSettings
; Description....: Retrieves the restart information registered for the specified process.
; Syntax.........: _WinAPI_GetApplicationRestartSettings ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array that contains the following information.
;
;                            [0] - The restart command line.
;                            [1] - The flags.
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This information is available only for the current process; you cannot call _WinAPI_GetApplicationRestartSettings()
;                  function after your program is restarted to get the restart command line.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetApplicationRestartSettings
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetApplicationRestartSettings($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $Access

	If $__WINVER < 0x0600 Then
		$Access = 0x00000410
	Else
		$Access = 0x00001010
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', $Access, 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tCmd = DllStructCreate('wchar[2048]')
	Local $Ret = DllCall('kernel32.dll', 'uint', 'GetApplicationRestartSettings', 'ptr', $hProcess[0], 'ptr', DllStructGetPtr($tCmd), 'dword*', 2048, 'dword*', 0)

	If @error Then
		$Ret = 0
	Else
		If $Ret[0] Then
			$Ret = $Ret[0]
		EndIf
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, $Ret, 0)
	EndIf

	Local $Result[2]

	$Result[0] = DllStructGetData($tCmd, 1)
	$Result[1] = $Ret[4]

	Return $Result
EndFunc   ;==>_WinAPI_GetApplicationRestartSettings

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetArcDirection
; Description....: Retrieves the current arc direction for the specified device context.
; Syntax.........: _WinAPI_GetArcDirection ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The current arc direction ($AD_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetArcDirection
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetArcDirection($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetArcDirection', 'hwnd', $hDC)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		Switch $Ret[0]
			Case $AD_COUNTERCLOCKWISE, $AD_CLOCKWISE

			Case Else
				Return SetError(1, 0, 0)
		EndSwitch
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetArcDirection

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBinaryType
; Description....: Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.
; Syntax.........: _WinAPI_GetBinaryType ( $sPath )
; Parameters.....: $sPath  - The full path of the file whose executable type is to be determined.
; Return values..: Success - 1 - The file is executable, @extended flag will be contain one of the $SCS_* constant to
;                                indicate the file's executable type.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetBinaryType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBinaryType($sPath)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetBinaryTypeW', 'wstr', $sPath, 'dword*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	If Not $Ret[0] Then
		$Ret[2] = 0
	EndIf
	Return SetError(0, $Ret[2], $Ret[0])
EndFunc   ;==>_WinAPI_GetBinaryType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBitmapBits
; Description....: Copies the bitmap bits of a specified device-dependent bitmap into a buffer.
; Syntax.........: _WinAPI_GetBitmapBits ( $hBitmap, $iSize, $pBits )
; Parameters.....: $hBitmap - Handle to the device-dependent bitmap.
;                  $iSize   - The number of bytes to copy from the bitmap into the buffer.
;                  $pBits   - A pointer to a buffer to receive the bitmap bits.
; Return values..: Success  - The number of bytes copied to the buffer.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetBitmapBits
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBitmapBits($hBitmap, $iSize, $pBits)

	Local $Ret = DllCall('gdi32.dll', 'dword', 'GetBitmapBits', 'ptr', $hBitmap, 'dword', $iSize, 'ptr', $pBits)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetBitmapBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBitmapDimension
; Description....: Retrieves a dimension for the specified bitmap.
; Syntax.........: _WinAPI_GetBitmapDimension ( $hBitmap )
; Parameters.....: $hBitmap - Handle to the bitmap to retrieve dimension.
; Return values..: Success  - $tagSIZE structure that contains the bitmap dimension.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBitmapDimension($hBitmap)

	Local $tObj = DllStructCreate($tagBITMAP)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetObject', 'int', $hBitmap, 'int', DllStructGetSize($tObj), 'ptr', DllStructGetPtr($tObj))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSIZE = DllStructCreate($tagSIZE)

	DllStructSetData($tSIZE, 1, DllStructGetData($tObj, 'bmWidth'))
	DllStructSetData($tSIZE, 2, DllStructGetData($tObj, 'bmHeight'))

	Return $tSIZE
EndFunc   ;==>_WinAPI_GetBitmapDimension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBitmapDimensionEx
; Description....: Retrieves the dimensions of a compatible bitmap.
; Syntax.........: _WinAPI_GetBitmapDimensionEx ( $hBitmap )
; Parameters.....: $hBitmap - Handle to a compatible bitmap (DDB).
; Return values..: Success  - $tagSIZE structure that contains fields for the height and width of the bitmap, in .01-mm units.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the dimensions have not yet been set, the structure that is returned will have zeros in those fields.
; Related........:
; Link...........: @@MsdnLink@@ GetBitmapDimensionEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBitmapDimensionEx($hBitmap)

	Local $tSIZE = DllStructCreate($tagSIZE)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetBitmapDimensionEx', 'ptr', $hBitmap, 'ptr', DllStructGetPtr($tSIZE))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tSIZE
EndFunc   ;==>_WinAPI_GetBitmapDimensionEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBkColor
; Description....: Retrieves the current background color for the specified device context.
; Syntax.........: _WinAPI_GetBkColor ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The value of the current background color, in RGB.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetBkColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBkColor($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetBkColor', 'hwnd', $hDC)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_GetBkColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBoundsRect
; Description....: Obtains the current accumulated bounding rectangle for a specified device context.
; Syntax.........: _WinAPI_GetBoundsRect ( $hDC [, $iFlags] )
; Parameters.....: $hDC    - Handle to the device context whose bounding rectangle the function will return.
;                  $iFlags - The flags that specifies how the function will behave. This parameter can be the following value.
;
;                            $DCB_RESET
;
; Return values..: Success - $tagRECT structure that contains the current bounding rectangle, @extended flag will contain the
;                            value specifies the state of the accumulated bounding rectangle ($DCB_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetBoundsRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBoundsRect($hDC, $iFlags = 0)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('gdi32.dll', 'uint', 'GetBoundsRect', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT), 'uint', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $Ret[0], $tRECT)
EndFunc   ;==>_WinAPI_GetBoundsRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBufferedPaintBits
; Description....: Retrieves a pointer to the buffer bitmap if the buffer is a device-independent bitmap (DIB).
; Syntax.........: _WinAPI_GetBufferedPaintBits ( $hBP )
; Parameters.....: $hBP    - Handle of the buffered paint context.
; Return values..: Success - A pointer to the address of the buffer bitmap pixels, @extended flag will contain the width, in pixels, of the buffer bitmap.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetBufferedPaintBits
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBufferedPaintBits($hBP)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetBufferedPaintBits', 'ptr', $hBP, 'ptr*', 0, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			ConsoleWrite(Hex($Ret[0]) & @CR)
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return SetError(0, $Ret[3], $Ret[2])
EndFunc   ;==>_WinAPI_GetBufferedPaintBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBufferedPaintDC
; Description....: Gets the paint device context (DC).
; Syntax.........: _WinAPI_GetBufferedPaintDC ( $hBP )
; Parameters.....: $hBP    - Handle of the buffered paint context.
; Return values..: Success - Handle of the requested DC. This is the same DC that is returned by _WinAPI_BeginBufferedPaint().
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetBufferedPaintDC
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBufferedPaintDC($hBP)

	Local $Ret = DllCall('uxtheme.dll', 'hwnd', 'GetBufferedPaintDC', 'ptr', $hBP)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetBufferedPaintDC

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBufferedPaintTargetDC
; Description....: Retrieves the target device context (DC).
; Syntax.........: _WinAPI_GetBufferedPaintTargetDC ( $hBP )
; Parameters.....: $hBP    - Handle of the buffered paint context.
; Return values..: Success - Handle of the requested DC. This is the same DC that was passed to _WinAPI_BeginBufferedPaint().
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetBufferedPaintTargetDC
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBufferedPaintTargetDC($hBP)

	Local $Ret = DllCall('uxtheme.dll', 'hwnd', 'GetBufferedPaintTargetDC', 'ptr', $hBP)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetBufferedPaintTargetDC

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBufferedPaintTargetRect
; Description....: Retrieves the target rectangle.
; Syntax.........: _WinAPI_GetBufferedPaintTargetRect ( $hBP )
; Parameters.....: $hBP    - Handle of the buffered paint context.
; Return values..: Success - $tagRECT structure that contains the rectangle specified by _WinAPI_BeginBufferedPaint() function.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetBufferedPaintTargetRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBufferedPaintTargetRect($hBP)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetBufferedPaintTargetRect', 'ptr', $hBP, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_GetBufferedPaintTargetRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBValue
; Description....: Retrieves an intensity value for the blue component of a 32-bit RGB value.
; Syntax.........: _WinAPI_GetBValue ( $iRGB )
; Parameters.....: $iRGB - The color value, in RGB.
; Return values..: The intensity of the blue component of the specified RGB color.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBValue($iRGB)
	Return BitShift(BitAND(__RGB($iRGB), 0xFF0000), 16)
EndFunc   ;==>_WinAPI_GetBValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCaretBlinkTime
; Description....: Returns the time required to invert the caret's pixels.
; Syntax.........: _WinAPI_GetCaretBlinkTime ( )
; Parameters.....: None
; Return values..: Success - The blink time, in milliseconds.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCaretBlinkTime
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCaretBlinkTime()

	Local $Ret = DllCall('user32.dll', 'uint', 'GetCaretBlinkTime')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetCaretBlinkTime

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCaretPos
; Description....: Retrieves the caret's position.
; Syntax.........: _WinAPI_GetCaretPos ( )
; Parameters.....: None
; Return values..: Success - The array that contains the client coordinates of the caret.
;
;                            [0] - x-coordinate of the caret.
;                            [1] - y-coordinate of the caret.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCaretPos
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCaretPos()

	Local $tPOINT = DllStructCreate($tagPOINT)
	Local $Ret = DllCall('user32.dll', 'int', 'GetCaretPos', 'ptr', DllStructGetPtr($tagPOINT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[2]

	For $i = 0 To 1
		$Result[$i] = DllStructGetData($tPOINT, $i + 1)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetCaretPos

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCDType
; Description....: Retrieves a type of the media which is loaded into a specified CD-ROM device.
; Syntax.........: _WinAPI_GetCDType ( $sDrive )
; Parameters.....: $sDrive - The drive letter of the CD tray to retrieve information, in the format D:, E:, etc.
; Return values..: Success - The type of the media, it must be one of the following values.
;
;                            0x0000 - No media
;                            0x0008 - CD-ROM
;                            0x0009 - CD-R
;                            0x000A - CD-RW
;                            0x0010 - DVD-ROM
;                            0x0011 - DVD-R Sequential Recording
;                            0x0012 - DVD-RAM
;                            0x0013 - DVD-RW Restricted Overwrite
;                            0x0014 - DVD-RW Sequential Recording
;                            0x0015 - DVD-R Dual Layer
;                            0x0016 - DVD-R Dual Layer Jump Recording
;                            0x0017 - DVD-RW Dual Layer
;                            0x0018 - DVD-Download Disc Recording
;                            0x001A - DVD+RW
;                            0x001B - DVD+R
;                            0x0040 - BD-ROM
;                            0x0041 - BD-R Sequential Recording Mode (SRM)
;                            0x0042 - BD-R Random Recording Mode (RRM)
;                            0x0043 - BD-RE
;                            0x0050 - HD DVD-ROM
;                            0x0051 - HD DVD-R
;                            0x0052 - HD DVD-RAM
;                            0x0053 - HD DVD-RW
;                            0x0058 - HD DVD-R Dual Layer
;                            0x005A - HD DVD-RW Dual Layer
;                            0xFFFF - Unknown
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_SCSI_PASS_THROUGH
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCDType($sDrive)

	If @AutoItX64 Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0xC0000000, 0x03)

	If Not $hFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSPT = DllStructCreate('ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;byte Alignment[3];ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16];byte Hdr[8]')
	Local $tCDB = DllStructCreate('byte;byte;byte[2];byte[3];byte[2];byte;byte[2];byte[4]', DllStructGetPtr($tSPT, 'Cdb'))
	Local $tHDR = DllStructCreate('byte[4];byte;byte;byte[2]', DllStructGetPtr($tSPT, 'Hdr'))
	Local $Size = DllStructGetSize($tSPT) - 8

	DllStructSetData($tSPT, 'Length', $Size)
	DllStructSetData($tSPT, 'ScsiStatus', 0)
	DllStructSetData($tSPT, 'PathId', 0)
	DllStructSetData($tSPT, 'TargetId', 0)
	DllStructSetData($tSPT, 'Lun', 0)
	DllStructSetData($tSPT, 'CdbLength', 12)
	DllStructSetData($tSPT, 'SenseInfoLength', 0)
	DllStructSetData($tSPT, 'DataIn', 1)
	DllStructSetData($tSPT, 'DataTransferLength', 8)
	DllStructSetData($tSPT, 'TimeOutValue', 86400)
	DllStructSetData($tSPT, 'DataBufferOffset', $Size)
	DllStructSetData($tSPT, 'SenseInfoOffset', 0)

	DllStructSetData($tCDB, 1, 0x46)
	DllStructSetData($tCDB, 2, 0)
	DllStructSetData($tCDB, 3, 0, 1)
	DllStructSetData($tCDB, 3, 0, 2)
	DllStructSetData($tCDB, 5, 0, 1)
	DllStructSetData($tCDB, 5, 8, 2)
	DllStructSetData($tCDB, 6, 0)
	DllStructSetData($tCDB, 7, 0, 1)
	DllStructSetData($tCDB, 7, 0, 2)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', $IOCTL_SCSI_PASS_THROUGH, 'ptr', DllStructGetPtr($tSPT), 'dword', $Size, 'ptr', DllStructGetPtr($tSPT), 'dword', DllStructGetSize($tSPT), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return BitOR(BitShift(DllStructGetData($tHDR, 4, 1), -8), DllStructGetData($tHDR, 4, 2))
EndFunc   ;==>_WinAPI_GetCDType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetClassInfoEx
; Description....: Retrieves information about a window class.
; Syntax.........: _WinAPI_GetClassInfoEx ( $sClass [, $hInstance] )
; Parameters.....: $sClass    - The class name. The name must be that of a preregistered class or a class registered by a previous
;                               call to the _WinAPI_RegisterClass() or _WinAPI_RegisterClassEx() function. Alternatively, this
;                               parameter can be a class atom. The atom must be in the low-order word of $sClass; the high-order
;                               word must be zero.
;                  $hInstance - Handle to the instance of the application that created the class. To retrieve information about
;                               classes defined by the system (such as buttons or list boxes), set this parameter to 0.
; Return values..: Success    - $tagWNDCLASSEX structure that contains the information about the class.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetClassInfoEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetClassInfoEx($sClass, $hInstance = 0)

	Local $TypeOfClass = 'ptr'

	If IsString($sClass) Then
		$TypeOfClass = 'wstr'
	EndIf

	Local $tWNDCLASSEX = DllStructCreate($tagWNDCLASSEX)
	Local $Ret = DllCall('user32.dll', 'int', 'GetClassInfoExW', 'ptr', $hInstance, $TypeOfClass, $sClass, 'ptr', DllStructGetPtr($tWNDCLASSEX))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tWNDCLASSEX
EndFunc   ;==>_WinAPI_GetClassInfoEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetClassLongEx
; Description....: Retrieves the specified value associated with the specified window.
; Syntax.........: _WinAPI_GetClassLongEx ( $hWnd, $iIndex )
; Parameters.....: $hWnd   - Handle to the window.
;                  $iIndex - The value to retrieve. This parameter can be one of the following values.
;
;                            $GCL_CBCLSEXTRA
;                            $GCL_CBWNDEXTRA
;                            $GCL_HBRBACKGROUND
;                            $GCL_HCURSOR
;                            $GCL_HICON
;                            $GCL_HICONSM
;                            $GCL_HMODULE
;                            $GCL_MENUNAME
;                            $GCL_STYLE
;                            $GCL_WNDPROC
;
; Return values..: Success - The requested value.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetClassLong
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetClassLongEx($hWnd, $iIndex)

	Local $Ret

	If StringInStr(@OSArch, '64') Then
		$Ret = DllCall('user32.dll', 'ulong_ptr', 'GetClassLongPtrW', 'hwnd', $hWnd, 'int', $iIndex)
	Else
		$Ret = DllCall('user32.dll', 'ulong', 'GetClassLongW', 'hwnd', $hWnd, 'int', $iIndex)
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetClassLongEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetClipboardSequenceNumber
; Description....: Retrieves the clipboard sequence number for the current window station.
; Syntax.........: _WinAPI_GetClipboardSequenceNumber ( )
; Parameters.....: None
; Return values..: Success - The clipboard sequence number.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetClipboardSequenceNumber
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetClipboardSequenceNumber()

	Local $Ret = DllCall('user32.dll', 'dword', 'GetClipboardSequenceNumber')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetClipboardSequenceNumber

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetClipBox
; Description....: Retrieves the dimensions of the bounding rectangle of the visible area.
; Syntax.........: _WinAPI_GetClipBox ( $hDC, ByRef $tRECT )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tRECT  - $tagRECT structure that receive the rectangle dimensions, in logical units.
; Return values..: Success - The value that specifies the new clipping region's complexity; it can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetClipBox
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetClipBox($hDC, ByRef $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetClipBox', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		$tRECT = 0
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetClipBox

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetClipCursor
; Description....: Retrieves the screen coordinates of the rectangular area to which the cursor is confined.
; Syntax.........: _WinAPI_GetClipCursor ( )
; Parameters.....: None
; Return values..: Success - $tagRECT structure that receives the screen coordinates of the confining rectangle.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetClipCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetClipCursor()

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'GetClipCursor', 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_GetClipCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetClipRgn
; Description....: Retrieves a handle identifying the current application-defined clipping region.
; Syntax.........: _WinAPI_GetClipRgn ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - Handle to a copy of the current clipping region.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application-defined clipping region is a clipping region identified by the _WinAPI_SelectClipRgn() function.
;                  It is not a clipping region created when the application calls the _WinAPI_BeginPaint().
; Related........:
; Link...........: @@MsdnLink@@ GetClipRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetClipRgn($hDC)

	Local $hRgn = _WinAPI_CreateRectRgn(0, 0, 0, 0)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetClipRgn', 'hwnd', $hDC, 'ptr', $hRgn)

	If (@error) Or ($Ret[0] = -1) Then
		$Ret = 0
	Else
		If Not $Ret[0] Then
			$Ret = 1
		EndIf
	EndIf
	If Not IsArray($Ret) Then
		_WinAPI_DeleteObject($hRgn)
		If Not $Ret Then
			Return SetError(1, 0, 0)
		Else
			Return 0
		EndIf
	EndIf
	Return $hRgn
EndFunc   ;==>_WinAPI_GetClipRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCompressedFileSize
; Description....: Retrieves the actual number of bytes of disk storage used to store a specified file.
; Syntax.........: _WinAPI_GetCompressedFileSize ( $sFile )
; Parameters.....: $sFile   - The name of the file.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed
;                  or a sparse file, the value obtained is the actual file size.
; Related........:
; Link...........: @@MsdnLink@@ GetCompressedFileSize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCompressedFileSize($sFile)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetCompressedFileSizeW', 'wstr', $sFile, 'dword*', 0)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, 0)
	EndIf
	Return _WinAPI_MakeQWord($Ret[0], $Ret[2])
EndFunc   ;==>_WinAPI_GetCompressedFileSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCompression
; Description....: Retrieves the current compression state of a file or directory.
; Syntax.........: _WinAPI_GetCompression ( $sPath )
; Parameters.....: $sPath  - Path to file or directory to retrieve compression state.
; Return values..: Success - The current compression state.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FSCTL_GET_COMPRESSION
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCompression($sPath)

	Local $hFile = _WinAPI_CreateFileEx($sPath, 3, 0x80000000, 0x01, 0x02000000)

	If Not $hFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tData = DllStructCreate('ushort')
	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', $FSCTL_GET_COMPRESSION, 'ptr', 0, 'dword', 0, 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetCompression

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetComputerNameEx
; Description....: Retrieves a NetBIOS or DNS name associated with the local computer.The names are established at system startup, when the system reads them from the registry.
; Syntax.........: _WinAPI_GetComputerNameEx ( $iNameType )
; Parameters.....: $iNameType - The type of name to be retrieved.
;
;                             $ComputerNameNetBIOS
;                             $ComputerNameDnsHostname
;                             $ComputerNameDnsDomain
;                             $ComputerNameDnsFullyQualified
;                             $ComputerNamePhysicalNetBIOS
;                             $ComputerNamePhysicalDnsHostname
;                             $ComputerNamePhysicalDnsDomain
;                             $ComputerNamePhysicalDnsFullyQualified
; Return values..: Success  - a NetBIOS or DNS name associated with the local computer.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetComputerNameEx
; Example........: Yes
; ===============================================================================================================================
Func _WinAPI_GetComputerNameEx($iNameType)
	Local $tBufferSize = DllStructCreate("int")
	Local $Ret = DllCall("Kernel32.dll", "INT", "GetComputerNameEx", "INT", $iNameType, "ptr", "", "ptr", DllStructGetPtr($tBufferSize))
	Local $tBuffer = DllStructCreate("CHAR Name[" & DllStructGetData($tBufferSize, 1) & "]")
	$Ret = DllCall("Kernel32.dll", "INT", "GetComputerNameEx", "INT", $iNameType, "ptr", DllStructGetPtr($tBuffer), "ptr", DllStructGetPtr($tBufferSize))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return DllStructGetData($tBuffer, 1)
	$tBufferSize = 0
	$tBuffer = 0
EndFunc   ;==>_WinAPI_GetComputerNameEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetConnectedDlg
; Description....: Launches the Get Connected wizard within the calling application to enable network connectivity.
; Syntax.........: _WinAPI_GetConnectedDlg ( $iDlg [, $iFlags [, $hParent]] )
; Parameters.....: $iDlg    - Specifies which the dialog should be launched, valid values:
;                  |0 - Local area network connectivity.
;                  |1 - Internet connectivity.
;                  |2 - Virtual private network (VPN) connectivity.
;                  $iFlags  - Specifies an additional options. This parameter can be one or more of the following values.
;                  |0 - Default.
;                  |1 - Do not display the Get Connected wizard page that shows whether or not the user has a working or active Internet connection.
;                  |2 - Do not display the Get Connected wizard page that shows a list of existing internet connections.
;                  |4 - Hide the finish page of the Get Connected wizard.
;                  $hParent - Handle to the parent window that called this API.
; Return values..: Success  - 1 - The Internet is connected.
;                             0 - Otherwise.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetConnectedDlg($iDlg, $iFlags = 0, $hParent = 0)

	If Not __DLL('connect.dll') Then
		Return SetError(1, 0, 0)
	EndIf

	Switch $iDlg
		Case 0
			$iDlg = 'GetNetworkConnected'
		Case 1
			$iDlg = 'GetInternetConnected'
		Case 2
			$iDlg = 'GetVPNConnected'
		Case Else
			Return SetError(1, 0, 0)
	EndSwitch

	Local $Str = ''

	If BitAND($iFlags, 1) Then
		$Str &= '-SkipInternetDetection '
	EndIf
	If BitAND($iFlags, 2) Then
		$Str &= '-SkipExistingConnections '
	EndIf
	If BitAND($iFlags, 4) Then
		$Str &= '-HideFinishPage '
	EndIf

	Local $Ret = DllCall('connect.dll', 'uint', $iDlg, 'hwnd', $hParent, 'dword', 0, 'dword', 0, 'dword', 0, 'ptr', 0, 'wstr', StringStripWS($Str, 2))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		Switch $Ret[0]
			Case 0, 1 ; S_OK, S_FALSE

			Case Else
				Return SetError(1, $Ret[0], 0)
		EndSwitch
	EndIf
	Return Number(Not $Ret[0])
EndFunc   ;==>_WinAPI_GetConnectedDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCurrentDirectory
; Description....: Retrieves the current directory for the current process.
; Syntax.........: _WinAPI_GetCurrentDirectory ( )
; Parameters.....: None
; Return values..: Success - The absolute path to the current directory.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCurrentDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCurrentDirectory()

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetCurrentDirectoryW', 'dword', 1024, 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetCurrentDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCurrentHwProfile
; Description....: Retrieves information about the current hardware profile for the local computer.
; Syntax.........: _WinAPI_GetCurrentHwProfile ( )
; Parameters.....: None
; Return values..: Success - $tagHW_PROFILE_INFO structure that contains information about the current hardware profile.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCurrentHwProfile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCurrentHwProfile()

	Local $tHW_PROFILE_INFO = DllStructCreate($tagHW_PROFILE_INFO)
	Local $Ret = DllCall('advapi32.dll', 'int', 'GetCurrentHwProfileW', 'ptr', DllStructGetPtr($tHW_PROFILE_INFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tHW_PROFILE_INFO
EndFunc   ;==>_WinAPI_GetCurrentHwProfile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCurrentObject
; Description....: Retrieves a handle to an object of the specified type that has been selected into the specified device context.
; Syntax.........: _WinAPI_GetCurrentObject ( $hDC, $iType )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iType  - The object type to be queried. This parameter can be one of the following values.
;
;                            $OBJ_BITMAP
;                            $OBJ_BRUSH
;                            $OBJ_COLORSPACE
;                            $OBJ_FONT
;                            $OBJ_PAL
;                            $OBJ_PEN
;
; Return values..: Success - Handle to the specified object.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCurrentObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCurrentObject($hDC, $iType)

	Local $Ret  = DllCall('gdi32.dll', 'ptr', 'GetCurrentObject', 'hwnd', $hDC, 'uint', $iType)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetCurrentObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCurrentPosition
; Description....: Retrieves the current position for the specified device context.
; Syntax.........: _WinAPI_GetCurrentPosition ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - $tagPOINT structure that contains the logical coordinates of the current position.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCurrentPositionEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCurrentPosition($hDC)

	Local $tPOINT = DllStructCreate($tagPOINT)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetCurrentPositionEx', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPOINT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tPOINT
EndFunc   ;==>_WinAPI_GetCurrentPosition

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCurrentProcessExplicitAppUserModelID
; Description....: Retrieves the application-defined, explicit Application User Model ID for the current process.
; Syntax.........: _WinAPI_GetCurrentProcessExplicitAppUserModelID ( )
; Parameters.....: None
; Return values..: Success - The string that represents an Application User Model ID (AppUserModelID).
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application can only retrieve an AppUserModelID that has been explicitly set by using the _WinAPI_SetCurrentProcessExplicitAppUserModelID()
;                  function. System-assigned default AppUserModelIDs cannot be retrieved.
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ GetCurrentProcessExplicitAppUserModelID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCurrentProcessExplicitAppUserModelID()

	Local $Ret = DllCall('shell32.dll', 'uint', 'GetCurrentProcessExplicitAppUserModelID', 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf

	Local $ID = DllStructGetData(DllStructCreate('wchar[128]', $Ret[1]), 1)

	_WinAPI_CoTaskMemFree($Ret[1])
	Return $ID
EndFunc   ;==>_WinAPI_GetCurrentProcessExplicitAppUserModelID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCurrentThemeName
; Description....: Retrieves the name of the current visual styles, color scheme name, and size name.
; Syntax.........: _WinAPI_GetCurrentThemeName ( )
; Parameters.....: None
; Return values..: Success - The array that contains the following information.
;
;                  [0] - The theme path and file name.
;                  [1] - The color scheme name.
;                  [2] - The size name.
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCurrentThemeName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCurrentThemeName()

	Local $tData = DllStructCreate('wchar[1024];wchar[1024];wchar[1024]')
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetCurrentThemeName', 'ptr', DllStructGetPtr($tData, 1), 'int', 1024, 'ptr', DllStructGetPtr($tData, 2), 'int', 1024, 'ptr', DllStructGetPtr($tData, 3), 'int', 1024)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[3]

	For $i = 0 To 2
		$Result[$i] = DllStructGetData($tData, $i + 1)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetCurrentThemeName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCursor
; Description....: Retrieves a handle to the current cursor.
; Syntax.........: _WinAPI_GetCursor ( )
; Parameters.....: None
; Return values..: Success - Handle to the current cursor. If there is no cursor, the return value is 0.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCursor()

	Local $Ret = DllCall('user32.dll', 'ptr', 'GetCursor')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDateFormat
; Description....: Formats a date as a date string for a locale specified by the locale identifier.
; Syntax.........: _WinAPI_GetDateFormat ( [$LCID [, $tSYSTEMTIME [, $iFlag [, $sFormat]]]] )
; Parameters.....: $LCID        - Locale identifier (LCID) that specifies the locale. If this parameter is 0, the function will
;                                 use default locale for the user.
;                  $tSYSTEMTIME - $tagSYSTEMTIME structure that contains the date information to format. If this parameter is 0,
;                                 the function will use the current local system date.
;                  $iFlag       - Flags specifying date format options. This parameter can be one or more of the following values.
;
;                                 $DATE_LONGDATE
;                                 $DATE_SHORTDATE (Default)
;                                 $DATE_USE_ALT_CALENDAR
;
;                                 *Windows Vista or later
;
;                                 $DATE_LTRREADING
;                                 $DATE_RTLREADING
;                                 $DATE_YEARMONTH
;
;                                 *Windows 7 or later
;
;                                 $DATE_AUTOLAYOUT
;
;                  $sFormat     - The string that is used to form the date. For example, "dddd dd, yyyy". If this parameter is 0,
;                                 the function returns the string according to the date format for the specified locale ($LCID).
; Return values..: Success      - The formatted date string.
;                  Failure      - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDateFormat
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDateFormat($LCID = 0, $tSYSTEMTIME = 0, $iFlags = 0, $sFormat = '')

	Local $TypeOfFormat = 'wstr'

	If Not $LCID Then
		$LCID = 0x0400
	EndIf
	If Not StringStripWS($sFormat, 3) Then
		$TypeOfFormat = 'ptr'
		$sFormat = 0
	EndIf

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetDateFormatW', 'long', $LCID, 'dword', $iFlags, 'ptr', DllStructGetPtr($tSYSTEMTIME), $TypeOfFormat, $sFormat, 'ptr', DllStructGetPtr($tData), 'int', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetDateFormat

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDCEx
; Description....: Retrieves a handle to a device context (DC) for the client area of a specified window.
; Syntax.........: _WinAPI_GetDCEx ( $hWnd, $hRgn, $iFlags )
; Parameters.....: $hWnd   - Handle to the window whose DC is to be retrieved. If this value is 0, _WinAPI_GetDCEx() retrieves the
;                            DC for the entire screen. If the value of $iFlags parameter is $DCX_INTERSECTRGN or DCX_EXCLUDERGN,
;                            then the operating system assumes ownership of the region and will automatically delete it when it is
;                            no longer needed. In this case, the application should not use or delete the region after a successful
;                            call to _WinAPI_GetDCEx().
;                  $hRgn   - A clipping region that may be combined with the visible region of the DC.
;                  $iFlags - Flags that specifies how the DC is created. This parameter can be one or more of the following values.
;
;                            $DCX_WINDOW
;                            $DCX_CACHE
;                            $DCX_PARENTCLIP
;                            $DCX_CLIPSIBLINGS
;                            $DCX_CLIPCHILDREN
;                            $DCX_NORESETATTRS
;                            $DCX_LOCKWINDOWUPDATE
;                            $DCX_EXCLUDERGN
;                            $DCX_INTERSECTRGN
;                            $DCX_INTERSECTUPDATE
;                            $DCX_VALIDATE
;
; Return values..: Success - Handle to the DC for the specified window.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Unless the display DC belongs to a window class, the _WinAPI_ReleaseDC() function must be called to release the
;                  DC after painting.
; Related........:
; Link...........: @@MsdnLink@@ GetDCEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDCEx($hWnd, $hRgn, $iFlags)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'GetDCEx', 'hwnd', $hWnd, 'ptr', $hRgn, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetDCEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDefaultPrinter
; Description....: Retrieves the printer name of the default printer for the current user on the local computer.
; Syntax.........: _WinAPI_GetDefaultPrinter ( )
; Parameters.....: None
; Return values..: Success - String containing the default printer name.
;                  Failure - Empty string and sets the @error flag to:
;                            1 - Function fails or not found
;                            2 - No default printer
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDefaultPrinter
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDefaultPrinter()

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('winspool.drv', 'int', 'GetDefaultPrinterW', 'ptr', DllStructGetPtr($tData), 'dword*', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1 + (_WinAPI_GetLastError() = 0x02), 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetDefaultPrinter

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDefaultUserProfileDirectory
; Description....: Retrieves the path to the root of the default user's profile.
; Syntax.........: _WinAPI_GetDefaultUserProfileDirectory ( )
; Parameters.....: None
; Return values..: Success - The path to the directory.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDefaultUserProfileDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDefaultUserProfileDirectory()

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('userenv.dll', 'int', 'GetDefaultUserProfileDirectoryW', 'ptr', DllStructGetPtr($tData), 'dword*', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetDefaultUserProfileDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDeviceDriverBaseName
; Description....: Retrieves the base name of the specified device driver.
; Syntax.........: _WinAPI_GetDeviceDriverBaseName ( $hDriver )
; Parameters.....: $hDriver - The load address of the device driver. This value can be retrieved using the _WinAPI_EnumDeviceDrivers() function.
; Return values..: Success  - The base name of the device driver.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDeviceDriverBaseName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDeviceDriverBaseName($hDriver)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'GetDeviceDriverBaseNameW', 'ptr', $hDriver, 'ptr', DllStructGetPtr($tData), 'dword', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetDeviceDriverBaseName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDeviceDriverFileName
; Description....: Retrieves the path available for the specified device driver.
; Syntax.........: _WinAPI_GetDeviceDriverFileName ( $hDriver )
; Parameters.....: $hDriver - The load address of the device driver. This value can be retrieved using the _WinAPI_EnumDeviceDrivers() function.
; Return values..: Success  - The path to the device driver.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDeviceDriverFileName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDeviceDriverFileName($hDriver)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'GetDeviceDriverFileNameW', 'ptr', $hDriver, 'ptr', DllStructGetPtr($tData), 'dword', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetDeviceDriverFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDeviceGammaRamp
; Description....: Gets the gamma ramp on direct color display boards that support downloadable gamma ramps in hardware.
; Syntax.........: _WinAPI_GetDeviceGammaRamp ( $hDC, ByRef $aRamp )
; Parameters.....: $hDC    - Handle to a device context of the direct color display board in question.
;                  $aRamp  - The 2D array ([r1, g1, b1], [r2, g2, b2], ... [r256, g256, b256]) where the function place the current
;                            gamma ramp of the color display board. Each element in this array is an integer value with a range
;                            from 0 to 65535 which is a mapping between RGB values in the frame buffer and digital-analog-converter
;                            (DAC) values.
;
;                            (See MSDN for more information)
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Direct color display modes do not use color lookup tables and are usually 16, 24, or 32 bit. Not all direct color
;                  video boards support loadable gamma ramps. _WinAPI_GetDeviceGammaRamp() succeeds only for devices with drivers
;                  that support downloadable gamma ramps in hardware.
; Related........:
; Link...........: @@MsdnLink@@ GetDeviceGammaRamp
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDeviceGammaRamp($hDC, ByRef $aRamp)

	$aRamp = 0

	Local $tData = DllStructCreate('ushort[256];ushort[256];ushort[256]')
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetDeviceGammaRamp', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Dim $aRamp[256][3]

	For $i = 0 to 2
		For $j = 0 To 255
			$aRamp[$j][$i] = DllStructGetData($tData, $i + 1, $j + 1)
		Next
	Next
	Return 1
EndFunc   ;==>_WinAPI_GetDeviceGammaRamp

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDIBColorTable
; Description....: Retrieves RGB color table from the DIB section bitmap.
; Syntax.........: _WinAPI_GetDIBColorTable ( $hBitmap )
; Parameters.....: $hBitmap - A DIB section bitmap from which to retrieve the color table.
; Return values..: Success  - "dword[n]" structure that contains a color information from the DIB color table, @extended flag
;                             will contain the number of colors in this structure.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_GetDIBColorTable() function retrieves a color table for DIB section bitmaps that use 1, 4, or
;                  8 bits-per-pixel. A DIB section bitmaps that use bits-per-pixel value greater than eight do not have a color
;                  table, but they do have associated color masks. Call the _WinAPI_GetObject() function to retrieve those
;                  color masks.
; Related........:
; Link...........: @@MsdnLink@@ GetDIBColorTable
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDIBColorTable($hBitmap)

	Local $hDC, $hSv, $tData, $tPeak, $Ret

	$hDC = _WinAPI_CreateCompatibleDC(0)
	$hSv = _WinAPI_SelectObject($hDC, $hBitmap)
	$tPeak = DllStructCreate('dword[256]')
	$Ret = DllCall('gdi32.dll', 'uint', 'GetDIBColorTable', 'hwnd', $hDC, 'uint', 0, 'uint', 256, 'ptr', DllStructGetPtr($tPeak))
	If (@error) Or (Not $Ret[0]) Or (Not $Ret[4]) Then
		$Ret = 0
	EndIf
	_WinAPI_SelectObject($hDC, $hSv)
	_WinAPI_DeleteDC($hDC)
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	$tData = DllStructCreate('dword[' & $Ret[0] & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	If Not _WinAPI_MoveMemory(DllStructGetPtr($tData), $Ret[4], 4 * $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $Ret[0], $tData)
EndFunc   ;==>_WinAPI_GetDIBColorTable

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDiskFreeSpaceEx
; Description....: Retrieves information about the amount of space that is available on a disk volume.
; Syntax.........: _WinAPI_GetDiskFreeSpaceEx ( $sDrive )
; Parameters.....: $sDrive - The drive to retrieve information, in the format D:, E:, etc.
; Return values..: Success - The array containing the following parameters:
;
;                            [0] - The total number of available free bytes on a disk. If per-user quotas are being used, this value
;                                  may be less than the total number of free bytes on a disk.
;                            [1] - The total number of available bytes on a disk. If per-user quotas are being used, this value
;                                  may be less than the total number of bytes on a disk.
;                            [2] - The total number of free bytes on a disk.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDiskFreeSpaceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDiskFreeSpaceEx($sDrive)

	Local $tData = DllStructCreate('int64;int64;int64')
	Local $Mode = _WinAPI_SetErrorMode($SEM_FAILCRITICALERRORS)
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetDiskFreeSpaceEx', 'str', $sDrive, 'ptr', DllStructGetPtr($tData, 1), 'ptr', DllStructGetPtr($tData, 2), 'ptr', DllStructGetPtr($tData, 3))

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_SetErrorMode($Mode)
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[3]

	For $i = 0 To 2
		$Result[$i] = DllStructGetData($tData, $i + 1)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetDiskFreeSpaceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDiskSerialNumber
; Description....: Retrieves information about the amount of space that is available on a disk volume.
; Syntax.........: _WinAPI_GetDiskFreeSpaceEx ( $sDrive )
; Parameters.....: $sDrive - The drive to retrieve information, in the format D:, E:, etc.
; Return values..: Success - The array containing the following parameters:
;                            [0] - The total number of available free bytes on a disk. If per-user quotas are being used, this value
;                                  may be less than the total number of free bytes on a disk.
;                            [1] - The total number of available bytes on a disk. If per-user quotas are being used, this value
;                                  may be less than the total number of bytes on a disk.
;                            [2] - The total number of free bytes on a disk.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDiskFreeSpaceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDiskSerialNumber($sPhysDisk)

	Local $iResult, $hDisk = _WinAPI_CreateFile("\\.\" & $sPhysDisk, 2, 6, 6, 1)
	Local $tSCIP = DllStructCreate($tagSENDCMDINPARAMS)
	Local $tSCOP = DllStructCreate($tagSENDCMDOUTPARAMS & ";char Buffer[1024]")
	Local $tQuery = DllStructCreate($tagSTORAGEPROPERTYQUERY)
	Local $tDescr = DllStructCreate($tagSTORAGEDEVICEDESCRIPTOR)
	DllStructSetData($tQuery, "PropertyId", 0)
	DllStructSetData($tQuery, "QueryType", 0)

	$iResult = _WinAPI_DeviceIoControl($hDisk, $IOCTL_STORAGE_QUERY_PROPERTY_BASE, _
			DllStructGetPtr($tQuery), DllStructGetSize($tQuery), _
			DllStructGetPtr($tDescr), DllStructGetSize($tDescr))

	If DllStructGetData($tDescr, "BusType") = 2 Then
		DllStructSetData($tSCIP, "Command", 0xA1)
	Else
		DllStructSetData($tSCIP, "Command", 0xEC)
	EndIf

	$iResult = _WinAPI_DeviceIoControl($hDisk, $DFP_RECEIVE_DRIVE_DATA, _
			DllStructGetPtr($tSCIP), DllStructGetSize($tSCIP), _
			DllStructGetPtr($tSCOP), DllStructGetSize($tSCOP))

	Local $sSerialNum
	For $i = 21 To 40 Step 2
		$sSerialNum &= DllStructGetData($tSCOP, "Buffer", $i + 1)
		$sSerialNum &= DllStructGetData($tSCOP, "Buffer", $i)
	Next
	$sSerialNum = StringReplace($sSerialNum, " ", "")
	$tSCIP = 0
	$tSCOP = 0
	$tQuery = 0
	$tDescr = 0
	_WinAPI_CloseHandle($hDisk)
	Return $sSerialNum
EndFunc   ;==>_WinAPI_GetDiskSerialNumber

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDllDirectory
; Description....: Retrieves the application-specific portion of the search path used to locate DLLs for the application.
; Syntax.........: _WinAPI_GetDllDirectory ( )
; Parameters.....: None
; Return values..: Success  - The search path.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDllDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDllDirectory()

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetDllDirectoryW', 'dword', 1024, 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetDllDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDriveBusType
; Description....: Retrieves a bus type for the specified drive.
; Syntax.........: _WinAPI_GetDriveBusType ( $sDrive )
; Parameters.....: $sDrive - The drive letter to retrieve information, in the format D:, E:, etc.
; Return values..: Success - The bus type constant ($DRIVE_BUS_TYPE_*).
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function works with the Plug and Play drivers only.
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_STORAGE_QUERY_PROPERTY
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDriveBusType($sDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0, 0)

	If Not $hFile Then
		Return SetError(1, 0, -1)
	EndIf

	Local $tSPQ = DllStructCreate('ulong PropertyId;ulong QueryType;byte AdditionalParameters[4]')
	Local $tSDD = DllStructCreate('ulong Version;ulong Size;byte DeviceType;byte DeviceTypeModifier;byte RemovableMedia;byte CommandQueueing;ulong VendorIdOffset;ulong ProductIdOffset;ulong ProductRevisionOffset;ulong SerialNumberOffset;ulong BusType;ulong RawPropertiesLength;byte RawDeviceProperties[1]')

	DllStructSetData($tSPQ, 'PropertyId', 0)
	DllStructSetData($tSPQ, 'QueryType', 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', $IOCTL_STORAGE_QUERY_PROPERTY, 'ptr', DllStructGetPtr($tSPQ), 'dword', DllStructGetSize($tSPQ), 'ptr', DllStructGetPtr($tSDD), 'dword', DllStructGetSize($tSDD), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, -1)
	EndIf
	Return DllStructGetData($tSDD, 'BusType')
EndFunc   ;==>_WinAPI_GetDriveBusType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDriveGeometryEx
; Description....: Retrieves extended information about the disk's geometry.
; Syntax.........: _WinAPI_GetDriveGeometryEx ( $iDrive )
; Parameters.....: $iDrive - The drive letter to retrieve information, in the format D:, E:, etc.
; Return values..: Success - $tagDISK_GEOMETRY_EX structure that contains the information about the disk's geometry.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_DISK_GET_DRIVE_GEOMETRY_EX
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDriveGeometryEx($iDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\PhysicalDrive' & $iDrive, 3, 0x80000000, 0x01)

	If Not $hFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tDISK_GEOMETRY_EX = DllStructCreate($tagDISK_GEOMETRY_EX)
	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', $IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, 'ptr', 0, 'dword', 0, 'ptr', DllStructGetPtr($tDISK_GEOMETRY_EX), 'dword', DllStructGetSize($tDISK_GEOMETRY_EX), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Local $aResult[5]
	$aResult[0] = DllStructGetData($tDISK_GEOMETRY_EX, 'Cylinders')
	$aResult[1] = DllStructGetData($tDISK_GEOMETRY_EX, 'TracksPerCylinder')
	$aResult[2] = DllStructGetData($tDISK_GEOMETRY_EX, 'SectorsPerTrack')
	$aResult[3] = DllStructGetData($tDISK_GEOMETRY_EX, 'BytesPerSector')
	$aResult[4] = DllStructGetData($tDISK_GEOMETRY_EX, 'DiskSize')

	Return $aResult
EndFunc   ;==>_WinAPI_GetDriveGeometryEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDriveNumber
; Description....: Retrieves a device type, device number, and partition number for the specified drive.
; Syntax.........: _WinAPI_GetDriveNumber ( $sDrive )
; Parameters.....: $sDrive - The drive letter to retrieve information, in the format D:, E:, etc.
; Return values..: Success - $tagSTORAGE_DEVICE_NUMBER structure that contains the relevant information.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_STORAGE_GET_DEVICE_NUMBER
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDriveNumber($sDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0, 0)

	If Not $hFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSTORAGE_DEVICE_NUMBER = DllStructCreate($tagSTORAGE_DEVICE_NUMBER)
	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', $IOCTL_STORAGE_GET_DEVICE_NUMBER, 'ptr', 0, 'dword', 0, 'ptr', DllStructGetPtr($tSTORAGE_DEVICE_NUMBER), 'dword', DllStructGetSize($tSTORAGE_DEVICE_NUMBER), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return $tSTORAGE_DEVICE_NUMBER
EndFunc   ;==>_WinAPI_GetDriveNumber

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDriveType
; Description....: Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive.
; Syntax.........: _WinAPI_GetDriveType ( [$sDrive] )
; Parameters.....: $sDrive - The drive letter to retrieve information, in the format D:, E:, etc.
; Return values..: Success - The type of drive ($DRIVE_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDriveType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDriveType($sDrive = '')

	Local $tDrive, $pDrive = 0

	$sDrive = StringStripWS($sDrive, 3)
	If $sDrive Then
		$tDrive = DllStructCreate('char[' & StringLen($sDrive) + 1 & ']')
		DllStructSetData($tDrive, 1, $sDrive)
		$pDrive = DllStructGetPtr($tDrive)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetDriveType', 'ptr', $pDrive)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetDriveType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetEnhMetaFile
; Description....: Creates a handle that identifies the enhanced-format metafile stored in the specified file.
; Syntax.........: _WinAPI_GetEnhMetaFile ( $sFile )
; Parameters.....: $sFile  - The name of an enhanced metafile (.emf).
; Return values..: Success - Handle to the enhanced metafile.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the
;                  _WinAPI_DeleteEnhMetaFile() function.
; Related........:
; Link...........: @@MsdnLink@@ GetEnhMetaFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetEnhMetaFile($sFile)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'GetEnhMetaFileW', 'wstr', $sFile)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetEnhMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetEnhMetaFileBits
; Description....: Retrieves the contents of the specified enhanced-format metafile and copies them into a buffer.
; Syntax.........: _WinAPI_GetEnhMetaFileBits ( $hEmf )
; Parameters.....: $hEmf   - Handle to the enhanced metafile.
; Return values..: Success - The "byte[n]" structure (buffer) that contains the metafile data.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After the enhanced-metafile bits are retrieved, they can be used to create a memory-based metafile by calling the
;                  _WinAPI_SetEnhMetaFileBits() function.
; Related........:
; Link...........: @@MsdnLink@@ GetEnhMetaFileBits
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetEnhMetaFileBits($hEmf)

	Local $Ret, $tData

	$Ret = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileBits', 'ptr', $hEmf, 'uint', 0, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$tData = DllStructCreate('byte[' & $Ret[0] & ']')
	$Ret = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileBits', 'ptr', $hEmf, 'uint', $Ret[0], 'ptr', DllStructGetPtr($tData))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tData
EndFunc   ;==>_WinAPI_GetEnhMetaFileBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetEnhMetaFileDescription
; Description....: Retrieves an optional text description from an enhanced-format metafile.
; Syntax.........: _WinAPI_GetEnhMetaFileDescription ( $hEmf )
; Parameters.....: $hEmf   - Handle to the enhanced metafile.
; Return values..: Success - If the optional text description does not exist, the return value is 0, otherwise an array that
;                            contains the following information.
;
;                            [0] - Application name
;                            [1] - Picture name
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetEnhMetaFileDescription
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetEnhMetaFileDescription($hEmf)

	Local $tData = DllStructCreate('wchar[1024]'), $pData = DllStructGetPtr($tData)
	Local $Ret = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileDescriptionW', 'ptr', $hEmf, 'uint', 1024, 'ptr', $pData)

	If (@error) Or ($Ret[0] = 0xFFFF) Then
		Return SetError(1, 0, 0)
	Else
		If Not $Ret[0] Then
			Return 0
		EndIf
	EndIf

	Local $aData = _WinAPI_StructToArray($pData)

	If Not IsArray($aData) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[2]

	For $i = 0 To 1
		If $aData[0] > $i Then
			$Result[$i] = $aData[$i + 1]
		Else
			$Result[$i] = ''
		EndIf
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetEnhMetaFileDescription

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetEnhMetaFileDimension
; Description....: Retrieves a dimension for the specified enhanced-format metafile.
; Syntax.........: _WinAPI_GetEnhMetaFileHeader ( $hEmf )
; Parameters.....: $hEmf   - Handle to the enhanced metafile for which a dimension is to be retrieved.
; Return values..: Success - $tagSIZE structure that contains the enhanced metafile dimension.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetEnhMetaFileDimension($hEmf)

	Local $tENHMETAHEADER = _WinAPI_GetEnhMetaFileHeader($hEmf)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSIZE = DllStructCreate($tagSIZE)

	DllStructSetData($tSIZE, 1, Round((DllStructGetData($tENHMETAHEADER, 'rcFrame', 3) - DllStructGetData($tENHMETAHEADER, 'rcFrame', 1)) * DllStructGetData($tENHMETAHEADER, 'Device', 1) / DllStructGetData($tENHMETAHEADER, 'Millimeters', 1) / 100))
	DllStructSetData($tSIZE, 2, Round((DllStructGetData($tENHMETAHEADER, 'rcFrame', 4) - DllStructGetData($tENHMETAHEADER, 'rcFrame', 2)) * DllStructGetData($tENHMETAHEADER, 'Device', 2) / DllStructGetData($tENHMETAHEADER, 'Millimeters', 2) / 100))

	Return $tSIZE
EndFunc   ;==>_WinAPI_GetEnhMetaFileDimension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetEnhMetaFileHeader
; Description....: Retrieves the record containing the header for the specified enhanced-format metafile.
; Syntax.........: _WinAPI_GetEnhMetaFileHeader ( $hEmf )
; Parameters.....: $hEmf   - Handle to the enhanced metafile for which the header is to be retrieved.
; Return values..: Success - $tagENHMETAHEADER structure that contains the header record, @extended flag will be contain the
;                            the number of bytes copied to the structure, in bytes.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetEnhMetaFileHeader
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetEnhMetaFileHeader($hEmf)

	Local $tENHMETAHEADER = DllStructCreate($tagENHMETAHEADER)
	Local $Ret = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileHeader', 'ptr', $hEmf, 'uint', DllStructGetSize($tENHMETAHEADER), 'ptr', DllStructGetPtr($tENHMETAHEADER))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $Ret[0], $tENHMETAHEADER)
EndFunc   ;==>_WinAPI_GetEnhMetaFileHeader

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetErrorMessage
; Description....: Retrieves a text error message for the specified system error code.
; Syntax.........: _WinAPI_GetErrorMessage ( $iCode [, $iLanguage] )
; Parameters.....: $iCode     - The system error code to retrieve a message.
;                  $iLanguage - The language identifier (LCID).
; Return values..: Success    - The requested message.
;                  Failure    - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FormatMessage
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetErrorMessage($iCode, $iLanguage = 0)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('kernel32.dll', 'dword', 'FormatMessageW', 'dword', 0x1000, 'ptr', 0, 'dword', $iCode, 'dword', $iLanguage, 'ptr', DllStructGetPtr($tData), 'dword', 1024, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return StringRegExpReplace(DllStructGetData($tData, 1), '[' & @LF & ',' & @CR & ']*\Z', '')
EndFunc   ;==>_WinAPI_GetErrorMessage

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetErrorMode
; Description....: Retrieves the error mode for the current process.
; Syntax.........: _WinAPI_GetErrorMode ( )
; Parameters.....: None
; Return values..: Success - The process error mode ($SEM_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetErrorMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetErrorMode()

	Local $Ret = DllCall('kernel32.dll', 'uint', 'GetErrorMode')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetErrorMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetExitCodeProcess
; Description....: Retrieves the termination status of the specified process.
; Syntax.........: _WinAPI_GetExitCodeProcess ( $hProcess )
; Parameters.....: $hProcess - Handle to the process.
; Return values..: Success   - The process termination status. If the process has not terminated and the function succeeds,
;                              the status returned is STILL_ACTIVE (259).
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetExitCodeProcess
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetExitCodeProcess($hProcess)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetExitCodeProcess', 'ptr', $hProcess, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetExitCodeProcess

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetExtended
; Description....: Retrieves the last extended function return value.
; Syntax.........: _WinAPI_GetExtended ( )
; Parameters.....: None
; Return values..: The last extended value.
; Author.........: Yashied
; Modified.......:
; Remarks........: Note that not all the functions returns the extended value. For example, _WinAPI_CreateDIB() function returns
;                  a pointer to the location of the DIB bit values. The _WinAPI_GetExtended() must be called immediately after
;                  calling the appropriate function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetExtended()
	Return $__Ext
EndFunc   ;==>_WinAPI_GetExtended

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileAttributes
; Description....: Retrieves file system attributes for a specified file or directory.
; Syntax.........: _WinAPI_GetFileAttributes ( $sFile )
; Parameters.....: $sFile  - The name of the file or directory.
; Return values..: Success - The value contains the attributes of the specified file or directory.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetFileAttributes
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileAttributes($sFile)

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetFileAttributesW', 'wstr', $sFile)

	If (@error) Or ($Ret[0] = 0xFFFFFFFF) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetFileAttributes

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileInformationByHandle
; Description....: Retrieves file information for the specified file.
; Syntax.........: _WinAPI_GetFileInformationByHandle ( $hFile )
; Parameters.....: $hFile  - handle to the file that contains the information to be retrieved.
; Return values..: Success - The array containing the following information:
;
;                            [0] - The file attributes (FILE_ATTRIBUTE_*).
;                            [1] - $tagFILETIME structure that specifies when a file or directory is created.
;                            [2] - $tagFILETIME structure that specifies the last time that a file is read from or written to.
;                            [3] - $tagFILETIME structure that specifies the last time that a file is written to.
;                            [4] - The serial number of the volume that contains a file.
;                            [5] - The file size.
;                            [6] - The number of links to this file.
;                            [7] - The unique identifier that is associated with a file.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetFileInformationByHandle
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileInformationByHandle($hFile)

	Local $tBHFI = DllStructCreate('dword;dword[2];dword[2];dword[2];dword;dword;dword;dword;dword;dword')
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetFileInformationByHandle', 'ptr', $hFile, 'ptr', DllStructGetPtr($tBHFI))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[8]

	$Result[0] = DllStructGetData($tBHFI, 1)
	For $i = 1 To 3
		If DllStructGetData($tBHFI, $i + 1) Then
			$Result[$i] = DllStructCreate($tagFILETIME)
			_WinAPI_MoveMemory(DllStructGetPtr($Result[$i]), DllStructGetPtr($tBHFI, $i + 1), 8)
		Else
			$Result[$i] = 0
		EndIf
	Next
	$Result[4] = DllStructGetData($tBHFI, 5)
	$Result[5] = _WinAPI_MakeQWord(DllStructGetData($tBHFI, 7), DllStructGetData($tBHFI, 6))
	$Result[6] = DllStructGetData($tBHFI, 8)
	$Result[7] = _WinAPI_MakeQWord(DllStructGetData($tBHFI, 9), DllStructGetData($tBHFI, 10))
	Return $Result
EndFunc   ;==>_WinAPI_GetFileInformationByHandle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileSizeOnDisk
; Description....: Retrieves the file allocation size on disk.
; Syntax.........: _WinAPI_GetFileSizeOnDisk ( $sFile )
; Parameters.....: $sFile  - The name of the file to retrieve allocation size.
; Return values..: Success - The allocation size, in bytes. This value is a multiple of the sector or cluster size of the nderlying
;                            physical device.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileSizeOnDisk($sFile)

	$sFile = _WinAPI_PathSearchAndQualify($sFile, 1)
	If Not $sFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $aRet = DllCall('kernel32.dll', 'int', 'GetDiskFreeSpaceW', 'wstr', StringLeft($sFile, 2), 'dword*', 0, 'dword*', 0, 'dword*', 0, 'dword*', 0)

	If (@error) Or (Not $aRet[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return Ceiling(FileGetSize($sFile) / ($aRet[2] * $aRet[3])) * ($aRet[2] * $aRet[3])
EndFunc   ;==>_WinAPI_GetFileSizeOnDisk

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileTitle
; Description....: Retrieves the name of the specified file.
; Syntax.........: _WinAPI_GetFileTitle ( $sFile )
; Parameters.....: $sFile  - The name and location of a file.
; Return values..: Success - The name of the file.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_GetFileTitle() should only be called with legal file names; using an illegal file name has an undefined result.
;
;                  _WinAPI_GetFileTitle() returns the string that the system would use to display the file name to the user.
;                  The display name includes an extension only if that is the user's preference for displaying file names. This means
;                  that the returned string may not accurately identify the file if it is used in calls to file system functions.
; Related........:
; Link...........: @@MsdnLink@@ GetFileTitle
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileTitle($sFile)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('comdlg32.dll', 'short', 'GetFileTitleW', 'wstr', $sFile, 'ptr', DllStructGetPtr($tData), 'word', 1024)

	If (@error) Or ($Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetFileTitle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileType
; Description....: Retrieves the file type of the specified file.
; Syntax.........: _WinAPI_GetFileType ( $hFile )
; Parameters.....: $hFile  - Handle to the file.
; Return values..: Success - The file type ($FILE_TYPE_*)
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetFileType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileType($hFile)

	Local $Ret = DllCall('kernel32.dll ', 'dword', 'GetFileType', 'ptr', $hFile)

	If @error Then
		Return SetError(1, 0, -1)
	Else
		If (Not $Ret[0]) And (_WinAPI_GetLastError()) Then
			Return SetError(1, 0, -1)
		EndIf
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetFileType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileVersionInfo
; Description....: Retrieves version information for the specified file.
; Syntax.........: _WinAPI_GetFileVersionInfo ( $sFile )
; Parameters.....: $sFile  - The name of the file.
; Return values..: Success - The "byte[n]" structure (buffer) that contains the file-version information.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetFileVersionInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileVersionInfo($sFile)

	Local $Ret, $tData

	$Ret = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeW', 'wstr', $sFile, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$tData = DllStructCreate('byte[' & $Ret[0] & ']')
	$Ret = DllCall('version.dll', 'int', 'GetFileVersionInfoW', 'wstr', $sFile, 'dword', 0, 'dword', $Ret[0], 'ptr', DllStructGetPtr($tData))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tData
EndFunc   ;==>_WinAPI_GetFileVersionInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFinalPathNameByHandle
; Description....: Retrieves the final path for the specified file.
; Syntax.........: _WinAPI_GetFinalPathNameByHandle ( $hFile [, $iFlags] )
; Parameters.....: $hFile  - Handle to a file or directory.
;                  $iFlags - The type of result to return. This parameter can be combination of one $FILE_NAME_* and one
;                            $VOLUME_NAME_* values.
;
;                            $FILE_NAME_NORMALIZED
;                            $FILE_NAME_OPENED
;
;                            $VOLUME_NAME_DOS
;                            $VOLUME_NAME_GUID
;                            $VOLUME_NAME_NONE
;                            $VOLUME_NAME_NT
;
; Return values..: Success - The path of $hFile.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetFinalPathNameByHandle
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFinalPathNameByHandle($hFile, $iFlags = 0)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetFinalPathNameByHandleW', 'ptr', $hFile, 'ptr', DllStructGetPtr($tData), 'dword', 1023, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetFinalPathNameByHandle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFontResourceInfo
; Description....: Retrieves the fontname from the specified font resource file.
; Syntax.........: _WinAPI_GetFontResourceInfo ( $sFont [, $fForce] )
; Parameters.....: $sFont  - String that names a font resource file. To retrieve a fontname whose information comes from several
;                            resource files, they must be separated by a "|" . For example, abcxxxxx.pfm | abcxxxxx.pfb.
;                  $fForce - Specifies whether adds a file to the font table, valid values:
;                  |TRUE   - Forced add the specified file to the system font table and remove it after retrieving the fontname.
;                  |FALSE  - Don`t add and remove. (Default)
; Return values..: Success - The name of the font.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFontResourceInfo($sFont, $fForce = 0)

	If $fForce Then
		If Not _WinAPI_AddFontResourceEx($sFont, $FR_NOT_ENUM) Then
			Return SetError(1, 0, '')
		EndIf
	EndIf

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetFontResourceInfoW', 'wstr', $sFont, 'dword*', 1024, 'ptr', DllStructGetPtr($tData), 'dword', 0x01)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	If $fForce Then
		_WinAPI_RemoveFontResourceEx($sFont, $FR_NOT_ENUM)
	EndIf
	If Not IsArray($Ret) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetFontResourceInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFRBuffer
; Description....: Retrieves the current size of the internal buffer that used the _WinAPI_FindTextDlg() and _WinAPI_ReplaceTextDlg() functions.
; Syntax.........: _WinAPI_GetFRBuffer ( )
; Parameters.....: None
; Return values..: The size, in TCHARs, of the internal buffer.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFRBuffer()
	Return $__Buff - 1
EndFunc   ;==>_WinAPI_GetFRBuffer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFullPathName
; Description....: Retrieves the full path and file name of the specified file.
; Syntax.........: _WinAPI_GetFullPathName ( $sFile )
; Parameters.....: $sFile   - The name of the file.
; Return values..: Success  - The drive and path.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_GetFullPathName() merges the name of the current drive and directory with a specified file name to
;                  determine the full path and file name of a specified file. This function does not verify that the resulting
;                  path and file name are valid, or that they see an existing file on the associated volume.
; Related........:
; Link...........: @@MsdnLink@@ GetFullPathName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFullPathName($sFile)

	Local $tPath = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetFullPathNameW', 'wstr', $sFile, 'dword', 1024, 'ptr', DllStructGetPtr($tPath), 'ptr*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tPath, 1)
EndFunc   ;==>_WinAPI_GetFullPathName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetGraphicsMode
; Description....: Retrieves the current graphics mode for the specified device context.
; Syntax.........: _WinAPI_GetGraphicsMode ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The current graphics mode ($GM_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetGraphicsMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetGraphicsMode($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetGraphicsMode', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetGraphicsMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetGUIThreadInfo
; Description....: Retrieves information about the active window or a specified GUI thread.
; Syntax.........: _WinAPI_GetGUIThreadInfo ( $iThreadID )
; Parameters.....: $iThreadID - The identifier for the thread for which information is to be retrieved.
; Return values..: Success    - The array that contains the following information.
;
;                               [0 ] - The thread state. It can be one or more of the $GUI_* values.
;                               [1 ] - A handle to the active window within the thread.
;                               [2 ] - A handle to the window that has the keyboard focus.
;                               [3 ] - A handle to the window that has captured the mouse.
;                               [4 ] - A handle to the window that owns any active menus.
;                               [5 ] - A handle to the window in a move or size loop.
;                               [6 ] - A handle to the window that is displaying the caret.
;                               [7 ] - The x-coordinate of the upper-left corner of the caret's bounding rectangle, in client coordinates.
;                               [8 ] - The y-coordinate of the upper-left corner of the caret's bounding rectangle, in client coordinates.
;                               [9 ] - The width of the caret's bounding rectangle.
;                               [10] - The height of the caret's bounding rectangle.
;
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetGUIThreadInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetGUIThreadInfo($iThreadID)

	Local $tGUITI = DllStructCreate('dword;dword;hwnd;hwnd;hwnd;hwnd;hwnd;hwnd;long;long;long;long')

	DllStructSetData($tGUITI, 1, DllStructGetSize($tGUITI))

	Local $Ret = DllCall('user32.dll', 'int', 'GetGUIThreadInfo', 'dword', $iThreadID, 'ptr', DllStructGetPtr($tGUITI))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[11]

	For $i = 0 To 10
		$Result[$i] = DllStructGetData($tGUITI, $i + 2)
	Next
	For $i = 9 To 10
		$Result[$i] -= $Result[$i - 2]
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetGUIThreadInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetGValue
; Description....: Retrieves an intensity value for the green component of a 32-bit RGB value.
; Syntax.........: _WinAPI_GetGValue ( $iRGB )
; Parameters.....: $iRGB - The color value, in RGB.
; Return values..: The intensity of the green component of the specified RGB color.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetGValue($iRGB)
	Return BitShift(BitAND(__RGB($iRGB), 0x00FF00), 8)
EndFunc   ;==>_WinAPI_GetGValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetHandleInformation
; Description....: Retrieves certain properties of an object handle.
; Syntax.........: _WinAPI_GetHandleInformation ( $hObject )
; Parameters.....: $hObject - Handle to an object whose information is to be retrieved.
; Return values..: Success  - The value that specifies the properties of the object handle ($HANDLE_FLAG_*).
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetHandleInformation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetHandleInformation($hObject)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetHandleInformation', 'ptr', $hObject, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetHandleInformation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetHGlobalFromStream
; Description....: Retrieves the global memory handle to a stream.
; Syntax.........: _WinAPI_GetHGlobalFromStream ( $hStream )
; Parameters.....: $hStream - Pointer to the stream object previously created by a call to the _WinAPI_CreateStreamOnHGlobal() function.
; Return values..: Success  - Pointer to the current memory handle used by the specified stream object.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function can be called only from within the same process from which the byte array was created.
; Related........:
; Link...........: @@MsdnLink@@ GetHGlobalFromStream
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetHGlobalFromStream($hStream)

	Local $Ret = DllCall('ole32.dll', 'uint', 'GetHGlobalFromStream', 'ptr', $hStream, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetHGlobalFromStream

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetIconBitmap
; Description....: Retrieves icon color bitmap for the specified icon.
; Syntax.........: _WinAPI_GetIconBitmap ( $hIcon )
; Parameters.....: $hIcon  - Handle to the icon to retrieve bitmap.
; Return values..: Success - Handle to the bitmap.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The calling application must manage this bitmap and delete when it are no longer necessary.
; Related........:
; Link...........: @@MsdnLink@@ GetIconInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetIconBitmap($hIcon)

	Local $tICONINFO = DllStructCreate($tagICONINFO)
	Local $Ret = DllCall('user32.dll', 'int', 'GetIconInfo', 'ptr', $hIcon, 'ptr', DllStructGetPtr($tICONINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	_WinAPI_DeleteObject(DllStructGetData($tICONINFO, 4))
	Return DllStructGetData($tICONINFO, 5)
EndFunc   ;==>_WinAPI_GetIconBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetIconDimension
; Description....: Retrieves a dimension for the specified icon.
; Syntax.........: _WinAPI_GetIconDimension ( $hIcon )
; Parameters.....: $hIcon  - Handle to the icon to retrieve dimension.
; Return values..: Success - $tagSIZE structure that contains the icon dimension.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetIconDimension($hIcon)

	Local $tICONINFO = DllStructCreate($tagICONINFO)
	Local $Ret = DllCall('user32.dll', 'int', 'GetIconInfo', 'ptr', $hIcon, 'ptr', DllStructGetPtr($tICONINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSIZE = _WinAPI_GetBitmapDimension(DllStructGetData($tICONINFO, 5))

	For $i = 4 To 5
		_WinAPI_DeleteObject(DllStructGetData($tICONINFO, $i))
	Next
	If Not IsDllStruct($tSIZE) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tSIZE
EndFunc   ;==>_WinAPI_GetIconDimension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetIconInfoEx
; Description....: Retrieves information about the specified icon or cursor.
; Syntax.........: _WinAPI_GetIconInfoEx ( $hIcon )
; Parameters.....: $hIcon  - Handle to the icon or cursor. To retrieve information about a standard icon or cursor, use $IDC_* constants.
; Return values..: Success - $tagICONINFOEX structure that contains information about an icon or a cursor.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_GetIconInfoEx() creates bitmaps for the "hMask" and "hColor" members of the $tagICONINFOEX structure.
;                  The calling application must manage these bitmaps and delete them when they are no longer necessary.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetIconInfoEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetIconInfoEx($hIcon)

	Local $tICONINFOEX = DllStructCreate($tagICONINFOEX)

	DllStructSetData($tICONINFOEX, 1, DllStructGetSize($tICONINFOEX))

	Local $Ret = DllCall('user32.dll', 'int', 'GetIconInfoExW', 'ptr', $hIcon, 'ptr', DllStructGetPtr($tICONINFOEX))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tICONINFOEX
EndFunc   ;==>_WinAPI_GetIconInfoEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetIconMask
; Description....: Retrieves icon bitmask bitmap for the specified icon.
; Syntax.........: _WinAPI_GetIconMask ( $hIcon )
; Parameters.....: $hIcon  - Handle to the icon to retrieve bitmap.
; Return values..: Success - Handle to the bitmap.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The calling application must manage this bitmap and delete when it are no longer necessary.
; Related........:
; Link...........: @@MsdnLink@@ GetIconInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetIconMask($hIcon)

	Local $tICONINFO = DllStructCreate($tagICONINFO)
	Local $Ret = DllCall('user32.dll', 'int', 'GetIconInfo', 'ptr', $hIcon, 'ptr', DllStructGetPtr($tICONINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	_WinAPI_DeleteObject(DllStructGetData($tICONINFO, 5))
	Return DllStructGetData($tICONINFO, 4)
EndFunc   ;==>_WinAPI_GetIconMask

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetIdleTime
; Description....: Retrieves the time that has elapsed since the last input.
; Syntax.........: _WinAPI_GetIdleTime ( )
; Parameters.....: None
; Return values..: Success - The elapsed time, in milliseconds.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetLastInputInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetIdleTime()

	Local $tLASTINPUTINFO = DllStructCreate('uint;dword')

	DllStructSetData($tLASTINPUTINFO, 1, DllStructGetSize($tLASTINPUTINFO))

	Local $Ret = DllCall('user32.dll', 'int', 'GetLastInputInfo', 'ptr', DllStructGetPtr($tLASTINPUTINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return _WinAPI_GetTickCount() - DllStructGetData($tLASTINPUTINFO, 2)
EndFunc   ;==>_WinAPI_GetIdleTime

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetKeyboardLayout
; Description....: Retrieves the active input locale identifier for the specified window.
; Syntax.........: _WinAPI_GetKeyboardLayout ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to retrieve the input locale identifier.
; Return values..: Success - The input locale identifier.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetKeyboardLayout
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetKeyboardLayout($hWnd)

	Local $Ret

	$Ret = DllCall('user32.dll', 'long', 'GetWindowThreadProcessId', 'hwnd', $hWnd, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$Ret = DllCall('user32.dll', 'long', 'GetKeyboardLayout', 'long', $Ret[0])
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetKeyboardLayout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetKeyboardLayoutList
; Description....: Retrieves the all input locale identifiers corresponding to the current set of input locales in the system.
; Syntax.........: _WinAPI_GetKeyboardLayoutList ( )
; Parameters.....: None
; Return values..: Success - The array of input locale identifiers. The zeroth array element contains the number of identifiers.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetKeyboardLayoutList
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetKeyboardLayoutList()

	Local $Ret

	$Ret = DllCall('user32.dll', 'int', 'GetKeyboardLayoutList', 'int', 0, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tData = DllStructCreate('long[' & $Ret[0] & ']')

	$Ret = DllCall('user32.dll', 'int', 'GetKeyboardLayoutList', 'int', $Ret[0], 'ptr', DllStructGetPtr($tData))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $List[$Ret[0] + 1] = [$Ret[0]]

	For $i = 1 To $List[0]
		$List[$i] = DllStructGetData($tData, 1, $i)
	Next
	Return $List
EndFunc   ;==>_WinAPI_GetKeyboardLayoutList

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetKeyboardState
; Description....: Copies the status of the 256 virtual keys to the specified buffer.
; Syntax.........: _WinAPI_GetKeyboardState ( )
; Parameters.....: None
; Return values..: Success - The structure of "byte[256]" that receives the status data for each virtual key.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application can call this function to retrieve the current status of all the virtual keys. The status changes
;                  as a process removes keyboard messages from its message queue. The status does not change as keyboard messages are
;                  posted to the process's message queue, nor does it change as keyboard messages are posted to or retrieved from
;                  message queues of other processes.
;
;                  When the function returns, each member of the array contains status data for a virtual key. If the high-order
;                  bit is 1, the key is down; otherwise, it is up. If the key is a toggle key, for example CAPS LOCK, then the
;                  low-order bit is 1 when the key is toggled and is 0 if the key is untoggled. The low-order bit is meaningless for
;                  non-toggle keys. A toggle key is said to be toggled when it is turned on. A toggle key's indicator light (if any)
;                  on the keyboard will be on when the key is toggled, and off when the key is untoggled.
;
;                  To retrieve status information for an individual key, use the _WinAPI_GetKeyState() function. To retrieve the
;                  current state for an individual key regardless of whether the corresponding keyboard message has been retrieved
;                  from the message queue, use the _WinAPI_GetAsyncKeyState() function.
;
; Related........:
; Link...........: @@MsdnLink@@ GetKeyboardState
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetKeyboardState()

	Local $tData = DllStructCreate('byte[256]')
	Local $Ret = DllCall('user32.dll', 'int', 'GetKeyboardState', 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tData
EndFunc   ;==>_WinAPI_GetKeyboardState

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetKeyboardType
; Description....: Retrieves information about the current keyboard.
; Syntax.........: _WinAPI_GetKeyboardType ( $iType )
; Parameters.....: $iType   - The type of keyboard information to be retrieved, valid values:
;                  |0 - Keyboard type.
;                  |1 - Keyboard subtype (original equipment manufacturer (OEM)-dependent value).
;                  |2 - The number of function keys on the keyboard.
; Return values..: Success  - The value that specifies the requested information. If $iType is 0, return value may be one of the following values.
;                  |1 - IBM PC/XT or compatible (83-key) keyboard.
;                  |2 - Olivetti "ICO" (102-key) keyboard.
;                  |3 - IBM PC/AT (84-key) or similar keyboard.
;                  |4 - IBM enhanced (101- or 102-key) keyboard.
;                  |5 - Nokia 1050 and similar keyboards.
;                  |6 - Nokia 9140 and similar keyboards.
;                  |7 - Japanese keyboard.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When a single USB keyboard is connected to the computer, this function returns the code 81.
; Related........:
; Link...........: @@MsdnLink@@ GetKeyboardType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetKeyboardType($iType)

	Local $Ret = DllCall('user32.dll', 'int', 'GetKeyboardType', 'int', $iType)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetKeyboardType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetKeyNameText
; Description....: Retrieves a string that represents the name of a key.
; Syntax.........: _WinAPI_GetKeyNameText ( $lParam )
; Parameters.....: $lParam - Specifies the second parameter of the keyboard message (such as WM_KEYDOWN) to be processed.
; Return values..: Success - String containing the name of the key.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The format of the key-name string depends on the current keyboard layout. The keyboard driver maintains a list
;                  of names in the form of character strings for keys with names longer than a single character. The key name
;                  is translated according to the layout of the currently installed keyboard, thus the function may give different
;                  results for different input locales. The name of a character key is the character itself. The names of dead
;                  keys are spelled out in full.
; Related........:
; Link...........: @@MsdnLink@@ GetKeyNameText
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetKeyNameText($lParam)

	Local $tData = DllStructCreate('wchar[128]')
	Local $Ret = DllCall('user32.dll', 'int', 'GetKeyNameTextW', 'long', $lParam, 'ptr', DllStructGetPtr($tData), 'int', 128)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetKeyNameText

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetKeyState
; Description....: Retrieves the status of the specified virtual key.
; Syntax.........: _WinAPI_GetKeyState ( $vKey )
; Parameters.....: $vKey   - Specifies a virtual key ($VK_*). If the desired virtual key is a letter or digit (A through Z,
;                            a through z, or 0 through 9).
; Return values..: Success - The value that specifies the status of the specified virtual key. If the high-order bit is 1, the key is
;                            down; otherwise, it is up. If the low-order bit is 1, the key is toggled. A key, such as the
;                            CAPS LOCK key, is toggled if it is turned on. The key is off and untoggled if the low-order bit is 0.
;                            A toggle key's indicator light (if any) on the keyboard will be on when the key is toggled, and off
;                            when the key is untoggled.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The key status returned from this function changes as a process reads key messages from its message queue.
;                  The status does not reflect the interrupt-level state associated with the hardware. Use the _WinAPI_GetAsyncKeyState()
;                  function to retrieve that information.
; Related........:
; Link...........: @@MsdnLink@@ GetKeyState
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetKeyState($vKey)

	Local $Ret = DllCall('user32.dll', 'int', 'GetKeyState', 'int', $vKey)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetKeyState

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetLastActivePopup
; Description....: Determines which pop-up window owned by the specified window was most recently active.
; Syntax.........: _WinAPI_GetLastActivePopup ( $hWnd )
; Parameters.....: $hWnd   - Handle to the owner window.
; Return values..: Success - Handle of the most recently active pop-up window.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetLastActivePopup
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetLastActivePopup($hWnd)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'GetLastActivePopup', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Or ($Ret[0] = $hWnd) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetLastActivePopup

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetLocaleInfo
; Description....: Retrieves information about a locale specified by identifier.
; Syntax.........: _WinAPI_GetLocaleInfo ( $LCID, $iType )
; Parameters.....: $LCID   - Locale identifier for which to retrieve information or one of the following predefined values.
;
;                            $LOCALE_CUSTOM_DEFAULT
;                            $LOCALE_CUSTOM_UI_DEFAULT
;                            $LOCALE_CUSTOM_UNSPECIFIED
;
;                            $LOCALE_INVARIANT
;                            $LOCALE_SYSTEM_DEFAULT
;                            $LOCALE_USER_DEFAULT
;
;                  $iType  - The one of the locale information constants ($LOCALE_*) to retrieve.
; Return values..: Success - String containing the requested information.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: WideBoyDixon
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetLocaleInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetLocaleInfo($LCID, $iType)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetLocaleInfoW', 'long', $LCID, 'dword', $iType, 'ptr', DllStructGetPtr($tData), 'int', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetLocaleInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetLogicalDrives
; Description....: Retrieves a bitmask representing the currently available disk drives.
; Syntax.........: _WinAPI_GetLogicalDrives ( )
; Parameters.....: None
; Return values..: Success - The value is a bitmask representing the currently available disk drives. Bit position 0 (the least-significant bit)
;                            is drive A, bit position 1 is drive B, bit position 2 is drive C, and so on.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetLogicalDrives
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetLogicalDrives()

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetLogicalDrives')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetLogicalDrives

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetMapMode
; Description....: Retrieves the current mapping mode.
; Syntax.........: _WinAPI_GetMapMode ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The value specifies the mapping mode (MM_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetMapMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetMapMode($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetMapMode', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetMapMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetMessageExtraInfo
; Description....: Retrieves the extra message information for the current thread.
; Syntax.........: _WinAPI_GetMessageExtraInfo ( )
; Parameters.....: None
; Return values..: Success - The value associated with the current thread.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetMessageExtraInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetMessageExtraInfo()

	Local $Ret = DllCall('user32.dll', 'lparam', 'GetMessageExtraInfo')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetMessageExtraInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetModuleFileName
; Description....: Retrieves the fully-qualified path for the file that contains the specified module.
; Syntax.........: _WinAPI_GetModuleFileName( $hModule )
; Parameters.....: $hModule - Handle to the loaded module whose path is being requested. If this parameter is 0, function retrieves
;                             the path of the executable file of the current process.
; Return values..: Success  - The fully-qualified path of the module.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetModuleFileName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetModuleFileName($hModule)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetModuleFileNameW', 'ptr', $hModule, 'ptr', DllStructGetPtr($tData), 'dword', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetModuleFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetModuleFileNameEx
; Description....: Retrieves the fully-qualified path for the file associated with the process.
; Syntax.........: _WinAPI_GetModuleFileNameEx ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The fully-qualified path to the file.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetModuleFileNameEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetModuleFileNameEx($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', 0x00000410, 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, '')
	EndIf

	Local $tPath = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('psapi.dll', 'int', 'GetModuleFileNameExW', 'ptr', $hProcess[0], 'ptr', 0, 'ptr', DllStructGetPtr($tPath), 'int', 1024)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tPath, 1)
EndFunc   ;==>_WinAPI_GetModuleFileNameEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetModuleHandleEx
; Description....: Retrieves a module handle for the specified module.
; Syntax.........: _WinAPI_GetModuleHandleEx ( $sModule [, $iFlags] )
; Parameters.....: $sModule - The name of the loaded module (either a .dll or .exe file), or a pointer to an address in the module
;                             (if $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS flag is specified). If this parameter is 0 or empty string,
;                             the function returns a handle to the file used to create the calling process (.exe file).
;                  $iFlags  - This parameter can be one or more of the following values.
;
;                             $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
;                             $GET_MODULE_HANDLE_EX_FLAG_PIN
;                             $GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
;                             $GET_MODULE_HANDLE_EX_FLAG_DEFAULT
;
; Return values..: Success  - Handle to the specified module.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetModuleHandleEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetModuleHandleEx($sModule, $iFlags = 0)

	Local $TypeOfModule = 'ptr'

	If IsString($sModule) Then
		If StringStripWS($sModule, 3) Then
			$TypeOfModule = 'wstr'
		Else
			$sModule = 0
		EndIf
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetModuleHandleExW', 'dword', $iFlags, $TypeOfModule, $sModule, 'ptr*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_GetModuleHandleEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetModuleInformation
; Description....: Retrieves information about the specified module.
; Syntax.........: _WinAPI_GetModuleInformation( $hProcess, $hModule )
; Parameters.....: $hProcess - Handle to the process that contains the module. The handle must have the $PROCESS_QUERY_INFORMATION or
;                              $PROCESS_QUERY_LIMITED_INFORMATION access right and the $PROCESS_VM_READ access right.
;                  $hModule  - Handle to the module. If this parameter is 0, the function retrieves information only about the
;                              executable file ("SizeOfImage" and "EntryPoint" members of the $tagMODULEINFO structure).
; Return values..: Success   - $tagMODULEINFO structure that contains information about the module.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not retrieve information for modules that were loaded with the $LOAD_LIBRARY_AS_DATAFILE flag.
;                  For more information, see _WinAPI_LoadLibraryEx().
; Related........:
; Link...........: @@MsdnLink@@ GetModuleInformation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetModuleInformation($hProcess, $hModule = 0)

	Local $tMODULEINFO = DllStructCreate($tagMODULEINFO)
	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'GetModuleInformation', 'ptr', $hProcess, 'ptr', $hModule, 'ptr', DllStructGetPtr($tMODULEINFO), 'dword', DllStructGetSize($tMODULEINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tMODULEINFO
EndFunc   ;==>_WinAPI_GetModuleInformation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetObjectEx
; Description....: Retrieves information for the specified graphics object.
; Syntax.........: _WinAPI_GetObjectEx ( $hObject )
; Parameters.....: $hObject - Handle to the graphics object of interest. This can be a handle to one of the following: a logical
;                             bitmap, a brush, a font, a palette, or a pen.
; Return values..: Success  - The structure that depends on the graphics object ($hObject) and @extended flag will contain the value
;                             that identifies the object ($OBJ_*). You do not need to create the desired structure, _WinAPI_GetObjectEx()
;                             function itself will create it. The following table shows the structures that will be returns for
;                             each type of graphics object.
;
;                             $OBJ_BITMAP (HBITMAP)
;                             Returns $tagDIBSECTION structure.
;
;                             $OBJ_BRUSH (HBRUSH)
;                             Returns $tagLOGBRUSH structure.
;
;                             $OBJ_FONT (HFONT)
;                             Returns $tagLOGFONT structure.
;
;                             $OBJ_PAL (HPALETTE)
;                             Returns "ushort" structure that specifies the number of entries in the palette.
;
;                             $OBJ_PEN (HPEN)
;                             Returns $tagLOGPEN (12 bytes) or $tagEXTLOGPEN (24 and more bytes) structure.
;
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetObjectEx($hObject)

	Local $Ret, $Size, $Struct, $Type, $Entry, $tData = 0

	$Ret = DllCall('gdi32.dll', 'int', 'GetObjectW', 'int', $hObject, 'int', 0, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$Size = $Ret[0]
	$Type = _WinAPI_GetObjectType($hObject)
	Switch $Type
		Case $OBJ_BITMAP
			$Struct = $tagDIBSECTION
		Case $OBJ_BRUSH
			$Struct = $tagLOGBRUSH
		Case $OBJ_FONT
			$Struct = $tagLOGFONT
		Case $OBJ_PAL
			$Struct = 'ushort'
		Case $OBJ_PEN
			If $Size > 12 Then
				$tData = DllStructCreate($tagEXTLOGPEN)
				$Entry = BitShift($Size - DllStructGetSize($tData), 2)
				If $Entry Then
					$tData = DllStructCreate($tagEXTLOGPEN & ';dword StyleEntry[' & $Entry & ']')
				EndIf
			Else
				$Struct = $tagLOGPEN
			EndIf
		Case Else
			Return SetError(2, 0, 0)
	EndSwitch
	If Not IsDllStruct($tData) Then
		$tData = DllStructCreate($Struct)
	EndIf
	$Ret = DllCall('gdi32.dll', 'int', 'GetObjectW', 'int', $hObject, 'int', DllStructGetSize($tData), 'ptr', DllStructGetPtr($tData))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $Type, $tData)
EndFunc   ;==>_WinAPI_GetObjectEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetObjectID
; Description....: Retrieves the object identifier for the specified file or directory.
; Syntax.........: _WinAPI_GetObjectID ( $sPath )
; Parameters.....: $sPath  - Path to the file or directory from which the object identifier is to be retrieved.
; Return values..: Success - $tagGUID structure that contains the object identifier for the file or directory within the volume on which it resides.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Unlike _WinAPI_CreateObjectID(), this function only returns the object identifier. If a file or directory does not
;                  have an object identifier, the function fails.
; Related........:
; Link...........: @@MsdnLink@@ FSCTL_GET_OBJECT_ID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetObjectID($sPath)

	Local $hFile, $Flags

	If _WinAPI_PathIsDirectory($sPath) Then
		$Flags = 0x02000000
	Else
		$Flags = 0
	EndIf
	$hFile = _WinAPI_CreateFileEx($sPath, 3, 0, 0x06, $Flags)
	If Not $hFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tGUID, $tFOID = DllStructCreate('byte[16];byte[48]')
	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x0009009C, 'ptr', 0, 'dword', 0, 'ptr', DllStructGetPtr($tFOID), 'dword', DllStructGetSize($tFOID), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	$tGUID = DllStructCreate($tagGUID)
	_WinAPI_MoveMemory(DllStructGetPtr($tGUID), DllStructGetPtr($tFOID), 16)
	Return $tGUID
EndFunc   ;==>_WinAPI_GetObjectID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetObjectNameByHandle
; Description....: Retrieves a name of the specified object.
; Syntax.........: _WinAPI_GetObjectNameByHandle ( $hObject )
; Parameters.....: $hObject - Handle to the object to obtain information about.
; Return values..: Success  - The name of the object.
;                  Failure  - Empty string and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ZwQueryObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetObjectNameByHandle($hObject)

	Local $tPOTI = DllStructCreate('ushort;ushort;ptr;byte[512]')
	Local $Ret = DllCall('ntdll.dll', 'uint', 'ZwQueryObject', 'ptr', $hObject, 'uint', 2, 'ptr', DllStructGetPtr($tPOTI), 'ulong', DllStructGetSize($tPOTI), 'ptr', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $pData = DllStructGetData($tPOTI, 3)

	If Not $pData Then
		Return SetError(1, 0, 0)
	EndIf
	Return _WinAPI_GetString($pData)
EndFunc   ;==>_WinAPI_GetObjectNameByHandle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetObjectType
; Description....: Retrieves the type of the specified object.
; Syntax.........: _WinAPI_GetObjectType ( $hObject )
; Parameters.....: $hObject - Handle to the graphics object.
; Return values..: Success  - The value identifies the object ($OBJ_*).
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetObjectType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetObjectType($hObject)

	Local $Ret = DllCall('gdi32.dll', 'dword', 'GetObjectType', 'ptr', $hObject)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetObjectType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetOutlineTextMetrics
; Description....: Retrieves text metrics for TrueType fonts.
; Syntax.........: _WinAPI_GetOutlineTextMetrics ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - $tagOUTLINETEXTMETRIC structure that contains the text metrics.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetOutlineTextMetrics
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetOutlineTextMetrics($hDC)

	Local $Ret, $tOLTM

	$Ret = DllCall('gdi32.dll', 'uint', 'GetOutlineTextMetricsW', 'hwnd', $hDC, 'uint', 0, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	;	$tOLTM = DllStructCreate($tagOUTLINETEXTMETRIC)
	$tOLTM = DllStructCreate('uint otmSize;long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;byte tmPitchAndFamily;byte tmCharSet;byte otmFiller[4];' & $tagPANOSE & 'uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffset[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName')
	;	$tOLTM = DllStructCreate($tagOUTLINETEXTMETRIC & 'byte[' & ($Ret[0] - DllStructGetSize($tOLTM)) & ']')
	$tOLTM = DllStructCreate('uint otmSize;long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;byte tmPitchAndFamily;byte tmCharSet;byte otmFiller[4];' & $tagPANOSE & 'uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffset[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;byte[' & ($Ret[0] - DllStructGetSize($tOLTM)) & ']')
	$Ret = DllCall('gdi32.dll', 'uint', 'GetOutlineTextMetricsW', 'hwnd', $hDC, 'uint', $Ret[0], 'ptr', DllStructGetPtr($tOLTM))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tOLTM
EndFunc   ;==>_WinAPI_GetOutlineTextMetrics

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetParentProcess
; Description....: Retrieves the PID of the parent process for the specified process.
; Syntax.........: _WinAPI_GetParentProcess ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The PID of the parent process.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetParentProcess($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $hSnapshot = DllCall('kernel32.dll', 'ptr', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)

	If (@error) Or (Not $hSnapshot[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tPROCESSENTRY32 = DllStructCreate('dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]')
	Local $pPROCESSENTRY32 = DllStructGetPtr($tPROCESSENTRY32)
	Local $Ret, $Result = 0

	$hSnapshot = $hSnapshot[0]
	DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
	$Ret = DllCall('kernel32.dll', 'int', 'Process32FirstW', 'ptr', $hSnapshot, 'ptr', $pPROCESSENTRY32)
	While (Not @error) And ($Ret[0])
		If DllStructGetData($tPROCESSENTRY32, 'ProcessID') = $PID Then
			$Result = DllStructGetData($tPROCESSENTRY32, 'ParentProcessID')
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'Process32NextW', 'ptr', $hSnapshot, 'ptr', $pPROCESSENTRY32)
	WEnd
	_WinAPI_CloseHandle($hSnapshot)
	If Not $Result Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_GetParentProcess

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPerformanceInfo
; Description....: Retrieves the performance information.
; Syntax.........: _WinAPI_GetPerformanceInfo ( )
; Parameters.....: None
; Return values..: Success - The array containing the following information:
;
;                            [0] - The memory that currently committed by the system, in bytes.
;                            [1] - The current maximum memory that can be committed by the system without extending the paging file(s), in bytes.
;                            [2] - The maximum memory that were simultaneously in the committed state since the last system reboot, in bytes.
;                            [3] - The amount of actual physical memory, in bytes.
;                            [4] - The amount of physical memory currently available, in bytes.
;                            [5] - The amount of system cache memory, in bytes.
;                            [6] - The sum of the memory currently in the paged and nonpaged kernel pools, in bytes.
;                            [7] - The memory currently in the paged kernel pool, in bytes.
;                            [8] - The memory currently in the nonpaged kernel pool, in bytes.
;                            [9] - The size of a page, in bytes.
;                           [10] - The current number of open handles.
;                           [11] - The current number of processes.
;                           [12] - The current number of threads.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetPerformanceInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPerformanceInfo()

	Local $tPI = DllStructCreate('dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;dword;dword;dword')
	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'GetPerformanceInfo', 'ptr', DllStructGetPtr($tPI), 'dword', DllStructGetSize($tPI))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[13]

	For $i = 0 To 12
		$Result[$i] = DllStructGetData($tPI, $i + 2)
	Next
	For $i = 0 To 8
		$Result[$i] *= $Result[9]
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetPerformanceInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPhysicallyInstalledSystemMemory
; Description....: Retrieves the amount of RAM that is physically installed on the computer.
; Syntax.........: _WinAPI_GetPhysicallyInstalledSystemMemory (  )
; Parameters.....: none
; Return values..: Success - returns TotalMemory In Kilobytes
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetPhysicallyInstalledSystemMemory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPhysicallyInstalledSystemMemory()
	Local $aRet = DllCall("Kernel32.dll", "int", "GetPhysicallyInstalledSystemMemory", "uint64*", "")
	If (@error) Or (Not $aRet[1]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $aRet[1]
EndFunc   ;==>_WinAPI_GetPhysicallyInstalledSystemMemory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPixel
; Description....: Retrieves the color value of the pixel at the specified coordinates.
; Syntax.........: _WinAPI_GetPixel ( $hDC, $iX, $iY )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical units, of the pixel to be examined.
;                  $iY     - The y-coordinate, in logical units, of the pixel to be examined.
; Return values..: Success - The color of the pixel, in RGB.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetPixel
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPixel($hDC, $iX, $iY)

	Local $Ret = DllCall('gdi32.dll', 'dword', 'GetPixel', 'hwnd', $hDC, 'int', $iX, 'int', $iY)

	If (@error) Or ($Ret[0] = 0xFFFFFFFF) Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_GetPixel

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPolyFillMode
; Description....: Retrieves the current polygon fill mode.
; Syntax.........: _WinAPI_GetPolyFillMode ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The polygon fill mode, which can be one of the following values.
;
;                            $ALTERNATE
;                            $WINDING
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetPolyFillMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPolyFillMode($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetPolyFillMode', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetPolyFillMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPosFromRect
; Description....: Interprets the coordinates of the rectangle as offset and position coordinates.
; Syntax.........: _WinAPI_GetPosFromRect ( $tRECT )
; Parameters.....: $tRECT  - $tagRECT structure that contains the logical coordinates of the rectangle.
; Return values..: Success - The array containing the following parameters:
;
;                            [0] - The x-coordinate of the upper-left corner of the rectangle.
;                            [1] - The y-coordinate of the upper-left corner of the rectangle.
;                            [2] - The width of the rectangle.
;                            [3] - The height of the rectangle.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function is inverse to the _WinAPI_CreateRectEx().
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPosFromRect($tRECT)

	Local $Result[4]

	For $i = 0 To 3
		$Result[$i] = DllStructGetData($tRECT, $i + 1)
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
	Next
	For $i = 2 To 3
		$Result[$i] -= $Result[$i - 2]
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetPosFromRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcAddress
; Description....: Retrieves the address of a function from the specified dynamic-link library (DLL).
; Syntax.........: _WinAPI_GetProcAddress ( $hModule, $sProc )
; Parameters.....: $hModule - Handle to the DLL module that contains the function.
;                  $sProc   - The function name.
; Return values..: Success  - The address of the function.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcAddress
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcAddress($hModule, $sProc)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'GetProcAddress', 'ptr', $hModule, 'str', $sProc)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetProcAddress

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessCommandLine
; Description....: Retrieves the command-line string for the specified process.
; Syntax.........: _WinAPI_GetProcessCommandLine ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The command-line string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function uses undocumented API functions and may stop working properly in future versions of Windows.
;
;                  Using this function for some processes may require full access rights. Use _WinAPI_AdjustTokenPrivileges()
;                  function to enable SeDebugPrivilege privilege before calling _WinAPI_GetProcessCommandLine().
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessCommandLine($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, '')
		EndIf
	EndIf

	Local $Ret, $hProcess, $Error = True

	$Ret = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', 0x00000410, 'int', 0, 'dword', $PID)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf

	$hProcess = $Ret[0]

	Local $tPBI = DllStructCreate('ulong_ptr Reserved1;ptr PebBaseAddress;ulong_ptr Reserved2[2];ulong_ptr UniqueProcessId;ulong_ptr Reserved3')
	Local $tUPP = DllStructCreate('byte Reserved1[16];ulong_ptr Reserved2[12];ptr ImagePathName;ptr CommandLine')
	Local $tCmd = DllStructCreate('wchar[1024]')
	Local $tPEB

	If @OSArch = 'X86' Then
		$tPEB = DllStructCreate('byte Reserved1[2];byte BeingDebugged;byte Reserved2;ulong_ptr Reserved3[2];ptr LoaderData;ptr ProcessParameters;byte Reserved4[104];ulong_ptr Reserved5[52];ptr PostProcessInitRoutine;byte Reserved6[128];ulong_ptr Reserved7;ulong SessionId')
	Else
		$tPEB = DllStructCreate('byte Reserved1[2];byte BeingDebugged;byte Reserved2[21];ptr LoaderData;ptr ProcessParameters;byte Reserved3[520];ptr PostProcessInitRoutine;byte Reserved4[136];ulong SessionId')
	EndIf

	Do
		$Ret = DllCall('ntdll.dll', 'int', 'NtQueryInformationProcess', 'ptr', $hProcess, 'ulong', 0, 'ptr', DllStructGetPtr($tPBI), 'ulong', DllStructGetSize($tPBI), 'ulong*', 0)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'ReadProcessMemory', 'ptr', $hProcess, 'ptr', DllStructGetData($tPBI, 'PebBaseAddress'), 'ptr', DllStructGetPtr($tPEB), 'ulong_ptr', DllStructGetSize($tPEB), 'ulong_ptr*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'ReadProcessMemory', 'ptr', $hProcess, 'ptr', DllStructGetData($tPEB, 'ProcessParameters'), 'ptr', DllStructGetPtr($tUPP), 'ulong_ptr', DllStructGetSize($tUPP), 'ulong_ptr*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'ReadProcessMemory', 'ptr', $hProcess, 'ptr', DllStructGetData($tUPP, 'CommandLine'), 'ptr', DllStructGetPtr($tCmd), 'ulong_ptr', DllStructGetSize($tCmd), 'ulong_ptr*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	_WinAPI_CloseHandle($hProcess)
	If $Error Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tCmd, 1)
EndFunc   ;==>_WinAPI_GetProcessCommandLine

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessCreationTime
; Description....: Retrieves the creation time of the process.
; Syntax.........: _WinAPI_GetProcessCreationTime ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - $tagFILETIME structure that contains the creation time of the process.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessTimes
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessCreationTime($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', 0x00000400, 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tFILETIME = DllStructCreate('dword;dword')
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetProcessTimes', 'ptr', $hProcess[0], 'ptr', DllStructGetPtr($tFILETIME), 'ptr*', 0, 'ptr*', 0, 'ptr*', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tFILETIME
EndFunc   ;==>_WinAPI_GetProcessCreationTime


; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessFileName
; Description....: Retrieves the fully-qualified path of the executable file for the specified process.
; Syntax.........: _WinAPI_GetProcessFileName ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The fully-qualified path to the file.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetModuleFileNameEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessFileName($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, '')
		EndIf
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', 0x00000410, 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, '')
	EndIf

	Local $tPath = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'GetModuleFileNameExW', 'ptr', $hProcess[0], 'ptr', 0, 'ptr', DllStructGetPtr($tPath), 'int', 1024)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tPath, 1)
EndFunc   ;==>_WinAPI_GetProcessFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessHandleCount
; Description....: Retrieves the number of open handles that belong to the specified process.
; Syntax.........: _WinAPI_GetProcessHandleCount ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The number of open handles.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessHandleCount
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessHandleCount($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $Access

	If _WinAPI_GetVersion() < '6.0' Then
		$Access = 0x00000400
	Else
		$Access = 0x00001000
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', $Access, 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetProcessHandleCount', 'ptr', $hProcess[0], 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetProcessHandleCount

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessID
; Description....: Retrieves the process identifier of the specified process.
; Syntax.........: _WinAPI_GetProcessID ( $hProcess )
; Parameters.....: $hProcess - Handle to the process. The handle must have the $PROCESS_QUERY_INFORMATION or
;                              $PROCESS_QUERY_LIMITED_INFORMATION access right.
; Return values..: Success   - The process identifier.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessId
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessID($hProcess)

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetProcessId', 'ptr', $hProcess)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetProcessID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessIoCounters
; Description....: Retrieves accounting information for all I/O operations performed by the specified process.
; Syntax.........: _WinAPI_GetProcessIoCounters ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array that contains the following information.
;
;                            [0] - The number of read operations performed.
;                            [1] - The number of write operations performed.
;                            [2] - The number of I/O operations performed, other than read and write operations.
;                            [3] - The number of bytes read.
;                            [4] - The number of bytes written.
;                            [5] - The number of bytes transferred during operations other than read and write operations.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessIoCounters
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessIoCounters($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $Access

	If _WinAPI_GetVersion() < '6.0' Then
		$Access = 0x00000400
	Else
		$Access = 0x00001000
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', $Access, 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tIO_COUNTERS = DllStructCreate('uint64[6]')
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetProcessIoCounters', 'ptr', $hProcess[0], 'ptr', DllStructGetPtr($tIO_COUNTERS))

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[6]

	For $i = 0 To 5
		$Result[$i] = DllStructGetData($tIO_COUNTERS, 1, $i + 1)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetProcessIoCounters

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessMemoryInfo
; Description....: Retrieves information about the memory usage of the specified process.
; Syntax.........: _WinAPI_GetProcessMemoryInfo ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array that contains the following information.
;
;                            [0] - The number of page faults.
;                            [1] - The peak working set size, in bytes.
;                            [2] - The current working set size, in bytes.
;                            [3] - The peak paged pool usage, in bytes.
;                            [4] - The current paged pool usage, in bytes.
;                            [5] - The peak nonpaged pool usage, in bytes.
;                            [6] - The current nonpaged pool usage, in bytes.
;                            [7] - The current space allocated for the pagefile, in bytes.
;                            [8] - The peak space allocated for the pagefile, in bytes.
;                            [9] - The current amount of memory that cannot be shared with other processes, in bytes.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessMemoryInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessMemoryInfo($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', 0x00000410, 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tPMC_EX = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr')
	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'GetProcessMemoryInfo', 'ptr', $hProcess[0], 'ptr', DllStructGetPtr($tPMC_EX), 'int', DllStructGetSize($tPMC_EX))

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[10]

	For $i = 0 To 9
		$Result[$i] = DllStructGetData($tPMC_EX, $i + 2)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetProcessMemoryInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessName
; Description....: Retrieves the name for the specified process.
; Syntax.........: _WinAPI_GetProcessName ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The process name.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessName($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, '')
		EndIf
	EndIf

	Local $hSnapshot = DllCall('kernel32.dll', 'ptr', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)

	If (@error) Or (Not $hSnapshot[0]) Then
		Return SetError(1, 0, '')
	EndIf

	Local $tPROCESSENTRY32 = DllStructCreate('dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]')
	Local $pPROCESSENTRY32 = DllStructGetPtr($tPROCESSENTRY32)
	Local $Ret, $Error = 1

	$hSnapshot = $hSnapshot[0]
	DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
	$Ret = DllCall('kernel32.dll', 'int', 'Process32FirstW', 'ptr', $hSnapshot, 'ptr', $pPROCESSENTRY32)
	While (Not @error) And ($Ret[0])
		If DllStructGetData($tPROCESSENTRY32, 'ProcessID') = $PID Then
			$Error = 0
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'Process32NextW', 'ptr', $hSnapshot, 'ptr', $pPROCESSENTRY32)
	WEnd
	_WinAPI_CloseHandle($hSnapshot)
	If $Error Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tPROCESSENTRY32, 'ExeFile')
EndFunc   ;==>_WinAPI_GetProcessName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessShutdownParameters
; Description....: Retrieves the shutdown parameters for the currently calling process.
; Syntax.........: _WinAPI_GetProcessShutdownParameters ( )
; Parameters.....: None
; Return values..: Success - The shutdown priority level (see _WinAPI_SetProcessShutdownParameters()). If @extended flag is set,
;                            a retry dialog box for the user will be display.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessShutdownParameters
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessShutdownParameters()

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetProcessShutdownParameters', 'dword*', 0, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, Number(Not $Ret[2]), $Ret[1])
EndFunc   ;==>_WinAPI_GetProcessShutdownParameters

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessTimes
; Description....: Retrieves timing information for the specified process.
; Syntax.........: _WinAPI_GetProcessTimes ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array that contains the following information.
;
;                            [0] - $tagFILETIME structure that contains the creation time of the process.
;                            [1] - The time that the process has executed in kernel mode, in 100-nanosecond time units.
;                            [2] - The time that the process has executed in user mode, in 100-nanosecond time units.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessTimes
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessTimes($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $Access

	If _WinAPI_GetVersion() < '6.0' Then
		$Access = 0x00000400
	Else
		$Access = 0x00001000
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', $Access, 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tFILETIME = DllStructCreate($tagFILETIME)
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetProcessTimes', 'ptr', $hProcess[0], 'ptr', DllStructGetPtr($tFILETIME), 'uint64*', 0, 'uint64*', 0, 'uint64*', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[3]

	$Result[0] = $tFILETIME
	$Result[1] = $Ret[4]
	$Result[2] = $Ret[5]

	Return $Result
EndFunc   ;==>_WinAPI_GetProcessTimes

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessUser
; Description....: Retrieves the user and domain name for the specified process.
; Syntax.........: _WinAPI_GetProcessUser ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array that contains the following information.
;
;                            [0] - The user (account) name.
;                            [1] - The domain name.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Using this function for some processes may require full access rights. Use _WinAPI_AdjustTokenPrivileges()
;                  function to enable SeDebugPrivilege privilege before calling _WinAPI_GetProcessUser().
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessUser($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $tSID, $tData, $hProcess, $hToken, $Access, $Ret
	Local $Error = 1

	If _WinAPI_GetVersion() < '6.0' Then
		$Access = 0x00000400
	Else
		$Access = 0x00001000
	EndIf

	$hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', $Access, 'int', 0, 'dword', $PID)
	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Do
		$hToken = _WinAPI_OpenProcessToken(0x00000008, $hProcess[0])
		If Not $hToken Then
			ExitLoop
		EndIf
		$tSID = DllStructCreate('ptr;byte[1024]')
		$Ret = DllCall('advapi32.dll', 'int', 'GetTokenInformation', 'ptr', $hToken, 'uint', 1, 'ptr', DllStructGetPtr($tSID), 'dword', DllStructGetSize($tSID), 'dword*', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$tData = DllStructCreate('wchar[1024];wchar[1024]')
		$Ret = DllCall('advapi32.dll', 'int', 'LookupAccountSidW', 'ptr', 0, 'ptr', DllStructGetData($tSID, 1), 'ptr', DllStructGetPtr($tData, 1), 'dword*', 1024, 'ptr', DllStructGetPtr($tData, 2), 'dword*', 1024, 'uint*', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	If $hToken Then
		_WinAPI_CloseHandle($hToken)
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If $Error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[2]

	For $i = 0 To 1
		$Result[$i] = DllStructGetData($tData, $i + 1)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetProcessUser

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessWindowStation
; Description....: Retrieves a handle to the current window station for the calling process.
; Syntax.........: _WinAPI_GetProcessWindowStation ( )
; Parameters.....: None
; Return values..: Success    - Handle to the window station for the current process.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Do not close the handle returned by this function.
; Related........:
; Link...........: @@MsdnLink@@ GetProcessWindowStation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessWindowStation()

	Local $Ret = DllCall('user32.dll', 'ptr', 'GetProcessWindowStation')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetProcessWindowStation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessWorkingDirectory
; Description....: Retrieves the the current working directory for the specified process.
; Syntax.........: _WinAPI_GetProcessWorkingDirectory ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The path to the working directory.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function uses undocumented API functions and may stop working properly in future versions of Windows.
;
;                  Using this function for some processes may require full access rights. Use _WinAPI_AdjustTokenPrivileges()
;                  function to enable "SeDebugPrivilege" privilege before calling this function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessWorkingDirectory($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, '')
		EndIf
	EndIf

	Local $Ret, $hProcess, $Error = True

	$Ret = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', 0x00000410, 'int', 0, 'dword', $PID)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf

	$hProcess = $Ret[0]

	Local $tPBI = DllStructCreate('ulong_ptr Reserved1;ptr PebBaseAddress;ulong_ptr Reserved2[2];ulong_ptr UniqueProcessId;ulong_ptr Reserved3')
	Local $tUPP = DllStructCreate('byte Reserved1[16];ulong_ptr Reserved2[6];ptr CurrentDirectory;ptr Reserved3[7]')
	Local $tWD = DllStructCreate('wchar[1024]')
	Local $tPEB

	If @OSArch = 'X86' Then
		$tPEB = DllStructCreate('byte Reserved1[2];byte BeingDebugged;byte Reserved2;ulong_ptr Reserved3[2];ptr LoaderData;ptr ProcessParameters;byte Reserved4[104];ulong_ptr Reserved5[52];ptr PostProcessInitRoutine;byte Reserved6[128];ulong_ptr Reserved7;ulong SessionId')
	Else
		$tPEB = DllStructCreate('byte Reserved1[2];byte BeingDebugged;byte Reserved2[21];ptr LoaderData;ptr ProcessParameters;byte Reserved3[520];ptr PostProcessInitRoutine;byte Reserved4[136];ulong SessionId')
	EndIf

	Do
		$Ret = DllCall('ntdll.dll', 'int', 'NtQueryInformationProcess', 'ptr', $hProcess, 'ulong', 0, 'ptr', DllStructGetPtr($tPBI), 'ulong', DllStructGetSize($tPBI), 'ulong*', 0)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'ReadProcessMemory', 'ptr', $hProcess, 'ptr', DllStructGetData($tPBI, 'PebBaseAddress'), 'ptr', DllStructGetPtr($tPEB), 'ulong_ptr', DllStructGetSize($tPEB), 'ulong_ptr*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'ReadProcessMemory', 'ptr', $hProcess, 'ptr', DllStructGetData($tPEB, 'ProcessParameters'), 'ptr', DllStructGetPtr($tUPP), 'ulong_ptr', DllStructGetSize($tUPP), 'ulong_ptr*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'ReadProcessMemory', 'ptr', $hProcess, 'ptr', DllStructGetData($tUPP, 'CurrentDirectory'), 'ptr', DllStructGetPtr($tWD), 'ulong_ptr', DllStructGetSize($tWD), 'ulong_ptr*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	_WinAPI_CloseHandle($hProcess)
	If $Error Then
		Return SetError(1, 0, '')
	EndIf
	Return _WinAPI_PathRemoveBackslash(DllStructGetData($tWD, 1))
EndFunc   ;==>_WinAPI_GetProcessWorkingDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProfilesDirectory
; Description....: Retrieves the path to the root directory where all user profiles are stored.
; Syntax.........: _WinAPI_GetProfilesDirectory ( )
; Parameters.....: None
; Return values..: Success - The path to the profiles directory.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProfilesDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProfilesDirectory()

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('userenv.dll', 'int', 'GetProfilesDirectoryW', 'ptr', DllStructGetPtr($tData), 'dword*', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetProfilesDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPwrCapabilities
; Description....: Retrieves information about the system power capabilities.
; Syntax.........: _WinAPI_GetPwrCapabilities ( )
; Parameters.....: None
; Return values..: Success - The array that contains the following information:
;
;                            [0 ] - If TRUE, there is a system power button.
;                            [1 ] - If TRUE, there is a system sleep button.
;                            [2 ] - If TRUE, there is a lid switch.
;                            [3 ] - If TRUE, the operating system supports sleep state S1.
;                            [4 ] - If TRUE, the operating system supports sleep state S2.
;                            [5 ] - If TRUE, the operating system supports sleep state S3.
;                            [6 ] - If TRUE, the operating system supports sleep state S4 (hibernation).
;                            [7 ] - If TRUE, the operating system supports power off state S5 (soft off).
;                            [8 ] - If TRUE, the system hibernation file is present.
;                            [9 ] - If TRUE, the system supports wake capabilities.
;                            [10] - If TRUE, the system supports video display dimming capabilities.
;                            [11] - If TRUE, the system supports APM BIOS power management features.
;                            [12] - If TRUE, there is an uninterruptible power supply (UPS).
;                            [13] - If TRUE, the system supports thermal zones.
;                            [14] - If TRUE, the system supports processor throttling.
;                            [15] - The minimum level of system processor throttling supported, expressed as a percentage.
;                            [16] - The maximum level of system processor throttling supported, expressed as a percentage.
;                            [17] - If TRUE, the system supports the hybrid sleep state.
;                            [18] - If TRUE, the system supports allowing the removal of power to fixed disk devices.
;                            [19] - If TRUE, there are one or more batteries in the system.
;                            [20] - If TRUE, the system batteries are short-term. Short-term batteries are used in uninterruptible power supplies (UPS).
;                            [21] - The lowest system sleep state (Sx) that will generate a wake event when the system is on AC power.
;                            [22] - The lowest system sleep state (Sx) that will generate a wake event via the lid switch.
;                            [23] - The lowest system sleep state (Sx) supported by hardware that will generate a wake event via the RTC.
;                            [24] - The minimum allowable system power state supporting wake events.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetPwrCapabilities
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPwrCapabilities()

	If Not __DLL('powrprof.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	Local $tSPC = DllStructCreate('byte[18];byte[3];byte;byte[8];byte[2];ulong[6];ulong[5]')
	Local $Ret = DllCall('powrprof.dll', 'int', 'GetPwrCapabilities', 'ptr', DllStructGetPtr($tSPC))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[25]

	For $i =  0 to 17
		$Result[$i] = DllStructGetData($tSPC, 1, $i + 1)
	Next
	$Result[18] = DllStructGetData($tSPC, 3)
	For $i = 19 to 20
		$Result[$i] = DllStructGetData($tSPC, 5, $i - 18)
	Next
	For $i = 21 to 24
		$Result[$i] = DllStructGetData($tSPC, 7, $i - 20)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetPwrCapabilities

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetRegionData
; Description....: Fills the specified buffer with data describing a region.
; Syntax.........: _WinAPI_GetRegionData ( $hRgn, ByRef $tRGNDATA )
; Parameters.....: $hRgn     - Handle to the region.
;                  $tRGNDATA - $tagRGNDATA structure that receives the region data in logical units.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetRegionData
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetRegionData($hRgn, ByRef $tRGNDATA)

	Local $Ret

	$Ret = DllCall('gdi32.dll', 'dword', 'GetRegionData', 'ptr', $hRgn, 'dword', 0, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		$tRGNDATA = 0
		Return SetError(1, 0, 0)
	EndIf
	If $Ret[0] > 32 Then
		$tRGNDATA = DllStructCreate($tagRGNDATAHEADER & 'byte[' & ($Ret[0] - 32) & ']')
	Else
		$tRGNDATA = DllStructCreate($tagRGNDATAHEADER)
	EndIf
	$Ret = DllCall('gdi32.dll', 'dword', 'GetRegionData', 'ptr', $hRgn, 'dword', $Ret[0], 'ptr', DllStructGetPtr($tRGNDATA))
	If (@error) Or (Not $Ret[0]) Then
		$tRGNDATA = 0
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_GetRegionData

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetRegKeyNameByHandle
; Description....: Retrieves a name for the specified registry key.
; Syntax.........: _WinAPI_GetRegKeyNameByHandle ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key.
; Return values..: Success - The name of the key.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ ZwQueryKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetRegKeyNameByHandle($hKey)

	Local $tKNI = DllStructCreate('ulong;wchar[2048]')
	Local $Ret = DllCall('ntdll.dll', 'uint', 'ZwQueryKey', 'ulong_ptr', $hKey, 'uint', 3, 'ptr', DllStructGetPtr($tKNI), 'ulong', DllStructGetSize($tKNI), 'ulong*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return DllStructGetData($tKNI, 2)
EndFunc   ;==>_WinAPI_GetRegKeyNameByHandle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetRgnBox
; Description....: Retrieves the bounding rectangle of the specified region.
; Syntax.........: _WinAPI_GetRgnBox ( $hRgn, ByRef $tRECT )
; Parameters.....: $hRgn   - Handle to the region.
;                  $tRECT  - $tagRECT structure that receives the bounding rectangle in logical units.
; Return values..: Success - The value that specifies the region's complexity. It can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetRgnBox
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetRgnBox($hRgn, ByRef $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetRgnBox', 'ptr', $hRgn, 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetRgnBox

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetROP2
; Description....: Retrieves the foreground mix mode of the specified device context.
; Syntax.........: _WinAPI_GetROP2 ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The value that specifies the foreground mix mode ($R2_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetROP2
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetROP2($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetROP2', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetROP2

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetRValue
; Description....: Retrieves an intensity value for the red component of a 32-bit RGB value.
; Syntax.........: _WinAPI_GetRValue ( $iRGB )
; Parameters.....: $iRGB - The color value, in RGB.
; Return values..: The intensity of the red component of the specified RGB color.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetRValue($iRGB)
	Return BitAND(__RGB($iRGB), 0x0000FF)
EndFunc   ;==>_WinAPI_GetRValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetShellWindow
; Description....: Retrieves a handle to the Shell's desktop window.
; Syntax.........: _WinAPI_GetShellWindow ( )
; Parameters.....: None
; Return values..: Success - The handle of the Shell's desktop window.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetShellWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetShellWindow()

	Local $Ret = DllCall('user32.dll', 'hwnd', 'GetShellWindow')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetShellWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetStartupInfo
; Description....: Retrieves the contents of the STARTUPINFO structure that was specified when the calling process was created.
; Syntax.........: _WinAPI_GetStartupInfo ( )
; Parameters.....: None
; Return values..: Success - $tagSTARTUPINFO structure that contains the startup information.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetStartupInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetStartupInfo()

	Local $tSI = DllStructCreate($tagSTARTUPINFO)

	DllCall('kernel32.dll', 'none', 'GetStartupInfoW', 'ptr', DllStructGetPtr($tSI))
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tSI
EndFunc   ;==>_WinAPI_GetStartupInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetString
; Description....: Returns a string located at the specified memory address.
; Syntax.........: _WinAPI_GetString ( $pString [, $fUnicode] )
; Parameters.....: $pString  - Pointer to a null-terminated string.
;                  $fUnicode - Specifies whether a string is Unicode or ASCII code of a character, valid values:
;                  |TRUE     - Unicode. (Default)
;                  |FALSE    - ASCII.
; Return values..: Success   - A string. @extended returns the lenght of the string, in TCHARs (not including the null-terminating character).
;                  Failure   - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the pointer is incorrect, _WinAPI_GetString() does not set @error flag but always returns an empty string.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetString($pString, $fUnicode = 1)

	Local $Lenght = _WinAPI_StrLen($pString, $fUnicode)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	If Not $Lenght Then
		Return ''
	EndIf

	Local $tString = DllStructCreate(__Iif($fUnicode, 'wchar', 'char') & '[' & ($Lenght + 1) & ']', $pString)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return SetError(0, $Lenght + 1, DllStructGetData($tString, 1))
EndFunc   ;==>_WinAPI_GetString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemDefaultLCID
; Description....: Returns the locale identifier (LCID) for the system locale.
; Syntax.........: _WinAPI_GetSystemDefaultLCID ( )
; Parameters.....: None
; Return values..: Success - The default LCID for the system.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: WideBoyDixon
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetSystemDefaultLCID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemDefaultLCID()

	Local $Ret = DllCall('kernel32.dll', 'long', 'GetSystemDefaultLCID')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetSystemDefaultLCID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemDEPPolicy
; Description....: Gets the data execution prevention (DEP) policy setting for the system.
; Syntax.........: _WinAPI_GetSystemDEPPolicy ( )
; Parameters.....:
; Return values..: Success  - returns a value of type DEP_SYSTEM_POLICY_TYPE, which can be one of the following values
;                             0 - DEP is disabled for all parts of the system, regardless of hardware support for DEP.
;                                 The processor runs in PAE mode with 32-bit versions of Windows unless PAE is disabled in the boot configuration data.
;                             1 - DEP is enabled for all parts of the system. All processes always run with DEP enabled.
;                                 DEP cannot be explicitly disabled for selected applications. System compatibility fixes are ignored.
;                             2 - On systems with processors that are capable of hardware-enforced DEP, DEP is automatically enabled only for operating system components.
;                                 This is the default setting for client versions of Windows. DEP can be explicitly enabled for selected applications or the current process.
;                             3 - DEP is automatically enabled for operating system components and all processes. This is the default setting for Windows Server versions.
;                                 DEP can be explicitly disabled for selected applications or the current process. System compatibility fixes for DEP are in effect.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Windows Vista with SP1, Windows XP with SP3
; Related........:
; Link...........: @@MsdnLink@@ GetSystemDEPPolicy
; Example........: Yes
; #FUNCTION# ====================================================================================================================
Func _WinAPI_GetSystemDEPPolicy()
	Local $Ret = DllCall("Kernel32.dll", "INT", "GetSystemDEPPolicy")
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetSystemDEPPolicy

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemInfo
; Description....: Retrieves information about the current system.
; Syntax.........: _WinAPI_GetSystemInfo ( )
; Parameters.....: None
; Return values..: Success - The array containing the following information:
;
;                  [0] - The processor architecture of the installed operating system ($PROCESSOR_ARCHITECTURE_*).
;                  [1] - The page size and the granularity of page protection and commitment.
;                  [2] - A pointer to the lowest memory address accessible to applications and dynamic-link libraries (DLLs).
;                  [3] - A pointer to the highest memory address accessible to applications and DLLs.
;                  [4] - A mask representing the set of processors configured into the system. Bit 0 is processor 0; bit 31 is processor 31.
;                  [5] - The number of physical processors in the system.
;                  [6] - An obsolete member that is retained for compatibility ($PROCESSOR_*).
;                  [7] - The granularity for the starting address at which virtual memory can be allocated.
;                  [8] - The architecture-dependent processor level.
;                  [9] - The architecture-dependent processor revision (0x0000xxyy; xx - model; yy - stepping).
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetSystemInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemInfo()

	Local $Proc

	If _WinAPI_IsWow64Process() Then
		$Proc = 'GetNativeSystemInfo'
	Else
		$Proc = 'GetSystemInfo'
	EndIf

	Local $tagSYSTEMINFO = DllStructCreate('ushort;ushort;dword;ptr;ptr;dword_ptr;dword;dword;dword;ushort;ushort')

	DllCall('kernel32.dll', 'none', $Proc, 'ptr', DllStructGetPtr($tagSYSTEMINFO))
	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[10]

	$Result[0] = DllStructGetData($tagSYSTEMINFO, 1)
	For $i = 1 To 9
		$Result[$i] = DllStructGetData($tagSYSTEMINFO, $i + 2)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetSystemInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemPowerStatus
; Description....: Retrieves the power status of the system.
; Syntax.........: _WinAPI_GetSystemPowerStatus ( )
; Parameters.....: None
; Return values..: Success - The array containing the following parameters:
;
;                            [0] - The AC power status. This member can be one of the following values.
;                                    0 - Offline
;                                    1 - Online
;                                  255 - Unknown status
;                            [1] - The battery charge status. This member can contain one or more of the following flags.
;                                    0 - The battery is not being charged and the battery capacity is between low and high.
;                                    1 - High - the battery capacity is at more than 66 percent
;                                    2 - Low - the battery capacity is at less than 33 percent
;                                    4 - Critical - the battery capacity is at less than five percent
;                                    8 - Charging
;                                  128 - No system battery
;                                  255 - Unknown status - unable to read the battery flag information
;                            [2] - The percentage of full battery charge remaining. This member can be a value in the range 0 to 100,
;                                  or 255 if status is unknown.
;                            [3] - The number of seconds of battery life remaining, or (?) if remaining seconds are unknown.
;                            [4] - The number of seconds of battery life when at full charge, or (?) if full battery
;                                  lifetime is unknown.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetSystemPowerStatus
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemPowerStatus()

	Local $tSYSTEM_POWER_STATUS = DllStructCreate('byte;byte;byte;byte;dword;dword')
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetSystemPowerStatus', 'ptr', DllStructGetPtr($tSYSTEM_POWER_STATUS))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[5]

	$Result[0] = DllStructGetData($tSYSTEM_POWER_STATUS, 1)
	$Result[1] = DllStructGetData($tSYSTEM_POWER_STATUS, 2)
	$Result[2] = DllStructGetData($tSYSTEM_POWER_STATUS, 3)
	$Result[3] = DllStructGetData($tSYSTEM_POWER_STATUS, 5)
	$Result[4] = DllStructGetData($tSYSTEM_POWER_STATUS, 6)

	For $i = 3 To 4
		If _WinAPI_DWordToInt($Result[$i]) = -1 Then
			$Result[$i] = -1
		EndIf
	Next

	Return $Result
EndFunc   ;==>_WinAPI_GetSystemPowerStatus

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemTimes
; Description....: Retrieves system timing information.
; Syntax.........: _WinAPI_GetSystemTimes ( )
; Parameters.....: None
; Return values..: Success - The array that contains the following information.
;
;                            [0] - The time that the system has been idle.
;                            [1] - The time that the system has spent executing in kernel mode, in 100-nanosecond time units.
;                            [2] - The time that the system has spent executing in user mode, in 100-nanosecond time units.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: On a multiprocessor system, the _WinAPI_GetSystemTimes() returns a values are the sum of the designated times
;                  across all processors.
; Related........:
; Link...........: @@MsdnLink@@ GetSystemTimes
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemTimes()

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetSystemTimes', 'uint64*', 0, 'uint64*', 0, 'uint64*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[3]

	For $i = 0 To 2
		$Result[$i] = $Ret[$i + 1]
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetSystemTimes

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemWow64Directory
; Description....: Retrieves the path of the system directory used by WOW64.
; Syntax.........: _WinAPI_GetSystemWow64Directory ( )
; Parameters.....: None
; Return values..: Success - The path of the system directory. This path does not end with a backslash.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This directory is not present on 32-bit Windows.
; Related........:
; Link...........: @@MsdnLink@@ GetSystemWow64Directory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemWow64Directory()

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('kernel32.dll', 'uint', 'GetSystemWow64DirectoryW', 'ptr', DllStructGetPtr($tData), 'uint', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetSystemWow64Directory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTcpTable
; Description....: retrieves the IPv4 TCP connection table.
; Syntax.........: _WinAPI_GetTCPtable( [optional handle to "ws2_32.dll" [, optional handle to "iphlpapi.dll" ] ] )
; Parameters.....:
; Return values..: Success:    TCPtable[][] = 2-D array
;                              [0][0] = number of connections for connection n:
;                              [n][0] = connection state (integer)
;                              [n][1] = local IP
;                              [n][2] = local port
;                              [n][3] = remote IP
;                              [n][4] = remote port
;                              [n][5] = connection state (informative text)
;                  Failure:    TCPtable[0][0] = -1
; Author.........:
; Modified.......:
; Remarks........:
; Related........:
; Link...........: @@MsdnLink@@ GetTcpTable, MIB_TCPTABLE
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTcpTable()

	Local $TCPtable[1][1] = [[-1]] ; preset to "failed"
	Local $dwSize = DllStructCreate("dword") ; for MIB_TCPTABLE buffer size

	Local $MIB_TCPTABLE = DllStructCreate("dword") ; nominal struct initially
	DllStructSetData($dwSize, 1, 0) ; force zero size
	Local $Ret = DllCall("iphlpapi.dll", "int", "GetTcpTable", "ptr", DllStructGetPtr($MIB_TCPTABLE), "ptr", DllStructGetPtr($dwSize), "int", 1) ; get size
	If @error Or $Ret[0] <> 122 Then Return $TCPtable ; dllCall error or RC is *not* ERROR_INSUFFICIENT_BUFFER = 122

	$MIB_TCPTABLE = ""
	For $i = 1 To DllStructGetData($dwSize, 1) / 4 ; make to requested size of buffer
		$MIB_TCPTABLE &= "dword;"
	Next
	$MIB_TCPTABLE = DllStructCreate(StringTrimRight($MIB_TCPTABLE, 1)) ; requested struct
	DllStructSetData($dwSize, 1, DllStructGetSize($MIB_TCPTABLE)) ; recheck its size
	$Ret = DllCall("iphlpapi.dll", "int", "GetTcpTable", "ptr", DllStructGetPtr($MIB_TCPTABLE), "ptr", DllStructGetPtr($dwSize), "int", 1) ; get data
	If @error Or $Ret[0] Then Return $TCPtable ; dllCall error or RC is Error

	Local $numTCPentries = DllStructGetData($MIB_TCPTABLE, 1) ; number of entries
	ReDim $TCPtable[$numTCPentries + 1][6]

	For $i = 1 To $numTCPentries
		Local $offset = ($i - 1) * 5 + 1 ; dword offset into struct
		$TCPtable[$i][0] = DllStructGetData($MIB_TCPTABLE, $offset + 1) ; integer connection state

		$Ret = DllCall("ws2_32.dll", "str", "inet_ntoa", "uint", DllStructGetData($MIB_TCPTABLE, $offset + 2)) ; local IP / translate
		If @error Then Return $TCPtable ; dllCall error
		$TCPtable[$i][1] = $Ret[0]
		$Ret = DllCall("ws2_32.dll", "ushort", "ntohs", "uint", DllStructGetData($MIB_TCPTABLE, $offset + 3)) ; local port / translate
		If @error Then Return $TCPtable ; dllCall error
		$TCPtable[$i][2] = $Ret[0]

		If $TCPtable[$i][0] <= 2 Then ; CLOSED or LISTENING state
			$TCPtable[$i][3] = "0.0.0.0"
			$TCPtable[$i][4] = 0
		Else
			$Ret = DllCall("ws2_32.dll", "str", "inet_ntoa", "uint", DllStructGetData($MIB_TCPTABLE, $offset + 4)) ; remote IP / translate
			If @error Then Return $TCPtable ; dllCall error
			$TCPtable[$i][3] = $Ret[0]
			$Ret = DllCall("ws2_32.dll", "ushort", "ntohs", "uint", DllStructGetData($MIB_TCPTABLE, $offset + 5)) ; remote port / translate
			If @error Then Return $TCPtable ; dllCall error
			$TCPtable[$i][4] = $Ret[0]
		EndIf
	Next

	$dwSize = 0
	$MIB_TCPTABLE = 0
	$TCPtable[0][0] = $numTCPentries ; success
	Return $TCPtable

EndFunc   ;==>_WinAPI_GetTcpTable

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTempFileName
; Description....: Creates a name for a temporary file.
; Syntax.........: _WinAPI_GetTempFileName ( $sPath [, $sPrefix] )
; Parameters.....: $sPath   - The directory path for the file name. Applications typically specify a period (.) for the current directory.
;                  $sPrefix - The prefix string. The function uses up to the first three characters of this string as the prefix of the
;                             file name.
; Return values..: Success  - The temporary file name.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Temporary files whose names have been created by this function are not automatically deleted.
; Related........:
; Link...........: @@MsdnLink@@ GetTempFileName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTempFileName($sPath, $sPrefix = '')

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('kernel32.dll', 'uint', 'GetTempFileNameW', 'wstr', $sPath, 'wstr', $sPrefix, 'uint', 0, 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetTempFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTextAlign
; Description....: Retrieves the text-alignment setting for the specified device context.
; Syntax.........: _WinAPI_GetTextAlign ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The status of the text-alignment flags. The return value is a combination of the $TA_* and $VTA_* constants.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTextAlign
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTextAlign($hDC)

	Local $Ret = DllCall('gdi32.dll', 'uint', 'GetTextAlign', 'hwnd', $hDC)

	If (@error) Or ($Ret[0] = 0xFFFFFFFF) Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetTextAlign

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTextColor
; Description....: Retrieves the current text color for the specified device context.
; Syntax.........: _WinAPI_GetTextColor ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The value of the current text color, in RGB.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTextColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTextColor($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetTextColor', 'hwnd', $hDC)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_GetTextColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTextFace
; Description....: Retrieves the typeface name of the font that is selected into the specified device context.
; Syntax.........: _WinAPI_GetTextFace ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The typeface name.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTextFace
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTextFace($hDC)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetTextFaceW', 'hwnd', $hDC, 'int', 1024, 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetTextFace

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTextMetrics
; Description....: Retrieves basic information for the currently selected font.
; Syntax.........: _WinAPI_GetTextMetrics ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - $tagTEXTMETRIC structure that contains the information about the currently selected font.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTextMetrics
; Example........: Yes
; ===============================================================================================================================
#cs
Func _WinAPI_GetTextMetrics($hDC)

	;	Local $tTEXTMETRIC = DllStructCreate($tagTEXTMETRIC)
	Local $tTEXTMETRIC = DllStructCreate('long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;byte tmPitchAndFamily;byte tmCharSet')
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetTextMetricsW', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tTEXTMETRIC))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tTEXTMETRIC
EndFunc   ;==>_WinAPI_GetTextMetrics
#ce
; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeAppProperties
; Description....: Retrieves the property flags that control how visual styles are applied in the current application.
; Syntax.........: _WinAPI_GetThemeAppProperties ( )
; Parameters.....: None
; Return values..: Success - The property bit flags ($STAP_ALLOW_*) combined with a logical OR operator.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Individual flags can be extracted from the result by combining the result with the logical
;                  AND of the desired flag.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeAppProperties
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeAppProperties()

	Local $Ret = DllCall('uxtheme.dll', 'int', 'GetThemeAppProperties')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThemeAppProperties

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeBackgroundContentRect
; Description....: Retrieves the size of the content area for the background defined by the visual style.
; Syntax.........: _WinAPI_GetThemeBackgroundContentRect ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the content area.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context to use when drawing.
;                  $tRECT    - $tagRECT structure that contains the total background rectangle. This is the area inside the borders or margins.
; Return values..: Success   - $tagRECT structure that contains the content area background rectangle.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeBackgroundContentRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeBackgroundContentRect($hTheme, $iPartId, $iStateId, $hDC, $tRECT)

	Local $tAREA = DllStructCreate($tagRECT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeBackgroundContentRect', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tAREA))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tAREA
EndFunc   ;==>_WinAPI_GetThemeBackgroundContentRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeBackgroundExtent
; Description....: Calculates the size and location of the background, defined by the visual style, given the content area.
; Syntax.........: _WinAPI_GetThemeBackgroundExtent ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the content area.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context to use when drawing.
;                  $tRECT    - $tagRECT structure that contains the content background rectangle.
; Return values..: Success   - $tagRECT structure that contains the background rectangle.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeBackgroundExtent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeBackgroundExtent($hTheme, $iPartId, $iStateId, $hDC, $tRECT)

	Local $tAREA = DllStructCreate($tagRECT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeBackgroundExtent', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tAREA))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tAREA
EndFunc   ;==>_WinAPI_GetThemeBackgroundExtent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeBackgroundRegion
; Description....: Computes the region for a regular or partially transparent background that is bounded by a specified rectangle.
; Syntax.........: _WinAPI_GetThemeBackgroundRegion ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the region.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context to draw into.
;                  $tRECT    - $tagRECT structure that contains the specified rectangle used to compute the region.
; Return values..: Success   - Handle to the computed region.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The region handle that is returned by this function should be released when it is no longer needed,
;                  using _WinAPI_DeleteObject().
; Related........:
; Link...........: @@MsdnLink@@ GetThemeBackgroundRegion
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeBackgroundRegion($hTheme, $iPartId, $iStateId, $hDC, $tRECT)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeBackgroundRegion', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[6]
EndFunc   ;==>_WinAPI_GetThemeBackgroundExtent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeBitmap
; Description....: Retrieves the bitmap associated with a particular theme, part, state, and property.
; Syntax.........: _WinAPI_GetThemeBitmap ( $hTheme, $iPartId, $iStateId, $iPropId [, $iFlag] )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the bitmap.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve. Set this parameter to 0 to automatically select the first available bitmap
;                              for this part and state, or use one of the following values.
;
;                              $TMT_DIBDATA
;                              $TMT_GLYPHDIBDATA
;                              $TMT_HBITMAP
;
;                  $iFlag    - This parameter can be one of the following values.
;
;                              $GBF_DIRECT
;                              $GBF_COPY
;                              $GBF_VALIDBITS
;
; Return values..: Success   - Handle to the requested bitmap.
;                  Failure   - (-1) and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If $iFlag is set to $GBF_COPY, release the bitmap returned by this function when no longer needed by calling
;                  _WinAPI_DeleteObject().
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeBitmap
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeBitmap($hTheme, $iPartId, $iStateId, $iPropId, $iFlag = 0x01)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeBitmap', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'ulong', $iFlag, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
		ConsoleWrite(Hex($Ret[0]) & @CR)
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[6]
EndFunc   ;==>_WinAPI_GetThemeBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeBool
; Description....: Retrieves the value of a BOOL property from the SysMetrics section of theme data.
; Syntax.........: _WinAPI_GetThemeBool ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the BOOL property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve. It can be one of the following values.
;
;                              $TMT_TRANSPARENT
;                              $TMT_AUTOSIZE
;                              $TMT_BORDERONLY
;                              $TMT_COMPOSITED
;                              $TMT_BGFILL
;                              $TMT_GLYPHTRANSPARENT
;                              $TMT_GLYPHONLY
;                              $TMT_ALWAYSSHOWSIZINGBAR
;                              $TMT_MIRRORIMAGE
;                              $TMT_UNIFORMSIZING
;                              $TMT_INTEGRALSIZING
;                              $TMT_SOURCEGROW
;                              $TMT_SOURCESHRINK
;                              $TMT_USERPICTURE
;
; Return values..: Success   - The retrieved property value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeBool
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeBool($hTheme, $iPartId, $iStateId, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeBool', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_GetThemeBool

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeColor
; Description....: Retrieves the value of a color property for the specified window.
; Syntax.........: _WinAPI_GetThemeColor ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the color property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve.
; Return values..: Success   - The received color, in RGB.
;                  Failure   - (-1) and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeColor($hTheme, $iPartId, $iStateId, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeColor', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'dword*', 0)

	If @error Then
		Return SetError(1, 0, -1)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], -1)
		EndIf
	EndIf
	Return __RGB($Ret[5])
EndFunc   ;==>_WinAPI_GetThemeColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeDocumentationProperty
; Description....: Retrieves the value for a theme property from the documentation section of the specified theme file.
; Syntax.........: _WinAPI_GetThemeDocumentationProperty ( $sFile, $sProperty )
; Parameters.....: $sFile     - The name of the theme file that will be opened to query for the property.
;                  $sProperty - The name of the theme property to query. This parameter can be one of the following values.
;
;                               $SZ_THDOCPROP_AUTHOR
;                               $SZ_THDOCPROP_CANONICALNAME
;                               $SZ_THDOCPROP_DISPLAYNAME
;                               $SZ_THDOCPROP_TOOLTIP
;
; Return values..: Success    - The property string value.
;                  Failure    - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeDocumentationProperty
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeDocumentationProperty($sFile, $sProperty)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeDocumentationProperty', 'wstr', $sFile, 'wstr', $sProperty, 'ptr', DllStructGetPtr($tData), 'int', 1024)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetThemeDocumentationProperty

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeEnumValue
; Description....: Retrieves the value of an enumerated type property.
; Syntax.........: _WinAPI_GetThemeEnumValue ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the enumerated type property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
; Return values..: Success   - The enumerated type value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeEnumValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeEnumValue($hTheme, $iPartId, $iStateId, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeEnumValue', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_GetThemeEnumValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeFilename
; Description....: Retrieves the value of a filename property.
; Syntax.........: _WinAPI_GetThemeFilename ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the filename property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
; Return values..: Success   - The retrieved file name.
;                  Failure   - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeFilename
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeFilename($hTheme, $iPartId, $iStateId, $iPropId)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeFilename', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'ptr', DllStructGetPtr($tData), 'int', 1024)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetThemeFilename

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeFont
; Description....: Retrieves the value of a font property.
; Syntax.........: _WinAPI_GetThemeFont ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the font property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve.
; Return values..: Success   - $tagLOGFONT structure that contains a font property value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeFont
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeFont($hTheme, $iPartId, $iStateId, $iPropId)

	Local $tLOGFONT = DllStructCreate($tagLOGFONT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeFont', 'ptr', $hTheme, 'hwnd', 0, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'ptr', DllStructGetPtr($tLOGFONT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tLOGFONT
EndFunc   ;==>_WinAPI_GetThemeFont

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeInt
; Description....: Retrieves the value of an int property.
; Syntax.........: _WinAPI_GetThemeInt ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the int property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve.
; Return values..: Success   - The retrieved value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeInt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeInt($hTheme, $iPartId, $iStateId, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeInt', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_GetThemeInt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeMargins
; Description....: Retrieves the value of a MARGINS property.
; Syntax.........: _WinAPI_GetThemeMargins ( $hTheme, $iPartId, $iStateId, $iPropId, $hDC, $tRECT)
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the MARGINS property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve.
;                  $hDC      - Handle to a device context to select fonts into.
;                  $tRECT    - $tagRECT structure that contains the rectangle that specifies the area to be drawn into.
; Return values..: Success   - $tagMARGINS structure that contains a margins value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeMargins
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeMargins($hTheme, $iPartId, $iStateId, $iPropId, $hDC, $tRECT)

	Local $tMARGINS = DllStructCreate($tagMARGINS)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeMargins', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tMARGINS))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tMARGINS
EndFunc   ;==>_WinAPI_GetThemeMargins

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeMetric
; Description....: Retrieves the value of a metric property.
; Syntax.........: _WinAPI_GetThemeMetric ( $hTheme, $iPartId, $iStateId, $iPropId [, $hDC] )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the metric property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve. It can be one of the following values.
;
;                              $TMT_ALPHALEVEL
;                              $TMT_ALPHATHRESHOLD
;                              $TMT_BORDERSIZE
;                              $TMT_GLYPHINDEX
;                              $TMT_GRADIENTRATIO1
;                              $TMT_GRADIENTRATIO2
;                              $TMT_GRADIENTRATIO3
;                              $TMT_GRADIENTRATIO4
;                              $TMT_GRADIENTRATIO5
;                              $TMT_HEIGHT
;                              $TMT_IMAGECOUNT
;                              $TMT_MINDPI1
;                              $TMT_MINDPI2
;                              $TMT_MINDPI3
;                              $TMT_MINDPI4
;                              $TMT_MINDPI5
;                              $TMT_PROGRESSCHUNKSIZE
;                              $TMT_PROGRESSSPACESIZE
;                              $TMT_ROUNDCORNERWIDTH
;                              $TMT_ROUNDCORNERHEIGHT
;                              $TMT_SATURATION
;                              $TMT_TEXTBORDERSIZE
;                              $TMT_TRUESIZESTRETCHMARK
;                              $TMT_WIDTH
;
;                  $hDC      - Handle to the device context.
; Return values..: Success   - The metric property value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeMetric
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeMetric($hTheme, $iPartId, $iStateId, $iPropId, $hDC = 0)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeMetric', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[6]
EndFunc   ;==>_WinAPI_GetThemeMetric

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemePartSize
; Description....: Calculates the original size of the part defined by a visual style.
; Syntax.........: _WinAPI_GetThemePartSize ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT, $iType )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part part to calculate the size of.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to a device context to select fonts into.
;                  $tRECT    - $tagRECT structure that contains the rectangle used for the part drawing destination.
;                  $iType    - The type of size to retrieve. This parameter can be one of the following values.
;
;                              $TS_MIN
;                              $TS_TRUE
;                              $TS_DRAW
;
; Return values..: Success   - $tagSIZE structure that contains a dimensions of the specified part.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemePartSize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemePartSize($hTheme, $iPartId, $iStateId, $hDC, $tRECT, $iType)

	Local $tSIZE = DllStructCreate($tagSIZE)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemePartSize', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'int', $iType, 'ptr', DllStructGetPtr($tSIZE))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tSIZE
EndFunc   ;==>_WinAPI_GetThemePartSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemePosition
; Description....: Retrieves the value of a position property.
; Syntax.........: _WinAPI_GetThemePosition ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the position property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve.
; Return values..: Success   - $tagPOINT structure that contains a position value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemePosition
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemePosition($hTheme, $iPartId, $iStateId, $iPropId)

	Local $tPOINT = DllStructCreate($tagPOINT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemePosition', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'ptr', DllStructGetPtr($tPOINT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tPOINT
EndFunc   ;==>_WinAPI_GetThemePosition

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemePropertyOrigin
; Description....: Retrieves the location of the theme property definition for a property.
; Syntax.........: _WinAPI_GetThemePropertyOrigin ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the theme.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
; Return values..: Success   - The value that indicates where the property was found. It can be one of the following values.
;
;                              0 - Property was found in the state section.
;                              1 - Property was found in the part section.
;                              2 - Property was found in the class section.
;                              3 - Property was found in the list of global variables.
;                              4 - Property was not found.
;
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemePropertyOrigin
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemePropertyOrigin($hTheme, $iPartId, $iStateId, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemePropertyOrigin', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'uint*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then

			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_GetThemePropertyOrigin

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeRect
; Description....: Retrieves the value of a RECT property.
; Syntax.........: _WinAPI_GetThemeRect ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part containing the RECT property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve.
; Return values..: Success   - $tagRECT structure that contains a rectangle.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeRect($hTheme, $iPartId, $iStateId, $iPropId)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeRect', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_GetThemeRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeString
; Description....: Retrieves the value of a string property.
; Syntax.........: _WinAPI_GetThemeString ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the string property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
; Return values..: Success   - The retrieved string value.
;                  Failure   - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeString
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeString($hTheme, $iPartId, $iStateId, $iPropId)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeString', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'ptr', DllStructGetPtr($tData), 'int', 1024)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetThemeString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysBool
; Description....: Retrieves the Boolean value of a system metric.
; Syntax.........: _WinAPI_GetThemeSysBool ( $hTheme, $iBoolId )
; Parameters.....: $hTheme  - Handle to the theme data.
;                  $iBoolId - The value that specifies the system Boolean metric desired. It may be the following value.
;
;                             $TMT_FLATMENUS
;
; Return values..: Success  - The value of desired system metric.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the theme data handle is not 0, this function returns the desired BOOL from the SysMetrics section of the
;                  visual style, otherwise, the function returns the value of the specified system Boolean.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysBool
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysBool($hTheme, $iBoolId)

	Local $Ret = DllCall('uxtheme.dll', 'int', 'GetThemeSysBool', 'ptr', $hTheme, 'int', $iBoolId)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThemeSysBool

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysColor
; Description....: Retrieves the value of a system color.
; Syntax.........: _WinAPI_GetThemeSysColor ( $hTheme, $iColorId )
; Parameters.....: $hTheme   - Handle to the theme data.
;                  $iColorId - The value that specifies the color number. It may be one of the $COLOR_* constants.
; Return values..: Success   - The value of the specified system color.
;                  Failure   - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the theme data handle is not 0, this function returns the color from the SysMetrics section of the current
;                  visual style, otherwise, the function returns the color matching the global system color.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysColor($hTheme, $iColorId)

	Local $Ret = DllCall('uxtheme.dll', 'dword', 'GetThemeSysColor', 'ptr', $hTheme, 'int', $iColorId)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThemeSysColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysColorBrush
; Description....: Retrieves a system color brush.
; Syntax.........: _WinAPI_GetThemeSysColorBrush ( $hTheme, $iColorId )
; Parameters.....: $hTheme   - Handle to the theme data.
;                  $iColorId - The value that specifies the number of the desired system color. It may be one of the following values.
;
;                              $TMT_SCROLLBAR
;                              $TMT_BACKGROUND
;                              $TMT_ACTIVECAPTION
;                              $TMT_INACTIVECAPTION
;                              $TMT_WINDOW
;                              $TMT_WINDOWFRAME
;                              $TMT_MENUTEXT
;                              $TMT_WINDOWTEXT
;                              $TMT_CAPTIONTEXT
;                              $TMT_ACTIVEBORDER
;                              $TMT_INACTIVEBORDER
;                              $TMT_APPWORKSPACE
;                              $TMT_HIGHLIGHT
;                              $TMT_HIGHLIGHTTEXT
;                              $TMT_BTNFACE
;                              $TMT_BTNSHADOW
;                              $TMT_GRAYTEXT
;                              $TMT_BTNTEXT
;                              $TMT_INACTIVECAPTIONTEXT
;                              $TMT_BTNHIGHLIGHT
;                              $TMT_DKSHADOW3D
;                              $TMT_LIGHT3D
;                              $TMT_INFOTEXT
;                              $TMT_INFOBK
;                              $TMT_BUTTONALTERNATEFACE
;                              $TMT_HOTTRACKING
;                              $TMT_GRADIENTACTIVECAPTION
;                              $TMT_GRADIENTINACTIVECAPTION
;                              $TMT_MENUHILIGHT
;                              $TMT_MENUBAR
;
; Return values..: Success   - Handle to the brush.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the theme data handle is not 0, this function returns the brush that matches the specified color from the SysMetrics
;                  section of the visual style, otherwise, the function returns the brush matching the global system color.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysColorBrush
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysColorBrush($hTheme, $iColorId)

	Local $Ret = DllCall('uxtheme.dll', 'ptr', 'GetThemeSysColorBrush', 'ptr', $hTheme, 'int', $iColorId)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThemeSysColorBrush

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysFont
; Description....: Retrieves the font information of a system font.
; Syntax.........: _WinAPI_GetThemeSysFont ( $hTheme, $iFontId )
; Parameters.....: $hTheme  - Handle to the theme data.
;                  $iFontId - The value that specifies a system font. It may be one of the following values.
;
;                             $TMT_CAPTIONFONT
;                             $TMT_SMALLCAPTIONFONT
;                             $TMT_MENUFONT
;                             $TMT_STATUSFONT
;                             $TMT_MSGBOXFONT
;                             $TMT_ICONTITLEFONT
;
; Return values..: Success  - $tagLOGFONT structure that contains the font information.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the theme data handle is not 0, this function returns the font information from the SysMetrics section of the
;                  visual style, otherwise, the function returns the value of the global system metric.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysFont
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysFont($hTheme, $iFontId)

	Local $tLOGFONT = DllStructCreate($tagLOGFONT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeSysFont', 'ptr', $hTheme, 'int', $iFontId, 'ptr', DllStructGetPtr($tLOGFONT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tLOGFONT
EndFunc   ;==>_WinAPI_GetThemeSysFont

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysInt
; Description....: Retrieves the value of a system INT.
; Syntax.........: _WinAPI_GetThemeSysInt ( $hTheme, $iIntId )
; Parameters.....: $hTheme  - Handle to the theme data.
;                  $iBoolId - The value that specifies the desired system INT. It may be the following value.
;
;                             $TMT_MINCOLORDEPTH
;
; Return values..: Success  - The system integer value.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysInt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysInt($hTheme, $iIntId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeSysInt', 'ptr', $hTheme, 'int', $iIntId, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_GetThemeSysInt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysSize
; Description....: Retrieves the value of a system size metric from theme data.
; Syntax.........: _WinAPI_GetThemeSysSize ( $hTheme, $iSizeId )
; Parameters.....: $hTheme  - Handle to the theme data.
;                  $iSizeId - The value that specifies the system size metric desired. The following values are valid.
;
;                             $SM_CXBORDER
;                             $SM_CXVSCROLL
;                             $SM_CXHSCROLL
;                             $SM_CXSIZE
;                             $SM_CYSIZE
;                             $SM_CXSMSIZE
;                             $SM_CYSMSIZE
;                             $SM_CXMENUSIZE
;                             $SM_CYMENUSIZE
;                             $SM_CXPADDEDBORDER
;
; Return values..: Success  - The size in pixels.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If $hTheme is not 0, this function returns the size stored in the current visual style (SysMetrics section
;                  of the visual style) scaled to the current screen dpi. If $hTheme is 0, this function returns the global system
;                  metric in pixels that is scaled to the current dpi only if the application is marked as dpi-aware; otherwise,
;                  the pixels returned are unscaled.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysSize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysSize($hTheme, $iSizeId)

	Local $Ret = DllCall('uxtheme.dll', 'int', 'GetThemeSysSize', 'ptr', $hTheme, 'int', $iSizeId)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThemeSysSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysString
; Description....: Retrieves the value of a system string.
; Syntax.........: _WinAPI_GetThemeSysString ( $hTheme, $iStringId )
; Parameters.....: $hTheme    - Handle to the theme data.
;                  $iStringId - The value that specifies a system string. It may be one of the following values.
;
;                               $TMT_CSSNAME
;                               $TMT_XMLNAME
;
; Return values..: Success    - The string value.
;                  Failure    - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the theme data handle is not 0, this function returns the desired string from the SysMetrics section of the
;                  visual style, otherwise, the function returns the value of the global system metric.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysString
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysString($hTheme, $iStringId)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeSysString', 'ptr', $hTheme, 'int', $iStringId, 'ptr', DllStructGetPtr($tData), 'int', 1024)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetThemeSysString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeTextExtent
; Description....: Calculates the size and location of the specified text when rendered in the visual style font.
; Syntax.........: _WinAPI_GetThemeTextExtent ( $hTheme, $iPartId, $iStateId, $hDC, $sText, $tRECT, $iFlags )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part in which the text will be drawn.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context to select the font into.
;                  $sText    - The string that contains the text to draw.
;                  $tRECT    - $tagRECT structure that contains the rectangle used to control layout of the text. This parameter may be set to 0.
;                  $iFlags   - The string's formatting flags ($DT_*).
; Return values..: Success   - $tagRECT structure that contains, in logical coordinates, the rectangle required to fit the rendered text.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeTextExtent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeTextExtent($hTheme, $iPartId, $iStateId, $hDC, $sText, $tRECT, $iFlags)

	Local $tAREA = DllStructCreate($tagRECT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeTextExtent', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'wstr', $sText, 'int', -1, 'dword', $iFlags, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tAREA))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tAREA
EndFunc   ;==>_WinAPI_GetThemeTextExtent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeTextMetrics
; Description....: Retrieves information about the font specified by a visual style for a particular part.
; Syntax.........: _WinAPI_GetThemeTextMetrics ( $hTheme, $iPartId, $iStateId [, $hDC] )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part to retrieve font information about.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context to use for screen context.
; Return values..: Success   - $tagTEXTMETRIC structure that contains the font information.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeTextMetrics
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeTextMetrics($hTheme, $iPartId, $iStateId, $hDC = 0)

;	Local $tTEXTMETRIC = DllStructCreate($tagTEXTMETRIC)
	Local $tTEXTMETRIC = DllStructCreate('long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;byte tmPitchAndFamily;byte tmCharSet')
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeTextMetrics', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tTEXTMETRIC))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tTEXTMETRIC
EndFunc   ;==>_WinAPI_GetThemeTextMetrics

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeTransitionDuration
; Description....: Gets the duration for the specified transition.
; Syntax.........: _WinAPI_GetThemeTransitionDuration ( $hTheme, $iPartId, $iStateIdFrom, $iStateIdTo, $iPropId )
; Parameters.....: $hTheme       - Handle of the theme data.
;                  $iPartId      - ID of the part.
;                  $iStateIdFrom - The state ID of the part before the transition.
;                  $iStateIdTo   - The state ID of the part after the transition.
;                  $iPropId      - The property ID ($TMT_*).
; Return values..: Success       - The transition duration, in milliseconds.
;                  Failure       - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeTransitionDuration
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeTransitionDuration($hTheme, $iPartId, $iStateIdFrom, $iStateIdTo, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeTransitionDuration', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateIdFrom, 'int', $iStateIdTo, 'int', $iPropId, 'dword*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[6]
EndFunc   ;==>_WinAPI_GetThemeTransitionDuration

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThreadDesktop
; Description....: Retrieves a handle to the desktop assigned to the specified thread.
; Syntax.........: _WinAPI_GetThreadDesktop ( $iThreadID )
; Parameters.....: $iThreadID - The thread identifier. The _WinAPI_CreateProcess() and _WinAPI_GetCurrentThreadID() return thread identifiers.
; Return values..: Success    - Handle to the desktop associated with the specified thread.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: You do not need to call the _WinAPI_CloseDesktop() function to close the returned handle.
; Related........:
; Link...........: @@MsdnLink@@ GetThreadDesktop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThreadDesktop($iThreadID)

	Local $Ret = DllCall('user32.dll', 'ptr', 'GetThreadDesktop', 'dword', $iThreadID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThreadDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThreadErrorMode
; Description....: Retrieves the error mode for the calling thread.
; Syntax.........: _WinAPI_GetThreadErrorMode ( )
; Parameters.....: None
; Return values..: Success - The process error mode ($SEM_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ GetThreadErrorMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThreadErrorMode()

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetThreadErrorMode')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThreadErrorMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTickCount
; Description....: Retrieves the number of milliseconds that have elapsed since the system was started.
; Syntax.........: _WinAPI_GetTickCount ( )
; Parameters.....: None
; Return values..: Success - The number of milliseconds that have elapsed since the system was started.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The time will wrap around to zero if the system is run continuously for 49.7 days. You should check for an
;                  overflow condition when comparing times. To obtain the time elapsed since the computer was started, retrieve the
;                  System Up Time counter in the performance data in the registry key HKEY_PERFORMANCE_DATA.
; Related........:
; Link...........: @@MsdnLink@@ GetTickCount
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTickCount()

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetTickCount')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetTickCount

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTickCount64
; Description....: Retrieves the number of milliseconds that have elapsed since the system was started.
; Syntax.........: _WinAPI_GetTickCount64 ( )
; Parameters.....: None
; Return values..: Success - The number of milliseconds that have elapsed since the system was started.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetTickCount64
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTickCount64()

	Local $Ret = DllCall('kernel32.dll', 'uint64', 'GetTickCount64')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetTickCount64

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTimeFormat
; Description....: Formats time as a time string for a locale specified by identifier.
; Syntax.........: _WinAPI_GetTimeFormat ( [$LCID [, $tSYSTEMTIME [, $iFlag [, $sFormat]]]] )
; Parameters.....: $LCID        - Locale identifier (LCID) that specifies the locale. If this parameter is 0, the function will
;                                 use default locale for the user.
;                  $tSYSTEMTIME - $tagSYSTEMTIME structure that contains the time information to format. If this parameter is 0,
;                                 the function will use the current local system time.
;                  $iFlag       - Flags specifying time format options. This parameter can be one or more of the following values.
;
;                                 $TIME_FORCE24HOURFORMAT
;                                 $TIME_NOMINUTESORSECONDS
;                                 $TIME_NOSECONDS
;                                 $TIME_NOTIMEMARKER
;
;                  $sFormat     - The string that is used to form the time. For example, "hh:mm:ss tt". If this parameter is 0,
;                                 the function returns the string according to the time format for the specified locale ($LCID).
; Return values..: Success      - The formatted time string.
;                  Failure      - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTimeFormat
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTimeFormat($LCID = 0, $tSYSTEMTIME = 0, $iFlags = 0, $sFormat = '')

	Local $TypeOfFormat = 'wstr'

	If Not $LCID Then
		$LCID = 0x0400
	EndIf
	If Not StringStripWS($sFormat, 3) Then
		$TypeOfFormat = 'ptr'
		$sFormat = 0
	EndIf

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetTimeFormatW', 'long', $LCID, 'dword', $iFlags, 'ptr', DllStructGetPtr($tSYSTEMTIME), $TypeOfFormat, $sFormat, 'ptr', DllStructGetPtr($tData), 'int', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetTimeFormat

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTopWindow
; Description....: Retrieves a handle to the child window at the top of the Z order.
; Syntax.........: _WinAPI_GetTopWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the parent window whose child windows are to be examined. If this parameter is 0, the function
;                            returns a handle to the window at the top of the Z order.
; Return values..: Success - Handle to the child window at the top of the Z order. If the specified window has no child windows,
;                            the return value is 0.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTopWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTopWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'GetTopWindow', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetTopWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUpdateRect
; Description....: Retrieves the coordinates of the rectangle that completely encloses the update region of the specified window.
; Syntax.........: _WinAPI_GetUpdateRect ( $hWnd [, $fErase] )
; Parameters.....: $hWnd   - Handle to the window whose update region is to be retrieved.
;                  $fErase - Specifies whether the background in the update region is to be erased, valid values:
;                  |TRUE   - The background is erased. (Default)
;                  |FALSE  - The background remains unchanged.
; Return values..: Success - $tagRECT structure that contains the coordinates of the enclosing rectangle, in device units.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The update rectangle retrieved by the _WinAPI_BeginPaint() function is identical to that retrieved by
;                  _WinAPI_GetUpdateRect()
;
;                  _WinAPI_BeginPaint() automatically validates the update region, so any call to _WinAPI_GetUpdateRect() made
;                   immediately after the call to _WinAPI_BeginPaint() retrieves an empty update region.
; Related........:
; Link...........: @@MsdnLink@@ GetUpdateRect
; Example........: YesNULLREGION
; ===============================================================================================================================

Func _WinAPI_GetUpdateRect($hWnd, $fErase = 1)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'GetUpdateRect', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tRECT), 'int', $fErase)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_GetUpdateRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUpdateRgn
; Description....: Retrieves the update region of a window by copying it into the specified region.
; Syntax.........: _WinAPI_GetUpdateRgn ( $hWnd, $hRgn [, $fErase] )
; Parameters.....: $hWnd   - Handle to the window with an update region that is to be retrieved.
;                  $hRgn   - Handle to the region to receive the update region.
;                  $fErase - Specifies whether the background in the update region is to be erased, valid values:
;                  |TRUE   - The background is erased. (Default)
;                  |FALSE  - The background remains unchanged.
; Return values..: Success - The value that indicates the complexity of the resulting region; it can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_BeginPaint() automatically validates the update region, so any call to _WinAPI_GetUpdateRgn() made
;                  immediately after the call to _WinAPI_BeginPaint() retrieves an empty update region.
; Related........:
; Link...........: @@MsdnLink@@ GetUpdateRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUpdateRgn($hWnd, $hRgn, $fErase = 1)

	Local $Ret = DllCall('user32.dll', 'int', 'GetUpdateRgn', 'hwnd', $hWnd, 'ptr', $hRgn, 'int', $fErase)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetUpdateRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUserDefaultLCID
; Description....: Returns the locale identifier (LCID) for the user default locale.
; Syntax.........: _WinAPI_GetUserDefaultLCID ( )
; Parameters.....: None
; Return values..: Success - The default LCID for the user.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: WideBoyDixon
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetUserDefaultLCID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUserDefaultLCID()

	Local $Ret = DllCall('kernel32.dll', 'long', 'GetUserDefaultLCID')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetUserDefaultLCID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUserObjectInformation
; Description....: Retrieves information about the specified window station or desktop object.
; Syntax.........: _WinAPI_GetUserObjectInformation ( $hObject, $iIndex )
; Parameters.....: $hObject - Handle to the window station or desktop object.
;                  $iIndex  - The information to be retrieved. The parameter can be one of the following values.
;
;                             $UOI_FLAGS
;                             $tagUSEROBJECTFLAGS structure containing information about a window station or desktop handle.
;
;                             $UOI_HEAPSIZE
;                             The size of the desktop heap, in KB.
;
;                             $UOI_IO
;                             1 if the object is a handle to the desktop that is receiving input from the user, 0 otherwise.
;
;                             $UOI_NAME
;                             The name of the object, as a string.
;
;                             $UOI_TYPE
;                             The type of the object, as a string.
;
;                             $UOI_USER_SID
;                             The security identifier (SID) structure as "byte[n]".
;
; Return values..: Success  - The object information. Return type depends on the information type (see above).
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetUserObjectInformation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUserObjectInformation($hObject, $iIndex)

	Local $Ret, $tData

	$Ret = DllCall('user32.dll', 'int', 'GetUserObjectInformationW', 'ptr', $hObject, 'int', $iIndex, 'ptr', 0, 'dword', 0, 'dword*', 0)
	If (@error) Or (Not $Ret[5]) Then
		Return SetError(1, 0, 0)
	EndIf
	Switch $iIndex
		Case 1
			$tData = DllStructCreate($tagUSEROBJECTFLAGS)
		Case 5, 6
			$tData = DllStructCreate('uint')
		Case 2, 3
			$tData = DllStructCreate('wchar[' & $Ret[5] & ']')
		Case 4
			$tData = DllStructCreate('byte[' & $Ret[5] & ']')
		Case Else
			Return SetError(1, 0, 0)
	EndSwitch
	$Ret = DllCall('user32.dll', 'int', 'GetUserObjectInformationW', 'ptr', $hObject, 'int', $iIndex, 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData), 'dword*', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Switch $iIndex
		Case 1, 4
			Return $tData
		Case Else
			Return DllStructGetData($tData, 1)
	EndSwitch
EndFunc   ;==>_WinAPI_GetUserObjectInformation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUserName
; Description....: Retrieves the name of the user associated with the current thread.
; Syntax.........: _WinAPI_GetUserDefaultLCID ( )
; Parameters.....: None
; Return values..: Success - the name of the user associated with the current thread..
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: WideBoyDixon
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetUserName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUserName()

	Local Const $Buffer = DllStructCreate("char lpBuffer[257]")
	Local Const $pBuffer = DllStructGetPtr($Buffer)

	Local Const $Size = DllStructCreate("dword lpnSize")
	DllStructSetData($Size, "lpnSize", 32767)
	Local Const $pSize = DllStructGetPtr($Size)

	#cs BOOL WINAPI GetUserName(
		__out   LPTSTR lpBuffer,
		__inout LPDWORD lpnSize);
	#ce
	DllCall("Advapi32.dll", "bool", "GetUserName", _
			"ptr", $pBuffer, _
			"ptr", $pSize)

	Return DllStructGetData($Buffer, "lpBuffer")
EndFunc   ;==>_WinAPI_GetUserName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetVersion
; Description....: Retrieves version of the current operating system.
; Syntax.........: _WinAPI_GetVersion ( )
; Parameters.....: None
; Return values..: Success - The string containing the current OS version.
;
;                            "6.1" - Windows 7 / Windows Server 2008 R2
;                            "6.0" - Windows Server 2008 / Windows Vista
;                            "5.2" - Windows Server 2003 R2 / Windows Home Server / Windows Server 2003 / Windows XP Professional x64 Edition
;                            "5.1" - Windows XP
;                            "5.0" - Windows 2000
;
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetVersion()

	Local $aRet = _WinAPI_GetVersionEx()

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return $aRet[0] & '.' & $aRet[1]
EndFunc   ;==>_WinAPI_GetVersion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetVersionEx
; Description....: Retrieves information about the current operating system.
; Syntax.........: _WinAPI_GetVersionEx ( )
; Parameters.....: None
; Return values..: Success - $tagOSVERSIONINFOEX structure that contains the information about the current operating system.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When using the GetVersionEx function to determine whether your application is running on a particular version of
;                  the operating system, check for version numbers that are greater than or equal to the desired version numbers.
;                  This ensures that the test succeeds for later versions of the operating system.
; Related........:
; Link...........: @@MsdnLink@@ GetVersionEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetVersionEx()

	Local $tOSVERSIONINFOEX = DllStructCreate($tagOSVERSIONINFOEX)

	DllStructSetData($tOSVERSIONINFOEX, 'OSVersionInfoSize', DllStructGetSize($tOSVERSIONINFOEX))

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetVersionExW', 'ptr', DllStructGetPtr($tOSVERSIONINFOEX))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Local $aRet[9]
	$aRet[0] = DllStructGetData($tOSVERSIONINFOEX, 'MajorVersion')
	$aRet[1] = DllStructGetData($tOSVERSIONINFOEX, 'MinorVersion')
	$aRet[2] = DllStructGetData($tOSVERSIONINFOEX, 'BuildNumber')
	$aRet[3] = DllStructGetData($tOSVERSIONINFOEX, 'PlatformId')
	$aRet[4] = DllStructGetData($tOSVERSIONINFOEX, 'CSDVersion')
	$aRet[5] = DllStructGetData($tOSVERSIONINFOEX, 'ServicePackMajor')
	$aRet[6] = DllStructGetData($tOSVERSIONINFOEX, 'ServicePackMinor')
	$aRet[7] = DllStructGetData($tOSVERSIONINFOEX, 'SuiteMask')
	$aRet[8] = DllStructGetData($tOSVERSIONINFOEX, 'ProductType')
	Return $aRet
EndFunc   ;==>_WinAPI_GetVersionEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetVolumeNameForVolumeMountPoint
; Description....: Retrieves a volume GUID path for the volume that is associated with the specified volume mount point.
; Syntax.........: _WinAPI_GetVolumeNameForVolumeMountPoint ( $sPath )
; Parameters.....: $sPath  - The path of a mounted folder (for example, Y:\MountX\) or a drive letter (for example, X:\).
; Return values..: Success - The volume GUID path. This path is of the form "\\?\Volume{GUID}\" where GUID is a GUID that
;                            identifies the volume. If there is more than one volume GUID path for the volume, only the first one
;                            in the mount manager's cache is returned.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetVolumeNameForVolumeMountPoint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetVolumeNameForVolumeMountPoint($sPath)

	Local $tData = DllStructCreate('wchar[80]')
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetVolumeNameForVolumeMountPointW', 'wstr', $sPath, 'ptr', DllStructGetPtr($tData), 'dword', 80)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_GetVolumeNameForVolumeMountPoint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowDisplayAffinity
; Description....: Retrieves the current display affinity setting, from any process, for a given window.
; Syntax.........: _WinAPI_GetWindowDisplayAffinity ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window for which display affinity setting is retrieved.
; Return values..: Success - The current window's display affinity setting ($WDA_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function succeeds only when the window is layered and Desktop Windows Manager (DWM) is composing the desktop.
;                  For more information, see _WinAPI_SetWindowDisplayAffinity().
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ GetWindowDisplayAffinity
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowDisplayAffinity($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'GetWindowDisplayAffinity', 'hwnd', $hWnd, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetWindowDisplayAffinity

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowExt
; Description....: Retrieves the x-extent and y-extent of the window for the specified device context.
; Syntax.........: _WinAPI_GetWindowExt ( $hDC )
; Parameters.....: $hDC      - Handle to the device context.
; Return values..: Success   - $tagSIZE structure that contains the x- and y-extents in page-space units, that is, logical units.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetWindowExtEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowExt($hDC)

	Local $tSIZE = DLLStructCreate($tagSIZE)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetWindowExtEx', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tSIZE))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tSIZE
EndFunc   ;==>_WinAPI_GetWindowExt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowFileName
; Description....: Retrieves the fully-qualified path of the module associated with the specified window handle.
; Syntax.........: _WinAPI_GetWindowFileName ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window whose module file name will be retrieved.
; Return values..: Success - The full path and file name.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowFileName($hWnd)

	Local $PID = 0, $Result

	If _WinAPI_IsWindow($hWnd) Then
		_WinAPI_GetWindowThreadProcessId($hWnd, $PID)
	EndIf
	If Not $PID Then
		Return SetError(1, 0, '')
	EndIf
	$Result = _WinAPI_GetProcessFileName($PID)
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_GetWindowFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowInfo
; Description....: Retrieves information about the specified window.
; Syntax.........: _WinAPI_GetWindowInfo ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window whose information is to be retrieved.
; Return values..: Success - $tagWINDOWINFO structure that contains the information about the specified window.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetWindowInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowInfo($hWnd)

	Local $tWINDOWINFO = DllStructCreate($tagWINDOWINFO)

	DllStructSetData($tWINDOWINFO, 'Size', DllStructGetSize($tWINDOWINFO))

	Local $Ret = DllCall('user32.dll', 'int', 'GetWindowInfo', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tWINDOWINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tWINDOWINFO
EndFunc   ;==>_WinAPI_GetWindowInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowLongEx
; Description....: Retrieves information about the specified window.
; Syntax.........: _WinAPI_GetWindowLongEx ( $hWnd, $iIndex )
; Parameters.....: $hWnd   - Handle to the window and, indirectly, the class to which the window belongs.
;                  $iIndex - The zero-based offset to the value to be retrieved. Valid values are in the range zero through the
;                            number of bytes of extra window memory, minus the size of an integer. To retrieve any other value,
;                            specify one of the following values.
;
;                            $GWL_EXSTYLE
;                            $GWL_HINSTANCE
;                            $GWL_HWNDPARENT
;                            $GWL_ID
;                            $GWL_STYLE
;                            $GWL_USERDATA
;                            $GWL_WNDPROC
;
; Return values..: Success - The requested value.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If _WinAPI_SetWindowLongEx() has not been called previously, _WinAPI_GetWindowLongEx() returns 0.
; Related........:
; Link...........: @@MsdnLink@@ GetWindowLong
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowLongEx($hWnd, $iIndex)

	Local $Ret

	If StringInStr(@OSArch, '64') Then
		$Ret = DllCall('user32.dll', 'long_ptr', 'GetWindowLongPtrW', 'hwnd', $hWnd, 'int', $iIndex)
	Else
		$Ret = DllCall('user32.dll', 'long', 'GetWindowLongW', 'hwnd', $hWnd, 'int', $iIndex)
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetWindowLongEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowOrg
; Description....: Retrieves the x-coordinates and y-coordinates of the window origin for the specified device context.
; Syntax.........: _WinAPI_GetWindowOrg ( $hDC )
; Parameters.....: $hDC      - Handle to the device context.
; Return values..: Success   - $tagPOINT structure that receives the coordinates, in logical units, of the window origin.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetWindowOrgEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowOrg($hDC)

	Local $tPOINT = DLLStructCreate($tagPOINT)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetWindowOrgEx', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPOINT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tPOINT
EndFunc   ;==>_WinAPI_GetWindowOrg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowSubclass
; Description....: Retrieves the reference data for the specified window subclass callback.
; Syntax.........: _WinAPI_GetWindowSubclass ( $hWnd, $pSubclassProc, $ID )
; Parameters.....: $hWnd          - Handle of the window being subclassed.
;                  $pSubclassProc - A pointer to a window procedure. This pointer and the subclass ID uniquely identify this subclass callback.
;
;                                   (See MSDN for more information)
;
;                  $ID            - The subclass ID.
; Return values..: Success - The reference data for the window subclass callback.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetWindowSubclass
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowSubclass($hWnd, $pSubclassProc, $ID)

	Local $Ret = DllCall('comctl32.dll', 'int', 'GetWindowSubclass', 'hwnd', $hWnd, 'ptr', $pSubclassProc, 'uint_ptr', $ID, 'dword_ptr*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[4]
EndFunc   ;==>_WinAPI_GetWindowSubclass

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowTheme
; Description....: Retrieves a theme handle to a window that has visual styles applied.
; Syntax.........: _WinAPI_GetWindowTheme ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window.
; Return values..: Success - Handle to the theme or 0 if no visual style is applied.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetWindowTheme
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowTheme($hWnd)

	Local $Ret = DllCall('uxtheme.dll', 'ptr', 'GetWindowTheme', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetWindowTheme

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowModuleFileName
; Description....: Retrieves the full path and file name of the module associated with the specified window handle.
; Syntax.........: _WinAPI_GetWindowModuleFileName ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window whose module file name will be retrieved.
; Return values..: Success - The full path and file name.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowModuleFileName($hWnd)

	Local $PID = 0, $Result = ''

	_WinAPI_GetWindowThreadProcessId($hWnd, $PID)
	If $PID Then
		$Result = _WinAPI_GetModuleFileNameEx($PID)
	EndIf
	Return SetError(@error, 0, $Result)
EndFunc   ;==>_WinAPI_GetWindowModuleFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWorkArea
; Description....: Retrieves the size of the work area on the primary display monitor.
; Syntax.........: _WinAPI_GetWorkArea ( )
; Parameters.....: None
; Return values..: Success - $tagRECT structure that contains the screen coordinates of the work area.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SystemParametersInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWorkArea()

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'SystemParametersInfo', 'uint', 48, 'uint', 0, 'ptr', DllStructGetPtr($tRECT), 'uint', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_GetWorkArea

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWorldTransform
; Description....: Retrieves the current world-space to page-space transformation.
; Syntax.........: _WinAPI_GetWorldTransform ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - $tagXFORM structure that contains the current world-space to page-space transformation.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The precision of the transformation may be altered if an application calls the _WinAPI_ModifyWorldTransform()
;                  prior to calling _WinAPI_GetWorldTransform(). This is because the internal format for storing transformation
;                  values uses a higher precision than a FLOAT value.
; Related........:
; Link...........: @@MsdnLink@@ GetWorldTransform
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWorldTransform($hDC)

	Local $tXFORM = DllStructCreate($tagXFORM)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetWorldTransform', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tXFORM))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tXFORM
EndFunc   ;==>_WinAPI_GetWorldTransform

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GradientFill
; Description....: Fills rectangle or triangle gradient.
; Syntax.........: _WinAPI_GradientFill ($hDC, $aVertex [, $iStart [, $iEnd [, $fRotate]]] )
; Parameters.....: $hDC     - Handle to the device context.
;                  $aVertex - The 2D array ([x1, y1, $rgb1], [x2, y2, $rgb2], ... [xN, yN, $rgbN]) that contains the necessary
;                             gradient vertices. Each vertex in this array contains the following parameters.
;
;                             x   - The x-coordinate, in logical units.
;                             y   - The y-coordinate, in logical units
;                             rgb - The color information at the point of x, y.
;
;                  $iStart  - The index of array to start filling at.
;                  $iEnd    - The index of array to stop filling at.
;                  $fRotate - Specifies whether fills a rectangle from left to right edge (horizontal gradient). $fRotate used
;                             only for the rectangular gradients, for the triangular gradients this parameter will be ignored,
;                             valid values:
;                  |TRUE    - Fills from left to right edge.
;                  |FALSE   - Fills from top to bottom edge. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the number of vertices defined by using $iStart and $iEnd parameters is 2, _WinAPI_GradientFill() function
;                  fills a rectangle. If the number of vertices is 3, fills a triangle. For the rectangle, the vertices must
;                  specify its upper left and lower right corners. Note that $aVertex array may contain any number of vertices
;                  of the gradient, but only 2 or 3 vertices may be used at the same time from this array.
;                  Otherwise, the function is fails.
;
;                  _WinAPI_GradientFill() function can only fill the rectangle or triangle at one call. Use multiple calls this
;                  function to fill a complex gradients.
; Related........:
; Link...........: @@MsdnLink@@ GdiGradientFill
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GradientFill($hDC, $aVertex, $iStart = 0, $iEnd = -1, $fRotate = 0)

	If UBound($aVertex, 2) < 3 Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Count, $Mode, $Point, $tGradient, $tVertex, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aVertex) - 1) Then
		$iEnd = UBound($aVertex) - 1
	EndIf
	$Point = $iEnd - $iStart + 1
	If $Point > 3 Then
		$iEnd = $iStart + 2
		$Point = 3
	EndIf
	Switch $Point
		Case 2
			$Mode = Number(Not $fRotate)
		Case 3
			$Mode = 2
		Case Else
			Return SetError(1, 0, 0)
	EndSwitch
	For $i = $iStart To $iEnd
		$Struct &= 'ushort[8];'
	Next
	$tVertex = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = 1
	$tGradient = DllStructCreate('ulong[' & $Point & ']')
	For $i = $iStart To $iEnd
		DllStructSetData($tGradient, 1, $Count - 1, $Count)
		DllStructSetData($tVertex, $Count, _WinAPI_LoWord($aVertex[$i][0]), 1)
		DllStructSetData($tVertex, $Count, _WinAPI_HiWord($aVertex[$i][0]), 2)
		DllStructSetData($tVertex, $Count, _WinAPI_LoWord($aVertex[$i][1]), 3)
		DllStructSetData($tVertex, $Count, _WinAPI_HiWord($aVertex[$i][1]), 4)
		DllStructSetData($tVertex, $Count, BitShift(_WinAPI_GetRValue($aVertex[$i][2]), -8), 5)
		DllStructSetData($tVertex, $Count, BitShift(_WinAPI_GetGValue($aVertex[$i][2]), -8), 6)
		DllStructSetData($tVertex, $Count, BitShift(_WinAPI_GetBValue($aVertex[$i][2]), -8), 7)
		DllStructSetData($tVertex, $Count, 0, 8)
		$Count += 1
	Next

	Local $Ret = DllCall('gdi32.dll', 'int', 'GdiGradientFill', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tVertex), 'ulong', $Point, 'ptr', DllStructGetPtr($tGradient), 'ulong', 1, 'ulong', $Mode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_GradientFill

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Hex64
; Description....: Converts an integer value into a string of its hexadecimal representation.
; Syntax.........: _WinAPI_Hex64 ( $iValue [, $iLenght] )
; Parameters.....: $iValue  - The expression to convert.
;                  $iLenght - The number of characters to be returned (up to 16) for integer. Characters are truncated from the
;                             left-hand side if length is too small.
; Return values..: Success  - 1.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Hex64($iValue, $iLenght = 16)

	If (Not IsNumber($iValue)) Or ($iLenght < 1) Or ($iLenght > 16) Then
		Return SetError(1, 0, '')
	EndIf

	Local $tInt64 = DllStructCreate('int64')
	Local $tDWord = DllStructCreate('dword;dword', DllStructGetPtr($tInt64))

	DllStructSetData($tInt64, 1, $iValue)
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return StringRight(Hex(DllStructGetData($tDWord, 2)) & Hex(DllStructGetData($tDWord, 1)), $iLenght)
EndFunc   ;==>_WinAPI_Hex64

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_HiByte
; Description....: Returns the high BYTE of a 16-bit (2 bytes) value.
; Syntax.........: _WinAPI_HiByte ( $iValue )
; Parameters.....: $iValue - 16-bit value.
; Return values..: High BYTE value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_HiByte($iValue)
	Return BitAND(BitShift($iValue, 8), 0xFF)
EndFunc   ;==>_WinAPI_HiByte

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_HideCaret
; Description....: Removes the caret from the screen.
; Syntax.........: _WinAPI_HideCaret ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window that owns the caret. If this parameter is 0, _WinAPI_HideCaret() searches the
;                            current task for the window that owns the caret.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_HideCaret() hides the caret only if the specified window owns the caret. If the specified window does
;                  not own the caret, _WinAPI_HideCaret() does nothing and returns 0.
;
;                  Hiding is cumulative. If your application calls _WinAPI_HideCaret() five times in a row, it must also call
;                  _WinAPI_ShowCaret() five times before the caret is displayed.
; Related........:
; Link...........: @@MsdnLink@@ HideCaret
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_HideCaret($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'HideCaret', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_HideCaret

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_HiDWord
; Description....: Returns the high DWORD of a 64-bit (8 bytes) value.
; Syntax.........: _WinAPI_HiDWord ( $iValue )
; Parameters.....: $iValue - 64-bit value.
; Return values..: High DWORD value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_HiDWord($iValue)

	Local $tInt64, $tQWord

	$tInt64 = DllStructCreate('int64')
	$tQWord = DllStructCreate('dword;dword', DllStructGetPtr($tInt64))
	DllStructSetData($tInt64, 1, $iValue)
	Return DllStructGetData($tQWord, 2)
EndFunc   ;==>_WinAPI_HiDWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InflateRect
; Description....: Increases or decreases the width and height of the specified rectangle.
; Syntax.........: _WinAPI_InflateRect ( ByRef $tRECT, $DX, $DY )
; Parameters.....: $tRECT  - $tagRECT structure that increases or decreases in size.
;                  $DX     - The amount to increase or decrease (negative value) the rectangle width.
;                  $DY     - The amount to increase or decrease (negative value) the rectangle height.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ InflateRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_InflateRect(ByRef $tRECT, $DX, $DY)

	Local $Ret = DllCall('user32.dll', 'int', 'InflateRect', 'ptr', DllStructGetPtr($tRECT), 'int', $DX, 'int', $DY)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_InflateRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IntersectClipRect
; Description....: Creates a new clipping region from the intersection of the current clipping region and the specified rectangle.
; Syntax.........: _WinAPI_IntersectClipRect ( $hDC, $tRECT )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tRECT  - $tagRECT structure that contains the logical coordinates of the specified rectangle.
; Return values..: Success - The value that specifies the new clipping region's complexity; it can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IntersectClipRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IntersectClipRect($hDC, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'IntersectClipRect', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IntersectClipRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IntersectRect
; Description....: Creates the intersection of two rectangles.
; Syntax.........: _WinAPI_IntersectRect ( $tRECT1, $tRECT2 )
; Parameters.....: $tRECT1 - $tagRECT structure that contains the first source rectangle.
;                  $tRECT2 - $tagRECT structure that contains the second source rectangle.
; Return values..: Success - $tagRECT structure that contains the intersection of the $tRECT1 and $tRECT2 rectangles.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the source rectangles do not intersect, an empty rectangle (in which all coordinates are set to zero) is
;                  placed into the destination rectangle.
; Related........:
; Link...........: @@MsdnLink@@ IntersectRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IntersectRect($tRECT1, $tRECT2)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'IntersectRect', 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tRECT1), 'ptr', DllStructGetPtr($tRECT2))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_IntersectRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IntToDWord
; Description....: Converts a value of type INT to a value of type DWORD.
; Syntax.........: _WinAPI_IntToDWord ( $iValue )
; Parameters.....: $iValue - The value to be converted.
; Return values..: The converted (DWORD) value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IntToDWord($iValue)

	Local $tData = DllStructCreate('dword')

	DllStructSetData($tData, 1, $iValue)

	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_IntToDWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InvalidateRgn
; Description....: Adds a region to the specified window's update region.
; Syntax.........: _WinAPI_InvalidateRgn ( $hWnd [, $hRgn [, $fErase]] )
; Parameters.....: $hWnd   - Handle to the window with an update region that is to be modified.
;                  $hRgn   - Handle to the region to be added to the update region. The region is assumed to have client coordinates.
;                            If this parameter is 0, the entire client area is added to the update region.
;                  $fErase - Specifies whether the background within the update region is to be erased when the
;                            update region is processed.
;                  |TRUE   - The background is erased. (Default)
;                  |FALSE  - The background remains unchanged.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ InvalidateRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_InvalidateRgn($hWnd, $hRgn = 0, $fErase = 1)

	Local $Ret = DllCall('user32.dll', 'int', 'InvalidateRgn', 'hwnd', $hWnd, 'ptr', $hRgn, 'int', $fErase)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_InvalidateRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InvertANDBitmap
; Description....: Inverts the specified AND bitmask bitmap by performing a logical NOT operation.
; Syntax.........: _WinAPI_InvertANDBitmap ( $hBitmap [, $fDelete] )
; Parameters.....: $hBitmap - Handle to the source bitmap that must be inverted.
;                  $fDelete - Specifies whether to delete the source bitmap after the function is successful, valid values:
;                  |TRUE    - The bitmap will be destroyed when the function succeeds.
;                  |FALSE   - Don't delete, you must destroy a bitmap when it no longer needed. (Default)
; Return values..: Success  - Handle to the inverted bitmap.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_InvertANDBitmap() creates a 1 bits-per-pixel inverted bitmask DIB from the 1 bits-per-pixel AND bitmask bitmap.
;                  If the source bitmap is not a 1 bits-per-pixel bitmap, the function fails.
;
;                  When you are finished using the bitmap, destroy it using the _WinAPI_DeleteObject() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_InvertANDBitmap($hBitmap, $fDelete = 0)

	Local $tBITMAP, $hSrcDC, $hSrcSv, $hDstDC, $hDstSv, $hResult

	$tBITMAP = DllStructCreate($tagBITMAP)
	If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tBITMAP), DllStructGetPtr($tBITMAP))) Or (DllStructGetData($tBITMAP, 'bmBitsPixel') <> 1) Then
		Return SetError(1, 0, 0)
	EndIf
	$hResult = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'), 1)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$hSrcDC = _WinAPI_CreateCompatibleDC(0)
	$hSrcSv = _WinAPI_SelectObject($hSrcDC, $hBitmap)
	$hDstDC = _WinAPI_CreateCompatibleDC(0)
	$hDstSv = _WinAPI_SelectObject($hDstDC, $hResult)
	_WinAPI_BitBlt($hDstDC, 0, 0, DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'), $hSrcDC, 0, 0, 0x00330008)
	_WinAPI_SelectObject($hSrcDC, $hSrcSv)
	_WinAPI_DeleteDC($hSrcDC)
	_WinAPI_SelectObject($hDstDC, $hDstSv)
	_WinAPI_DeleteDC($hDstDC)
	If $fDelete Then
		_WinAPI_DeleteObject($hBitmap)
	EndIf
	Return $hResult
EndFunc   ;==>_WinAPI_InvertANDBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InvertColor
; Description....: Inverts (negative) the specified color.
; Syntax.........: _WinAPI_InvertColor ( $iColor )
; Parameters.....: $iColor - The color to be inverted. This color can be specified in RGB or BGR format.
; Return values..: The inverted color.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_InvertColor($iColor)
	Return 0xFFFFFF - BitAND($iColor, 0xFFFFFF)
EndFunc   ;==>_WinAPI_InvertColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InvertRect
; Description....: Inverts a rectangle in a window by performing a logical NOT operation on the color values for each pixel.
; Syntax.........: _WinAPI_InvertRect ( $hDC, $tRECT )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tRECT  - $tagRECT structure that contains the logical coordinates of the rectangle to be inverted.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: On monochrome screens, the _WinAPI_InvertRect() makes white pixels black and black pixels white. On color screens,
;                  the inversion depends on how colors are generated for the screen. Calling _WinAPI_InvertRect() twice for the same
;                  rectangle restores the display to its previous colors.
; Related........:
; Link...........: @@MsdnLink@@ InvertRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_InvertRect($hDC, $tRECT)

	Local $Ret = DllCall('user32.dll', 'int', 'InvertRect', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_InvertRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InvertRgn
; Description....: Inverts the colors in the specified region.
; Syntax.........: _WinAPI_InvertRgn ( $hDC, $hRgn )
; Parameters.....: $hDC    - Handle to the device context.
;                  $hRgn   - Handle to the region for which colors are inverted. The region's coordinates are
;                            presumed to be logical coordinates.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: On monochrome screens, the _WinAPI_InvertRgn() function makes white pixels black and black pixels white. On color
;                  screens, this inversion is dependent on the type of technology used to generate the colors for the screen.
; Related........:
; Link...........: @@MsdnLink@@ InvertRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_InvertRgn($hDC, $hRgn)

	Local $Ret = DllCall('gdi32.dll', 'int', 'InvertRgn', 'hwnd', $hDC, 'ptr', $hRgn)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_InvertRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IOCTL
; Description....: Create a unique system I/O control code (IOCTL).
; Syntax.........: _WinAPI_IOCTL ( $iDeviceType, $iFunction, $iMethod, $iAccess )
; Parameters.....: $iDeviceType - The type of device.
;                  $iFunction   - The action within the device category.
;                  $iMethod     - The method codes for how buffers are passed for I/O and file system controls.
;                  $iAccess     - The access check value for any access.
; Return values..: The IOCTL (DWORD) value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CTL_CODE
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IOCTL($iDeviceType, $iFunction, $iMethod, $iAccess)
	Return BitOR(BitShift($iDeviceType, -16), BitShift($iAccess, -14), BitShift($iFunction, -2), $iMethod)
EndFunc   ;==>_WinAPI_IOCTL

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsAlphaBitmap
; Description....: Determines whether the specified bitmap has an alpha channel.
; Syntax.........: _WinAPI_IsAlphaBitmap ( $hBitmap )
; Parameters.....: $hBitmap - Handle to the bitmap to test. This bitmap must be a 32 bits-per-pixel.
; Return values..: Success  - 1 - The specified bitmap has an alpha channel.
;                             0 - Otherwise.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function only works with 32 bits-per-pixel uncompressed bitmaps. If the source bitmap is non 32 bits-per-pixel
;                  bitmap, or is a compressed bitmap, the _WinAPI_IsAlphaBitmap() always returns 0.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsAlphaBitmap($hBitmap)

	Local $tDIB, $Ret, $Error

	$hBitmap = _WinAPI_CopyBitmap($hBitmap)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Do
		$Error = 1
		$tDIB = DllStructCreate($tagDIBSECTION)
		If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), DllStructGetPtr($tDIB))) Or (DllStructGetData($tDIB, 'bmBitsPixel') <> 32) Or (DllStructGetData($tDIB, 'biCompression')) Then
			ExitLoop
		EndIf
		$Ret = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __AlphaProc(), 'ptr', 0, 'uint', 0, 'ptr', DllStructGetPtr($tDIB), 'ptr', 0)
		If (@error) Or ($Ret[0] = -1) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	_WinAPI_DeleteObject($hBitmap)
	If $Error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsAlphaBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsBadCodePtr
; Description....: Determines whether the calling process has read access to the memory at the specified address.
; Syntax.........: _WinAPI_IsBadCodePtr ( $pAddress )
; Parameters.....: $pAddress - A pointer to a memory address.
; Return values..: Success   - 1 - The calling process does not not have read access to the specified memory.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsBadCodePtr
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsBadCodePtr($pAddress)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsBadCodePtr', 'ptr', $pAddress)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>IsBadCodePtr

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsBadReadPtr
; Description....: Verifies that the calling process has read access to the specified range of memory.
; Syntax.........: _WinAPI_IsBadReadPtr ( $pAddress, $iLenght )
; Parameters.....: $pAddress - A pointer to the first byte of the memory block.
;                  $iLenght  - The size of the memory block, in bytes.
; Return values..: Success   - 1 - The calling process does not have read access to all bytes in the specified memory range.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsBadReadPtr
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsBadReadPtr($pAddress, $iLenght)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsBadReadPtr', 'ptr', $pAddress, 'uint_ptr', $iLenght)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsBadReadPtr

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsBadStringPtr
; Description....: Verifies that the calling process has read access to the specified range of memory.
; Syntax.........: _WinAPI_IsBadStringPtr ( $pAddress, $iLenght )
; Parameters.....: $pAddress - A pointer to a null-terminated string, either Unicode or ASCII.
;                  $iLenght  - The maximum size of the string, in TCHARs.
; Return values..: Success   - 1 - The calling process does not have read access to all characters up to the string's terminating null
;                                  character or up to the number of specified characters.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function checks for read access in all characters up to the string's terminating null character or up to the
;                  number of characters specified by this parameter, whichever is smaller.
; Related........:
; Link...........: @@MsdnLink@@ IsBadStringPtr
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsBadStringPtr($pAddress, $iLenght)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsBadStringPtr', 'ptr', $pAddress, 'uint_ptr', $iLenght)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsBadStringPtr

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsBadWritePtr
; Description....: Verifies that the calling process has write access to the specified range of memory.
; Syntax.........: _WinAPI_IsBadWritePtr ( $pAddress, $iLenght )
; Parameters.....: $pAddress - A pointer to the first byte of the memory block.
;                  $iLenght  - The size of the memory block, in bytes.
; Return values..: Success   - 1 - The calling process does not have write access to all bytes in the specified memory range.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsBadWritePtr
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsBadWritePtr($pAddress, $iLenght)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsBadWritePtr', 'ptr', $pAddress, 'uint_ptr', $iLenght)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsBadWritePtr

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsChild
; Description....: Tests whether a window is a child window of a specified parent window.
; Syntax.........: _WinAPI_IsChild ( $hWnd, $hWndParent )
; Parameters.....: $hWnd       - Handle to the window to be tested.
;                  $hWndParent - Handle to the parent window.
; Return values..: Success     - 1 - The window is a child window of the specified parent window.
;                                0 - Otherwise.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsChild
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsChild($hWnd, $hWndParent)

	Local $Ret = DllCall('user32.dll', 'int', 'IsChild', 'hwnd', $hWndParent, 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsChild

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsDoorOpen
; Description....: Checks if a CD (DVD) tray is open.
; Syntax.........: _WinAPI_IsDoorOpen ( $sDrive )
; Parameters.....: $sDrive - The drive letter of the CD tray to check, in the format D:, E:, etc.
; Return values..: Success - 1 - CD (DVD) tray is open.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: G.Sandler (CreatoR)
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_SCSI_PASS_THROUGH
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsDoorOpen($sDrive)

	If @AutoItX64 Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0xC0000000, 0x03)

	If Not $hFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSPT = DllStructCreate('ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;byte Alignment[3];ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16];byte Hdr[8]')
	Local $tCDB = DllStructCreate('byte;byte;byte[6];byte[2];byte;byte;byte[4]', DllStructGetPtr($tSPT, 'Cdb'))
	Local $tHDR = DllStructCreate('byte;byte;byte[3];byte;byte[2]', DllStructGetPtr($tSPT, 'Hdr'))
	Local $Size = DllStructGetSize($tSPT) - 8

	DllStructSetData($tSPT, 'Length', $Size)
	DllStructSetData($tSPT, 'ScsiStatus', 0)
	DllStructSetData($tSPT, 'PathId', 0)
	DllStructSetData($tSPT, 'TargetId', 0)
	DllStructSetData($tSPT, 'Lun', 0)
	DllStructSetData($tSPT, 'CdbLength', 12)
	DllStructSetData($tSPT, 'SenseInfoLength', 0)
	DllStructSetData($tSPT, 'DataIn', 1)
	DllStructSetData($tSPT, 'DataTransferLength', 8)
	DllStructSetData($tSPT, 'TimeOutValue', 86400)
	DllStructSetData($tSPT, 'DataBufferOffset', $Size)
	DllStructSetData($tSPT, 'SenseInfoOffset', 0)

	DllStructSetData($tCDB, 1, 0xBD)
	DllStructSetData($tCDB, 2, 0)
	DllStructSetData($tCDB, 4, 0, 1)
	DllStructSetData($tCDB, 4, 8, 2)
	DllStructSetData($tCDB, 5, 0)
	DllStructSetData($tCDB, 6, 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', $IOCTL_SCSI_PASS_THROUGH, 'ptr', DllStructGetPtr($tSPT), 'dword', $Size, 'ptr', DllStructGetPtr($tSPT), 'dword', DllStructGetSize($tSPT), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return Number(BitAND(DllStructGetData($tHDR, 2), 0x10) = 0x10)
EndFunc   ;==>_WinAPI_IsDoorOpen

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsHungAppWindow
; Description....: Determines whether the specified application is not responding.
; Syntax.........: _WinAPI_IsHungAppWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window.
; Return values..: Success - 1 - The window stops responding.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application is considered to be not responding if it is not waiting for input, is not in startup processing,
;                  and has not called PeekMessage within the internal timeout period of 5 seconds.
; Related........:
; Link...........: @@MsdnLink@@ IsHungAppWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsHungAppWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'IsHungAppWindow', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsHungAppWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsIconic
; Description....: Determines whether the specified window is minimized (iconic).
; Syntax.........: _WinAPI_IsIconic ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to test.
; Return values..: Success - 1 - The window is iconic.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsIconic
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsIconic($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'IsIconic', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsIconic

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsInternetConnected
; Description....: Determines whether the current user is connected to the Internet.
; Syntax.........: _WinAPI_IsInternetConnected ( )
; Parameters.....: None
; Return values..: Success - 1 - The user is connected to the Internet.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ IsInternetConnected
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsInternetConnected()

	If Not __DLL('connect.dll') Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('connect.dll', 'uint', 'IsInternetConnected')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		Switch $Ret[0]
			Case 0, 1 ; S_OK, S_FALSE

			Case Else
				Return SetError(1, $Ret[0], 0)
		EndSwitch
	EndIf
	Return Number(Not $Ret[0])
EndFunc   ;==>_WinAPI_IsInternetConnected

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsLoadKBLayout
; Description....: Determines whether the specified input locale loaded into the system.
; Syntax.........: _WinAPI_IsLoadKBLayout ( $iLanguage )
; Parameters.....: $iLanguage - The name of the input locale identifier (LCID).
; Return values..: Success    - 1 - The input locale is loaded.
;                               0 - Otherwise.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsLoadKBLayout($iLanguage)

	Local $Layout = _WinAPI_GetKeyboardLayoutList()

	If Not IsArray($Layout) Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = 1 To $Layout[0]
		If $Layout[$i] = $iLanguage Then
			Return 1
		EndIf
	Next
	Return 0
EndFunc   ;==>_WinAPI_IsLoadKBLayout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsNetworkAlive
; Description....: Determines whether or not a local system is connected to a network, and identifies the type of network connection.
; Syntax.........: _WinAPI_IsNetworkAlive ( )
; Parameters.....: None
; Return values..: Success - The type of network connection ($NETWORK_ALIVE_*) if a local system is connected to a network.
;                            0 - Is no connection.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Always check @error flag before checking the return value of this function. If the @error is not 0,
;                  the function has failed and the following values do not apply.
;
;                  This function is only available for TCP/IP connections.
; Related........:
; Link...........: @@MsdnLink@@ IsNetworkAlive
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsNetworkAlive()

	If Not __DLL('sensapi.dll') Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('sensapi.dll', 'int', 'IsNetworkAlive', 'int*', 0)

	If (@error) Or (Not $Ret[0]) Or (_WinAPI_GetLastError()) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_IsNetworkAlive

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsPressed
; Description....: Checks whether the key is pressed from the specified range.
; Syntax.........: _WinAPI_IsPressed ( [$iFrom [, $iTo]] )
; Parameters.....: $iFrom  - Specifies a virtual-key code to start checking. The code must be a value in the range 1 to 254.
;                  $iTo    - Specifies a virtual-key code to end checking. The code must be a value in the range 1 to 254 and be
;                            greater than value of the $iFrom parameter.
; Return values..: Success - 1 - The key is pressed.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The key status returned from this function changes as a process reads key messages from its message queue.
;                  The status does not reflect the interrupt-level state associated with the hardware. Use the _WinAPI_GetAsyncKeyState()
;                  function to retrieve that information.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsPressed($iFrom = 0x01, $iTo = 0xFF)

	Local $tData = _WinAPI_GetKeyboardState()

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	For $i = $iFrom To $iTo
		Switch $i
			Case 0x0A, 0x0B, 0x0E To 0x0F, 0x16, 0x1A, 0x1C To 0x1F, 0x3A To 0x40, 0x5E, 0x88 To 0x8F, 0x97 To 0x9F, 0xB8 To 0xB9, 0xC1 To 0xDA, 0xE0, 0xE8
				ContinueLoop
			Case Else
				If BitAND(DllStructGetData($tData, 1, $i + 1), 0xF0) Then
					Return $i
				EndIf
		EndSwitch
	Next
	Return 0
EndFunc   ;==>_WinAPI_IsPressed

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsProcessInJob
; Description....: Determines whether the process is running in the specified job.
; Syntax.........: _WinAPI_IsProcessInJob( $hProcess [, $hJob] )
; Parameters.....: $hProcess - Handle to the process to be tested. The handle must have the $PROCESS_QUERY_INFORMATION or
;                              $PROCESS_QUERY_LIMITED_INFORMATION access right.
;                  $hJob     - Handle to the job. If this parameter is 0, the function tests if the process is running under any job.
; Return values..: Success   - 1 - The process is running in the job.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application cannot obtain a handle to the job object in which it is running unless it has the name of the job
;                  object. However, an application can call the _WinAPI_QueryInformationJobObject() function with 0 to obtain
;                  information about the job object.
; Related........:
; Link...........: @@MsdnLink@@ IsProcessInJob
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsProcessInJob($hProcess, $hJob = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsProcessInJob', 'ptr', $hProcess, 'ptr', $hJob, 'int*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_IsProcessInJob

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsProcessorFeaturePresent
; Description....: Determines whether the specified processor feature is supported by the current computer.
; Syntax.........: _WinAPI_IsProcessorFeaturePresent ( $iFeature )
; Parameters.....: $iFeature - The processor feature to be tested. This parameter can be one of the $PF_* constants.
; Return values..: Success   - 1 - The feature is supported.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsProcessorFeaturePresent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsProcessorFeaturePresent($iFeature)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsProcessorFeaturePresent', 'dword', $iFeature)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsProcessorFeaturePresent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsRectEmpty
; Description....: Determines whether the specified rectangle is empty.
; Syntax.........: _WinAPI_IsRectEmpty ( $tRECT )
; Parameters.....: $tRECT  - $tagRECT structure that contains the logical coordinates of the rectangle.
; Return values..: Success - 1 - The rectangle is empty.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An empty rectangle is one that has no area; that is, the coordinate of the right side is less than or equal
;                  to the coordinate of the left side, or the coordinate of the bottom side is less than or equal to the
;                  coordinate of the top side.
; Related........:
; Link...........: @@MsdnLink@@ IsRectEmpty
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsRectEmpty($tRECT)

	Local $Ret = DllCall('user32.dll', 'int', 'IsRectEmpty', 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsRectEmpty

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsThemeActive
; Description....: Tests if a visual style for the current application is active.
; Syntax.........: _WinAPI_IsThemeActive ( )
; Parameters.....: None
; Return values..: Success - 1 - The visual style is enabled.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsThemeActive
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsThemeActive()

	Local $Ret = DllCall('uxtheme.dll', 'int', 'IsThemeActive')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsThemeActive

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsThemeBackgroundPartiallyTransparent
; Description....: Retrieves whether the background specified by the visual style has transparent pieces or alpha-blended pieces.
; Syntax.........: _WinAPI_IsThemeBackgroundPartiallyTransparent ( $hTheme, $iPartId, $iStateId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part.
;                  $iStateId - The state of the part.
; Return values..: Success   - 1 - The theme-specified background has transparent pieces or alpha-blended pieces.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsThemeBackgroundPartiallyTransparent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsThemeBackgroundPartiallyTransparent($hTheme, $iPartId, $iStateId)

	Local $Ret = DllCall('uxtheme.dll', 'int', 'IsThemeBackgroundPartiallyTransparent', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsThemeBackgroundPartiallyTransparent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsThemePartDefined
; Description....: Retrieves whether a visual style has defined parameters for the specified part.
; Syntax.........: _WinAPI_IsThemePartDefined ( $hTheme, $iPartId )
; Parameters.....: $hTheme  - Handle to a window's specified theme data.
;                  $iPartId - The part.
; Return values..: Success  - 1 - The theme has defined parameters for the specified $iPartId.
;                             0 - Otherwise.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsThemePartDefined
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsThemePartDefined($hTheme, $iPartId)

	Local $Ret = DllCall('uxtheme.dll', 'int', 'IsThemePartDefined', 'ptr', $hTheme, 'int', $iPartId, 'int', 0)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsThemePartDefined

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsValidLocale
; Description....: Determines if the specified locale is installed or supported on the operating system.
; Syntax.........: _WinAPI_IsValidLocale ( $LCID [, $iFlag] )
; Parameters.....: $LCID   - Locale identifier of the locale to validate.
;                  $iFlag  - Flag specifying the validity test to apply to the locale identifier. This parameter can have one
;                            of the following values.
;
;                            $LCID_INSTALLED
;                            $LCID_SUPPORTED
;
; Return values..: Success - 1 - The locale identifier passes the specified validity test.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsValidLocale
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsValidLocale($LCID, $iFlag)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsValidLocale', 'long', $LCID, 'dword', $iFlag)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsValidLocale

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsWindowEnabled
; Description....: Determines whether the specified window is enabled for mouse and keyboard input.
; Syntax.........: _WinAPI_IsWindowEnabled ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to test.
; Return values..: Success - 1 - The window is enabled.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: A child window receives input only if it is both enabled and visible.
; Related........:
; Link...........: @@MsdnLink@@ IsWindowEnabled
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsWindowEnabled($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'IsWindowEnabled', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsWindowEnabled

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsWindowUnicode
; Description....: Determines whether the specified window is a native Unicode window.
; Syntax.........: _WinAPI_IsWindowUnicode ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to test.
; Return values..: Success - 1 - The window is a native Unicode window.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsWindowUnicode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsWindowUnicode($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'IsWindowUnicode', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsWindowUnicode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsWow64Process
; Description....: Determines whether the specified process is running under WOW64.
; Syntax.........: _WinAPI_IsWow64Process ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - 1 - The process is running under WOW64.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsWow64Process
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsWow64Process($PID = 0)

	If Not $PID Then
		$PID = _WinAPI_GetCurrentProcessID()
		If Not $PID Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $Access

	If _WinAPI_GetVersion() < '6.0' Then
		$Access = 0x00000400
	Else
		$Access = 0x00001000
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', $Access, 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsWow64Process', 'ptr', $hProcess[0], 'int*', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_IsWow64Process

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsWritable
; Description....: Determines whether a disk is writable.
; Syntax.........: _WinAPI_IsWritable ( $sDrive )
; Parameters.....: $sDrive - The drive letter of the disk to check, in the format D:, E:, etc.
; Return values..: Success - 1 - The disk is writable.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_DISK_IS_WRITABLE
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsWritable($sDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0, 0)

	If Not $hFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', $IOCTL_DISK_IS_WRITABLE, 'ptr', 0, 'dword', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)

	If @error Then
		$Ret = 0
	Else
		If Not $Ret[0] Then
			Switch _WinAPI_GetLastError()
				Case 19 ; ERROR_WRITE_PROTECT

				Case Else
					$Ret = 0
			EndSwitch
		EndIf
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsWritable

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsZoomed
; Description....: Determines whether a window is maximized.
; Syntax.........: _WinAPI_IsZoomed ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to test.
; Return values..: Success - 1 - The window is zoomed.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsZoomed
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsZoomed($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'IsZoomed', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsZoomed

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Keybd_Event
; Description....: Synthesizes a keystroke.
; Syntax.........: _WinAPI_Keybd_Event ( $vKey, $iFlags [, $iScanCode [, $iExtraInfo]] )
; Parameters.....: $vKey       - The virtual-key code ($VK_*). The code must be a value in the range 1 to 254.
;
;                                0x01 - Left mouse button
;                                0x02 - Right mouse button
;                                0x03 - Control-break processing
;                                0x04 - Middle mouse button (three-button mouse)
;                                0x05 - X1 mouse button
;                                0x06 - X2 mouse button
;
;                                0x08 - BACKSPACE key
;                                0x09 - TAB key
;
;                                0x0C - CLEAR key
;                                0x0D - ENTER key
;
;                                0x10 - SHIFT key
;                                0x11 - CTRL key
;                                0x12 - ALT key
;                                0x13 - PAUSE key
;                                0x14 - CAPS LOCK key
;
;                                0x1B - ESC key
;
;                                0x20 - SPACEBAR key
;                                0x21 - PAGE UP key
;                                0x22 - PAGE DOWN key
;                                0x23 - END key
;                                0x24 - HOME key
;                                0x25 - LEFT ARROW key
;                                0x26 - UP ARROW key
;                                0x27 - RIGHT ARROW key
;                                0x28 - DOWN ARROW key
;                                0x29 - SELECT key
;                                0x2A - PRINT key
;                                0x2B - EXECUTE key
;                                0x2C - PRINT SCREEN key
;                                0x2D - INS key
;                                0x2E - DEL key
;                                0x2F - HELP key
;                                0x30 - 0x39 - (0 - 9) key
;
;                                0x41 - 0x5A - (A - Z) key
;                                0x5B - Left Windows key
;                                0x5C - Right Windows key
;                                0x5D - Applications key
;
;                                0x5F - Computer Sleep key
;                                0x60 - 0x69 - Numeric keypad (0 - 9) key
;                                0x6A - Multiply key
;                                0x6B - Add key
;                                0x6C - Separator key
;                                0x6D - Subtract key
;                                0x6E - Decimal key
;                                0x6F - Divide key
;                                0x70 - 0x87 - (F1 - F24) key
;
;                                0x90 - NUM LOCK key
;                                0x91 - SCROLL LOCK key
;
;                                0xA0 - Left SHIFT key
;                                0xA1 - Right SHIFT key
;                                0xA2 - Left CONTROL key
;                                0xA3 - Right CONTROL key
;                                0xA4 - Left MENU key
;                                0xA5 - Right MENU key
;                                0xA6 - Browser Back key
;                                0xA7 - Browser Forward key
;                                0xA8 - Browser Refresh key
;                                0xA9 - Browser Stop key
;                                0xAA - Browser Search key
;                                0xAB - Browser Favorites key
;                                0xAC - Browser Start and Home key
;                                0xAD - Volume Mute key
;                                0xAE - Volume Down key
;                                0xAF - Volume Up key
;                                0xB0 - Next Track key
;                                0xB1 - Previous Track key
;                                0xB2 - Stop Media key
;                                0xB3 - Play/Pause Media key
;                                0xB4 - Start Mail key
;                                0xB5 - Select Media key
;                                0xB6 - Start Application 1 key
;                                0xB7 - Start Application 2 key
;
;                                0xBA - ';:' key
;                                0xBB - '+' key
;                                0xBC - ',' key
;                                0xBD - '-' key
;                                0xBE - '.' key
;                                0xBF - '/?' key
;                                0xC0 - '`~' key
;
;                                0xDB - '[{' key
;                                0xDC - '\|' key
;                                0xDD - ']}' key
;                                0xDE - 'single-quote/double-quote' key
;
;                                0xE2 - Either the angle bracket key or the backslash key on the RT 102-key keyboard
;
;                                0xE7 - Used to pass Unicode characters as if they were keystrokes
;
;                                0xF6 - Attn key
;                                0xF7 - CrSel key
;                                0xF8 - ExSel key
;                                0xF9 - Erase EOF key
;                                0xFA - Play key
;                                0xFB - Zoom key
;
;                                0xFD - PA1 key
;                                0xFE - Clear key
;
;                  $iFlags     - This parameter can be one or more of the following values.
;
;                                $KEYEVENTF_EXTENDEDKEY
;                                $KEYEVENTF_KEYUP
;
;                  $iScanCode  - The hardware scan code for the key.
;                  $iExtraInfo - The additional value associated with the key stroke.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ keybd_event
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Keybd_Event($vKey, $iFlags, $iScanCode = 0, $iExtraInfo = 0)
	DllCall('user32.dll', 'int', 'keybd_event', 'int', $vKey, 'int', $iScanCode, 'int', $iFlags, 'ptr', $iExtraInfo)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_Keybd_Event

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_KillTimer
; Description....: Destroys the specified timer.
; Syntax.........: _WinAPI_KillTimer ( $hWnd, $iTimerID )
; Parameters.....: $hWnd     - Handle to the window associated with the specified timer. This value must be the same as the
;                              $hWnd value passed to the _WinAPI_SetTimer() function that created the timer.
;                  $iTimerID - The timer identifier which specifies the timer to be destroyed.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not remove WM_TIMER messages already posted to the message queue.
; Related........:
; Link...........: @@MsdnLink@@ KillTimer
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_KillTimer($hWnd, $iTimerID)

	Local $Ret = DllCall('user32.dll', 'int', 'KillTimer', 'hwnd', $hWnd, 'uint_ptr', $iTimerID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_KillTimer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LineDDA
; Description....: Determines which pixels should be highlighted for a line.
; Syntax.........: _WinAPI_LineDDA ( $X1, $Y1, $X2, $Y2, $pLineProc [, $pData] )
; Parameters.....: $X1        - Specifies the x-coordinate, in logical units, of the line's starting point.
;                  $Y1        - Specifies the y-coordinate, in logical units, of the line's starting point.
;                  $X2        - Specifies the x-coordinate, in logical units, of the line's ending point.
;                  $Y2        - Specifies the y-coordinate, in logical units, of the line's ending point.
;                  $pLineProc - Pointer to an application-defined callback function.
;                  $pData     - Pointer to the application-defined data.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_LineDDA() function passes the coordinates for each point along the line, except for the line's ending
;                  point, to the application-defined callback function. In addition to passing the coordinates of a point, this
;                  function passes any existing application-defined data.
; Related........:
; Link...........: @@MsdnLink@@ LineDDA
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LineDDA($X1, $Y1, $X2, $Y2, $pLineProc, $pData = 0)

	Local $Ret = DllCall('gdi32.dll', 'int', 'LineDDA', 'int', $X1, 'int', $Y1, 'int', $X2, 'int', $Y2, 'ptr', $pLineProc, 'lparam', $pData)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_LineDDA

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadCursor
; Description....: Loads the specified cursor resource from the executable (.EXE) file.
; Syntax.........: _WinAPI_LoadCursor ( $hInstance, $sName )
; Parameters.....: $hInstance - Handle to an instance of the module whose executable file contains the cursor to be loaded.
;                  $sName     - The name of the cursor resource or resource identifier to be loaded. To use one of the predefined
;                               cursors, the application must set the $hInstance parameter to 0 and the $sName parameter to one
;                               of the following values.
;
;                               $IDC_APPSTARTING
;                               $IDC_HAND
;                               $IDC_ARROW
;                               $IDC_CROSS
;                               $IDC_IBEAM
;                               $IDC_ICON
;                               $IDC_NO
;                               $IDC_SIZE
;                               $IDC_SIZEALL
;                               $IDC_SIZENESW
;                               $IDC_SIZENS
;                               $IDC_SIZENWSE
;                               $IDC_SIZEWE
;                               $IDC_UPARROW
;                               $IDC_WAIT
;
; Return values..: Success    - Handle to the newly loaded cursor.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function loads the cursor resource only if it has not been loaded; otherwise, it retrieves the handle to
;                  the existing resource.
; Related........:
; Link...........: @@MsdnLink@@ LoadCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadCursor($hInstance, $sName)

	Local $TypeOfName = 'int'

	If IsString($sName) Then
		$TypeOfName = 'wstr'
	EndIf

	Local $Ret = DllCall('user32.dll', 'ptr', 'LoadCursorW', 'ptr', $hInstance, $TypeOfName, $sName)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LoadCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadCursorFromFile
; Description....: Creates a cursor based on data contained in a file.
; Syntax.........: _WinAPI_LoadCursorFromFile ( $sFile )
; Parameters.....: $sFile  - The file data to be used to create the cursor. The data in the file must be in either .CUR or .ANI format.
; Return values..: Success - Handle to the new cursor.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ LoadCursorFromFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadCursorFromFile($sFile)

	Local $Ret = DllCall('user32.dll', 'ptr', 'LoadCursorFromFileW', 'wstr', $sFile)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LoadCursorFromFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadIcon
; Description ...: Loads the specified icon resource from the executable (.exe) file associated with an application instance
; Syntax.........: _WinAPI_LoadIcon($hInstance, $vIconName)
; Parameters ....: $hInstance - Handle to an instance of the module whose executable file contains the icon to be loaded. This
;                  +parameter must be 0 when a standard icon is being loaded
;                  $vIconName - A string representing the icon resource name. Alternatively, this can be a number specifying the
;                  +resource identifier.
; Return values .: Success      - A handle to the newly loaded icon
;                  Failure      - 0
; Remarks .......: After you are done with the object, call _WinAPI_DestroyIcon to release the object resources
; Related .......: _WinAPI_DestroyIcon, _WinAPI_LoadImage
; Link ..........; @@MsdnLink@@ LoadIconA
; Example .......; No
; ===============================================================================================================================
Func _WinAPI_LoadIcon($hInstance, $vIconName)
	Local $sType, $aResult

	If IsString($vIconName) Then
		$sType = "str"
	Else
		$sType = "int"
	EndIf
	$aResult = DllCall("user32.dll", "hwnd", "LoadIconA", "hwnd", $hInstance, $sType, $vIconName)

	If @error Then Return SetError(@error, @extended, 0)
	Return SetError(0, 0, $aResult[0])
EndFunc   ;==>_WinAPI_LoadIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadIconWithScaleDown
; Description....: Loads an icon and scales down a larger image instead of scaling up a smaller image.
; Syntax.........: _WinAPI_LoadIconWithScaleDown ( $hInstance, $sName, $iWidth, $iHeight )
; Parameters.....: $hInstance - Handle to the module of either a DLL or executable (.exe) file that contains the icon to be loaded.
;                  $sName     - The information about the icon to load. If $hInstance is not 0, $sName specifies the icon resource
;                               either by name or ordinal, otherwise, $sName specifies either the name of a standalone icon (.ico)
;                               file or the identifier of a predefined icon to load.
;
;                               $IDI_APPLICATION
;                               $IDI_ASTERISK
;                               $IDI_ERROR
;                               $IDI_EXCLAMATION
;                               $IDI_HAND
;                               $IDI_INFORMATION
;                               $IDI_QUESTION
;                               $IDI_SHIELD
;                               $IDI_WARNING
;                               $IDI_WINLOGO
;
;                  $iWidth    - The desired width, in pixels, of the icon.
;                  $iHeight   - The desired height, in pixels, of the icon.
; Return values..: Success    - The icon handle.
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ LoadIconWithScaleDown
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadIconWithScaleDown($hInstance, $sName, $iWidth, $iHeight)

	Local $TypeOfName = 'int'

	If IsString($sName) Then
		$TypeOfName = 'wstr'
	EndIf

	Local $Ret = DllCall('comctl32.dll ', 'uint', 'LoadIconWithScaleDown', 'ptr', $hInstance, $TypeOfName, $sName, 'int', $iWidth, 'int', $iHeight, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_LoadIconWithScaleDown

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadIndirectString
; Description....: Extracts the string from the specified resource when given an indirect string.
; Syntax.........: _WinAPI_LoadIndirectString ( $sStrIn )
; Parameters.....: $sStrIn - The input indirect string.
; Return values..: Success - The output string.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the string is an indirect string (a string beginning with the "@" symbol), it is in the following form.
;
;                  @filename,resource
;
;                  The string is extracted from the file named, using the resource value as a locator. If the resource value is
;                  zero or greater, the number becomes the index of the string in the binary file. If the number is negative,
;                  it becomes a resource ID. An indirect string can be appended with a version modifier, as shown here:
;
;                  @filename,resource;v2
;
;                  This form can be used when a string is changed but still uses the same index or resource ID as the old string.
;                  Without a version modifier, the Multilingual User Interface (MUI) cache would not recognize that the string had
;                  changed and would continue to use the old value. By appending the version modifier, the value is seen as a
;                  new resource and is added to the cache. Note that it is recommended that you use a new resource ID or index
;                  for a new string, and use a version modifier only when that is not possible.
;
;                  If the input string is not an indirect string, the function returns an input string unchanged.
; Related........:
; Link...........: @@MsdnLink@@ SHLoadIndirectString
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadIndirectString($sStrIn)

	Local $tData = DllStructCreate('wchar[4096]')
	Local $Ret = DllCall('shlwapi.dll', 'uint', 'SHLoadIndirectString', 'wstr', $sStrIn, 'ptr', DllStructGetPtr($tData), 'uint', 4096, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_LoadIndirectString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadKeyboardLayout
; Description....: Loads a new input locale identifier into the system.
; Syntax.........: _WinAPI_LoadKeyboardLayout ( $iLanguage [, $iFlag] )
; Parameters.....: $iLanguage - The name of the input locale identifier to load (LCID).
;                  $iFlag     - The flag that specifies how the input locale identifier is to be loaded. This parameter can be
;                               one of the following values.
;
;                               $KLF_ACTIVATE
;                               $KLF_NOTELLSHELL
;                               $KLF_REORDER
;                               $KLF_REPLACELANG
;                               $KLF_SUBSTITUTE_OK
;                               $KLF_SETFORPROCESS
;
; Return values..: Success    - The input locale identifier to the locale matched with the requested name.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ LoadKeyboardLayout
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadKeyboardLayout($iLanguage, $iFlag = 0)

	Local $Ret = DllCall('user32.dll', 'long', 'LoadKeyboardLayoutW', 'wstr', Hex($iLanguage, 8), 'uint', $iFlag)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LoadKeyboardLayout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadMedia
; Description....: Loads media into a device.
; Syntax.........: _WinAPI_LoadMedia ( $sDrive )
; Parameters.....: $sDrive - The drive letter of the CD tray to load, in the format D:, E:, etc.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_STORAGE_LOAD_MEDIA
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadMedia($sDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0x80000000, 0x01)

	If Not $hFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', $IOCTL_STORAGE_LOAD_MEDIA, 'ptr', 0, 'dword', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LoadMedia

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadResource
; Description....: Loads the specified resource into global memory.
; Syntax.........: _WinAPI_LoadResource ( $hInstance, $hResource )
; Parameters.....: $hInstance - Handle to the module whose executable file contains the resource. If this parameter is 0, the system
;                               loads the resource from the module that was used to create the current process.
;                  $hResource - Handle to the resource to be loaded. This handle is returned by the _WinAPI_FindResource()
;                               or _WinAPI_FindResourceEx() function.
; Return values..: Success    - Handle to the data associated with the resource.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: To obtain a pointer to the resource data, call the _WinAPI_LockResource() function.
; Related........:
; Link...........: @@MsdnLink@@ LoadResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadResource($hInstance, $hResource)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'LoadResource', 'ptr', $hInstance, 'ptr', $hResource)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LoadResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoByte
; Description....: Returns the low BYTE of a 16-bit (2 bytes) value.
; Syntax.........: _WinAPI_LoByte ( $iValue )
; Parameters.....: $iValue - 16-bit value.
; Return values..: Low BYTE value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoByte($iValue)
	Return BitAND($iValue, 0xFF)
EndFunc   ;==>_WinAPI_LoByte

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LockDevice
; Description....: Enables or disables the mechanism that ejects media, for those devices possessing that locking capability.
; Syntax.........: _WinAPI_LockDevice ( $sDrive, $fLock )
; Parameters.....: $sDrive - The drive letter of the device to enable or disable, in the format D:, E:, etc.
;                  $fLock  - Specifies whether the device should be disabled, valid values:
;                  |TRUE   - The device is disabled.
;                  |FALSE  - The device is enabled.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Psandu.ro
; Modified.......: Yashied
; Remarks........: This function is valid only for devices that support removable media.
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_STORAGE_MEDIA_REMOVAL
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LockDevice($sDrive, $fLock)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0xC0000000, 0x03)

	If Not $hFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tPREVENT_MEDIA_REMOVAL = DllStructCreate('byte')

	DllStructSetData($tPREVENT_MEDIA_REMOVAL, 1, $fLock)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', $IOCTL_STORAGE_MEDIA_REMOVAL, 'ptr', DllStructGetPtr($tPREVENT_MEDIA_REMOVAL), 'dword', DllStructGetSize($tPREVENT_MEDIA_REMOVAL), 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_LockDevice

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LockFile
; Description....: Locks the specified file for exclusive access by the calling process.
; Syntax.........: _WinAPI_LockFile ( $hFile, $iOffset, $iLenght )
; Parameters.....: $hFile   - Handle to the file.
;                  $iOffset - The starting byte offset in the file where the lock should begin.
;                  $iLenght - The length of the byte range to be locked.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If a process terminates with a portion of a file locked or closes a file that has outstanding locks, the locks are
;                  unlocked by the operating system. However, the time it takes for the operating system to unlock these locks depends
;                  upon available system resources. Therefore, it is recommended that your process explicitly unlock all files it
;                  has locked when it terminates.
; Related........:
; Link...........: @@MsdnLink@@ LockFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LockFile($hFile, $iOffset, $iLenght)

	Local $Ret = DllCall('kernel32.dll', 'int', 'LockFile', 'ptr', $hFile, 'dword', _WinAPI_LoDWord($iOffset), 'dword', _WinAPI_HiDWord($iOffset), 'dword', _WinAPI_LoDWord($iLenght), 'dword', _WinAPI_HiDWord($iLenght))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_LockFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LockResource
; Description....: Locks the specified resource in memory.
; Syntax.........: _WinAPI_LockResource ( $hData )
; Parameters.....: $hData  - Handle to the resource to be locked. The _WinAPI_LoadResource() function returns this handle. Do not
;                            pass any value as a parameter other than a successful return value from the LoadResource function.
; Return values..: Success - Pointer to the first byte of the resource.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The pointer returned by this function is valid until the module containing the resource is unloaded. It is not
;                  necessary to unlock resources because the system automatically deletes them when the process that created
;                  them terminates.
;
;                  Do not try to lock a resource by using the handle returned by the _WinAPI_FindResource() or _WinAPI_FindResourceEx()
;                  function. Such a handle points to random data.
;
;                  Note _WinAPI_LockResource() does not actually lock memory; it is just used to obtain a pointer to the memory
;                  containing the resource data. The name of the function comes from versions prior to Windows XP, when it was
;                  used to lock a global memory block allocated by _WinAPI_LoadResource().
; Related........:
; Link...........: @@MsdnLink@@ LockResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LockResource($hData)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'LockResource', 'ptr', $hData)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LockResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LockWindowUpdate
; Description....: Disables or enables drawing in the specified window.
; Syntax.........: _WinAPI_LockWindowUpdate ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window in which drawing will be disabled. If this parameter is 0, drawing in the locked
;                            window is enabled.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Only one window can be locked at a time by using this function.
; Related........:
; Link...........: @@MsdnLink@@ LockWindowUpdate
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LockWindowUpdate($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'LockWindowUpdate', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_LockWindowUpdate

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LockWorkStation
; Description....: Locks the workstation's display.
; Syntax.........: _WinAPI_LockWorkStation ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ LockWorkStation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LockWorkStation()
	DllCall('user32.dll', 'int', 'LockWorkStation')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_LockWorkStation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoDWord
; Description....: Returns the low DWORD of a 64-bit (8 bytes) value.
; Syntax.........: _WinAPI_LoDWord ( $iValue )
; Parameters.....: $iValue - 64-bit value.
; Return values..: Low DWORD value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoDWord($iValue)

	Local $tInt64, $tQWord

	$tInt64 = DllStructCreate('int64')
	$tQWord = DllStructCreate('dword;dword', DllStructGetPtr($tInt64))
	DllStructSetData($tInt64, 1, $iValue)
	Return DllStructGetData($tQWord, 1)
EndFunc   ;==>_WinAPI_LoDWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LongMid
; Description....: Extracts a number of bits from a DWORD (32-bit) value.
; Syntax.........: _WinAPI_LongMid ( $iValue, $iStart, $iCount )
; Parameters.....: $iValue - 32-bit value.
;                  $iStart - The bit position to start. (0 - first bit)
;                  $iCount - The number of bits to extract.
; Return values..: The value that consists of a specified bits.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not check the parameters for valid values. If values is incorrect, the function may return
;                  an unexpected results.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LongMid($iValue, $iStart, $iCount)
	Return BitAND(BitShift($iValue, $iStart), BitOR(BitShift(BitShift(0x7FFFFFFF, 32 - ($iCount + 1)), 1), BitShift(1, -($iCount - 1))))
EndFunc   ;==>_WinAPI_LongMid

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LookupIconIdFromDirectoryEx
; Description....: Searches through icon or cursor data for the icon or cursor that best fits the current display device.
; Syntax.........: _WinAPI_LookupIconIdFromDirectoryEx ( $pData [, $fIcon [, $xDesired [, $yDesired [, $iFlags]]]] )
; Parameters.....: $pData    - The icon or cursor directory data. Because this function does not validate the resource data, it
;                              causes a general protection (GP) fault or returns an undefined value if presbits is not pointing
;                              to validresource data.
;                  $fIcon    - Specifies whether an icon or a cursor is sought, valid values:
;                  |TRUE     - The function is searching for an icon. (Default)
;                  |FALSE    - The function is searching for a cursor.
;                  $xDesired - The desired width, in pixels, of the icon or cursor. If this parameter is zero, the function uses the
;                              system metric value.
;                  $yDesired - The desired height, in pixels, of the icon or cursor. If this parameter is zero, the function uses the
;                              system metric value.
;                  $iFlags   - This parameter can be one or more of the following values.
;
;                              $LR_DEFAULTCOLOR
;                              $LR_MONOCHROME
;
; Return values..: Success   - An integer resource identifier for the icon or cursor that best fits the current display device.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The icon directory is loaded from a resource file with resource type $RT_GROUP_ICON (or $RT_GROUP_CURSOR),
;                  and an integer resource name for the specific icon to be loaded. _WinAPI_LookupIconIdFromDirectoryEx() returns
;                  an integer identifier that is the resource name of the icon that best fits the current display device.
; Related........:
; Link...........: @@MsdnLink@@ LookupIconIdFromDirectoryEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LookupIconIdFromDirectoryEx($pData, $fIcon = 1, $xDesired = 0, $yDesired = 0, $iFlags = 0)

	Local $Ret = DllCall('user32.dll', 'int', 'LookupIconIdFromDirectoryEx', 'ptr', $pData, 'int', $fIcon, 'int', $xDesired, 'int', $yDesired, 'uint', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LookupIconIdFromDirectoryEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LPtoDP
; Description....: Converts a logical coordinates into device coordinates.
; Syntax.........: _WinAPI_LPtoDP( $hDC, $tPOINT [, $iCount = 1] )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tPoint - $tagPOINT structure or structure of points ("long x1;long y1;...long xN;long yN") containing the
;                            x- and y-coordinates to be transformed.
;                  $iCount - The number of points.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_DPtoLP() function fails if the device coordinates exceed 27 bits, or if the converted logical coordinates
;                  exceed 32 bits. In the case of such an overflow, the results for all the points are undefined.
; Related........:
; Link...........: @@MsdnLink@@ LPtoDP
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LPtoDP($hDC, ByRef $tPoint, $iCount = 1)

	Local $Ret = DllCall('gdi32.dll', 'int', 'LPtoDP', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPoint), 'int', $iCount)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_LPtoDP

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LookupPrivilegeName
; Description....: Retrieves the name that corresponds to the privilege by a specified locally unique identifier (LUID).
; Syntax.........: _WinAPI_LookupPrivilegeName ( $tLUID )
; Parameters.....: $tLUID  - $tagLUID structure that specifies the LUID by which the privilege is known on the target system.
; Return values..: Success - The string that represents the privilege name. For example, "SeSecurityPrivilege".
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ LookupPrivilegeName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LookupPrivilegeName($tLUID)

	Local $tData = DllStructCreate('wchar[128]')
	Local $Ret = DllCall('advapi32.dll', 'int', 'LookupPrivilegeNameW', 'ptr', 0, 'ptr', DllStructGetPtr($tLUID), 'ptr', DllStructGetPtr($tData), 'dword*', 128)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_LookupPrivilegeName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LookupPrivilegeValue
; Description....: Retrieves the locally unique identifier (LUID) to locally represent the specified privilege name.
; Syntax.........: _WinAPI_LookupPrivilegeValue ( $sPrivilege )
; Parameters.....: $sPrivilege - The string that specifies the name of the privilege ($SE_*).
; Return values..: Success     - $tagLUID structure that contains the LUID.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ LookupPrivilegeValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LookupPrivilegeValue($sPrivilege)

	Local $tLUID = DllStructCreate($tagLUID)
	Local $Ret = DllCall('advapi32.dll', 'int', 'LookupPrivilegeValueW', 'ptr', 0, 'wstr', $sPrivilege, 'ptr', DllStructGetPtr($tLUID))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tLUID
EndFunc   ;==>_WinAPI_LookupPrivilegeValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LZNTCompress
; Description....: Compresses an input data.
; Syntax.........: _WinAPI_LZNTCompress ( ByRef $tInput, ByRef $tOutput [, $fMaximum] )
; Parameters.....: $tInput   - "byte[n]" or any other structure that contains the data to be compressed.
;                  $tOutput  - "byte[n]" structure that receives the compressed data.
;                  $fMaximum - Specifies whether use a maximum data compression, valid values:
;                  |TRUE     - Uses an algorithm which provides maximum data compression but with relatively slower performance.
;                  |FALSE    - Uses an algorithm which provides a balance between data compression and performance. (Default)
; Return values..: Success   - The size of the compressed data, in bytes.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Trancexx
; Modified.......: Yashied
; Remarks........: The input and output buffers must be different, otherwise, the function fails.
; Related........:
; Link...........: @@MsdnLink@@ RtlCompressBuffer
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LZNTCompress(ByRef $tInput, ByRef $tOutput, $fMaximum = 0)

	Local $tBuffer, $tWorkSpace, $Ret, $Format = 0x0002

	If $fMaximum Then
		$Format = BitOR($Format, 0x0102)
	EndIf
	$tOutput = 0
	$Ret = DllCall('ntdll.dll', 'uint', 'RtlGetCompressionWorkSpaceSize', 'ushort', $Format, 'ulong*', 0, 'ulong*', 0)
	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	$tWorkSpace = DllStructCreate('byte[' & $Ret[2] & ']')
	$tBuffer = DllStructCreate('byte[' & (2 * DllStructGetSize($tInput)) & ']')
	$Ret = DllCall('ntdll.dll', 'uint', 'RtlCompressBuffer', 'ushort', $Format, 'ptr', DllStructGetPtr($tInput), 'ulong', DllStructGetSize($tInput), 'ptr', DllStructGetPtr($tBuffer), 'ulong', DllStructGetSize($tBuffer), 'ulong', 4096, 'ulong*', 0, 'ptr', DllStructGetPtr($tWorkSpace))
	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	$tOutput = DllStructCreate('byte[' & $Ret[7] & ']')
	If Not _WinAPI_MoveMemory(DllStructGetPtr($tOutput), DllStructGetPtr($tBuffer), $Ret[7]) Then
		$tOutput = 0
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[7]
EndFunc   ;==>_WinAPI_LZNTCompress

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LZNTDecompress
; Description....: Decompresses an input data.
; Syntax.........: _WinAPI_LZNTDecompress ( ByRef $tInput, ByRef $tOutput [, $iBufferSize] )
; Parameters.....: $tInput      - "byte[n]" or any other structure that contains the data to be decompressed.
;                  $tOutput     - "byte[n]" structure that receives the decompressed data.
;                  $iBufferSize - The size of the buffer which are used for decompressing, in bytes. Default is 8388608 (8 MB).
; Return values..: Success      - The size of the decompressed data, in bytes.
;                  Failure      - 0 and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Trancexx
; Modified.......: Yashied
; Remarks........: The input and output buffers must be different, otherwise, the function fails.
; Related........:
; Link...........: @@MsdnLink@@ RtlDecompressBuffer
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LZNTDecompress(ByRef $tInput, ByRef $tOutput, $iBufferSize = 8388608)

	Local $tBuffer, $Ret

	$tOutput = 0
	$tBuffer = DllStructCreate('byte[' & $iBufferSize & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Ret = DllCall('ntdll.dll', 'uint', 'RtlDecompressBuffer', 'ushort', 0x0002, 'ptr', DllStructGetPtr($tBuffer), 'ulong', $iBufferSize, 'ptr', DllStructGetPtr($tInput), 'ulong', DllStructGetSize($tInput), 'ulong*', 0)
	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	$tOutput = DllStructCreate('byte[' & $Ret[6] & ']')
	If Not _WinAPI_MoveMemory(DllStructGetPtr($tOutput), DllStructGetPtr($tBuffer), $Ret[6]) Then
		$tOutput = 0
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[6]
EndFunc   ;==>_WinAPI_LZNTDecompress

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MapViewOfFile
; Description....: Maps a view of a file mapping into the address space of a calling process.
; Syntax.........: _WinAPI_MapViewOfFile ( $hMapping [, $iOffset [, $iBytes [, $iAccess]]] )
; Parameters.....: $hMapping - Handle to a file mapping object. The _WinAPI_CreateFileMapping() and _WinAPI_OpenFileMapping()
;                              functions return this handle.
;                  $iOffset  - The file offset where the view is to begin.
;                  $iBytes   - The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size
;                              specified by _WinAPI_CreateFileMapping(). If $iBytes is 0, the mapping extends from the specified
;                              offset to the end of the file mapping.
;                  $iAccess  - The access to the file mapping object. This parameter can be one of the following values.
;
;                              $FILE_MAP_ALL_ACCESS
;                              $FILE_MAP_COPY
;                              $FILE_MAP_READ
;                              $FILE_MAP_WRITE
;
;                              Each of the preceding values can be combined with the following value.
;
;                              $FILE_MAP_EXECUTE
;
; Return values..: Success   - The starting address of the mapped view.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: For files that are larger than the address space, you can only map a small portion of the file data at one time.
;                  When the first view is complete, then you unmap it and map a new view.
; Related........:
; Link...........: @@MsdnLink@@ MapViewOfFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MapViewOfFile($hMapping, $iOffset = 0, $iBytes = 0, $iAccess = 0x0006)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'MapViewOfFile', 'ptr', $hMapping, 'dword', $iAccess, 'dword', _WinAPI_HiDWord($iOffset), 'dword', _WinAPI_LoDWord($iOffset), 'dword', $iBytes)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_MapViewOfFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MapVirtualKey
; Description....: Translates a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code.
; Syntax.........: _WinAPI_MapVirtualKey ( $iCode, $iType )
; Parameters.....: $iCode  - The virtual key code or scan code for a key. How this value is interpreted depends on the $iType parameter.
;                  $iType  - The translation to be performed. This value depends on the value of the $iCode parameter and can be
;                            one of the following values.
;
;                            $MAPVK_VK_TO_CHAR
;                            $MAPVK_VK_TO_VSC
;                            $MAPVK_VSC_TO_VK
;                            $MAPVK_VSC_TO_VK_EX
;
; Return values..: Success - A scan code, a virtual-key code, or a character value, depending on the above parameters.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application can use _WinAPI_MapVirtualKey() to translate scan codes to the virtual-key code constants
;                  $VK_SHIFT, $VK_CONTROL, and $VK_MENU, and vice versa. These translations do not distinguish between the left and
;                  right instances of the SHIFT, CTRL, or ALT keys.
;
;                  An application can get the scan code corresponding to the left or right instance of one of these keys by calling
;                  _WinAPI_MapVirtualKey() with uCode set to one of the following virtual-key code constants.
;
;                  $VK_LSHIFT
;                  $VK_RSHIFT
;                  $VK_LCONTROL
;                  $VK_RCONTROL
;                  $VK_LMENU
;                  $VK_RMENU
;
; Related........:
; Link...........: @@MsdnLink@@ MapVirtualKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MapVirtualKey($iCode, $iType)

	Local $Ret = DllCall('user32.dll', 'uint', 'MapVirtualKeyW', 'uint', $iCode, 'uint', $iType)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_MapVirtualKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MaskBlt
; Description....: Combines the color data for the source and destination bitmaps using the specified mask and raster operation.
; Syntax.........: _WinAPI_MaskBlt ( $hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $hMask, $iXMask, $iYMask, $iRop )
; Parameters.....: $hDestDC - Handle to the destination device context.
;                  $iXDest  - The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iYDest  - The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iWidth  - The width, in logical units, of the destination rectangle and source bitmap.
;                  $iHeight - The height, in logical units, of the destination rectangle and source bitmap.
;                  $hSrcDC  - Handle to the device context from which the bitmap is to be copied.
;                  $iXSrc   - The x-coordinate, in logical units, of the upper-left corner of the source bitmap.
;                  $iYSrc   - The y-coordinate, in logical units, of the upper-left corner of the source bitmap.
;                  $hMask   - Handle to the monochrome mask bitmap combined with the color bitmap in the source device context.
;                  $iXMask  - The horizontal pixel offset for the mask bitmap specified by the hbmMask parameter.
;                  $iYMask  - The vertical pixel offset for the mask bitmap specified by the hbmMask parameter.
;                  $iRop    - The raster-operation code (same as for _WinAPI_BitBlt()).
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: A value of 1 in the mask specified by $hMask indicates that the foreground raster operation code specified by
;                  $iRop should be applied at that location. A value of 0 in the mask indicates that the background raster operation
;                  code specified by $iRop should be applied at that location.
;
;                  If no mask bitmap is supplied, this function behaves exactly like _WinAPI_BitBlt(), using the foreground raster
;                  operation code.
; Related........:
; Link...........: @@MsdnLink@@ MaskBlt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MaskBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $hMask, $iXMask, $iYMask, $iRop)

	Local $Ret = DllCall('gdi32.dll', 'int', 'MaskBlt', 'hwnd', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidth, 'int', $iHeight, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'ptr', $hMask, 'int', $iXMask, 'int', $iYMask, 'dword', $iRop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_MaskBlt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MessageBoxCheck
; Description....: Displays a message box that gives the user the option of suppressing further occurrences.
; Syntax.........: _WinAPI_MessageBoxCheck ( $iType, $sTitle, $sText, $sRegVal [, $iDefault [, $hParent]] )
; Parameters.....: $iType    - The flags that specify the contents and behavior of the message box.
;
;                              You must specify the buttons to be displayed by setting one and only one of the following flags.
;
;                              $MB_OK
;                              $MB_OKCANCEL
;                              $MB_YESNO
;
;                              You can display an optional icon by setting one and only one of the following flags.
;
;                              $MB_ICONEXCLAMATION
;                              $MB_ICONHAND
;                              $MB_ICONINFORMATION
;                              $MB_ICONQUESTION
;
;                  $sTitle   - The string that contains the title of the message box.
;                  $sText    - The string that contains the message to be displayed.
;                  $sRegVal  - The string that contains a unique string value to associate with this message.
;                  $iDefault - The value that the function returns when the user has opted not to have the message box displayed
;                              again. If the user has not opted to suppress the message box, the message box is displayed and
;                              the function ignores $iDefault.
;                  $hParent  - The window handle to the message box's owner.
; Return values..: Success   - If the user has already chosen to suppress the message box, the function immediately returns the
;                              value assigned to $iDefault, otherwise, returns one of the $ID_* constants.
;                  Failure   - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function records the message boxes that the user has chosen to suppress under the following registry key.
;
;                  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\LowRegistry\DontShowMeThisDialogAgain
;
; Related........:
; Link...........: @@MsdnLink@@ SHMessageBoxCheck
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MessageBoxCheck($iType, $sTitle, $sText, $sRegVal, $iDefault = -1, $hParent = 0)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'SHMessageBoxCheckW', 'hwnd', $hParent, 'wstr', $sText, 'wstr', $sTitle, 'uint', $iType, 'int', $iDefault, 'wstr', $sRegVal)

	If @error Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_MessageBoxCheck

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MessageBoxIndirect
; Description....: Creates, displays, and operates a message box.
; Syntax.........: _WinAPI_MessageBoxIndirect ( $tMSGBOXPARAMS )
; Parameters.....: $tMSGBOXPARAMS - $tagMSGBOXPARAMS structure that contains information used to display the message box.
; Return values..: Success        - One of the $ID* constants.
;                  Failure        - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the
;                  "Text" and "Caption" members of the $tagMSGBOXPARAMS structure should not be taken from a resource file, because
;                  an attempt to load the resource may fail.
;
;                  If you create a message box while a dialog box is present, use a handle to the dialog box as the hWnd parameter.
;                  The hWnd parameter should not identify a child window, such as a control in a dialog box.
; Related........:
; Link...........: @@MsdnLink@@ MessageBoxIndirect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MessageBoxIndirect($tMSGBOXPARAMS)

	Local $Ret = DllCall('user32.dll', 'int', 'MessageBoxIndirectW', 'ptr', DllStructGetPtr($tMSGBOXPARAMS))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_MessageBoxIndirect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ModifyWorldTransform
; Description....: Changes the world transformation for a device context using the specified mode.
; Syntax.........: _WinAPI_ModifyWorldTransform ( $hDC, $tXFORM, $iMode )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tXFORM - $tagXFORM structure used to modify the world transformation for the given device context.
;                  $iMode  - Specifies how the transformation data modifies the current world transformation.
;                            This parameter must be one of the following values.
;
;                            $MWT_IDENTITY
;                            $MWT_LEFTMULTIPLY
;                            $MWT_RIGHTMULTIPLY
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_ModifyWorldTransform() will fail unless graphics mode for the specified device context has been set
;                  to $GM_ADVANCED by previously calling the _WinAPI_SetGraphicsMode(). Likewise, it will not be possible to reset
;                  the graphics mode for the device context to the default $GM_COMPATIBLE mode, unless world transform has first
;                  been reset to the default identity transform by calling _WinAPI_SetWorldTransform().
; Related........:
; Link...........: @@MsdnLink@@ ModifyWorldTransform
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ModifyWorldTransform($hDC, $tXFORM, $iMode)

	Local $Ret = DllCall('gdi32.dll', 'int', 'ModifyWorldTransform', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tXFORM), 'dword', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ModifyWorldTransform

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MoveFileEx
; Description....: Moves a file or directory, notifying the application of its progress through a callback function.
; Syntax.........: _WinAPI_MoveFileEx ( $sExistingFile, $sNewFile [, $iFlags [, $pProgressProc [, $pData] )
; Parameters.....: $sExistingFile - The name of the existing file or directory on the local computer.
;
;                                   If $iFlags specifies $MOVE_FILE_DELAY_UNTIL_REBOOT, the file cannot exist on a remote share
;                                   because delayed operations are performed before the network is available.
;
;                  $sNewFile      - The new name of the file or directory on the local computer.
;
;                                   When moving a file, $sNewFile can be on a different file system or volume. If $sNewFile is
;                                   on another drive, you must set the  $MOVE_FILE_COPY_ALLOWED flag in $iFlags parameter.
;
;                                   When moving a directory, $sExistingFile and $sNewFile  must be on the same drive.
;
;                                   If $iFlags specifies $MOVE_FILE_DELAY_UNTIL_REBOOT and $sNewFile is 0, _WinAPI_MoveFileEx()
;                                   registers $sExistingFile to be deleted when the system restarts. If $sExistingFile refers to
;                                   a directory, the system removes the directory at restart only if the directory is empty.
;
;                  $iFlags        - The move options. This parameter can be one or more of the following values.
;
;                                   $MOVE_FILE_COPY_ALLOWED
;                                   $MOVE_FILE_CREATE_HARDLINK
;                                   $MOVE_FILE_DELAY_UNTIL_REBOOT
;                                   $MOVE_FILE_FAIL_IF_NOT_TRACKABLE
;                                   $MOVE_FILE_REPLACE_EXISTING
;                                   $MOVE_FILE_WRITE_THROUGH
;
;                  $pProgressProc - The address of a callback function that is called each time another portion of the file
;                                   has been moved.
;
;                                   (See MSDN for more information)
;
;                  $pData         - The argument to be passed to the callback function.
; Return values..: Success        - 1.
;                  Failure        - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the $iFlags parameter specifies $MOVE_FILE_DELAY_UNTIL_REBOOT, _WinAPI_MoveFileEx() fails if it cannot
;                  access the registry. The function stores the locations of the files to be renamed at restart in the
;                  following registry value:
;
;                  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\PendingFileRenameOperations
;
; Related........:
; Link...........: @@MsdnLink@@ MoveFileWithProgress
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MoveFileEx($sExistingFile, $sNewFile, $iFlags = 0, $pProgressProc = 0, $pData = 0)

	Local $TypeOfNewFile = 'wstr'

	If Not StringStripWS($sNewFile, 3) Then
		$TypeOfNewFile = 'ptr'
		$sNewFile = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'MoveFileWithProgressW', 'wstr', $sExistingFile, $TypeOfNewFile, $sNewFile, 'ptr', $pProgressProc, 'long_ptr', $pData, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_MoveFileEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MoveMemory
; Description....: Moves a block of memory from one location to another.
; Syntax.........: _WinAPI_MoveMemory ( $pDestination, $pSource, $iLenght )
; Parameters.....: $pDestination - A pointer to the starting address of the move destination.
;                  $pSource      - A pointer to the starting address of the block of memory to be moved.
;                  $iLenght      - The size of the block of memory to move, in bytes.
; Return values..: Success       - 1.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The source and destination blocks may overlap.
; Related........:
; Link...........: @@MsdnLink@@ RtlMoveMemory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MoveMemory($pDestination, $pSource, $iLenght)
	DllCall('ntdll.dll', 'none', 'RtlMoveMemory', 'ptr', $pDestination, 'ptr', $pSource, 'ulong_ptr', $iLenght)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_MoveMemory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MoveToEx
; Description....: Updates the current position to the specified point.
; Syntax.........: _WinAPI_MoveToEx ( $hDC, $iX, $iY )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical units, of the new position, in logical units.
;                  $iY     - The y-coordinate, in logical units, of the new position, in logical units.
; Return values..: Success - $tagPOINT structure that receives the previous current position.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ MoveToEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MoveToEx($hDC, $iX, $iY)

	Local $tPOINT = DllStructCreate($tagPOINT)
	Local $Ret = DllCall('gdi32.dll', 'int', 'MoveToEx', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'ptr', DllStructGetPtr($tPOINT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tPOINT
EndFunc   ;==>_WinAPI_MoveToEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_NtStatusToDosError
; Description....: Converts the specified NTSTATUS code to its equivalent system error code.
; Syntax.........: _WinAPI_NtStatusToDosError ( $iStatus )
; Parameters.....: $iStatus - The NTSTATUS code to be converted.
; Return values..: Success  - The system error code. ERROR_MR_MID_NOT_FOUND (317) is returned when the specified NTSTATUS code
;                             does not have a corresponding system error code.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlNtStatusToDosError
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_NtStatusToDosError($iStatus)

	Local $Ret = DllCall('ntdll.dll', 'uint', 'RtlNtStatusToDosError', 'uint', $iStatus)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_NtStatusToDosError

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OemToChar
; Description....: Converts a string from the OEM-defined character set into either an ANSI string.
; Syntax.........: _WinAPI_OemToChar ( $sStr )
; Parameters.....: $sStr   - The string of characters from the OEM-defined character set.
; Return values..: Success - The converted string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OemToChar
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OemToChar($sStr)

	Local $tData = DllStructCreate('char[' & StringLen($sStr) + 1 & ']')
	Local $Ret = DllCall('user32.dll', 'int', 'OemToChar', 'str', $sStr, 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_OemToChar

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OffsetClipRgn
; Description....: Moves the clipping region of a device context by the specified offsets.
; Syntax.........: _WinAPI_OffsetClipRgn ( $hDC, $iXOffset, $iYOffset )
; Parameters.....: $hDC      - Handle to the device context.
;                  $iXOffset - The number of logical units to move left or right.
;                  $iYOffset - The number of logical units to move up or down.
; Return values..: Success   - The value that specifies the new clipping region's complexity; it can be one of the following values.
;
;                              $COMPLEXREGION
;                              $NULLREGION
;                              $SIMPLEREGION
;
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OffsetClipRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OffsetClipRgn($hDC, $iXOffset, $iYOffset)

	Local $Ret = DllCall('gdi32.dll', 'int', 'OffsetClipRgn', 'hwnd', $hDC, 'int', $iXOffset, 'int', $iYOffset)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OffsetClipRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OffsetPoints
; Description....: Moves a points from the array by the specified offsets.
; Syntax.........: _WinAPI_OffsetPoints ( ByRef $aPoint, $iXOffset, $iYOffset [, $iStart [, $iEnd]] )
; Parameters.....: $aPoint   - The 2D array ([x1, y1, ...], [x2, y2, ...], ... [xN, yN, ...]). Every first two elements from this
;                              array specifies a point to be move. Other array elements (if any) do not change.
;                  $iXOffset - The number of logical units to move left or right.
;                  $iYOffset - The number of logical units to move up or down.
;                  $iStart   - The index of array to start moving at.
;                  $iEnd     - The index of array to stop moving at.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OffsetPoints(ByRef $aPoint, $iXOffset, $iYOffset, $iStart = 0, $iEnd = -1)
	If UBound($aPoint, 2) < 2 Then
		Return SetError(2, 0, 0)
	EndIf
	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	If $iStart > $iEnd Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		$aPoint[$i][0] += $iXOffset
		$aPoint[$i][1] += $iYOffset
	Next
	Return 1
EndFunc   ;==>_WinAPI_OffsetPoints

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OffsetRect
; Description....: Moves the specified rectangle by the specified offsets.
; Syntax.........: _WinAPI_OffsetRect ( ByRef $tRECT, $DX, $DY )
; Parameters.....: $tRECT  - $tagRECT structure that to be moved.
;                  $DX     - The amount to move the rectangle left (negative value) or right.
;                  $DY     - The amount to move the rectangle up (negative value) or down.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OffsetRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OffsetRect(ByRef $tRECT, $DX, $DY)

	Local $Ret = DllCall('user32.dll', 'int', 'OffsetRect', 'ptr', DllStructGetPtr($tRECT), 'int', $DX, 'int', $DY)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_OffsetRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OffsetRgn
; Description....: Moves a region by the specified offsets.
; Syntax.........: _WinAPI_OffsetRgn ( $hRgn, $iXOffset, $iYOffset )
; Parameters.....: $hRgn     - Handle to the region to be moved.
;                  $iXOffset - The number of logical units to move left or right.
;                  $iYOffset - The number of logical units to move up or down.
; Return values..: Success   - The value that specifies the new clipping region's complexity; it can be one of the following values.
;
;                              $COMPLEXREGION
;                              $NULLREGION
;                              $SIMPLEREGION
;
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OffsetRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OffsetRgn($hRgn, $iXOffset, $iYOffset)

	Local $Ret = DllCall('gdi32.dll', 'int', 'OffsetRgn', 'ptr', $hRgn, 'int', $iXOffset, 'int', $iYOffset)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OffsetRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenFileById
; Description....: Opens the file that matches the specified object identifier.
; Syntax.........: _WinAPI_OpenFileById ( $hFile, $tGUID, $iAccess, $iShare [, $iFlags] )
; Parameters.....: $hFile   - The path or handle to any file on a volume or share on which the file to be opened is stored.
;                  $tGUID   - $tagGUID structure or its string representation that identifies the file to open.
;                  $iAccess - The access to the object. Access can be read, write, or both. If this parameter is 0, the application
;                             can query file and device attributes without accessing a device.
;
;                             $GENERIC_READ
;                             $GENERIC_WRITE
;
;                             (See MSDN for more information)
;
;                  $iShare  - The sharing mode of an object, which can be read, write, both, or none. If this parameter is 0 and
;                             function succeeds, the object cannot be shared and cannot be opened again until the handle
;                             is closed.
;
;                             $FILE_SHARE_DELETE
;                             $FILE_SHARE_READ
;                             $FILE_SHARE_WRITE
;
;                  $iFlags  - The file flags. When _WinAPI_OpenFileById() opens a file, it combines the file flags with existing
;                             file attributes, and ignores any supplied file attributes. This parameter can include any
;                             combination of the following values.
;
;                             $FILE_FLAG_BACKUP_SEMANTICS
;                             $FILE_FLAG_NO_BUFFERING
;                             $FILE_FLAG_OPEN_NO_RECALL
;                             $FILE_FLAG_OPEN_REPARSE_POINT
;                             $FILE_FLAG_OVERLAPPED
;                             $FILE_FLAG_RANDOM_ACCESS
;                             $FILE_FLAG_SEQUENTIAL_SCAN
;                             $FILE_FLAG_WRITE_THROUGH
;
; Return values..: Success  - Handle to a specified file.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When an application is finished using the object handle returned by this function, use the _WinAPI_CloseHandle()
;                  function to close the handle. This not only frees up system resources, but can have wider influence on things
;                  like sharing the file or device and committing data to disk.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ OpenFileById
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenFileById($hFile, $tGUID, $iAccess, $iShare, $iFlags = 0)

	Local $hAny, $tFIDD, $Ret, $Flags, $Error = 0

	If IsString($hFile) Then
		If _WinAPI_PathIsDirectory($hFile) Then
			$Flags = 0x02000000
		Else
			$Flags = 0
		EndIf
		$hAny = _WinAPI_CreateFileEx($hFile, 3, 0, 0x06, $Flags)
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
	Else
		$hAny = $hFile
	EndIf
	$tFIDD = DllStructCreate('dword;uint;byte[16]')
	DllStructSetData($tFIDD, 1, DllStructGetSize($tFIDD))
	DllStructSetData($tFIDD, 2, 1)
	If IsString($tGUID) Then
		$Ret = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', $tGUID, 'ptr', DllStructGetPtr($tFIDD, 3))
		If (@error) Or ($Ret[0]) Then
			Return SetError(1, 0, 0)
		EndIf
	Else
		If IsDllStruct($tGUID) Then
			_WinAPI_MoveMemory(DllStructGetPtr($tFIDD, 3), DllStructGetPtr($tGUID), 16)
		Else
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	$Ret = DllCall('kernel32.dll', 'ptr', 'OpenFileById', 'ptr', $hAny, 'ptr', DllStructGetPtr($tFIDD), 'dword', $iAccess, 'dword', $iShare, 'ptr', 0, 'dword', $iFlags)
	If (@error) Or ($Ret[0] = Ptr(-1)) Then
		$Error = 1
	EndIf
	If IsString($hFile) Then
		_WinAPI_CloseHandle($hAny)
	EndIf
	If $Error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenFileById

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenFileMapping
; Description....: Opens a named file mapping object.
; Syntax.........: _WinAPI_OpenFileMapping ( $sName [, $iAccess [, $fInherit]] )
; Parameters.....: $sName    - The name of the file mapping object to be opened.
;                  $iAccess  - The access to the file mapping object. This parameter can be one of the following values.
;
;                              $FILE_MAP_ALL_ACCESS
;                              $FILE_MAP_COPY
;                              $FILE_MAP_READ
;                              $FILE_MAP_WRITE
;
;                              Each of the preceding values can be combined with the following value.
;
;                              $FILE_MAP_EXECUTE
;
;                  $fInherit - Specifies whether inherites the handle by a processes, valid values:
;                  |TRUE     - The processes created by this process will inherit the handle.
;                  |FALSE    - The processes do not inherit this handle. (Default)
; Return values..: Success   - Handle to the specified file mapping object.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OpenFileMapping
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenFileMapping($sName, $iAccess = 0x0006, $fInherit = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'OpenFileMappingW', 'dword', $iAccess, 'int', $fInherit, 'wstr', $sName)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenFileMapping

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenIcon
; Description....: Restores a minimized (iconic) window to its previous size and position and activates the window.
; Syntax.........: _WinAPI_OpenIcon ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to be restored and activated.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OpenIcon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenIcon($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'OpenIcon', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_OpenIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenJobObject
; Description....: Opens an existing job object.
; Syntax.........: _WinAPI_OpenJobObject ( $sName [, $iAccess [, $fInherit] )
; Parameters.....: $sName    - The name of the job to be opened. Name comparisons are case sensitive.
;                  $iAccess  - The access to the job object. This parameter can be one or more of the following values.
;
;                              $JOB_OBJECT_ALL_ACCESS
;                              $JOB_OBJECT_ASSIGN_PROCESS
;                              $JOB_OBJECT_QUERY
;                              $JOB_OBJECT_SET_ATTRIBUTES
;                              $JOB_OBJECT_SET_SECURITY_ATTRIBUTES
;                              $JOB_OBJECT_TERMINATE
;
;                  $fInherit - Specifies whether inherites the handle by a processes, valid values:
;                  |TRUE     - The processes created by this process will inherit the handle.
;                  |FALSE    - The processes do not inherit this handle. (Default)
; Return values..: Success   - Handle to the job object.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OpenJobObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenJobObject($sName, $iAccess = 0x001F001F, $fInherit = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'OpenJobObjectW', 'dword', $iAccess, 'int', $fInherit, 'wstr', $sName)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenJobObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenMutex
; Description....: Opens an existing named mutex object.
; Syntax.........: _WinAPI_OpenMutex ( $sMutex [, $iAccess [, $fInherit]] )
; Parameters.....: $sMutex   - The name of the mutex to be opened. Name comparisons are case sensitive.
;                  $iAccess  - The access to the mutex object. The function fails if the security descriptor of the specified object
;                              does not permit the requested access for the calling process. This parameter can be one of the
;                              following values.
;
;                              $MUTEX_ALL_ACCESS
;                              $MUTEX_MODIFY_STATE
;
;                  $fInherit - Specifies whether inherites the handle by a processes, valid values:
;                  |TRUE     - The processes created by this process will inherit the handle.
;                  |FALSE    - The processes do not inherit this handle. (Default)
; Return values..: Success   - The handle to the mutex object.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function succeeds only if some process has already created the mutex by using the _WinAPI_CreateMutex()
;                  function. The calling process can use the returned handle in any function that requires a handle to
;                  a mutex object.
; Related........:
; Link...........: @@MsdnLink@@ OpenMutex
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenMutex($sMutex, $iAccess = 0x00100000, $fInherit = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'OpenMutexW', 'dword', $iAccess, 'int', $fInherit, 'wstr', $sMutex)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenMutex

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenProcessToken
; Description....: Opens the access token associated with a process.
; Syntax.........: _WinAPI_OpenProcessToken ( $iAccess [, $hProcess] )
; Parameters.....: $iAccess  - Access mask that specifies the requested types of access to the access token. This parameter can be
;                              one or more of the following values.
;
;                              $TOKEN_ADJUST_DEFAULT
;                              $TOKEN_ADJUST_GROUPS
;                              $TOKEN_ADJUST_PRIVILEGES
;                              $TOKEN_ADJUST_SESSIONID
;                              $TOKEN_ASSIGN_PRIMARY
;                              $TOKEN_DUPLICATE
;                              $TOKEN_EXECUTE
;                              $TOKEN_IMPERSONATE
;                              $TOKEN_QUERY
;                              $TOKEN_QUERY_SOURCE
;                              $TOKEN_READ
;                              $TOKEN_WRITE
;                              $TOKEN_ALL_ACCESS
;
;                  $hProcess - Handle to the process whose access token is opened. The process must have the
;                              $PROCESS_QUERY_INFORMATION access permission. If this parameter is 0, will use the current process.
; Return values..: Success   - Handle that identifies the newly opened access token.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Close the access token handle returned through this function by calling _WinAPI_CloseHandle().
; Related........:
; Link...........: @@MsdnLink@@ OpenProcessToken
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenProcessToken($iAccess, $hProcess = 0)

	If Not $hProcess Then
		$hProcess = _WinAPI_GetCurrentProcess()
	EndIf

	Local $Ret = DllCall('advapi32.dll', 'int', 'OpenProcessToken', 'ptr', $hProcess, 'dword', $iAccess, 'ptr*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_OpenProcessToken

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenSemaphore
; Description....: Opens an existing named semaphore object.
; Syntax.........: _WinAPI_OpenSemaphore ( $sSemaphore [, $iAccess [, $fInherit]] )
; Parameters.....: $sSemaphore - The name of the semaphore to be opened. Name comparisons are case sensitive.
;                  $iAccess    - The access to the semaphore object. The function fails if the security descriptor of the specified
;                                object does not permit the requested access for the calling process. This parameter can be one
;                                of the following values.
;
;                                $SEMAPHORE_ALL_ACCESS
;                                $SEMAPHORE_MODIFY_STATE
;
;                  $fInherit   - Specifies whether inherites the handle by a processes, valid values:
;                  |TRUE       - The processes created by this process will inherit the handle.
;                  |FALSE      - The processes do not inherit this handle. (Default)
; Return values..: Success     - The handle to the semaphore object.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function succeeds only if some process has already created the semaphore by using the _WinAPI_CreateSemaphore()
;                  function. The calling process can use the returned handle in any function that requires a handle to
;                  a semaphore object.
; Related........:
; Link...........: @@MsdnLink@@ OpenSemaphore
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenSemaphore($sSemaphore, $iAccess = 0x00100000, $fInherit = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'OpenSemaphoreW', 'dword', $iAccess, 'int', $fInherit, 'wstr', $sSemaphore)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenSemaphore

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenThemeData
; Description....: Opens the theme data for a window and its associated class.
; Syntax.........: _WinAPI_OpenThemeData ( $hWnd, $sClass )
; Parameters.....: $hWnd   - Handle of the window for which theme data is required.
;                  $sClass - The string that contains a semicolon-separated list of classes. This parameter may contain a list,
;                            not just a single name, to provide the class an opportunity to get the best match between the
;                            class and the current visual style.
; Return values..: Success - The handle to the theme.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OpenThemeData
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenThemeData($hWnd, $sClass)

	Local $Ret = DllCall('uxtheme.dll', 'ptr', 'OpenThemeData', 'hwnd', $hWnd, 'wstr', $sClass)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenThemeData

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenWindowStation
; Description....: Opens the specified window station.
; Syntax.........: _WinAPI_OpenWindowStation ( $sName [, $iAccess [, $fInherit]] )
; Parameters.....: $sName    - The name of the window station to be opened. Window station names are case-insensitive. This window
;                              station must belong to the current session.
;                  $iAccess  - The access to the window station. This parameter can be one or more of the following values.
;
;                              $WINSTA_ALL_ACCESS
;                              $WINSTA_ACCESSCLIPBOARD
;                              $WINSTA_ACCESSGLOBALATOMS
;                              $WINSTA_CREATEDESKTOP
;                              $WINSTA_ENUMDESKTOPS
;                              $WINSTA_ENUMERATE
;                              $WINSTA_EXITWINDOWS
;                              $WINSTA_READATTRIBUTES
;                              $WINSTA_READSCREEN
;                              $WINSTA_WRITEATTRIBUTES
;
;                  $fInherit - Specifies whether inherites the handle by a processes, valid values:
;                  |TRUE     - The processes created by this process will inherit the handle.
;                  |FALSE    - The processes do not inherit this handle. (Default)
; Return values..: Success   - Handle to the specified window station.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After you are done with the handle, you must call _WinAPI_CloseWindowStation() to free the handle.
; Related........:
; Link...........: @@MsdnLink@@ OpenWindowStation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenWindowStation($sName, $iAccess = 0, $fInherit = 0)

	Local $Ret = DllCall('user32.dll', 'ptr', 'OpenWindowStationW', 'wstr', $sName, 'int', $fInherit, 'dword', $iAccess)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenWindowStation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PageSetupDlg
; Description....: Creates a Page Setup dialog box that enables the user to specify the attributes of a printed page.
; Syntax.........: _WinAPI_PageSetupDlg ( ByRef $tPAGESETUPDLG )
; Parameters.....: $tPAGESETUPDLG - $tagPAGESETUPDLG structure that contains information used to initialize the Page Setup dialog box.
;                                   The structure receives information about the user's selections when the function returns.
;
;                                   (See MSDN for more information)
;
; Return values..: Success        - 1.
;                  Failure        - 0 and sets the @error flag to non-zero, @extended flag may contain the dialog box error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Note that the values of "hDevMode" and "hDevNames" member in $tagPAGESETUPDLG may change when they are passed into
;                  _WinAPI_PageSetupDlg(). This is because these members are filled on both input and output.
;
;                  Starting with Windows Vista, the _WinAPI_PageSetupDlg() does not contain the "Printer" button. To switch printer
;                  selection, use _WinAPI_PrintDlg() or _WinAPI_PrintDlgEx().
; Related........:
; Link...........: @@MsdnLink@@ PageSetupDlg
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PageSetupDlg(ByRef $tPAGESETUPDLG)

	Local $Ret = DllCall('comdlg32.dll', 'int', 'PageSetupDlgW', 'ptr', DllStructGetPtr($tPAGESETUPDLG))

	If (@error) Or (Not $Ret[0]) Then
		If @error Then
			Return SetError(1, 0, 0)
		Else
			Return SetError(1, _WinAPI_CommDlgExtendedErrorEx(), 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PageSetupDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PaintDesktop
; Description....: Fills the clipping region in the specified device context with the desktop pattern or wallpaper.
; Syntax.........: _WinAPI_PaintDesktop ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PaintDesktop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PaintDesktop($hDC)

	Local $Ret = DllCall('user32.dll', 'int', 'PaintDesktop', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PaintDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PaintRgn
; Description....: Paints the specified region by using the brush currently selected into the device context.
; Syntax.........: _WinAPI_PaintRgn ( $hDC, $hRgn )
; Parameters.....: $hDC    - Handle to the device context.
;                  $hRgn   - Handle to the region to be filled. The region's coordinates are presumed to be logical coordinates.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PaintRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PaintRgn($hDC, $hRgn)

	Local $Ret = DllCall('gdi32.dll', 'int', 'PaintRgn', 'hwnd', $hDC, 'ptr', $hRgn)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PaintRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PatBlt
; Description....: Paints the specified rectangle using the brush that is currently selected into the specified device context.
; Syntax.........: _WinAPI_PatBlt ( $hDC, $iX, $iY, $iWidth, $iHeight, $iRop )
; Parameters.....: $hDC     - Handle to the device context.
;                  $iX      - The x-coordinate, in logical units, of the upper-left corner of the rectangle to be filled.
;                  $iY      - The y-coordinate, in logical units, of the upper-left corner of the rectangle to be filled.
;                  $iWidth  - The width, in logical units, of the rectangle.
;                  $iHeight - The height, in logical units, of the rectangle.
;                  $iRop    - The raster operation code. This code can be one of the following values.
;
;                             $BLACKNESS
;                             $DSTINVERT
;                             $PATCOPY
;                             $PATINVERT
;                             $WHITENESS
;
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PatBlt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PatBlt($hDC, $iX, $iY, $iWidth, $iHeight, $iRop)

	Local $Ret = DllCall('gdi32.dll', 'int', 'PatBlt', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'int', $iWidth, 'int', $iHeight, 'dword', $iRop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PatBlt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathAddBackslash
; Description....: Adds a backslash to the end of a string to create the correct syntax for a path.
; Syntax.........: _WinAPI_PathAddBackslash ( $sPath )
; Parameters.....: $sPath  - The path to which the backslash will be appended. If this path already has a trailing backslash,
;                            no backslash will be added.
; Return values..: Success - The resulting path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathAddBackslash
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathAddBackslash($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'ptr', 'PathAddBackslashW', 'wstr', $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathAddBackslash

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathAddExtension
; Description....: Adds a file name extension to a path string.
; Syntax.........: _WinAPI_PathAddExtension ( $sPath [, $sExt] )
; Parameters.....: $sPath  - The path to which the file name extension will be appended. If there is already a file name extension
;                            present, no extension will be added.
;                  $sExt   - The file name extension. If this parameter is empty string, an ".exe" extension will be added.
; Return values..: Success - The resulting path, @extended will set to 1 if an extension was added, or 0 otherwise.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathAddExtension
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathAddExtension($sPath, $sExt = '')

	Local $TypeOfExt = 'wstr'

	If Not StringStripWS($sExt, 3) Then
		$TypeOfExt = 'ptr'
		$sExt = 0
	EndIf

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathAddExtensionW', 'wstr', $sPath, $TypeOfExt, $sExt)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return SetError(0, $Ret[0], $Ret[1])
EndFunc   ;==>_WinAPI_PathAddExtension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathCanonicalize
; Description....: Removes elements of a file path according to special strings inserted into that path.
; Syntax.........: _WinAPI_PathCanonicalize ( $sPath )
; Parameters.....: $sPath  - The path to be canonicalized.
; Return values..: Success - The canonicalized path.
;                  Failure - The original $sPath parameter and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function allows the user to specify what to remove from a path by inserting special character sequences
;                  into the path. The ".." sequence indicates to remove a path segment from the current position to the previous path
;                  segment. The "." sequence indicates to skip over the next path segment to the following path segment. The root
;                  segment of the path cannot be removed.
;
;                  If there are more ".." sequences than there are path segments, the function returns just the root, "\".
; Related........:
; Link...........: @@MsdnLink@@ PathCanonicalize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathCanonicalize($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathCanonicalizeW', 'wstr', '', 'wstr', $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathCanonicalize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathCommonPrefix
; Description....: Compares two paths to determine if they share a common prefix.
; Syntax.........: _WinAPI_PathCommonPrefix ( $sPath1, $sPath2 )
; Parameters.....: $sPath1 - The first path name.
;                  $sPath2 - The second path name.
; Return values..: Success - The common prefix, @extended flag will contain the count of common prefix characters in the path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathCommonPrefix
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathCommonPrefix($sPath1, $sPath2)

    Local $Ret = DllCall('shlwapi.dll', 'int', 'PathCommonPrefixW', 'wstr', $sPath1, 'wstr', $sPath2, 'wstr', '')

    If @error Then
        Return SetError(1, 0, '')
    EndIf
    Return SetError(0, $Ret[0], $Ret[3])
EndFunc   ;==>_WinAPI_PathCommonPrefix

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathCompactPath
; Description....: Truncates a file path to fit within a given pixel width by replacing path components with ellipses.
; Syntax.........: _WinAPI_PathCompactPath ( $hWnd, $sPath [, $iWidth] )
; Parameters.....: $hWnd   - Handle to the window used for font metrics.
;                  $sPath  - The path to be modified.
;                  $iWidth - The width, in pixels, in which the string must fit. If this parameter is 0, width will be equal to
;                            the width of the window's client area. If this parameter is a negative number, the width will be
;                            decreased to its absolute value.
; Return values..: Success - The modified path.
;                  Failure - The original $sPath parameter and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function will not compact the path beyond the base file name preceded by ellipses.
; Related........:
; Link...........: @@MsdnLink@@ PathCompactPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathCompactPath($hWnd, $sPath, $iWidth = 0)

	Local $hDC, $hBack, $tPath = DllStructCreate('wchar[' & (StringLen($sPath) + 32) & ']')
	Local $Ret

	If $iWidth < 1 Then
		$iWidth += _WinAPI_GetClientWidth($hWnd)
	EndIf
	$Ret = DllCall('user32.dll', 'hwnd', 'GetDC', 'hwnd', $hWnd)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, $sPath)
	EndIf
	$hDC = $Ret[0]
	$Ret = DllCall('user32.dll', 'ptr', 'SendMessage', 'hwnd', $hWnd, 'uint', 0x0031, 'int', 0, 'int', 0)
	$hBack = _WinAPI_SelectObject($hDC, $Ret[0])
	DllStructSetData($tPath, 1, $sPath)
	$Ret = DllCall('shlwapi.dll', 'int', 'PathCompactPathW', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPath), 'int', $iWidth)
	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_SelectObject($hDC, $hBack)
	_WinAPI_ReleaseDC($hWnd, $hDC)
	If Not IsArray($Ret) Then
		Return SetError(1, 0, $sPath)
	EndIf
	Return DllStructGetData($tPath, 1)
EndFunc   ;==>_WinAPI_PathCompactPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathCompactPathEx
; Description....: Truncates a path to fit within a certain number of characters by replacing path components with ellipses.
; Syntax.........: _WinAPI_PathCompactPathEx ( $sPath, $iMax )
; Parameters.....: $sPath  - The path to be modified.
;                  $iMax   - The maximum number of characters to be contained in the modified path.
; Return values..: Success - The modified path.
;                  Failure - The original $sPath parameter and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathCompactPathEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathCompactPathEx($sPath, $iMax)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathCompactPathExW', 'ptr', DllStructGetPtr($tData), 'wstr', $sPath, 'uint', $iMax + 1, 'dword', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, $sPath)
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_PathCompactPathEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathCreateFromUrl
; Description....: Converts a file URL to a Microsoft MS-DOS path.
; Syntax.........: _WinAPI_PathCreateFromUrl ( $sUrl )
; Parameters.....: $sUrl   - The URL.
; Return values..: Success - The MS-DOS path.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathCreateFromUrl
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathCreateFromUrl($sUrl)

    Local $Ret = DllCall('shlwapi.dll', 'uint', 'PathCreateFromUrlW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
    Return $Ret[2]
EndFunc   ;==>_WinAPI_PathCreateFromUrl

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathFindExtension
; Description....: Searches a path for an extension.
; Syntax.........: _WinAPI_PathFindExtension ( $sPath )
; Parameters.....: $sPath  - The path to search, including the extension being searched for.
; Return values..: Success - The string that contains the extension.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathFindExtension
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathFindExtension($sPath)

	Local $tData = DllStructCreate('wchar[1024]')

	DllStructSetData($tData, 1, $sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathFindExtensionW', 'ptr', DllStructGetPtr($tData))

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData(DllStructCreate('wchar[1024]', $Ret[0]), 1)
EndFunc   ;==>_WinAPI_PathFindExtension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathFindFileName
; Description....: Searches a path for a file name.
; Syntax.........: _WinAPI_PathFindFileName ( $sPath )
; Parameters.....: $sPath  - The path to search.
; Return values..: Success - The string that contains the filename.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathFindFileName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathFindFileName($sPath)

	Local $tData = DllStructCreate('wchar[1024]')

	DllStructSetData($tData, 1, $sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathFindFileNameW', 'ptr', DllStructGetPtr($tData))

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData(DllStructCreate('wchar[1024]', $Ret[0]), 1)
EndFunc   ;==>_WinAPI_PathFindFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathFindNextComponent
; Description....: Parses a path and returns the portion of that path that follows the first backslash.
; Syntax.........: _WinAPI_PathFindNextComponent ( $sPath )
; Parameters.....: $sPath  - The path to parse. Path components are delimited by backslashes. For instance, the path
;                            "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.
; Return values..: Success - The truncated path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function walks a path string until it encounters a backslash ("\"), ignores everything up to that point
;                  including the backslash, and returns the rest of the path. Therefore, if a path begins with a backslash (such as \path1\path2),
;                  the function simply removes the initial backslash and returns the rest (path1\path2).
; Related........:
; Link...........: @@MsdnLink@@ PathFindNextComponent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathFindNextComponent($sPath)

	Local $tData = DllStructCreate('wchar[1024]')

	DllStructSetData($tData, 1, $sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathFindNextComponentW', 'ptr', DllStructGetPtr($tData))

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	If Not $Ret[0] Then
		Return ''
	EndIf
	Return DllStructGetData(DllStructCreate('wchar[1024]', $Ret[0]), 1)
EndFunc   ;==>_WinAPI_PathFindNextComponent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathGetArgs
; Description....: Finds the command-line arguments within a given path.
; Syntax.........: _WinAPI_PathGetArgs ( $sPath )
; Parameters.....: $sPath  - The path to be searched.
; Return values..: Success - The string that contains the arguments portion of the path if successful.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function should not be used on generic command path templates (from users or the registry), but rather
;                  should be used only on templates that the application knows to be well formed.
; Related........:
; Link...........: @@MsdnLink@@ PathGetArgs
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathGetArgs($sPath)

	Local $tData = DllStructCreate('wchar[1024]')

	DllStructSetData($tData, 1, $sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathGetArgsW', 'ptr', DllStructGetPtr($tData))

	If @error Then
		Return SetError(1, 0, '')
	Else
		If Not $Ret[0] Then
			Return ''
		EndIf
	EndIf
	Return DllStructGetData(DllStructCreate('wchar[1024]', $Ret[0]), 1)
EndFunc   ;==>_WinAPI_PathGetArgs

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathGetCharType
; Description....: Determines the type of character in relation to a path.
; Syntax.........: _WinAPI_PathGetCharType ( $sChar )
; Parameters.....: $sChar  - The character for which to determine the type.
; Return values..: Success - Returns one or more of the following values that define the type of character.
;
;                            $GCT_INVALID
;                            $GCT_LFNCHAR
;                            $GCT_SEPARATOR
;                            $GCT_SHORTCHAR
;                            $GCT_WILD
;
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathGetCharType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathGetCharType($sChar)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathGetCharTypeW', 'dword', AscW($sChar))

	If @error Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathGetCharType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathGetDriveNumber
; Description....: Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.
; Syntax.........: _WinAPI_PathGetDriveNumber ( $sPath )
; Parameters.....: $sPath  - The path to be searched.
; Return values..: Success - The string that contains the drive letter (A:, B:, etc).
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathGetDriveNumber
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathGetDriveNumber($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathGetDriveNumberW', 'wstr', $sPath)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, '')
	EndIf
	Return Chr($Ret[0] + 65) & ':'
EndFunc   ;==>_WinAPI_PathGetDriveNumber

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsContentType
; Description....: Determines if a file's registered content type matches the specified content type.
; Syntax.........: _WinAPI_PathIsContentType ( $sPath, $sType )
; Parameters.....: $sPath  - The file whose content type will be compared.
;                  $sType  - The content type string. For example, "application/x-msdownload", "image/jpeg", "text/plain", etc.
; Return values..: Success - 1 - The file's content type matches the specified content type.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsContentType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsContentType($sPath, $sType)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsContentTypeW', 'wstr', $sPath, 'wstr', $sType)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsContentType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsDirectory
; Description....: Verifies that a path is a valid directory.
; Syntax.........: _WinAPI_PathIsDirectory ( $sPath )
; Parameters.....: $sPath  - The path to verify.
; Return values..: Success - 1 - The path is a valid directory.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsDirectory($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsDirectoryW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsDirectoryEmpty
; Description....: Determines whether a specified path is an empty directory.
; Syntax.........: _WinAPI_PathIsDirectoryEmpty ( $sPath )
; Parameters.....: $sPath  - The path to be tested.
; Return values..: Success - 1 - The path is an empty directory.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsDirectoryEmpty
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsDirectoryEmpty($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsDirectoryEmptyW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsDirectoryEmpty

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsExe
; Description....: Determines whether a file is an executable by examining the file extension.
; Syntax.........: _WinAPI_PathIsExe ( $sPath )
; Parameters.....: $sPath  - The path to be searched.
; Return values..: Success - 1 - The file extension is .cmd, .bat, .pif, .scf, .exe, .com, or .scr.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsExe
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsExe($sPath)

	Local $Ret = DllCall('shell32.dll', 'int', 'PathIsExe', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsExe

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsFileSpec
; Description....: Searches a path for any path-delimiting characters.
; Syntax.........: _WinAPI_PathIsFileSpec ( $sPath )
; Parameters.....: $sPath  - The path to be searched.
; Return values..: Success - 1 - There are no path-delimiting characters (":" or "\") within the path.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsFileSpec
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsFileSpec($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsFileSpecW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsFileSpec

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsLFNFileSpec
; Description....: Determines whether a file name is in long format.
; Syntax.........: _WinAPI_PathIsLFNFileSpec ( $sPath )
; Parameters.....: $sPath  - The file name to be tested.
; Return values..: Success - 1 - The file exceeds the number of characters allowed by the 8.3 format.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsLFNFileSpec
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsLFNFileSpec($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsLFNFileSpecW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsLFNFileSpec

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsRelative
; Description....: Searches a path and determines if it is relative.
; Syntax.........: _WinAPI_PathIsRelative ( $sPath )
; Parameters.....: $sPath  - The path to be searched.
; Return values..: Success - 1 - The path is relative.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsRelative
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsRelative($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsRelativeW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsRelative

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsRoot
; Description....: Parses a path to determine if it is a directory root.
; Syntax.........: _WinAPI_PathIsRoot ( $sPath )
; Parameters.....: $sPath  - The path to be validated.
; Return values..: Success - 1 - The path is a root.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsRoot
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsRoot($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsRootW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsRoot

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsSameRoot
; Description....: Compares two paths to determine if they have a common root component.
; Syntax.........: _WinAPI_PathIsSameRoot ( $sPath1, $sPath2 )
; Parameters.....: $sPath1 - The first path to be compared.
;                  $sPath2 - The second path to be compared.
; Return values..: Success - 1 - Both strings have the same root component.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsSameRoot
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsSameRoot($sPath1, $sPath2)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsSameRootW', 'wstr', $sPath1, 'wstr', $sPath2)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsSameRoot

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsSystemFolder
; Description....: Determines if an existing folder contains the attributes that make it a system folder.
; Syntax.........: _WinAPI_PathIsSystemFolder ( $sPath )
; Parameters.....: $sPath  - The name of an existing folder to check the system folder attributes.
; Return values..: Success - 1 - The path is a system folder.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsSystemFolder
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsSystemFolder($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsSystemFolderW', 'wstr', $sPath, 'dword', 0)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsSystemFolder

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsURL
; Description....: Tests a given string to determine if it conforms to a valid URL format.
; Syntax.........: _WinAPI_PathIsURL ( $sPath )
; Parameters.....: $sPath  - The URL path to validate.
; Return values..: Success - 1 - The path has a valid URL format.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsURL
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsURL($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsURLW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsURL

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsUNC
; Description....: Determines if the string is a valid Universal Naming Convention (UNC) for a server and share path.
; Syntax.........: _WinAPI_PathIsUNC ( $sPath )
; Parameters.....: $sPath  - The path to validate.
; Return values..: Success - 1 - The path is a valid UNC path.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsUNC
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsUNC($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsUNCW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsUNC

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsUNCServer
; Description....: Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.
; Syntax.........: _WinAPI_PathIsUNCServer ( $sPath )
; Parameters.....: $sPath  - The path to validate.
; Return values..: Success - 1 - The path is a valid UNC path for a server only (no share name).
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsUNCServer
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsUNCServer($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsUNCServerW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsUNCServer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsUNCServerShare
; Description....: Determines if a string is a valid Universal Naming Convention (UNC) share path.
; Syntax.........: _WinAPI_PathIsUNCServerShare ( $sPath )
; Parameters.....: $sPath  - The path to validate.
; Return values..: Success - 1 - The path is in the form "\\server\share".
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsUNCServerShare
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsUNCServerShare($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsUNCServerShareW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsUNCServerShare

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathMakeSystemFolder
; Description....: Gives an existing folder the proper attributes to become a system folder.
; Syntax.........: _WinAPI_PathMakeSystemFolder ( $sPath )
; Parameters.....: $sPath  - The name of an existing folder that will be made into a system folder.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathMakeSystemFolder
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathMakeSystemFolder($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathMakeSystemFolderW', 'wstr', $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PathMakeSystemFolder

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathMatchSpec
; Description....: Searches a string using a Microsoft MS-DOS wild card match type.
; Syntax.........: _WinAPI_PathMatchSpec ( $sPath, $sSpec )
; Parameters.....: $sPath  - The path to be searched.
;                  $sSpec  - The file type for which to search. For example, to test whether $sPath is a .doc file,
;                            $sSpec should be set to "*.doc".
; Return values..: Success - 1 - The string matches.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathMatchSpec
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathMatchSpec($sPath, $sSpec)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathMatchSpecW', 'wstr', $sPath, 'wstr', $sSpec)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathMatchSpec

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathParseIconLocation
; Description....: Parses a file location string that contains a file location and icon index.
; Syntax.........: _WinAPI_PathParseIconLocation ( $sPath )
; Parameters.....: $sPath  - The path that contains a file location string. It should be in the form "path,iconindex".
; Return values..: Success - The array containing the following parameters:
;
;                            [0] - The path of the file that contains the icon.
;                            [1] - The index of the icon.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function is useful for taking a DefaultIcon value from the registry and separating the icon index from the path.
; Related........:
; Link...........: @@MsdnLink@@ PathParseIconLocation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathParseIconLocation($sPath)

	Local $tData = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tData, 1, $sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathParseIconLocationW', 'ptr', DllStructGetPtr($tData))

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[2]

	$Result[0] = DllStructGetData($tData, 1)
	$Result[1] = $Ret[0]

	Return $Result
EndFunc   ;==>_WinAPI_PathParseIconLocation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathRelativePathTo
; Description....: Creates a relative path from one file or folder to another.
; Syntax.........: _WinAPI_PathRelativePathTo ( $sPathFrom, $fDirFrom, $sPathTo, $fDirTo )
; Parameters.....: $sPathFrom - The path to the file or directory that defines the start of the relative path.
;                  $fDirFrom  - Specifies whether is $sPathFrom path to the directory, valid values:
;                  |TRUE      - Directory.
;                  |FALSE     - File.
;                  $sPathTo   - The path to the file or directory that defines the endpoint of the relative path.
;                  $fDirTo    - Specifies whether is $fDirTo path to the directory, valid values:
;                  |TRUE      - Directory.
;                  |FALSE     - File.
; Return values..: Success    - The relative path.
;                  Failure    - Empty string and sets the @error flag to non-zero.
; Author.........: Mat
; Modified.......: Yashied
; Remarks........: This function takes a pair of paths and generates a relative path from one to the other. The paths do not have
;                  to be fully-qualified, but they must have a common prefix, otherwise, the function fails.
;
;                  For example, let the starting point, $sPathFrom, be "C:\A\B\C", and the ending point, $sPathTo, be "C:\A\D".
;                  _WinAPI_PathRelativePathTo() will return the relative path from $sPathFrom to $sPathTo as: "..\..\D\E". You will
;                  get the same result if you set $sPathFrom to "\A\B\C" and $sPathTo to "\A\D\E". On the other hand, "C:\A\B\C"
;                  and "D:\A\D" do not share a common prefix, and the function will fail. Note that "\" is not considered a prefix
;                  and is ignored. If you set $sPathFrom to "\\A\B\C", and $sPathTo to "\\C\D", the function will fail.
; Related........:
; Link...........: @@MsdnLink@@ PathRelativePathTo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathRelativePathTo($sPathFrom, $fDirFrom, $sPathTo, $fDirTo)

	If $fDirFrom Then
		$fDirFrom = 0x10
	EndIf
	If $fDirTo Then
		$fDirTo = 0x10
	EndIf

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathRelativePathToW', 'ptr', DllStructGetPtr($tData), 'wstr', $sPathFrom, 'dword', $fDirFrom, 'wstr', $sPathTo, 'dword', $fDirTo)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_PathRelativePathTo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathRemoveArgs
; Description....: Removes any arguments from a given path.
; Syntax.........: _WinAPI_PathRemoveArgs ( $sPath )
; Parameters.....: $sPath  - The path that contains the path from which to remove arguments.
; Return values..: Success - The path of no arguments.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function should not be used on generic command path templates (from users or the registry), but rather
;                  it should be used only on templates that the application knows to be well formed.
; Related........:
; Link...........: @@MsdnLink@@ PathRemoveArgs
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathRemoveArgs($sPath)

	Local $tData = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tData, 1, $sPath)
	DllCall('shlwapi.dll', 'none', 'PathRemoveArgsW', 'ptr', DllStructGetPtr($tData))
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_PathRemoveArgs

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathRemoveBackslash
; Description....: Removes the trailing backslash from a given path.
; Syntax.........: _WinAPI_PathRemoveBackslash ( $sPath )
; Parameters.....: $sPath  - The path from which to remove the backslash.
; Return values..: Success - The altered path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathRemoveBackslash
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathRemoveBackslash($sPath)

	Local $tData = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tData, 1, $sPath)

	Local $Ret = DllCall('shlwapi.dll', 'uint_ptr', 'PathRemoveBackslashW', 'uint_ptr', DllStructGetPtr($tData))

	If @error Then
		Return SetError(1, 0, '')
	Else
		If Not $Ret[0] Then
			Return $sPath
		EndIf
	EndIf
	Return StringRight(DllStructGetData($tData, 1), ($Ret[0] - $Ret[1]) / 2 + 1)
EndFunc   ;==>_WinAPI_PathRemoveBackslash

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathRemoveExtension
; Description....: Removes the file name extension from a path, if one is present.
; Syntax.........: _WinAPI_PathRemoveExtension ( $sPath )
; Parameters.....: $sPath  - The path from which to remove the extension.
; Return values..: Success - The path without extension.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathRemoveExtension
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathRemoveExtension($sPath)

	Local $tData = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tData, 1, $sPath)
	DllCall('shlwapi.dll', 'none', 'PathRemoveExtensionW', 'ptr', DllStructGetPtr($tData))
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_PathRemoveExtension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathRemoveFileSpec
; Description....: Removes the trailing file name and backslash from a path, if they are present.
; Syntax.........: _WinAPI_PathRemoveFileSpec ( $sPath )
; Parameters.....: $sPath  - The path from which to remove the file name.
; Return values..: Success - The path without file name.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathRemoveFileSpec
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathRemoveFileSpec($sPath)

	Local $tData = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tData, 1, $sPath)
	DllCall('shlwapi.dll', 'none', 'PathRemoveFileSpecW', 'ptr', DllStructGetPtr($tData))
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_PathRemoveFileSpec

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathRenameExtension
; Description....: Replaces the extension of a file name with a new extension.
; Syntax.........: _WinAPI_PathRenameExtension ( $sPath, $sExt )
; Parameters.....: $sPath  - The path in which to replace the extension.
;                  $sExt   - The string that contains a "." character followed by the new extension.
; Return values..: Success - The path with new extension.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the file name does not contain an extension, the extension will be attached to the end of the string.
; Related........:
; Link...........: @@MsdnLink@@ PathRenameExtension
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathRenameExtension($sPath, $sExt)

	Local $tData = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tData, 1, $sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathRenameExtensionW', 'ptr', DllStructGetPtr($tData), 'wstr', $sExt)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_PathRenameExtension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathSearchAndQualify
; Description....: Formats a path to the fully qualified path.
; Syntax.........: _WinAPI_PathSearchAndQualify ( $sPath [, $fExists] )
; Parameters.....: $sPath   - The path to be formated.
;                  $fExists - Specifies whether the path should be existing, valid values:
;                  |TRUE    - The path must be an existing path, otherwise, the function fails.
;                  |FALSE   - The path may not exist. (Default)
; Return values..: Success  - The formated path.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathSearchAndQualify
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathSearchAndQualify($sPath, $fExists = 0)

	Local $tPath = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathSearchAndQualifyW', 'wstr', $sPath, 'ptr', DllStructGetPtr($tPath), 'int', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	$sPath = DllStructGetData($tPath, 1)
	If ($fExists) And (Not FileExists($sPath)) Then
		Return SetError(1, 0, '')
	EndIf
	Return $sPath
EndFunc   ;==>_WinAPI_PathSearchAndQualify

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathSkipRoot
; Description....: Parses a path, ignoring the drive letter or Universal Naming Convention (UNC) server/share path elements.
; Syntax.........: _WinAPI_PathSkipRoot ( $sPath )
; Parameters.....: $sPath  - The path to parse.
; Return values..: Success - The string contains only subpath that follows the root (drive letter or UNC server/share).
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathSkipRoot
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathSkipRoot($sPath)

	Local $tData = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tData, 1, $sPath)

	Local $Ret = DllCall('shlwapi.dll', 'uint_ptr', 'PathSkipRootW', 'uint_ptr', DllStructGetPtr($tData))

	If @error Then
		Return SetError(1, 0, '')
	Else
		If Not $Ret[0] Then
			Return $sPath
		EndIf
	EndIf
	Return StringTrimLeft(DllStructGetData($tData, 1), ($Ret[0] - $Ret[1]) / 2)
EndFunc   ;==>_WinAPI_PathSkipRoot

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathStripPath
; Description....: Removes the path portion of a fully qualified path and file.
; Syntax.........: _WinAPI_PathStripPath ( $sPath )
; Parameters.....: $sPath  - The path and file name.
; Return values..: Success - The string contains only the file name, with the path removed.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathStripPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathStripPath($sPath)

	Local $tData = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tData, 1, $sPath)
	DllCall('shlwapi.dll', 'none', 'PathStripPathW', 'ptr', DllStructGetPtr($tData))
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_PathStripPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathStripToRoot
; Description....: Removes all parts of the path except for the root information.
; Syntax.........: _WinAPI_PathStripToRoot ( $sPath )
; Parameters.....: $sPath  - The path to be converted.
; Return values..: Success - The string contains only the root information taken from that path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathStripToRoot
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathStripToRoot($sPath)

	Local $tData = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tData, 1, $sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathStripToRootW', 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_PathStripToRoot

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathToRegion
; Description....: Creates a region from the path that is selected into the specified device context.
; Syntax.........: _WinAPI_PathToRegion ( $hDC )
; Parameters.....: $hDC    - Handle to a device context that contains a closed path.
; Return values..: Success - The handle to the region.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The device context identified by the $hDC parameter must contain a closed path.
;
;                  After _WinAPI_PathToRegion() converts a path into a region, the system discards the closed path from the specified
;                  device context.
; Related........:
; Link...........: @@MsdnLink@@ PathToRegion
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathToRegion($hDC)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'PathToRegion', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathToRegion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathUndecorate
; Description....: Removes the decoration from a path string.
; Syntax.........: _WinAPI_PathUndecorate ( $sPath )
; Parameters.....: $sPath  - The path.
; Return values..: Success - The undecorated string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathUndecorate
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathUndecorate($sPath)

	Local $tData = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tData, 1, $sPath)
	DllCall('shlwapi.dll', 'none', 'PathUndecorateW', 'ptr', DllStructGetPtr($tData))
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_PathUndecorate

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathUnExpandEnvStrings
; Description....: Replaces folder names in a fully-qualified path with their associated environment string.
; Syntax.........: _WinAPI_PathUnExpandEnvStrings ( $sPath )
; Parameters.....: $sPath  - The path to be unexpanded.
; Return values..: Success - The unexpanded string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathUnExpandEnvStrings
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathUnExpandEnvStrings($sPath)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathUnExpandEnvStringsW', 'wstr', $sPath, 'ptr', DllStructGetPtr($tData), 'uint', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_PathUnExpandEnvStrings

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathUnmakeSystemFolder
; Description....: Removes the attributes from a folder that make it a system folder.
; Syntax.........: _WinAPI_PathUnmakeSystemFolder ( $sPath )
; Parameters.....: $sPath  - The name of an existing folder that will have the system folder attributes removed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathUnmakeSystemFolder
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathUnmakeSystemFolder($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathUnmakeSystemFolderW', 'wstr', $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PathUnmakeSystemFolder

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathUnquoteSpaces
; Description....: Removes quotes from the beginning and end of a path.
; Syntax.........: _WinAPI_PathUnquoteSpaces ( $sPath )
; Parameters.....: $sPath  - The path.
; Return values..: Success - The path with beginning and ending quotation marks removed.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathUnquoteSpaces
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathUnquoteSpaces($sPath)

	Local $tData = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tData, 1, $sPath)
	DllCall('shlwapi.dll', 'none', 'PathUnquoteSpacesW', 'ptr', DllStructGetPtr($tData))
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_PathUnquoteSpaces

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathYetAnotherMakeUniqueName
; Description....: Creates a unique filename based on an existing filename.
; Syntax.........: _WinAPI_PathYetAnotherMakeUniqueName ( $sPath )
; Parameters.....: $sPath  - The file name that the unique name will be based on.
; Return values..: Success - 1.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathYetAnotherMakeUniqueName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathYetAnotherMakeUniqueName($sPath)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('shell32.dll', 'int', 'PathYetAnotherMakeUniqueName', 'ptr', DllStructGetPtr($tData), 'wstr', $sPath, 'ptr', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_PathYetAnotherMakeUniqueName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PickIconDlg
; Description....: Displays a dialog box that allows the user to choose an icon.
; Syntax.........: _WinAPI_PickIconDlg ( [$sIcon [, $iIndex [, $hParent]]] )
; Parameters.....: $sIcon   - The fully-qualified path of the file that contains the initial icon.
;                  $iIndex  - The index of the initial icon.
;                  $hParent - Handle of the parent window.
; Return values..: Success  - The array containing the following parameters:
;
;                             [0] - The path of the file that contains the selected icon.
;                             [1] - The index of the selected icon.
;
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function also sets the @error flag to 1 if the icon was not selected.
; Related........:
; Link...........: @@MsdnLink@@ PickIconDlg
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PickIconDlg($sIcon = '', $iIndex = 0, $hParent = 0)

	Local $tIcon = DllStructCreate('wchar[1024]'), $tIndex = DllStructCreate('int')
	Local $Ret, $Error = 1, $Result[2] = [$sIcon, $iIndex]

	DllStructSetData($tIcon, 1, $sIcon)
	DllStructSetData($tIndex, 1, $iIndex)
	$Ret = DllCall('shell32.dll', 'int', 'PickIconDlg', 'hwnd', $hParent, 'ptr', DllStructGetPtr($tIcon), 'int', 1024, 'ptr', DllStructGetPtr($tIndex))
	If (Not @error) And ($Ret[0]) Then
		$Ret = DllCall('kernel32.dll', 'int', 'ExpandEnvironmentStringsW', 'wstr', DllStructGetData($tIcon, 1), 'ptr', DllStructGetPtr($tIcon), 'int', 1024)
		If (Not @error) And ($Ret[0]) Then
			$Result[0] = DllStructGetData($tIcon, 1)
			$Result[1] = DllStructGetData($tIndex, 1)
			$Error = 0
		EndIf
	EndIf
	Return SetError($Error, 0, $Result)
EndFunc   ;==>_WinAPI_PickIconDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PlayEnhMetaFile
; Description....: Displays the picture stored in the specified enhanced-format metafile.
; Syntax.........: _WinAPI_PlayEnhMetaFile( $hDC, $hEmf, $tRECT )
; Parameters.....: $hDC    - Handle to the device context for the output device on which the picture will appear.
;                  $hEmf   - Handle to the enhanced metafile.
;                  $tRECT  - $tagRECT structure that contains the coordinates of the bounding rectangle used to display the picture,
;                            in logical units
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An enhanced metafile can be embedded in a newly created enhanced metafile by calling _WinAPI_PlayEnhMetaFile()
;                  and playing the source enhanced metafile into the device context for the new enhanced metafile.
; Related........:
; Link...........: @@MsdnLink@@ PlayEnhMetaFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PlayEnhMetaFile($hDC, $hEmf, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'PlayEnhMetaFile', 'hwnd', $hDC, 'ptr', $hEmf, 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PlayEnhMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PlaySound
; Description....: Plays a sound specified by the given file name, resource, or system event.
; Syntax.........: _WinAPI_PlaySound ( $sSound [, $iFlags [, $hInstance]] )
; Parameters.....: $sSound    - The string that specifies the sound to play. The maximum length is 255 characters. If $sSound is
;                               empty, any currently playing waveform sound is stopped.
;                  $iFlags    - The flags for sound playing. This parameter can be one or more of the following values.
;
;                               $SND_APPLICATION
;                               $SND_ALIAS
;                               $SND_ALIAS_ID
;                               $SND_ASYNC
;                               $SND_FILENAME
;                               $SND_LOOP
;                               $SND_MEMORY
;                               $SND_NODEFAULT
;                               $SND_NOSTOP
;                               $SND_NOWAIT
;                               $SND_PURGE
;                               $SND_RESOURCE
;                               $SND_SYNC
;
;                               Three flags ($SND_ALIAS, $SND_FILENAME, and $SND_RESOURCE) determine whether the name is interpreted
;                               as an alias for a system event, a file name, or a resource identifier. If none of these flags are
;                               specified, _WinAPI_PlaySound() searches the registry or the WIN.INI file for an association with
;                               the specified sound name. If an association is found, the sound event is played. If no association
;                               is found in the registry, the name is interpreted as a file name.
;
;                               If the $SND_ALIAS_ID flag is specified in $iFlags, the $sSound parameter must be one of the
;                               $SND_ALIAS_* values.
;
;                               (See MSDN for more information)
;
;                  $hInstance - Handle to the executable file that contains the resource to be loaded. If $iFlags does not
;                               contain the $SND_RESOURCE, this parameter will be ignored.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PlaySound
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PlaySound($sSound, $iFlags = 0x00020010, $hInstance = 0)

	Local $TypeOfSound = 'ptr'

	If $sSound Then
		If IsString($sSound) Then
			$TypeOfSound = 'wstr'
		EndIf
	Else
		$sSound = 0
		$iFlags = 0
	EndIf

	Local $Ret = DllCall('winmm.dll', 'int', 'PlaySoundW', $TypeOfSound, $sSound, 'ptr', $hInstance, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PlaySound

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PlgBlt
; Description....: Performs a bit-block transfer of color data from the specified rectangle in the source DC to the specified parallelogram in the DC context.
; Syntax.........: _WinAPI_PlgBlt ( $hDestDC, Const ByRef $aPoint, $hSrcDC, $iXSrc, $iYSrc, $iWidth, $iHeight [, $hMask [, $iXMask [, $iYMask]]] )
; Parameters.....: $hDestDC - Handle to the destination device context.
;                  $aPoint  - The 2D array ([x1, y1], [x2, y2], [x3, y3]) that identify three corners of the destination parallelogram.
;                             The upper-left corner of the source rectangle is mapped to the first point in this array, the upper-right
;                             corner to the second point in this array, and the lower-left corner to the third point. The lower-right
;                             corner of the source rectangle is mapped to the implicit fourth point in the parallelogram.
;                  $hSrcDC  - Handle to the source device context.
;                  $iXSrc   - The x-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iYSrc   - The y-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iWidth  - The width, in logical units, of the source rectangle.
;                  $iHeight - The height, in logical units, of the source rectangle.
;                  $hMask   - Handle to the monochrome bitmap that is used to mask the colors of the source rectangle.
;                  $iXMask  - The x-coordinate, in logical units, of the upper-left corner of the monochrome bitmap.
;                  $iYMask  - The y-coordinate, in logical units, of the upper-left corner of the monochrome bitmap.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_PlgBlt() works with device-dependent bitmaps. If the source and destination device contexts represent
;                  incompatible devices, the function returns an error.
;
;                  The fourth vertex of the parallelogram (D) is defined by treating the first three points (A, B, and C) as vectors
;                  and computing D = B + CA.
;
;                  If the bitmask is specified, a value of 1 in the mask indicates that the source pixel color should be copied to the
;                  destination. A value of 0 in the mask indicates that the destination pixel color is not to be changed. If the mask
;                  rectangle is smaller than the source and destination rectangles, the function replicates the mask pattern.
;
;                  Scaling, translation, and reflection transformations are allowed in the source device context; however, rotation
;                  and shear transformations are not. If the mask bitmap is not a monochrome bitmap, an error occurs. The stretching
;                  mode for the destination device context is used to determine how to stretch or compress the pixels, if that is
;                  necessary.
; Related........:
; Link...........: @@MsdnLink@@ PlgBlt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PlgBlt($hDestDC, Const ByRef $aPoint, $hSrcDC, $iXSrc, $iYSrc, $iWidth, $iHeight, $hMask = 0, $iXMask = 0, $iYMask = 0)

	If (UBound($aPoint) < 3) Or (UBound($aPoint, 2) < 2) Then
		Return SetError(2, 0, 0)
	EndIf

	Local $tPoints = DllStructCreate('long[2];long[2];long[2]')

	For $i = 0 To 2
		For $j = 0 To 1
			DllStructSetData($tPoints, $i + 1, $aPoint[$i][$j], $j + 1)
		Next
	Next

	Local $Ret = DllCall('gdi32.dll', 'int', 'PlgBlt', 'hwnd', $hDestDC, 'ptr', DllStructGetPtr($tPoints), 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'int', $iWidth, 'int', $iHeight, 'ptr', $hMask, 'int', $iXMask, 'int', $iYMask)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PlgBlt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PolyBezier
; Description....: Draws one or more Bezier curves.
; Syntax.........: _WinAPI_PolyBezier ( $hDC, $aPoint [, $iStart [, $iEnd]] )
; Parameters.....: $hDC    - Handle to a device context.
;                  $aPoint - The 2D array ([x1, y1], [x2, y2], ... [xN, yN]) that contains the endpoints and control points of the
;                            curve(s), in logical units. The number of points must be one more than three times the number of curves
;                            to be drawn, because each Bezier curve requires two control points and an endpoint, and the initial
;                            curve requires an additional starting point.
;                  $iStart - The index of array to start drawing at.
;                  $iEnd   - The index of array to stop drawing at.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function draws cubic Bezier curves by using the endpoints and control points specified by the $aPoint
;                  parameter. The first curve is drawn from the first point to the fourth point by using the second and third points
;                  as control points. Each subsequent curve in the sequence needs exactly three more points: the ending point of the
;                  previous curve is used as the starting point, the next two points in the sequence are control points, and the
;                  third is the ending point.
;
;                  The current position is neither used nor updated by the _WinAPI_PolyBezier() function. The figure is not filled.
;
;                  This function draws lines by using the current pen.
; Related........:
; Link...........: @@MsdnLink@@ PolyBezier
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PolyBezier($hDC, $aPoint, $iStart = 0, $iEnd = -1)

	If UBound($aPoint, 2) < 2 Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Point, $tPOINT, $Count = 0, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	$Point = 1 + 3 * Floor(($iEnd - $iStart) / 3)
	If $Point < 1 Then
		Return SetError(1, 0, 0)
	EndIf
	$iEnd = $iStart + $Point - 1
	For $i = $iStart To $iEnd
		$Struct &= 'long[2];'
	Next
	$tPOINT = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		$Count += 1
		For $j = 0 To 1
			DllStructSetData($tPOINT, $Count, $aPoint[$i][$j], $j + 1)
		Next
	Next

	Local $Ret = DllCall('gdi32.dll', 'int', 'PolyBezier', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPOINT), 'dword', $Point)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PolyBezier

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PolyBezierTo
; Description....: Draws one or more Bezier curves.
; Syntax.........: _WinAPI_PolyBezierTo ( $hDC, $aPoint [, $iStart [, $iEnd]] )
; Parameters.....: $hDC    - Handle to a device context.
;                  $aPoint - The 2D array ([x1, y1], [x2, y2], ... [xN, yN]) that contains the endpoints and control points of the
;                            curve(s), in logical units. The number of points must be three times the number of curves to be drawn,
;                            because each Bezier curve requires two control points and an ending point.
;                  $iStart - The index of array to start drawing at.
;                  $iEnd   - The index of array to stop drawing at.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function draws cubic Bezier curves by using the control points specified by the $aPoint parameter.
;                  The first curve is drawn from the current position to the third point by using the first two points as control points.
;                  For each subsequent curve, the function needs exactly three more points, and uses the ending point of the previous
;                  curve as the starting point for the next.
;
;                  The current position moves to the ending point of the last Bezier curve. The figure is not filled.
;
;                  This function draws lines by using the current pen.
; Related........:
; Link...........: @@MsdnLink@@ PolyBezierTo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PolyBezierTo($hDC, $aPoint, $iStart = 0, $iEnd = -1)

	If UBound($aPoint, 2) < 2 Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Point, $tPOINT, $Count = 0, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	$Point = 3 * Floor(($iEnd - $iStart + 1) / 3)
	If $Point < 3 Then
		Return SetError(1, 0, 0)
	EndIf
	$iEnd = $iStart + $Point - 1
	For $i = $iStart To $iEnd
		$Struct &= 'long[2];'
	Next
	$tPOINT = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		$Count += 1
		For $j = 0 To 1
			DllStructSetData($tPOINT, $Count, $aPoint[$i][$j], $j + 1)
		Next
	Next

	Local $Ret = DllCall('gdi32.dll', 'int', 'PolyBezierTo', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPOINT), 'dword', $Point)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PolyBezierTo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PolyDraw
; Description....: Draws a set of line segments and Bezier curves.
; Syntax.........: _WinAPI_PolyDraw ( $hDC, $aPoint [, $iStart [, $iEnd]] )
; Parameters.....: $hDC    - Handle to a device context.
;                  $aPoint - The 2D array ([x1, y1, type1], [x2, y2, type2], ... [xN, yN, typeN]) that contains the endpoints for
;                            each line segment and the endpoints and control points for each Bezier curve, in logical units. In addition,
;                            the array contains a parameters that specifies how each point is used. The third parameter of the array
;                            can be one of the following values.
;
;                            $PT_BEZIERTO
;                            $PT_LINETO
;                            $PT_MOVETO
;
;                            $PT_BEZIERTO or $PT_LINETO type can be combined with the following value that the corresponding point
;                            is the last point in a figure and the figure is closed.
;
;                            $PT_CLOSEFIGURE
;
;                  $iStart - The index of array to start drawing at.
;                  $iEnd   - The index of array to stop drawing at.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function can be used in place of consecutive calls to _WinAPI_MoveToEx(), _WinAPI_LineTo(), and _WinAPI_PolyBezierTo()
;                  functions to draw disjoint figures. The lines and curves are drawn using the current pen and figures are not filled.
;                  If there is an active path started by calling _WinAPI_BeginPath(), _WinAPI_PolyDraw() adds to the path.
;
;                  This function updates the current position.
; Related........:
; Link...........: @@MsdnLink@@ PolyDraw
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PolyDraw($hDC, $aPoint, $iStart = 0, $iEnd = -1)

	If UBound($aPoint, 2) < 3 Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Point, $tPOINT, $tTypes, $Count = 0, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	$Point = $iEnd - $iStart + 1
	If Not $Point Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		$Struct &= 'long[2];'
	Next
	$tPOINT = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$tTypes = DllStructCreate('byte[' & $Point & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		$Count += 1
		For $j = 0 To 1
			DllStructSetData($tPOINT, $Count, $aPoint[$i][$j], $j + 1)
		Next
		DllStructSetData($tTypes, 1, $aPoint[$i][2], $Count)
	Next

	Local $Ret = DllCall('gdi32.dll', 'int', 'PolyDraw', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPOINT), 'ptr', DllStructGetPtr($tTypes), 'dword', $Point)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PolyDraw

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Polygon
; Description....: Draws a polygon consisting of two or more vertices connected by straight lines.
; Syntax.........: _WinAPI_Polygon ( $hDC,  $aPoint [, $iStart [, $iEnd]] )
; Parameters.....: $dDC    - Handle to the device context.
;                  $aPoint - The 2D array ([x1, y1], [x2, y2], ... [xN, yN]) that contains the vertices of the polygon in logical
;                            units. The polygon is closed automatically by drawing a line from the last vertex to the first.
;                  $iStart - The index of array to start creating at.
;                  $iEnd   - The index of array to stop creating at.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The polygon is outlined by using the current pen and filled by using the current brush and polygon fill mode.
; Related........:
; Link...........: @@MsdnLink@@ Polygon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Polygon($hDC, $aPoint, $iStart = 0, $iEnd = -1)

	If UBound($aPoint, 2) < 2 Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Count, $tData, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	For $i = $iStart To $iEnd
		$Struct &= 'int[2];'
	Next
	$tData = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = 1
	For $i = $iStart To $iEnd
		For $j = 0 To 1
			DllStructSetData($tData, $Count, $aPoint[$i][$j], $j + 1)
		Next
		$Count += 1
	Next

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'Polygon', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tData), 'int', $Count - 1)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_Polygon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PrintDlg
; Description....: Displays a Print dialog box.
; Syntax.........: _WinAPI_PrintDlg ( ByRef $tPRINTDLG )
; Parameters.....: $tPRINTDLG - $tagPRINTDLG structure that contains information used to initialize the dialog box. When _WinAPI_PrintDlg()
;                               returns, this structure contains information about the user's selections.
;
;                               (See MSDN for more information)
;
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the dialog box error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Note that the values of "hDevMode" and "hDevNames" member in $tagPRINTDLG may change when they are passed into
;                  _WinAPI_PrintDlg(). This is because these members are filled on both input and output.
; Related........:
; Link...........: @@MsdnLink@@ PrintDlg
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PrintDlg(ByRef $tPRINTDLG)

	Local $Ret = DllCall('comdlg32.dll', 'int', 'PrintDlgW', 'ptr', DllStructGetPtr($tPRINTDLG))

	If (@error) Or (Not $Ret[0]) Then
		If @error Then
			Return SetError(1, 0, 0)
		Else
			Return SetError(1, _WinAPI_CommDlgExtendedErrorEx(), 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PrintDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PrintDlgEx
; Description....: Displays a Print property sheet that enables the user to specify the properties of a particular print job.
; Syntax.........: _WinAPI_PrintDlgEx ( ByRef $tPRINTDLGEX )
; Parameters.....: $tPRINTDLGEX - $tagPRINTDLGEX structure that contains information used to initialize the property sheet. When _WinAPI_PrintDlgEx()
;                                 returns, this structure contains information about the user's selections.
;
;                                 (See MSDN for more information)
;
; Return values..: Success      - 1, @extended flag will contain one of the following values.
;
;                                 $PD_RESULT_APPLY
;                                 $PD_RESULT_CANCEL
;                                 $PD_RESULT_PRINT
;
;                  Failure      - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Note that the values of "hDevMode" and "hDevNames" member in $tagPRINTDLGEX may change when they are passed into
;                  _WinAPI_PrintDlgEx(). This is because these members are filled on both input and output.
; Related........:
; Link...........: @@MsdnLink@@ PrintDlgEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PrintDlgEx(ByRef $tPRINTDLGEX)

	Local $tPDEX = DllStructCreate($tagPRINTDLGEX, DllStructGetPtr($tPRINTDLGEX))
	Local $Ret = DllCall('comdlg32.dll', 'int', 'PrintDlgExW', 'ptr', DllStructGetPtr($tPDEX))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return SetError(0, DllStructGetData($tPDEX, 'ResultAction'), 1)
EndFunc   ;==>_WinAPI_PrintDlgEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PrivateExtractIcon
; Description....: Extracts the icon with the specified dimension from the specified file.
; Syntax.........: _WinAPI_PrivateExtractIcon ( $sIcon, $iIndex, $iWidth, $iHeight )
; Parameters.....: $sIcon   - Path and name of the file from which the icon are to be extracted.
;                  $iIndex  - Index of the icon to extract.
;                  $iWidth  - Horizontal icon size wanted.
;                  $iHeight - Vertical icon size wanted.
; Return values..: Success  - Handle to the extracted icon.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the icon with the specified dimension is not found in the file, it will choose the nearest appropriate icon and
;                  change to the specified dimension. When you are finished using the icon, destroy it using the _WinAPI_FreeIcon()
;                  function.
; Related........:
; Link...........: @@MsdnLink@@ PrivateExtractIcons
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PrivateExtractIcon($sIcon, $iIndex, $iWidth, $iHeight)

	Local $Ret = DllCall('user32.dll', 'int', 'PrivateExtractIconsW', 'wstr', $sIcon, 'int', $iIndex, 'int', $iWidth, 'int', $iHeight, 'ptr*', 0, 'ptr*', 0, 'int', 1, 'int', 0)

	If (@error) Or (Not $Ret[0]) Or ($Ret[5] = 0) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_PrivateExtractIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PrintWindow
; Description....: Copies a visual window into the specified device context.
; Syntax.........: _WinAPI_PrintWindow ( $hWnd, $hDC [, $fClient] )
; Parameters.....: $hWnd    - Handle to the window that will be copied.
;                  $hDC     - Handle to the device context.
;                  $fClient - Specifies whether copies only the client area of the window, valid values:
;                  |TRUE    - Only the client area of the window is copied to device context.
;                  |FALSE   - The entire window is copied. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PrintWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PrintWindow($hWnd, $hDC, $fClient = 0)

	Local $Ret = DllCall('user32.dll', 'int', 'PrintWindow', 'hwnd', $hWnd, 'hwnd', $hDC, 'uint', $fClient)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PrintWindow

; #FUNCTION#;===============================================================================
;
; Name...........: _WinAPI_ProcessGetLoadedModules
; Description ...: Returns an array containing the full path of the loaded modules
; Syntax.........: _WinAPI_ProcessGetLoadedModules($iPID)
; Parameters ....:
; Return values .: Success - An array with all the paths
;               : Failure - -1 and @error=1 if the specified process couldn't be opened.
; Author ........: Andreas Karlsson (monoceres) & ProgAndy
; Modified.......:
; Remarks .......:
; Related .......:
; Link ..........;
; Example .......; No
;
;;==========================================================================================
Func _WinAPI_ProcessGetLoadedModules($iPID)
	Local $tModulesStruct = DllStructCreate("hwnd [200]")
	Local $SIZEOFHWND = DllStructGetSize($tModulesStruct) / 200
	Local $hProcess = _WinAPI_OpenProcess(BitOR(0x400, 0x10), False, $iPID)
	If Not $hProcess Then Return SetError(1, 0, -1)
	Local $Ret = DllCall("Psapi.dll", "int", "EnumProcessModules", "ptr", $hProcess, "ptr", DllStructGetPtr($tModulesStruct), "dword", DllStructGetSize($tModulesStruct), "dword*", "")
	If $Ret[4] > DllStructGetSize($tModulesStruct) Then
		$tModulesStruct = DllStructCreate("hwnd [" & $Ret[4] / $SIZEOFHWND & "]")
		$Ret = DllCall("Psapi.dll", "int", "EnumProcessModules", "ptr", $hProcess, "ptr", DllStructGetPtr($tModulesStruct), "dword", $Ret[4], "dword*", "")
	EndIf
	Local $aReturn[$Ret[4] / $SIZEOFHWND]
	For $i = 0 To UBound($aReturn) - 1

		$Ret = DllCall("Psapi.dll", "dword", "GetModuleFileNameExW", "ptr", $hProcess, "ptr", DllStructGetData($tModulesStruct, 1, $i + 1), "wstr", "", "dword", 65536)
		$aReturn[$i] = $Ret[3]

	Next
	_WinAPI_CloseHandle($hProcess)
	Return $aReturn
EndFunc   ;==>_WinAPI_ProcessGetLoadedModules

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PtInRectEx
; Description....: Determines whether the specified point lies within the specified rectangle.
; Syntax.........: _WinAPI_PtInRectEx ( $iX, $iY, $iLeft, $iTop, $iRight, $iBottom )
; Parameters.....: $iX      - The x-coordinate of the point.
;                  $iY      - The y-coordinate of the point.
;                  $iLeft   - The x-coordinate of the upper-left corner of the rectangle.
;                  $iTop    - The y-coordinate of the upper-left corner of the rectangle.
;                  $iRight  - The x-coordinate of the lower-right corner of the rectangle.
;                  $iBottom - The y-coordinate of the lower-right corner of the rectangle.
; Return values..: Success  - 1 - The specified point lies within the rectangle.
;                             0 - Otherwise.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PtInRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PtInRectEx($iX, $iY, $iLeft, $iTop, $iRight, $iBottom)

	Local $tRECT = _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
	Local $Ret = DllCall('user32.dll', 'int', 'PtInRect', 'ptr', DllStructGetPtr($tRECT), 'int', $iX, 'int', $iY)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PtInRectEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PtInRegion
; Description....: Determines whether the specified point is inside the specified region.
; Syntax.........: _WinAPI_PtInRegion ( $hRgn, $iX, $iY )
; Parameters.....: $hRgn   - Handle to the region to be examined.
;                  $iX     - The x-coordinate of the point in logical units.
;                  $iY     - The y-coordinate of the point in logical units.
; Return values..: Success - 1 - The specified point is in the region.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PtInRegion
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PtInRegion($hRgn, $iX, $iY)

	Local $Ret = DllCall('gdi32.dll', 'int', 'PtInRegion', 'ptr', $hRgn, 'int', $iX, 'int', $iY)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PtInRegion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PtVisible
; Description....: Determines whether the specified point is within the clipping region.
; Syntax.........: _WinAPI_PtVisible ( $hDC, $iX, $iY )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical units, of the point.
;                  $iY     - The y-coordinate, in logical units, of the point.
; Return values..: Success - 1 - The specified point is within the clipping region.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PtVisible
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PtVisible($hDC, $iX, $iY)

	Local $Ret = DllCall('gdi32.dll', 'int', 'PtVisible', 'hwnd', $hDC, 'int', $iX, 'int', $iY)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PtVisible

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_QueryDosDevice
; Description....: Retrieves the current mapping for a particular MS-DOS device name.
; Syntax.........: _WinAPI_QueryDosDevice ( $sDevice )
; Parameters.....: $sDevice - The name of the MS-DOS device.
; Return values..: Success  - The current mapping for the specified device. If the $sDevice parameter is empty string, return array
;                             of all existing MS-DOS device names (for example, "\Device\HarddiskVolume1" or "\Device\Floppy0").
;                             The zeroth array element contains the number of names.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ QueryDosDevice
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_QueryDosDevice($sDevice)

	Local $TypeOfDevice = 'wstr'

	If Not StringStripWS($sDevice, 3) Then
		$TypeOfDevice = 'ptr'
		$sDevice = 0
	EndIf

	Local $tData = DllStructCreate('wchar[' & (32 * 1024 / 2) & ']'), $pData = DllStructGetPtr($tData)
	Local $Ret = DllCall('kernel32.dll', 'dword', 'QueryDosDeviceW', $TypeOfDevice, $sDevice, 'ptr', $pData, 'dword', 16384)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf

	Local $Result = _WinAPI_StructToArray($pData)

	If IsString($sDevice) Then
		$Result = $Result[1]
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_QueryDosDevice

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_QueryInformationJobObject
; Description....: Retrieves limit and job state information from the job object.
; Syntax.........: _WinAPI_QueryInformationJobObject ( $hJob, $iJobObjectInfoClass, ByRef $tJobObjectInfo )
; Parameters.....: $hJob                - Handle to the job whose information is being queried. The handle must have the
;                                         $JOB_OBJECT_QUERY access right. If this value is 0 and the calling process is associated
;                                         with a job, the job associated with the calling process is used.
;                  $iJobObjectInfoClass - The information class for the limits to be queried. This parameter specifies the type
;                                         of $tJobObjectInfo structure, valid values:
;                  |1  - $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION
;                  |2  - $tagJOBOBJECT_BASIC_LIMIT_INFORMATION
;                  |3  - $tagJOBOBJECT_BASIC_PROCESS_ID_LIST
;                  |4  - $tagJOBOBJECT_BASIC_UI_RESTRICTIONS
;                  |5  - $tagJOBOBJECT_SECURITY_LIMIT_INFORMATION
;                  |8  - $tagJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
;                  |9  - $tagJOBOBJECT_EXTENDED_LIMIT_INFORMATION
;                  |11 - $tagJOBOBJECT_GROUP_INFORMATION
;                  $tJobObjectInfo      - $tagJOBOBJECT_* structure that retrieves the limit and job state information.
; Return values..: Success              - The length of data (in bytes) written to the structure pointed to by the
;                                         $tJobObjectInfo parameter.
;                  Failure              - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ QueryInformationJobObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_QueryInformationJobObject($hJob, $iJobObjectInfoClass, ByRef $tJobObjectInfo)

	Local $Ret = DllCall('kernel32.dll', 'int', 'QueryInformationJobObject', 'ptr', $hJob, 'int', $iJobObjectInfoClass, 'ptr', DllStructGetPtr($tJobObjectInfo), 'dword', DllStructGetSize($tJobObjectInfo), 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_QueryInformationJobObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_QueryPerformanceCounter
; Description....: Retrieves the current value of the high-resolution performance counter.
; Syntax.........: _WinAPI_QueryPerformanceCounter ( )
; Parameters.....: None
; Return values..: Success - The current performance-counter value, in counts.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ QueryPerformanceCounter
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_QueryPerformanceCounter()

	Local $Ret = DllCall('kernel32.dll', 'int', 'QueryPerformanceCounter', 'int64*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_QueryPerformanceCounter

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_QueryPerformanceFrequency
; Description....: Retrieves the frequency of the high-resolution performance counter.
; Syntax.........: _WinAPI_QueryPerformanceFrequency ( )
; Parameters.....: None
; Return values..: Success - The current performance-counter frequency, in counts per second.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ QueryPerformanceFrequency
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_QueryPerformanceFrequency()

	Local $Ret = DllCall('kernel32.dll', 'int', 'QueryPerformanceFrequency', 'int64*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_QueryPerformanceFrequency

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RadialGradientFill
; Description....: Fills radial gradient.
; Syntax.........: _WinAPI_RadialGradientFill($hDC, $iX, $iY, $iRadius, $iRGB1, $iRGB2 [, $iAngleStart [, $iAngleEnd [, $iStep]]] )
; Parameters.....: $hDC         - Handle to the device context.
;                  $iX          - The x-coordinate of the central point, in logical units.
;                  $iY          - The y-coordinate of the central point, in logical units.
;                  $iRadius     - The circle radius to filling the gradient.
;                  $iRGB1       - The color information at the central point.
;                  $iRGB2       - The color information at the edges of circle.
;                  $iAngleStart - The angle to start filling at, in degree.
;                  $iAngleEnd   - The angle to end filling at, in degree.
;                  $iStep       - The gradient filling step in degree. The larger value of this parameter, the gradient will be
;                                 better, but it's require more time, and vice versa.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not fills gradient with transparency, and does not use antialiasing.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RadialGradientFill($hDC, $iX, $iY, $iRadius, $iRGB1, $iRGB2, $iAngleStart = 0, $iAngleEnd = 360, $iStep = 5)

	Local $Val

	If Abs($iAngleStart) > 360 Then
		$iAngleStart = Mod($iAngleStart, 360)
	EndIf
	If Abs($iAngleEnd) > 360 Then
		$iAngleEnd = Mod($iAngleEnd, 360)
	EndIf
	If ($iAngleStart < 0) Or ($iAngleEnd < 0) Then
		$iAngleStart += 360
		$iAngleEnd += 360
	EndIf
	If $iAngleStart > $iAngleEnd Then
		$Val = $iAngleStart
		$iAngleStart = $iAngleEnd
		$iAngleEnd = $Val
	EndIf
	If $iStep < 1 Then
		$iStep = 1
	EndIf

	Local $Ki = ATan(1) / 45
	Local $Xp = Round($iX + $iRadius * Cos($Ki * $iAngleStart))
	Local $Yp = Round($iY + $iRadius * Sin($Ki * $iAngleStart))
	Local $Xn, $Yn, $An = $iAngleStart
	Local $Vertex[3][3]

	While $An < $iAngleEnd
		$An += $iStep
		If $An > $iAngleEnd Then
			$An = $iAngleEnd
		EndIf
		$Xn = Round($iX + $iRadius * Cos($Ki * $An))
		$Yn = Round($iY + $iRadius * Sin($Ki * $An))
		$Vertex[0][0] = $iX
		$Vertex[0][1] = $iY
		$Vertex[0][2] = $iRGB1
		$Vertex[1][0] = $Xp
		$Vertex[1][1] = $Yp
		$Vertex[1][2] = $iRGB2
		$Vertex[2][0] = $Xn
		$Vertex[2][1] = $Yn
		$Vertex[2][2] = $iRGB2
		If Not _WinAPI_GradientFill($hDC, $Vertex, 0, 2) Then
			Return SetError(1, 0, 0)
		EndIf
		$Xp = $Xn
		$Yp = $Yn
	WEnd
	Return 1
EndFunc   ;==>_WinAPI_RadialGradientFill

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RasEnumEntries
; Description....: Returns the RAS-Entrie information in an array.
; Syntax.........: _WinAPI_Rectangle (  )
; Parameters.....: none
; Return values..: Success  - Returns array of Ras entries.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........:
; Related........:
; Link...........:
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RasEnumEntries()
	Local $Result[1]
	Local $tBuffer = DllStructCreate($tagRASENTRYNAME)
	Local $iBufferSize = DllStructGetSize($tBuffer)
	Local $mem = __MemGlobalAlloc(256 * $iBufferSize, 0x0040)
	
	Local $aRasEntryName[256]

	For $i = 0 To 255
		$aRasEntryName[$i] = DllStructCreate($tagRASENTRYNAME, $mem + ($i * $iBufferSize))
	Next
	DllStructSetData($aRasEntryName[0], 1, $iBufferSize)

	Local $Res = DllCall("rasapi32.dll", "int", "RasEnumEntries", "ptr", 0, "ptr", 0, "ptr", DllStructGetPtr($aRasEntryName[0]), "int*", 256 * $iBufferSize, "int*", 0)

	If $Res[0] = 0 Then
		For $i = 0 To $Res[5] - 1
			$Result[$i] = DllStructGetData($aRasEntryName[$i], "szEntryName")
			ReDim $Result[UBound($Result) + 1]
		Next
		ReDim $Result[UBound($Result) - 1]
		Return $Result
	Else
		Return SetError(0, _WinAPI_GetLastError(), $Res[0])
	EndIf
EndFunc   ;==>_WinAPI_RasEnumEntries

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Rectangle
; Description....: Draws a rectangle.
; Syntax.........: _WinAPI_Rectangle ( $hDC, $tRECT )
; Parameters.....: $hDC     - Handle to the device context.
;                  $tRECT   - $tagRECT structure that contains the logical coordinates of the rectangle.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The rectangle is outlined by using the current pen and filled by using the current brush.
; Related........:
; Link...........: @@MsdnLink@@ Rectangle
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Rectangle($hDC, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'Rectangle', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_Rectangle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RectInRegion
; Description....: Determines whether any part of the specified rectangle is within the boundaries of a region.
; Syntax.........: _WinAPI_RectInRegion ( $hRgn, $tRECT )
; Parameters.....: $hRgn   - Handle to the region.
;                  $tRECT  - $tagRECT structure that contains the coordinates of the rectangle in logical units.
; Return values..: Success - 1 - Any part of the specified rectangle lies within the boundaries of the region
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RectInRegion
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RectInRegion($hRgn, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'RectInRegion', 'ptr', $hRgn, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_RectInRegion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RectVisible
; Description....: Determines whether any part of the specified rectangle lies within the clipping region.
; Syntax.........: _WinAPI_RectVisible ( $hDC, $tRECT )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tRECT  - $tagRECT structure that contains the logical coordinates of the specified rectangle.
; Return values..: Success - 1, 2 - The rectangle lies within the clipping region.
;                            0    - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RectVisible
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RectVisible($hDC, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'RectVisible', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		Switch $Ret[0]
			Case 0, 1, 2

			Case Else
				Return SetError(1, $Ret[0], 0)
		EndSwitch
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_RectVisible

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegCloseKey
; Description....: Closes a handle to the specified registry key.
; Syntax.........: _WinAPI_RegCloseKey ( $hKey [, $fFlush] )
; Parameters.....: $hKey   - Handle to the open key to be closed. The handle must have been opened by the _WinAPI_RegCreateKey()
;                            or _WinAPI_RegOpenKey() function.
;                  $fFlush - Specifies whether writes all the attributes of the specified registry key into the registry,
;                            valid values:
;                  |TRUE   - Write changes to disk before close the handle.
;                  |FALSE  - Don`t write. (Default)
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegCloseKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegCloseKey($hKey, $fFlush = 0)

	If $fFlush Then
		If Not _WinAPI_RegFlushKey($hKey) Then
			Return SetError(1, @extended, 0)
		EndIf
	EndIf

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegCloseKey', 'ulong_ptr', $hKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegCloseKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegConnectRegistry
; Description....: Establishes a connection to a predefined registry key on another computer.
; Syntax.........: _WinAPI_RegConnectRegistry ( $sComputer, $hKey )
; Parameters.....: $sComputer - The name of the remote computer. The string has the form as "\\computername". The caller must
;                               have access to the remote computer or the function fails. If this parameter is 0, the local
;                               computer name is used.
;                  $hKey      - The predefined registry handle. This parameter can be one of the following predefined keys
;                               on the remote computer.
;
;                               $HKEY_LOCAL_MACHINE
;                               $HKEY_PERFORMANCE_DATA
;                               $HKEY_USERS
;
; Return values..: Success    - Handle to the key on the remote computer.
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires the Remote Registry service to be running on the remote computer.
;
;                  If the current user does not have proper access to the remote computer, the call to _WinAPI_RegConnectRegistry()
;                  fails. If the computer is joined to a workgroup and the "Force network logons using local accounts to authenticate
;                  as Guest" policy is enabled, the function fails. Note that this policy is enabled by default if the computer is
;                  joined to a workgroup.
;
;                  When a handle returned by _WinAPI_RegConnectRegistry() is no longer needed, it should be closed by
;                  calling _WinAPI_RegCloseKey().
; Related........:
; Link...........: @@MsdnLink@@ RegConnectRegistry
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegConnectRegistry($sComputer, $hKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegConnectRegistryW', 'wstr', $sComputer, 'ulong_ptr', $hKey, 'ulong_ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_RegConnectRegistry

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegCopyTree
; Description....: Recursively copies the subkeys and values of the source subkey to the destination key.
; Syntax.........: _WinAPI_RegCopyTree ( $hSrcKey, $sSrcSubKey, $hDestKey )
; Parameters.....: $hSrcKey    - Handle to the source key or one of the predefined registry keys ($HKEY_*).
;                  $sSrcSubKey - The subkey whose subkeys and values are to be copied.
;                  $hDestKey   - Handle to the destination key.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not duplicate the security attributes of the keys and values that it copies. Rather,
;                  all security attributes in the destination key are the default attributes.
; Related........:
; Link...........: @@MsdnLink@@ SHCopyKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegCopyTree($hSrcKey, $sSrcSubKey, $hDestKey)

	Local $Ret = DllCall('shlwapi.dll', 'long', 'SHCopyKeyW', 'ulong_ptr', $hSrcKey, 'wstr', $sSrcSubKey, 'ulong_ptr', $hDestKey, 'dword', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegCopyTree

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegCopyTreeEx
; Description....: Copies the specified registry key, along with its values and subkeys, to the specified destination key.
; Syntax.........: _WinAPI_RegCopyTreeEx ( $hSrcKey, $sSrcSubKey, $hDestKey )
; Parameters.....: $hSrcKey    - Handle to an open registry key. The key must have been opened with the $KEY_READ access right.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function, or it can be
;                                one of the predefined registry keys ($HKEY_*).
;                  $sSrcSubKey - The name of the key. This key must be a subkey of the key identified by the $hSrcKey parameter.
;                  $hDestKey   - Handle to the destination key. The calling process must have $KEY_CREATE_SUB_KEY access to the key.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function, or it can be
;                                one of the predefined registry keys ($HKEY_*).
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function also copies the security descriptor for the key.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RegCopyTree
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegCopyTreeEx($hSrcKey, $sSrcSubKey, $hDestKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegCopyTreeW', 'ulong_ptr', $hSrcKey, 'wstr', $sSrcSubKey, 'ulong_ptr', $hDestKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegCopyTreeEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegCreateKey
; Description....: Creates the specified registry key.
; Syntax.........: _WinAPI_RegCreateKey ( $hKey [, $sSubKey [, $iAccess [, $iOptions [, $tSecurity]]]] )
; Parameters.....: $hKey      - Handle to an open registry key. If the key already exists, the function opens it. The calling process
;                               must have $KEY_CREATE_SUB_KEY access to the key. This handle is returned by the _WinAPI_RegCreateKey()
;                               or _WinAPI_RegOpenKey() function, or it can be one of the following predefined keys.
;
;                               $HKEY_CLASSES_ROOT
;                               $HKEY_CURRENT_CONFIG
;                               $HKEY_CURRENT_USER
;                               $HKEY_LOCAL_MACHINE
;                               $HKEY_USERS
;
;                  $sSubKey   - The name of a subkey that this function opens or creates. The subkey specified must be a subkey of
;                               the key identified by the $hKey parameter; it can be up to 32 levels deep in the registry tree.
;                  $iAccess   - The mask that specifies the access rights for the key. This parameter can be one or more of
;                               the following values.
;
;                               $KEY_ALL_ACCESS
;                               $KEY_CREATE_LINK
;                               $KEY_CREATE_SUB_KEY
;                               $KEY_ENUMERATE_SUB_KEYS
;                               $KEY_EXECUTE
;                               $KEY_NOTIFY
;                               $KEY_QUERY_VALUE
;                               $KEY_READ
;                               $KEY_SET_VALUE
;                               $KEY_WOW64_32KEY
;                               $KEY_WOW64_64KEY
;                               $KEY_WRITE
;
;                  $iOptions  - This parameter can be one of the following values.
;
;                               $REG_OPTION_BACKUP_RESTORE
;                               $REG_OPTION_CREATE_LINK
;                               $REG_OPTION_NON_VOLATILE
;                               $REG_OPTION_VOLATILE
;
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by
;                               child processes. If this parameter is 0, the handle cannot be inherited.
; Return values..: Success    - Handle to the opened or created key, @extended flag will contain one of the following
;                               disposition values.
;
;                               0 (FALSE) - The key existed and was simply opened without being changed.
;                               1 (TRUE)  - The key did not exist and was created.
;
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application cannot create a key that is a direct child of HKEY_USERS or HKEY_LOCAL_MACHINE. An application
;                  can create subkeys in lower levels of the HKEY_USERS or HKEY_LOCAL_MACHINE trees.
;
;                  If the key is not one of the predefined registry keys ($HKEY_*) you must call the _WinAPI_RegCloseKey()
;                  function after finished using the handle.
; Related........:
; Link...........: @@MsdnLink@@ RegCreateKeyEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegCreateKey($hKey, $sSubKey = '', $iAccess = 0xF003F, $iOptions = 0, $tSecurity = 0)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegCreateKeyExW', 'ulong_ptr', $hKey, 'wstr', $sSubKey, 'dword', 0, 'ptr', 0, 'dword', $iOptions, 'dword', $iAccess, 'ptr', DllStructGetPtr($tSecurity), 'ulong_ptr*', 0, 'dword*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return SetError(0, Number($Ret[9] = 1), $Ret[8])
EndFunc   ;==>_WinAPI_RegCreateKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDeleteEmptyKey
; Description....: Deletes an empty key.
; Syntax.........: _WinAPI_RegDeleteEmptyKey ( $hKey [, $sSubKey] )
; Parameters.....: $hKey    - Handle to an open registry key, or any of the following predefined keys.
;
;                             $HKEY_CLASSES_ROOT
;                             $HKEY_CURRENT_CONFIG
;                             $HKEY_CURRENT_USER
;                             $HKEY_LOCAL_MACHINE
;                             $HKEY_USERS
;
;                  $sSubKey - The name of the key to delete.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHDeleteEmptyKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDeleteEmptyKey($hKey, $sSubKey = '')

	Local $Ret = DllCall('shlwapi.dll', 'long', 'SHDeleteEmptyKeyW', 'ulong_ptr', $hKey, 'wstr', $sSubKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDeleteEmptyKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDeleteKey
; Description....: Deletes a subkey and its values.
; Syntax.........: _WinAPI_RegDeleteKey ( $hKey [, $sSubKey] )
; Parameters.....: $hKey    - Handle to an open registry key. The access rights of this key do not affect the delete operation.
;                             This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function, or it can be
;                             one of the following predefined keys.
;
;                             $HKEY_CLASSES_ROOT
;                             $HKEY_CURRENT_CONFIG
;                             $HKEY_CURRENT_USER
;                             $HKEY_LOCAL_MACHINE
;                             $HKEY_USERS
;
;                  $sSubKey - The name of the key to be deleted. It must be a subkey of the key that $hKey identifies, but it
;                             cannot have subkeys.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: A deleted key is not removed until the last handle to it is closed.
; Related........:
; Link...........: @@MsdnLink@@ RegDeleteKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDeleteKey($hKey, $sSubKey = '')

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegDeleteKeyW', 'ulong_ptr', $hKey, 'wstr', $sSubKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDeleteKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDeleteKeyValue
; Description....: Removes the specified value from the specified registry key and subkey.
; Syntax.........: _WinAPI_RegDeleteKeyValue ( $hKey, $sSubKey, $sValueName )
; Parameters.....: $hKey       - Handle to an open registry key. The key must have been opened with the $KEY_SET_VALUE access right.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function, or it can be
;                                one of the following predefined keys.
;
;                                $HKEY_CLASSES_ROOT
;                                $HKEY_CURRENT_CONFIG
;                                $HKEY_CURRENT_USER
;                                $HKEY_LOCAL_MACHINE
;                                $HKEY_USERS
;
;                  $sSubKey    - The name of the registry key. This key must be a subkey of the key identified by the $hKey parameter.
;                  $sValueName - The registry value to be removed from the key.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RegDeleteKeyValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDeleteKeyValue($hKey, $sSubKey, $sValueName)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegDeleteKeyValueW', 'ulong_ptr', $hKey, 'wstr', $sSubKey, 'wstr', $sValueName)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDeleteKeyValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDeleteTree
; Description....: Deletes a subkey and all its descendants.
; Syntax.........: _WinAPI_RegDeleteTree ( $hKey [, $sSubKey] )
; Parameters.....: $hKey    - Handle to an open registry key, or any of the following predefined keys.
;
;                             $HKEY_CLASSES_ROOT
;                             $HKEY_CURRENT_CONFIG
;                             $HKEY_CURRENT_USER
;                             $HKEY_LOCAL_MACHINE
;                             $HKEY_PERFORMANCE_DATA
;                             $HKEY_USERS
;
;                  $sSubKey - The name of the key to delete.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHDeleteKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDeleteTree($hKey, $sSubKey = '')

	Local $Ret = DllCall('shlwapi.dll', 'long', 'SHDeleteKeyW', 'ulong_ptr', $hKey, 'wstr', $sSubKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDeleteTree

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDeleteTreeEx
; Description....: Deletes the subkeys and values of the specified key recursively.
; Syntax.........: _WinAPI_RegDeleteTreeEx ( $hKey [, $sSubKey] )
; Parameters.....: $hKey    - Handle to an open registry key. The key must have been opened with the following access rights:
;                             $DELETE, $KEY_ENUMERATE_SUB_KEYS, and $KEY_QUERY_VALUE. This handle is returned by the _WinAPI_RegCreateKey()
;                             or _WinAPI_RegOpenKey() function, or it can be one of the following predefined keys.
;
;                             $HKEY_CLASSES_ROOT
;                             $HKEY_CURRENT_CONFIG
;                             $HKEY_CURRENT_USER
;                             $HKEY_LOCAL_MACHINE
;                             $HKEY_USERS
;
;                  $sSubKey - The name of the key to delete. This key must be a subkey of the key identified by the $hKey parameter.
;                             If this parameter is not specified, the subkeys and values of $hKey are deleted.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the key has values, it must be opened with $KEY_SET_VALUE or this function will fail.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RegDeleteTree
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDeleteTreeEx($hKey, $sSubKey = '')

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegDeleteTreeW', 'ulong_ptr', $hKey, 'wstr', $sSubKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDeleteTreeEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDeleteValue
; Description....: Removes a named value from the specified registry key.
; Syntax.........: _WinAPI_RegDeleteValue ( $hKey, $sValueName )
; Parameters.....: $hKey       - Handle to an open registry key. The key must have been opened with the $KEY_SET_VALUE access right.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function, or it can be
;                                one of the following predefined keys.
;
;                                $HKEY_CLASSES_ROOT
;                                $HKEY_CURRENT_CONFIG
;                                $HKEY_CURRENT_USER
;                                $HKEY_LOCAL_MACHINE
;                                $HKEY_USERS
;
;                  $sValueName - The registry value to be removed. If this parameter is empty string, the key's unnamed or default
;                                value is removed.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegDeleteValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDeleteValue($hKey, $sValueName)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegDeleteValueW', 'ulong_ptr', $hKey, 'wstr', $sValueName)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDeleteValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDisableReflectionKey
; Description....: Disables registry reflection for the specified key.
; Syntax.........: _WinAPI_RegDisableReflectionKey ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key. This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey()
;                            function; it cannot specify a key on a remote computer. If the key is not on the reflection list,
;                            the function succeeds but has no effect.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: On WOW64, 32-bit applications view a registry tree that is separate from the registry tree that 64-bit applications
;                  view. Registry reflection copies specific registry keys and values between the two views.
;
;                  To restore registry reflection for a disabled key, use the _WinAPI_RegEnableReflectionKey().
; Related........:
; Link...........: @@MsdnLink@@ RegDisableReflectionKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDisableReflectionKey($hKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegDisableReflectionKey', 'ulong_ptr', $hKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDisableReflectionKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDuplicateHKey
; Description....: Duplicates a registry key's handle.
; Syntax.........: _WinAPI_RegDuplicateHKey ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key to be duplicated.
; Return values..: Success - A duplicate of the handle.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHRegDuplicateHKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDuplicateHKey($hKey)

	Local $Ret = DllCall('shlwapi.dll', 'ulong_ptr', 'SHRegDuplicateHKey', 'ulong_ptr', $hKey)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_RegDuplicateHKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegEnableReflectionKey
; Description....: Restores registry reflection for the specified disabled key.
; Syntax.........: _WinAPI_RegEnableReflectionKey ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key. This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey()
;                            function; it cannot specify a key on a remote computer. If the key is not on the reflection list,
;                            the function succeeds but has no effect.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: On WOW64, 32-bit applications view a registry tree that is separate from the registry tree that 64-bit applications
;                  view. Registry reflection copies specific registry keys and values between the two views.
; Related........:
; Link...........: @@MsdnLink@@ RegEnableReflectionKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegEnableReflectionKey($hKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegEnableReflectionKey', 'ulong_ptr', $hKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegEnableReflectionKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegEnumKey
; Description....: Enumerates the subkeys of the specified open registry key.
; Syntax.........: _WinAPI_RegEnumKey ( $hKey, $iIndex )
; Parameters.....: $hKey   - Handle to an open registry key. The key must have been opened with the $KEY_ENUMERATE_SUB_KEYS access
;                            right. This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function.
;                            It can also be one of the following predefined keys.
;
;                            $HKEY_CLASSES_ROOT
;                            $HKEY_CURRENT_CONFIG
;                            $HKEY_CURRENT_USER
;                            $HKEY_LOCAL_MACHINE
;                            $HKEY_PERFORMANCE_DATA
;                            $HKEY_USERS
;
;                  $iIndex - The index of the subkey to retrieve. This parameter should be zero for the first call to the _WinAPI_RegEnumKey()
;                            function and then incremented for subsequent calls.
; Return values..: Success - The string that contains the name of the subkey.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: To enumerate subkeys, an application should initially call the _WinAPI_RegEnumKey() function with the $iIndex
;                  parameter set to zero. The application should then increment the $iIndex parameter and call _WinAPI_RegEnumKey()
;                  until there are no more subkeys (meaning the @extended flag sets to ERROR_NO_MORE_ITEMS (259)).
;
;                  The application can also set $iIndex to the index of the last subkey on the first call to the function and
;                  decrement the index until the subkey with the index 0 is enumerated. To retrieve the index of the last subkey,
;                  use the _WinAPI_RegQueryInfoKey() function.
;
;                  While an application is using the _WinAPI_RegEnumKey() function, it should not make calls to any registration
;                  functions that might change the key being enumerated.
; Related........:
; Link...........: @@MsdnLink@@ RegEnumKeyEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegEnumKey($hKey, $iIndex)

	Local $tData = DllStructCreate('wchar[256]')
	Local $Ret = DllCall('advapi32.dll', 'long', 'RegEnumKeyExW', 'ulong_ptr', $hKey, 'dword', $iIndex, 'ptr', DllStructGetPtr($tData), 'dword*', 256, 'dword', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_RegEnumKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegEnumValue
; Description....: Enumerates the values for the specified open registry key.
; Syntax.........: _WinAPI_RegEnumValue ( $hKey, $iIndex )
; Parameters.....: $hKey   - Handle to an open registry key. The key must have been opened with the $KEY_QUERY_VALUE access right.
;                            This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                            be one of the following predefined keys.
;
;                            $HKEY_CLASSES_ROOT
;                            $HKEY_CURRENT_CONFIG
;                            $HKEY_CURRENT_USER
;                            $HKEY_LOCAL_MACHINE
;                            $HKEY_PERFORMANCE_DATA
;                            $HKEY_USERS
;
;                  $iIndex - The index of the value to be retrieved. This parameter should be zero for the first call to the _WinAPI_RegEnumValue()
;                            function and then be incremented for subsequent calls.
; Return values..: Success - The string that contains the name of the value, @extended flag will contain the code indicating the
;                            type of data ($REG_*) stored in the specified value.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: To enumerate values, an application should initially call the _WinAPI_RegEnumValue() function with the $iIndex
;                  parameter set to zero. The application should then increment $iIndex and call the _WinAPI_RegEnumValue() function
;                  until there are no more values (until the @extended flag sets to ERROR_NO_MORE_ITEMS (259)).
;
;                  The application can also set $iIndex to the index of the last value on the first call to the function and
;                  decrement the index until the value with index 0 is enumerated. To retrieve the index of the last value,
;                  use the _WinAPI_RegQueryInfoKey() function.
;
;                  While using _WinAPI_RegEnumValue(), an application should not call any registry functions that might change the
;                  key being queried.
; Related........:
; Link...........: @@MsdnLink@@ RegEnumValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegEnumValue($hKey, $iIndex)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('advapi32.dll', 'long', 'RegEnumValueW', 'ulong_ptr', $hKey, 'dword', $iIndex, 'ptr', DllStructGetPtr($tData), 'dword*', 1024, 'dword', 0, 'dword*', 0, 'ptr', 0, 'ptr', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return SetError(0, $Ret[6], DllStructGetData($tData, 1))
EndFunc   ;==>_WinAPI_RegEnumValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegFlushKey
; Description....: Writes all the attributes of the specified open registry key into the registry.
; Syntax.........: _WinAPI_RegFlushKey ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key. The key must have been opened with the $KEY_QUERY_VALUE access right.
;                            This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                            be one of the following predefined keys.
;
;                            $HKEY_CLASSES_ROOT
;                            $HKEY_CURRENT_CONFIG
;                            $HKEY_CURRENT_USER
;                            $HKEY_LOCAL_MACHINE
;                            $HKEY_PERFORMANCE_DATA
;                            $HKEY_USERS
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_RegFlushKey() function returns only when all the data for the hive that contains the specified key
;                  has been written to the registry store on disk. The _WinAPI_RegFlushKey() function writes out the data for other
;                  keys in the hive that have been modified since the last lazy flush or system start. After _WinAPI_RegFlushKey()
;                  returns, use _WinAPI_RegCloseKey() to close the handle to the registry key.
; Related........:
; Link...........: @@MsdnLink@@ RegFlushKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegFlushKey($hKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegFlushKey', 'ulong_ptr', $hKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegFlushKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegisterApplicationRestart
; Description....: Registers the active instance of an application for restart.
; Syntax.........: _WinAPI_RegisterApplicationRestart ( [$iFlags [, $sCmd]] )
; Parameters.....: $iFlags - The flags that specifies an events when application will not be restarted. This parameter can be
;                            0 or one or more of the following values.
;
;                            $RESTART_NO_CRASH
;                            $RESTART_NO_HANG
;                            $RESTART_NO_PATCH
;                            $RESTART_NO_REBOOT
;
;                  $sCmd   - The command-line arguments for the application when it is restarted. The maximum size of the command
;                            line that you can specify is 2048 characters. If this parameter is empty string, the previously
;                            registered command line is removed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Your initial registration for restart must occur before the application encounters an unhandled exception
;                  or becomes unresponsive. You could then call this function from inside your recovery callback to update the
;                  command line. To prevent cyclical restarts, the system will only restart the application if it has been
;                  running for a minimum of 60 seconds.
;
;                  If you register for restart and the application encounters an unhandled exception or is not responsive,
;                  the user is offered the opportunity to restart the application; the application is not automatically restarted
;                  without the user's consent.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RegisterApplicationRestart
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegisterApplicationRestart($iFlags = 0, $sCmd = '')

	Local $Ret = DllCall('kernel32.dll', 'uint', 'RegisterApplicationRestart', 'wstr', $sCmd, 'dword', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegisterApplicationRestart

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegisterClassEx
; Description....: Registers a window class.
; Syntax.........: _WinAPI_RegisterClassEx ( $tWNDCLASSEX )
; Parameters.....: $tWNDCLASSEX - $tagWNDCLASSEX structure.
; Return values..: Success      - The value is a class atom that uniquely identifies the class being registered.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegisterClassEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegisterClassEx($tWNDCLASSEX)

	Local $Ret = DllCall('user32.dll', 'dword', 'RegisterClassExW', 'ptr', DllStructGetPtr($tWNDCLASSEX))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_RegisterClassEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegisterHotKey
; Description....: Defines a system-wide hot key.
; Syntax.........: _WinAPI_RegisterHotKey ( $hWnd, $ID, $iModifiers, $vKey )
; Parameters.....: $hWnd       - Handle to the window that will receive WM_HOTKEY messages generated by the hot key. If this parameter
;                                is 0, WM_HOTKEY messages are posted to the message queue of the calling thread and must be processed in
;                                the message loop.
;                  $ID         - Specifies the identifier of the hot key. An application must specify an id value in the range
;                                0x0000 through 0xBFFF.
;                  $iModifiers - Specifies keys that must be pressed in combination with the key specified by the $vKey parameter
;                                in order to generate the WM_HOTKEY message. The $iModifiers parameter can be a combination of the
;                                following values.
;
;                                $MOD_ALT
;                                $MOD_CONTROL
;                                $MOD_SHIFT
;                                $MOD_WIN
;
;                                *Windows 7 or later
;
;                                $MOD_NOREPEAT
;
;                  $vKey       - Specifies the virtual-key code of the hot key ($VK_*).
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When a key is pressed, the system looks for a match against all hot keys. Upon finding a match, the system posts
;                  the WM_HOTKEY message to the message queue of the window with which the hot key is associated. If the hot key is
;                  not associated with a window, then the WM_HOTKEY message is posted to the thread associated with the hot key.
;
;                  _WinAPI_RegisterHotKey() fails if the keystrokes specified for the hot key have already been registered by
;                  another hot key.
;
;                  In Windows XP and previous versions of Windows, if a hot key already exists with the same $hWnd and $ID parameters,
;                  it is replaced by the new hot key.
;
;                  In Windows Vista and subsequent versions of Windows, if a hot key already exists with the same $hWnd and $ID
;                  parameters, it is maintained along with the new hot key. In these versions of Windows, the application must
;                  explicitly call _WinAPI_UnregisterHotKey() to unregister the old hot key.
; Related........:
; Link...........: @@MsdnLink@@ RegisterHotKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegisterHotKey($hWnd, $ID, $iModifiers, $vKey)

	Local $Ret = DllCall('user32.dll', 'int', 'RegisterHotKey', 'hwnd', $hWnd, 'int', $ID, 'uint', $iModifiers, 'uint', $vKey)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegisterHotKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegisterPowerSettingNotification
; Description....: Registers the application to receive power setting notifications for the specific power setting event.
; Syntax.........: _WinAPI_RegisterPowerSettingNotification ( $hWnd, $GUID )
; Parameters.....: $hWnd   - Handle to the window that receives the change or notification messages.
;                  $GUID   - The a string that represents a GUID of the power setting for which notifications are to be sent.
;                            It may be one of the following values.
;
;                            $GUID_ACDC_POWER_SOURCE
;                            $GUID_BATTERY_PERCENTAGE_REMAINING
;                            $GUID_IDLE_BACKGROUND_TASK
;                            $GUID_MONITOR_POWER_ON
;                            $GUID_POWERSCHEME_PERSONALITY
;                            $GUID_SYSTEM_AWAYMODE
;
; Return values..: Success - A notification handle for unregistering for power notifications.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After calling this function, notifications are sent to the specified window using WM_POWERBROADCAST
;                  messages with a wParam parameter of PBT_POWERSETTINGCHANGE (see MSDN for more information).
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RegisterPowerSettingNotification
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegisterPowerSettingNotification($hWnd, $GUID)

	Local $Ret, $tGUID

	$tGUID = DllStructCreate($tagGUID)
	$Ret = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', $GUID, 'ptr', DllStructGetPtr($tGUID))
	If (@error) Or ($Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$Ret  = DllCall('user32.dll', 'ptr', 'RegisterPowerSettingNotification', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tGUID), 'dword', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_RegisterPowerSettingNotification

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegisterShellHookWindow
; Description....: Registers a specified Shell window to receive certain messages for events or notifications.
; Syntax.........: _WinAPI_RegisterShellHookWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to register for Shell hook messages.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegisterShellHookWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegisterShellHookWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'RegisterShellHookWindow', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegisterShellHookWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegLoadMUIString
; Description....: Loads the specified string from the specified key and subkey.
; Syntax.........: _WinAPI_RegLoadMUIString ( $hKey, $sValueName [, $sDirectory] )
; Parameters.....: $hKey       - Handle to an open registry key. The key must have been opened with the $KEY_QUERY_VALUE access right.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                                be one of the following predefined keys.
;
;                                $HKEY_CLASSES_ROOT
;                                $HKEY_CURRENT_CONFIG
;                                $HKEY_CURRENT_USER
;                                $HKEY_LOCAL_MACHINE
;                                $HKEY_USERS
;
;                  $sValueName - The name of the registry value.
;                  $sDirectory - The directory path.
; Return values..: Success     - The loaded string.
;                  Failure     - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The strings of the following form receive special handling:
;
;                  @[path]\dllname,-strID
;
;                  The string with identifier strID is loaded from dllname; the path is optional. If the $sDirectory parameter is
;                  empty string, the directory is prepended to the path specified in the registry data. Note that dllname can contain
;                  environment variables to be expanded.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RegLoadMUIString
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegLoadMUIString($hKey, $sValueName, $sDirectory = '')

	Local $TypeOfDirectory = 'wstr'

	If Not StringStripWS($sDirectory, 3) Then
		$TypeOfDirectory = 'ptr'
		$sDirectory = 0
	EndIf

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('advapi32.dll', 'long', 'RegLoadMUIStringW', 'ulong_ptr', $hKey, 'wstr', $sValueName, 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData), 'dword*', 0, 'dword', 0, $TypeOfDirectory, $sDirectory)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_RegLoadMUIString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegNotifyChangeKeyValue
; Description....: Notifies the caller about changes to the attributes or contents of a specified registry key.
; Syntax.........: _WinAPI_RegNotifyChangeKeyValue ( $hKey, $iFilter [, $fSubtree [, $fAsync [, $hEvent]]] )
; Parameters.....: $hKey     - Handle to an open registry key. The key must have been opened with the KEY_NOTIFY access right.
;                              This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                              be one of the following predefined keys.
;
;                              $HKEY_CLASSES_ROOT
;                              $HKEY_CURRENT_CONFIG
;                              $HKEY_CURRENT_USER
;                              $HKEY_LOCAL_MACHINE
;                              $HKEY_USERS
;
;                  $iFilter  - Indicates the changes that should be reported. This parameter can be one or more of the following values.
;
;                              $REG_NOTIFY_CHANGE_NAME
;                              $REG_NOTIFY_CHANGE_ATTRIBUTES
;                              $REG_NOTIFY_CHANGE_LAST_SET
;                              $REG_NOTIFY_CHANGE_SECURITY
;
;                  $fSubtree - Specifies whether report changes in the subkeys of the specified key, valid values:
;                  |TRUE     - The function reports changes in the specified key and all its subkeys.
;                  |FALSE    - The function reports changes only in the specified key. (Default)
;                  $fAsync   - Specifies whether return immediately, valid values:
;                  |TRUE     - The function returns immediately and reports changes by signaling the specified event.
;                  |FALSE    - The function does not return until a change has occurred. (Default)
;                  $hEvent   - Handle to an event. If the $fAsync parameter is TRUE, the function returns immediately and changes are
;                              reported by signaling this event, otherwise this parameter is ignored.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the specified key is closed, the event is signaled. This means that an application should not depend on the
;                  key being open after returning from a wait operation on the event.
; Related........:
; Link...........: @@MsdnLink@@ RegNotifyChangeKeyValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegNotifyChangeKeyValue($hKey, $iFilter, $fSubtree = 0, $fAsync = 0, $hEvent = 0)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegNotifyChangeKeyValue', 'ulong_ptr', $hKey, 'int', $fSubtree, 'dword', $iFilter, 'ptr', $hEvent, 'int', $fAsync)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegNotifyChangeKeyValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegOpenKey
; Description....: Opens the specified registry key.
; Syntax.........: _WinAPI_RegOpenKey ( $hKey [, $sSubKey [, $iAccess]] )
; Parameters.....: $hKey    - Handle to an open registry key. This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey()
;                             function, or it can be one of the following predefined keys.
;
;                             $HKEY_CLASSES_ROOT
;                             $HKEY_CURRENT_USER
;                             $HKEY_LOCAL_MACHINE
;                             $HKEY_USERS
;
;                  $sSubKey - The name of the registry subkey to be opened.
;                  $iAccess - A mask that specifies the desired access rights to the key. The function fails if the security
;                             descriptor of the key does not permit the requested access for the calling process. This parameter
;                             can be one or more of the $KEY_* constants.
; Return values..: Success  - Handle to the opened key.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Unlike the _WinAPI_RegCreateKey() function, the _WinAPI_RegOpenKey() function does not create the specified key
;                  if the key does not exist in the registry.
;
;                  If the key is not one of the predefined registry keys ($HKEY_*) you must call the _WinAPI_RegCloseKey()
;                  function after finished using the handle.
; Related........:
; Link...........: @@MsdnLink@@ RegOpenKeyEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegOpenKey($hKey, $sSubKey = '', $iAccess = 0xF003F)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegOpenKeyExW', 'ulong_ptr', $hKey, 'wstr', $sSubKey, 'dword', 0, 'dword', $iAccess, 'ulong_ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_RegOpenKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegQueryInfoKey
; Description....: Retrieves information about the specified registry key.
; Syntax.........: _WinAPI_RegQueryInfoKey ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key. The key must have been opened with the $KEY_QUERY_VALUE access right.
;                            This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                            be one of the following predefined keys.
;
;                            $HKEY_CLASSES_ROOT
;                            $HKEY_CURRENT_CONFIG
;                            $HKEY_CURRENT_USER
;                            $HKEY_LOCAL_MACHINE
;                            $HKEY_PERFORMANCE_DATA
;                            $HKEY_USERS
;
; Return values..: Success - The array containing the following parameters:
;
;                            [0] - The number of subkeys that are contained by the specified key.
;                            [1] - The size of the key's subkey with the longest name, in characters, not including the terminating null character.
;                            [2] - The number of values that are associated with the key.
;                            [3] - The size of the key's longest value name, in characters. The size does not include the terminating null character.
;                            [4] - The size of the longest data component among the key's values, in bytes.
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegQueryInfoKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegQueryInfoKey($hKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegQueryInfoKeyW', 'ulong_ptr', $hKey, 'ptr', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'dword*', 0, 'ptr', 0, 'dword*', 0, 'dword*', 0, 'dword*', 0, 'ptr', 0, 'ptr', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[5]

	$Result[0] = $Ret[5]
	$Result[1] = $Ret[6]
	$Result[2] = $Ret[8]
	$Result[3] = $Ret[9]
	$Result[4] = $Ret[10]

	Return $Result
EndFunc   ;==>_WinAPI_RegQueryInfoKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegQueryLastWriteTime
; Description....: Retrieves information about the last write time to the specified registry key.
; Syntax.........: _WinAPI_RegQueryLastWriteTime ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key. The key must have been opened with the $KEY_QUERY_VALUE access right.
;                            This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                            be one of the following predefined keys.
;
;                            $HKEY_CLASSES_ROOT
;                            $HKEY_CURRENT_CONFIG
;                            $HKEY_CURRENT_USER
;                            $HKEY_LOCAL_MACHINE
;                            $HKEY_PERFORMANCE_DATA
;                            $HKEY_USERS
;
; Return values..: Success - $tagFILETIME structure that contains the last write time.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegQueryInfoKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegQueryLastWriteTime($hKey)

	Local $tFILETIME = DllStructCreate($tagFILETIME)
	Local $Ret = DllCall('advapi32.dll', 'long', 'RegQueryInfoKeyW', 'ulong_ptr', $hKey, 'ptr', 0, 'ptr', 0, 'dword', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', DllStructGetPtr($tFILETIME))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tFILETIME
EndFunc   ;==>_WinAPI_RegQueryLastWriteTime

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegQueryMultipleValues
; Description....: Retrieves the type and data for a list of value names associated with an open registry key.
; Syntax.........: _WinAPI_RegQueryMultipleValues ( $hKey, ByRef $aValent, ByRef $tData [, $iStart [, $iEnd]] )
; Parameters.....: $hKey    - Handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right.
;                             This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                             be one of the following predefined keys.
;
;                                $HKEY_CLASSES_ROOT
;                                $HKEY_CURRENT_CONFIG
;                                $HKEY_CURRENT_USER
;                                $HKEY_LOCAL_MACHINE
;                                $HKEY_PERFORMANCE_DATA
;                                $HKEY_USERS
;
;                  $aValent - The 2D array ([valuename1, 0, 0, 0], [valuename2, 0, 0, 0], ... [valuenameN, 0, 0, 0]) that contains the
;                             name of a values to retrieve. On input, 1, 2, and 3 array elements are not used, but the size of the array
;                             should be [n][4], otherwise, the function fails. Also, this function fails if any of the specified
;                             values do not exist in the specified key.
;                  $tData   - The buffer to receive data. If the function succeeds, the buffer is a "byte[n]" structure that receives
;                             the data for each value. You should not change this structure until you finish to use the data returned
;                             by this function. After that, you can release the memory allocated by this structure.
;                  $iStart  - The index of array to start querying at.
;                  $iEnd    - The index of array to stop querying at.
; Return values..: Success  - The number of bytes copied to the buffer. The $aValent array will contain the following data:
;
;                             [n][0] - The name of the value (unchanged).
;                             [n][1] - The size of the data, in bytes.
;                             [n][2] - The pointer to the data in buffer pointed to by the $tData parameter.
;                             [n][3] - The type of data ($REG_*).
;
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: To prevent excessive serialization, the aggregate data returned by the function cannot exceed one megabyte.
; Related........:
; Link...........: @@MsdnLink@@ RegQueryMultipleValues
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegQueryMultipleValues($hKey, ByRef $aValent, ByRef $tData, $iStart = 0, $iEnd = -1)

	If UBound($aValent, 2) < 4 Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Ret, $Count, $Values, $tValent, $pValent, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aValent) - 1) Then
		$iEnd = UBound($aValent) - 1
	EndIf
	$Values = $iEnd - $iStart + 1
	For $i = 1 To $Values
		$Struct &= 'ptr;dword;dword_ptr;dword;'
	Next
	$tValent = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = 0
	For $i = $iStart To $iEnd
		$aValent[$i][2] = DllStructCreate('wchar[' & (StringLen($aValent[$i][0]) + 1) & ']')
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
		DllStructSetData($tValent, 4 * $Count + 1, DllStructGetPtr($aValent[$i][2]))
		DllStructSetData($aValent[$i][2], 1, $aValent[$i][0])
		$Count += 1
	Next
	$pValent = DllStructGetPtr($tValent)
	$Ret = DllCall('advapi32.dll', 'long', 'RegQueryMultipleValuesW', 'ulong_ptr', $hKey, 'ptr', $pValent, 'dword', $Values, 'ptr', 0, 'dword*', 0)
	If @error Then
		Return SetError(1, 0, 0)
	Else
		Switch $Ret[0]
			Case 234 ; ERROR_MORE_DATA

			Case Else
				Return SetError(1, $Ret[0], 0)
		EndSwitch
	EndIf
	$tData = DllStructCreate('byte[' & $Ret[5] & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Ret = DllCall('advapi32.dll', 'long', 'RegQueryMultipleValuesW', 'ulong_ptr', $hKey, 'ptr', $pValent, 'dword', $Values, 'ptr', DllStructGetPtr($tData), 'dword*', $Ret[5])
	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	$Count = 0
	For $i = $iStart To $iEnd
		For $j = 1 To 3
			$aValent[$i][$j] = DllStructGetData($tValent, 4 * $Count + $j + 1)
		Next
		$Count += 1
	Next
	Return $Ret[5]
EndFunc   ;==>_WinAPI_RegQueryMultipleValues

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegQueryReflectionKey
; Description....: Determines whether reflection has been disabled or enabled for the specified key.
; Syntax.........: _WinAPI_RegQueryReflectionKey ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key. This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey()
;                            function; it cannot specify a key on a remote computer. If the key is not on the reflection list,
;                            the function succeeds but has no effect.
; Return values..: Success - 1 - The reflection has been enabled.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: On WOW64, 32-bit applications view a registry tree that is separate from the registry tree that 64-bit applications
;                  view. Registry reflection copies specific registry keys and values between the two views.
; Related........:
; Link...........: @@MsdnLink@@ RegQueryReflectionKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegQueryReflectionKey($hKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegQueryReflectionKey', 'ulong_ptr', $hKey, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_RegQueryReflectionKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegQueryValue
; Description....: Retrieves the type and data for the specified value name associated with an open registry key.
; Syntax.........: _WinAPI_RegQueryValue ( $hKey, $sValueName, ByRef $tValueData, $iBytes )
; Parameters.....: $hKey       - Handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                                be one of the following predefined keys.
;
;                                $HKEY_CLASSES_ROOT
;                                $HKEY_CURRENT_CONFIG
;                                $HKEY_CURRENT_USER
;                                $HKEY_LOCAL_MACHINE
;                                $HKEY_PERFORMANCE_DATA
;                                $HKEY_PERFORMANCE_NLSTEXT
;                                $HKEY_PERFORMANCE_TEXT
;                                $HKEY_USERS
;
;                  $sValueName - The name of the registry value. If $sValueName is empty string, the function retrieves the type and
;                                data for the key's unnamed or default value, if any.
;                  $tValueData - The structure (buffer) that receives the value's data.
; Return values..: Success     - The size of the data copied to $tValueData, in bytes, @extended flag will contain the code indicating
;                                the type of data ($REG_*).
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, returned size includes any terminating null
;                  character or characters unless the data was stored without them.
;
;                  If the buffer specified by $tValueData parameter is not large enough to hold the data, the function returns
;                  ERROR_MORE_DATA (234) and returns the required buffer size. In this case, the contents of the buffer are
;                  undefined.
; Related........:
; Link...........: @@MsdnLink@@ RegQueryValueEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegQueryValue($hKey, $sValueName, ByRef $tValueData)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegQueryValueExW', 'ulong_ptr', $hKey, 'wstr', $sValueName, 'dword', 0, 'dword*', 0, 'ptr', DllStructGetPtr($tValueData), 'dword*', DllStructGetSize($tValueData))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return SetError(0, $Ret[4], $Ret[6])
EndFunc   ;==>_WinAPI_RegQueryValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegRestoreKey
; Description....: Reads the registry information in a specified file and copies it over the specified key.
; Syntax.........: _WinAPI_RegRestoreKey ( $hKey, $sFile )
; Parameters.....: $hKey   - Handle to an open registry key. This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey()
;                            function. It can also be one of the following predefined keys.
;
;                            $HKEY_CLASSES_ROOT
;                            $HKEY_CURRENT_CONFIG
;                            $HKEY_CURRENT_USER
;                            $HKEY_LOCAL_MACHINE
;                            $HKEY_USERS
;
;                  $sFile  - The name of the file with the registry information. This file is typically created by
;                            using the _WinAPI_RegSaveKey() function.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: There are two different registry hive file formats. Registry hives created on current operating systems typically
;                  cannot be loaded by earlier ones.
;
;                  The new information in the file specified by $sFile overwrites the contents of the key specified by the $hKey
;                  parameter, except for the key name.
;
;                  If any subkeys of the hKey parameter are open, _WinAPI_RegRestoreKey() fails.
; Related........:
; Link...........: @@MsdnLink@@ RegRestoreKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegRestoreKey($hKey, $sFile)

	Local $hToken, $Error = 1, $Ret = 0, $aAdjust
	Local $Privileges[2] = [$SE_BACKUP_NAME, $SE_RESTORE_NAME]

	$hToken = _WinAPI_OpenProcessToken(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	_WinAPI_AdjustTokenPrivileges($hToken, $Privileges, 1, $aAdjust)
	If Not (@error Or @extended) Then
		$Ret = DllCall('advapi32.dll', 'long', 'RegRestoreKeyW', 'ulong_ptr', $hKey, 'wstr', $sFile, 'dword', 8)
		If @error Then
			$Ret = 0
		Else
			$Ret = $Ret[0]
			If Not $Ret Then
				$Error = 0
			EndIf
		EndIf
	EndIf
	_WinAPI_AdjustTokenPrivileges($hToken, $Privileges, 2, $aAdjust)
	_WinAPI_CloseHandle($hToken)
	Return SetError($Error, $Ret, Number(Not $Error))
EndFunc   ;==>_WinAPI_RegRestoreKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegSaveKey
; Description....: Saves the specified key and all of its subkeys and values to a new file, in the standard format.
; Syntax.........: _WinAPI_RegSaveKey ( $hKey, $sFile [, $tSecurity] )
; Parameters.....: $hKey      - Handle to an open registry key.
;                  $sFile     - The name of the file in which the specified key and subkeys are to be saved. If the file already
;                               exists, the function replaces it. The new file has the archive attribute.
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that specifies a security descriptor for the new file. If this
;                               parameter is 0, the file gets a default security descriptor.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: You can use the file created by this function in subsequent calls to the _WinAPI_RegRestoreKey() functions.
; Related........:
; Link...........: @@MsdnLink@@ RegSaveKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegSaveKey($hKey, $sFile, $tSecurity = 0)

	Local $hToken, $Error = 1, $Ret = 0, $aAdjust

	$hToken = _WinAPI_OpenProcessToken(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	_WinAPI_AdjustTokenPrivileges($hToken, $SE_BACKUP_NAME, 1, $aAdjust)
	If Not (@error Or @extended) Then
		FileDelete($sFile)
		$Ret = DllCall('advapi32.dll', 'long', 'RegSaveKeyW', 'ulong_ptr', $hKey, 'wstr', $sFile, 'ptr', DllStructGetPtr($tSecurity))
		If @error Then
			$Ret = 0
		Else
			$Ret = $Ret[0]
			If Not $Ret Then
				$Error = 0
			EndIf
		EndIf
	EndIf
	_WinAPI_AdjustTokenPrivileges($hToken, $SE_BACKUP_NAME, 2, $aAdjust)
	_WinAPI_CloseHandle($hToken)
	Return SetError($Error, $Ret, Number(Not $Error))
EndFunc   ;==>_WinAPI_RegSaveKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegSetValue
; Description....: Sets the data and type of a specified value under a registry key.
; Syntax.........: _WinAPI_RegSetValue ($hKey, $sValueName, $iType, ByRef $tValueData, $iBytes)
; Parameters.....: $hKey       - Handle to an open registry key. The key must have been opened with the $KEY_SET_VALUE access right.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                                be one of the following predefined keys.
;
;                                $HKEY_CLASSES_ROOT
;                                $HKEY_CURRENT_CONFIG
;                                $HKEY_CURRENT_USER
;                                $HKEY_LOCAL_MACHINE
;                                $HKEY_PERFORMANCE_DATA
;                                $HKEY_USERS
;
;                  $sValueName - The name of the value to be set. If a value with this name is not already present in the key,
;                                the function adds it to the key. If $sValueName is empty string, the function sets the type and
;                                data for the key's unnamed or default value.
;                  $iType      - The type of data. This parameter can be one of the following values.
;
;                                $REG_BINARY
;                                $REG_DWORD
;                                $REG_DWORD_BIG_ENDIAN
;                                $REG_DWORD_LITTLE_ENDIAN
;                                $REG_EXPAND_SZ
;                                $REG_LINK
;                                $REG_MULTI_SZ
;                                $REG_NONE
;                                $REG_QWORD
;                                $REG_QWORD_LITTLE_ENDIAN
;                                $REG_SZ
;
;                  $tValueData - The structure (buffer) that contains the data to be stored. For string-based types, such as REG_SZ,
;                                the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated
;                                with two null characters. A backslash must be preceded by another backslash as an escape character.
;                                For example, specify "C:\\mydir\\myfile" to store the string "C:\mydir\myfile".
;                  $iBytes     - The size of the data, in bytes. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type,
;                                this size includes any terminating null character or characters unless the data was stored
;                                without them.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegSetValueEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegSetValue($hKey, $sValueName, $iType, ByRef $tValueData, $iBytes)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegSetValueExW', 'ulong_ptr', $hKey, 'wstr', $sValueName, 'dword', 0, 'dword', $iType, 'ptr', DllStructGetPtr($tValueData), 'dword', $iBytes)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegSetValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReleaseMutex
; Description....: Releases ownership of the specified mutex object.
; Syntax.........: _WinAPI_ReleaseMutex ( $hMutex )
; Parameters.....: $hMutex - Handle to the mutex object. The _WinAPI_CreateMutex() or _WinAPI_OpenMutex() function returns this handle.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_ReleaseMutex() function fails if the calling thread does not own the mutex object.
; Related........:
; Link...........: @@MsdnLink@@ ReleaseMutex
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReleaseMutex($hMutex)

	Local $Ret = DllCall('kernel32.dll', 'int', 'ReleaseMutex', 'ptr', $hMutex)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ReleaseMutex

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReleaseSemaphore
; Description....: Increases the count of the specified semaphore object by a specified amount.
; Syntax.........: _WinAPI_ReleaseSemaphore ( $hSemaphore [, $iIncrease] )
; Parameters.....: $hSemaphore - Handle to the semaphore object. The _WinAPI_CreateSemaphore() or _WinAPI_OpenSemaphore() function
;                                returns this handle.
;                  $iIncrease  - The amount by which the semaphore object's current count is to be increased. The value must be greater
;                                than zero. If the specified amount would cause the semaphore's count to exceed the maximum count that
;                                was specified when the semaphore was created, the count is not changed and the function returns 0.
; Return values..: Success     - The previous count for the semaphore.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The state of a semaphore object is signaled when its count is greater than zero and nonsignaled when its count
;                  is equal to zero. The process that calls the _WinAPI_CreateSemaphore() function specifies the semaphore's initial
;                  count. Each time a waiting process is released because of the semaphore's signaled state, the count of the
;                  semaphore is decreased by one.
; Related........:
; Link...........: @@MsdnLink@@ ReleaseSemaphore
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReleaseSemaphore($hSemaphore, $iIncrease = 1)

	Local $Ret = DllCall('kernel32.dll', 'int', 'ReleaseSemaphore', 'ptr', $hSemaphore, 'int', $iIncrease, 'int*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_ReleaseSemaphore

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReleaseStream
; Description....: Releases a stream object.
; Syntax.........: _WinAPI_ReleaseStream ( $pStream )
; Parameters.....: $pStream - Pointer to the stream object previously created by a call to the _WinAPI_CreateStreamOnHGlobal() function.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Prog@ndy
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DispCallFunc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReleaseStream($pStream)

	Local $Ret = DllCall('oleaut32.dll', 'uint', 'DispCallFunc', 'ptr', $pStream, 'uint', 8 * (1 + @AutoItX64), 'uint', 4, 'uint', 23, 'uint', 0, 'ptr', 0, 'ptr', 0, 'str', '')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ReleaseStream

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RemoveClipboardFormatListener
; Description....: Removes the given window from the system-maintained clipboard format listener list.
; Syntax.........: _WinAPI_RemoveClipboardFormatListener ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to be removed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RemoveClipboardFormatListener
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RemoveClipboardFormatListener($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'RemoveClipboardFormatListener', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RemoveClipboardFormatListener

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RemoveFontMemResourceEx
; Description....: Removes the fonts added from a memory image.
; Syntax.........: _WinAPI_RemoveFontMemResourceEx ( $hFont )
; Parameters.....: $hFont  - Handle to the font-resource. This handle is returned by the _WinAPI_AddFontMemResourceEx() function.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RemoveFontMemResourceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RemoveFontMemResourceEx($hFont)

	Local $Ret = DllCall('gdi32.dll', 'int', 'RemoveFontMemResourceEx', 'ptr', $hFont)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RemoveFontMemResourceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RemoveFontResourceEx
; Description....: Removes the fonts in the specified file from the system font table.
; Syntax.........: _WinAPI_RemoveFontResourceEx ( $sFont [, $iFlag [, $fNotify]] )
; Parameters.....: $sFont   - String that names a font resource file. To remove a font whose information comes from several resource
;                             files, they must be separated by a "|". For example, abcxxxxx.pfm|abcxxxxx.pfb.
;                  $iFlag   - The characteristics of the font to be removed from the system. In order for the font to be removed, the flags
;                             used must be the same as when the font was added with the _WinAPI_AddFontResourceEx() function.
;                  $fNotify - Specifies whether sends a WM_FONTCHANGE message, valid values:
;                  |TRUE    - Send the WM_FONTCHANGE message to all top-level windows after changing the pool of font resources.
;                  |FALSE   - Don`t send. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RemoveFontResourceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RemoveFontResourceEx($sFont, $iFlag = 0, $fNotify = 0)

	Local $Ret = DllCall('gdi32.dll', 'int', 'RemoveFontResourceExW', 'wstr', $sFont, 'dword', $iFlag, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	If $fNotify Then
		DllCall('user32.dll', 'int', 'SendMessage', 'hwnd', 0xFFFF, 'uint', 0x001D, 'int', 0, 'int', 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RemoveFontResourceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RemoveWindowSubclass
; Description....: Removes a subclass callback from a window.
; Syntax.........: _WinAPI_RemoveWindowSubclass ( $hWnd, $pSubclassProc, $ID )
; Parameters.....: $hWnd          - Handle of the window being subclassed.
;                  $pSubclassProc - A pointer to a window procedure. This pointer and the subclass ID uniquely identify this subclass callback.
;
;                                   (See MSDN for more information)
;
;                  $ID            - The subclass ID.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RemoveWindowSubclass
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RemoveWindowSubclass($hWnd, $pSubclassProc, $ID)

	Local $Ret = DllCall('comctl32.dll', 'int', 'RemoveWindowSubclass', 'hwnd', $hWnd, 'ptr', $pSubclassProc, 'uint_ptr', $ID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RemoveWindowSubclass

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReOpenFile
; Description....: Reopens the specified file system object with different access rights, sharing mode, and flags.
; Syntax.........: _WinAPI_ReOpenFile ( $hFile, $iAccess, $iShare [, $iFlags] )
; Parameters.....: $sFile   - Handle to the object to be reopened. The object must have been created by the _WinAPI_CreateFile() function.
;                  $iAccess - The required access to the object. If this parameter is 0, the application can query device attributes
;                             without accessing the device.
;
;                             $GENERIC_READ
;                             $GENERIC_WRITE
;
;                             (See MSDN for more information)
;
;                  $iShare  - The sharing mode of the object. If this parameter is 0, the object cannot be shared and cannot be
;                             opened again until the handle is closed.
;
;                             $FILE_SHARE_READ
;                             $FILE_SHARE_WRITE
;                             $FILE_SHARE_DELETE
;
;                  $iFlags  - The file or device attributes and flags. This parameter can be one or more of the following values.
;
;                             $FILE_FLAG_BACKUP_SEMANTICS
;                             $FILE_FLAG_DELETE_ON_CLOSE
;                             $FILE_FLAG_NO_BUFFERING
;                             $FILE_FLAG_OPEN_NO_RECALL
;                             $FILE_FLAG_OPEN_REPARSE_POINT
;                             $FILE_FLAG_OVERLAPPED
;                             $FILE_FLAG_POSIX_SEMANTICS
;                             $FILE_FLAG_RANDOM_ACCESS
;                             $FILE_FLAG_SEQUENTIAL_SCAN
;                             $FILE_FLAG_WRITE_THROUGH
;
;                             $SECURITY_ANONYMOUS
;                             $SECURITY_CONTEXT_TRACKING
;                             $SECURITY_DELEGATION
;                             $SECURITY_EFFECTIVE_ONLY
;                             $SECURITY_IDENTIFICATION
;                             $SECURITY_IMPERSONATION
;
; Return values..: Success  - Handle to the specified file.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The $iFlags parameter cannot contain any of the file attribute flags ($FILE_ATTRIBUTE_*). These can only be
;                  specified when the file is created.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ ReOpenFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReOpenFile($hFile, $iAccess, $iShare, $iFlags = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'ReOpenFile', 'ptr', $hFile, 'dword', $iAccess, 'dword', $iShare, 'dword', $iFlags)

	If (@error) Or ($Ret[0] = Ptr(-1)) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ReOpenFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReplaceFile
; Description....: Replaces one file with another file, and creates a backup copy of the original file.
; Syntax.........: _WinAPI_ReplaceFile ( $sReplacedFile, $sReplacementFile [, $sBackupFile [, $iFlags]] )
; Parameters.....: $sReplacedFile    - The name of the file to be replaced.
;                  $sReplacementFile - The name of the file that will replace the $sReplacedFile file.
;                  $sBackupFile      - The name of the file that will serve as a backup copy of the $sReplacedFile file. If this
;                                      parameter is empty string, no backup file is created.
;                  $iFlags           - The replacement options. This parameter can be one or more of the following values.
;
;                                      $REPLACEFILE_WRITE_THROUGH
;                                      $REPLACEFILE_IGNORE_MERGE_ERRORS
;                                      $REPLACEFILE_IGNORE_ACL_ERRORS
;
; Return values..: Success           - 1.
;                  Failure           - 0 and sets the @error flag to non-zero (see remarks).
; Author.........: Yashied
; Modified.......:
; Remarks........: If this function fails, call _WinAPI_GetLastError() function to get extended error information. The following
;                  are possible error codes for this function.
;
;                  ERROR_UNABLE_TO_MOVE_REPLACEMENT (1176)
;                  The replacement file could not be renamed. If $sBackupFile was specified, the replaced and replacement files
;                  retain their original file names. Otherwise, the replaced file no longer exists and the replacement file exists
;                  under its original name.
;
;                  ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 (1177)
;                  The replacement file could not be moved. The replacement file still exists under its original name; however,
;                  it has inherited the file streams and attributes from the file it is replacing. The file to be replaced still
;                  exists with the name specified by $sReplacedFile.
;
;                  ERROR_UNABLE_TO_REMOVE_REPLACED (1175)
;                  The replaced file could not be deleted. The replaced and replacement files retain their original file names.
;
;                  If any other error is returned, such as ERROR_INVALID_PARAMETER, the replaced and replacement files will retain
;                  their original file names. In this scenario, a backup file does not exist and it is not guaranteed that the
;                  replacement file will have inherited all of the attributes and streams of the replaced file.
;
; Related........:
; Link...........: @@MsdnLink@@ ReplaceFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReplaceFile($sReplacedFile, $sReplacementFile, $sBackupFile = '', $iFlags = 0)

	Local $TypeOfBackupFile = 'wstr'

	If Not StringStripWS($sBackupFile, 3) Then
		$TypeOfBackupFile = 'ptr'
		$sBackupFile = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'ReplaceFileW', 'wstr', $sReplacedFile, 'wstr', $sReplacementFile, $TypeOfBackupFile, $sBackupFile, 'dword', $iFlags, 'ptr', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ReplaceFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReplaceTextDlg
; Description....: Creates a system-defined modeless dialog box that lets the user specify a string to search for and a replacement string.
; Syntax.........: _WinAPI_ReplaceTextDlg ( $hOwner [, $sFindWhat [, $sReplaceWith [, $iFlags [, $pFindProc [, $lParam]]]]] )
; Parameters.....: $hOwner    -    A handle to the window that owns the dialog box. The window procedure of the specified window
;                                  receives FINDMSGSTRING messages from the dialog box. This parameter can be any valid window handle,
;                                  but it must not be 0.
;                  $sFindWhat    - The search string that is displayed when you initialize the dialog box.
;                  $sReplaceWith - The replacement string that is displayed when you initialize the dialog box.
;                  $iFlags       - A set of bit flags that used to initialize the dialog box. The dialog box sets these flags when it
;                                  sends the FINDMSGSTRING registered message to indicate the user's input. This parameter can be one
;                                  or more of the following values.
;
;                                  $FR_DIALOGTERM
;                                  $FR_DOWN
;                                  $FR_ENABLEHOOK
;                                  $FR_ENABLETEMPLATE
;                                  $FR_ENABLETEMPLATEHANDLE
;                                  $FR_FINDNEXT
;                                  $FR_HIDEUPDOWN
;                                  $FR_HIDEMATCHCASE
;                                  $FR_HIDEWHOLEWORD
;                                  $FR_MATCHCASE
;                                  $FR_NOMATCHCASE
;                                  $FR_NOUPDOWN
;                                  $FR_NOWHOLEWORD
;                                  $FR_REPLACE
;                                  $FR_REPLACEALL
;                                  $FR_SHOWHELP
;                                  $FR_WHOLEWORD
;
;                  $pReplaceProc - Pointer to an hook procedure that can process messages intended for the dialog box. This parameter is
;                                  ignored unless the $FR_ENABLEHOOK flag is not set.
;
;                                  (See MSDN for more information)
;
;                  $lParam       - Application-defined data that the system passes to the hook procedure.
; Return values..: Success       - The window handle to the dialog box.
;                  Failure       - 0 and sets the @error flag to non-zero, @extended flag may contain the dialog box error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_ReplaceTextDlg() does not perform a text replacement operation. Instead, the dialog box sends
;                  FINDMSGSTRING registered messages to the window procedure of the owner window of the dialog box.
;
;                  Before calling _WinAPI_ReplaceTextDlg(), you must call the _WinAPI_RegisterWindowMessage() function to get the
;                  identifier for the FINDMSGSTRING message. The dialog box procedure uses this identifier to send messages when the
;                  user clicks the "Find Next", "Replace", or "Replace All" buttons, or when the dialog box is closing. The "lParam"
;                  parameter of the FINDMSGSTRING message contains a pointer to a $tagFINDREPLACE structure. The "Flags" member
;                  of this structure indicates the event that caused the message. Other members of the structure indicate the
;                  user's input.
;
;                  The _WinAPI_ReplaceTextDlg() uses an internal buffer to hold the string that the user typed in the "Find What" and
;                  "Replace With" edit controls. You can increase the size of this buffer by using the _WinAPI_SetFRBuffer() function.
;                  In addition to free the memory allocated for the internal buffer, you must call the _WinAPI_FlushFRBuffer() in
;                  response to the FINDMSGSTRING message with $FR_DIALOGTERM flag set.
; Related........:
; Link...........: @@MsdnLink@@ ReplaceText
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReplaceTextDlg($hOwner, $sFindWhat = '', $sReplaceWith = '', $iFlags = 0, $pReplaceProc = 0, $lParam = 0)

	If (StringLen($sFindWhat) + 1 > $__Buff) Or (StringLen($sReplaceWith) + 1 > $__Buff) Then
		Return SetError(1, 0x4001, 0)
	EndIf

	$__Find = DllStructCreate('wchar[' & $__Buff & ']')
	$__Replace = DllStructCreate('wchar[' & $__Buff & ']')
	$__FR = DllStructCreate($tagFINDREPLACE)
	DllStructSetData($__Find, 1, $sFindWhat)
	DllStructSetData($__Replace, 1, $sReplaceWith)
	DllStructSetData($__FR, 'Size', DllStructGetSize($__FR))
	DllStructSetData($__FR, 'hOwner', $hOwner)
	DllStructSetData($__FR, 'hInstance', 0)
	DllStructSetData($__FR, 'Flags', $iFlags)
	DllStructSetData($__FR, 'FindWhat', DllStructGetPtr($__Find))
	DllStructSetData($__FR, 'ReplaceWith', DllStructGetPtr($__Replace))
	DllStructSetData($__FR, 'FindWhatLen', 2 * $__Buff)
	DllStructSetData($__FR, 'ReplaceWithLen', 2 * $__Buff)
	DllStructSetData($__FR, 'lParam', $lParam)
	DllStructSetData($__FR, 'Hook', $pReplaceProc)
	DllStructSetData($__FR, 'TemplateName', 0)

	Local $Ret = DllCall('comdlg32.dll', 'hwnd', 'ReplaceTextW', 'ptr', DllStructGetPtr($__FR))

	If (@error) Or (Not $Ret[0]) Then
		$__Find = 0
		$__Replace = 0
		$__FR = 0
		If @error Then
			Return SetError(1, 0, 0)
		Else
			Return SetError(1, _WinAPI_CommDlgExtendedErrorEx(), 0)
		EndIf
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ReplaceTextDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ResetEvent
; Description....: Sets the specified event object to the nonsignaled state.
; Syntax.........: _WinAPI_ResetEvent ( $hEvent )
; Parameters.....: $hEvent - Handle to the event object. The _WinAPI_CreateEvent() function returns this handle.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The state of an event object remains nonsignaled until it is explicitly set to signaled by the _WinAPI_SetEvent()
;                  function. This nonsignaled state blocks the execution of any threads that have specified the event object in a call to
;                  one of the _WinAPI_Wait... functions.
;
;                  The _WinAPI_ResetEvent() function is used primarily for manual-reset event objects, which must be set explicitly to the
;                  nonsignaled state. Auto-reset event objects automatically change from signaled to nonsignaled after a single waiting
;                  thread is released.
; Related........:
; Link...........: @@MsdnLink@@ ResetEvent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ResetEvent($hEvent)

	Local $Ret = DllCall('kernel32.dll', 'int', 'ResetEvent', 'ptr', $hEvent)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ResetEvent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ResizeBitmap
; Description....: Changes the size of a bitmap to the specified dimensions.
; Syntax.........: _WinAPI_ResizeBitmap ( $hBitmap, $iWidth, $iHeight [, $iMode] )
; Parameters.....: $hBitmap - Handle to the bitmap to be resized.
;                  $iWidth  - The width, in pixels, in which the bitmap must fit.
;                  $iHeight - The height, in pixels, in which the bitmap must fit.
;                  $iMode   - The resizing mode. This parameter can be one of the following values (same as for
;                             _WinAPI_SetStretchBltMode()).
;
;                             $BLACKONWHITE
;                             $COLORONCOLOR
;                             $HALFTONE
;                             $WHITEONBLACK
;                             $STRETCH_ANDSCANS
;                             $STRETCH_DELETESCANS
;                             $STRETCH_HALFTONE
;                             $STRETCH_ORSCANS
;
; Return values..: Success  - Handle to the new bitmap that was created.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not support bitmaps with Alpha channel, use _WinAPI_AlphaBlend() to work with this bitmaps.
;
;                  When you are finished using the bitmap, destroy it using the _WinAPI_DeleteObject() function. This function
;                  does not destroy the original bitmap, you must to destroy it.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ResizeBitmap($hBitmap, $iWidth, $iHeight, $iMode = 3)

	Local $Ret, $tObj, $hBmp, $hDC, $hDestDC, $hDestSv, $hSrcDC, $hSrcSv

	$tObj = DllStructCreate($tagBITMAP)
	$Ret = DllCall('gdi32.dll', 'int', 'GetObject', 'int', $hBitmap, 'int', DllStructGetSize($tObj), 'ptr', DllStructGetPtr($tObj))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$Ret = DllCall('user32.dll', 'hwnd', 'GetDC', 'hwnd', 0)
	$hDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleDC', 'hwnd', $hDC)
	$hDestDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleBitmap', 'hwnd', $hDC, 'int', $iWidth, 'int', $iHeight)
	$hBmp = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'SelectObject', 'hwnd', $hDestDC, 'ptr', $hBmp)
	$hDestSv = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleDC', 'hwnd', $hDC)
	$hSrcDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'SelectObject', 'hwnd', $hSrcDC, 'ptr', $hBitmap)
	$hSrcSv = $Ret[0]
	_WinAPI_SetStretchBltMode($hDestDC, $iMode)
	$Ret = _WinAPI_StretchBlt($hDestDC, 0, 0, $iWidth, $iHeight, $hSrcDC, 0, 0, DllStructGetData($tObj, 'bmWidth'), DllStructGetData($tObj, 'bmHeight'), 0x00CC0020)
	DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', 0, 'hwnd', $hDC)
	DllCall('gdi32.dll', 'ptr', 'SelectObject', 'hwnd', $hDestDC, 'ptr', $hDestSv)
	DllCall('gdi32.dll', 'ptr', 'SelectObject', 'hwnd', $hSrcDC, 'ptr', $hSrcSv)
	DllCall('gdi32.dll', 'int', 'DeleteDC', 'hwnd', $hDestDC)
	DllCall('gdi32.dll', 'int', 'DeleteDC', 'hwnd', $hSrcDC)
	If Not $Ret Then
		Return SetError(1, 0, 0)
	EndIf
	Return $hBmp
EndFunc   ;==>_WinAPI_ResizeBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RestartDlg
; Description....: Displays a dialog box that prompts the user to restart Microsoft Windows.
; Syntax.........: _WinAPI_RestartDlg ( [$sText [, $iFlags [, $hParent]]] )
; Parameters.....: $sText   - The text that displays in the dialog box which prompts the user.
;                  $iFlags  - The flags that specify the type of shutdown.
;
;                             This parameter must include one of the following values.
;
;                             $EWX_LOGOFF
;                             $EWX_POWEROFF
;                             $EWX_REBOOT
;                             $EWX_SHUTDOWN
;
;                             This parameter can optionally include the following values.
;
;                             $EWX_FORCE
;                             $EWX_FORCEIFHUNG
;
;                  $hParent - Handle to the parent window.
; Return values..: Success  - The identifier of the button that was pressed to close the dialog box.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RestartDialog
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RestartDlg($sText = '', $iFlags = 2, $hParent = 0)

	Local $Ret = DllCall('shell32.dll', 'int', 'RestartDialog', 'hwnd', $hParent, 'wstr', $sText, 'int', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_RestartDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RestoreDC
; Description....: Restores a device context (DC) to the specified state.
; Syntax.........: _WinAPI_RestoreDC ( $hDC, $ID )
; Parameters.....: $hDC    - Handle to the DC.
;                  $ID     - The saved state to be restored. If this parameter is positive, $DC represents a specific instance of the
;                            state to be restored. If this parameter is negative, $DC represents an instance relative to the current
;                            state. For example, (-1) restores the most recently saved state.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RestoreDC
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RestoreDC($hDC, $ID)

	Local $Ret = DllCall('gdi32.dll', 'int', 'RestoreDC', 'hwnd', $hDC, 'int', $ID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RestoreDC

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ResumeProcess
; Description....: resunme a process that is suspended
; Syntax.........: _WinAPI_ResumeProcess ( $hProcess )
; Parameters.....: $process - process name.
; Return values..: Success - 1
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ResumeProcess
; Example........: Yes
; ===============================================================================================================================
Func _WinAPI_ResumeProcess($hProcess)
	Local $Handle = DllCall("kernel32.dll", 'int', 'OpenProcess', 'int', 0x1f0fff, 'int', False, 'int', $hProcess)
	Local $Ret = DllCall("ntdll.dll", "int", "NtResumeProcess", "int", $Handle[0])
	DllCall('kernel32.dll', 'ptr', 'CloseHandle', 'ptr', $Handle)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
EndFunc   ;==>_WinAPI_ResumeProcess

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ResumeThread
; Description....: resunme a process that is suspended
; Syntax.........: _WinAPI_ResumeThread ( $hThread )
; Parameters.....: $process - Thread handle.
; Return values..: Success - 1
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ResumeThread
; Example........: Yes
; ===============================================================================================================================
Func _WinAPI_ResumeThread($hThread)

	Local $Ret = DllCall('kernel32.dll', 'dword', 'ResumeThread', 'ptr', $hThread)

	If (@error) Or (_WinAPI_DWordToInt($Ret[0]) = -1) Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ResumeThread

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RGB
; Description....: Creates a RGB color value based on red, green, and blue components.
; Syntax.........: _WinAPI_RGB ( $iRed, $iGreen, $iBlue )
; Parameters.....: $iRed   - The intensity of the red color.
;                  $iGreen - The intensity of the green color.
;                  $iBlue  - The intensity of the blue color.
; Return values..: The resultant RGB color.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RGB($iRed, $iGreen, $iBlue)
	Return __RGB(BitOR(BitShift($iBlue, -16), BitShift($iGreen, -8), $iRed))
EndFunc   ;==>_WinAPI_RGB

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RotatePoints
; Description....: Rotates a points from the array by the specified angle.
; Syntax.........: _WinAPI_RotatePoints ( ByRef $aPoint, $iXC, $iYC, $iAngle [, $iStart [, $iEnd]] )
; Parameters.....: $aPoint - The 2D array ([x1, y1, ...], [x2, y2, ...], ... [xN, yN, ...]). Every first two elements from this
;                            array specifies a point to be rotate. Other array elements (if any) do not change.
;                  $iXC    - X-coordinates of the point on which there is a rotation, in logical units.
;                  $iYC    - Y-coordinates of the point on which there is a rotation, in logical units.
;                  $iAngle - The angle to rotate, in degree.
;                  $iStart - The index of array to start rotating at.
;                  $iEnd   - The index of array to stop rotating at.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RotatePoints(ByRef $aPoint, $iXC, $iYC, $iAngle, $iStart = 0, $iEnd = -1)
	If UBound($aPoint, 2) < 2 Then
		Return SetError(2, 0, 0)
	EndIf
	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	If $iStart > $iEnd Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Cos = Cos(ATan(1) / 45 * $iAngle)
	Local $Sin = Sin(ATan(1) / 45 * $iAngle)
	Local $Xn, $Yn

	For $i = $iStart To $iEnd
		$Xn = $aPoint[$i][0] - $iXC
		$Yn = $aPoint[$i][1] - $iYC
		$aPoint[$i][0] = $iXC + Round($Xn * $Cos - $Yn * $Sin)
		$aPoint[$i][1] = $iYC + Round($Xn * $Sin + $Yn * $Cos)
	Next
	Return 1
EndFunc   ;==>_WinAPI_RotatePoints

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RoundRect
; Description....: Draws a rectangle with rounded corners.
; Syntax.........: _WinAPI_RoundRect ( $hDC, $tRECT, $iWidth, $iHeight )
; Parameters.....: $hDC     - Handle to the device context.
;                  $tRECT   - $tagRECT structure that contains the logical coordinates of the rectangle.
;                  $iWidth  - The width, in logical coordinates, of the ellipse used to draw the rounded corners.
;                  $iHeight - The height, in logical coordinates, of the ellipse used to draw the rounded corners.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The rectangle is outlined by using the current pen and filled by using the current brush.
; Related........:
; Link...........: @@MsdnLink@@ RoundRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RoundRect($hDC, $tRECT, $iWidth, $iHeight)

	Local $Ret = DllCall('gdi32.dll', 'int', 'RoundRect', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4), 'int', $iWidth, 'int', $iHeight)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RoundRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SaveDC
; Description....: Saves the current state of the specified device context (DC) by copying data describing selected objects and
;                  graphic modes to a context stack.
; Syntax.........: _WinAPI_SaveDC ( $hDC )
; Parameters.....: $hDC    - Handle to the DC whose state is to be saved.
; Return values..: Success - The value identifies the saved state.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SaveDC
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SaveDC($hDC)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'SaveDC', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SaveDC

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SaveHBITMAPToFile
; Description....: Saves a specified bitmap to the specified bitmap (.bmp) file.
; Syntax.........: _WinAPI_SaveHBITMAPToFile ( $sFile, $hBitmap [, $iXPelsPerMeter [, $iYPelsPerMeter]] )
; Parameters.....: $sFile          - The name of the .bmp file in which to save the bitmap.
;                  $hBitmap        - Handle to the bitmap to be save.
;                  $iXPelsPerMeter - The horizontal resolution, in pixels-per-meter.
;                  $iYPelsPerMeter - The vertical resolution, in pixels-per-meter.
; Return values..: Success         - 1.
;                  Failure         - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function saves the specified bitmap unchanged, except when the bitmap uses 32 bits-per-pixel color depth.
;                  In this situation, if the bitmap contains an alpha channel, it will be saved as 32 bits-per-pixel image, and
;                  as 24 bits-per-pixel image otherwise.
;
;                  The horizontal and vertical resolutions pointed by the $iXPelsPerMeter and $iYPelsPerMeter parameters has not
;                  affects the image quality, but application can use this value to select a bitmap from a resource group that best
;                  matches the characteristics of the current device. If the resolutions is not specified, the function uses the
;                  current screen resolutions, usually 2834 pixels-per-meter which corresponds to 72 pixels-per-inch (dpi).
;
;                  If the source bitmap is compressed, or use a color masks, the function fails.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SaveHBITMAPToFile($sFile, $hBitmap, $iXPelsPerMeter = Default, $iYPelsPerMeter = Default)

	Local $Data[4][2], $hDC, $hSv, $Bytes, $hFile, $hSource = 0, $tTable = 0, $Result = 0
	Local $tBMP = DllStructCreate('align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset')
	Local $tDIB = DllStructCreate($tagDIBSECTION)

	While $hBitmap
		If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), DllStructGetPtr($tDIB))) Or (DllStructGetData($tDIB, 'biCompression')) Then
			$hBitmap = 0
		Else
			Switch DllStructGetData($tDIB, 'bmBitsPixel')
				Case 32
					If Not _WinAPI_IsAlphaBitmap($hBitmap) Then
						If Not $hSource Then
							$hSource = _WinAPI_CreateDIB(DllStructGetData($tDIB, 'bmWidth'), DllStructGetData($tDIB, 'bmHeight'), 24)
							If @error Then
								$hBitmap = 0
							EndIf
							$hDC = _WinAPI_CreateCompatibleDC(0)
							$hSv = _WinAPI_SelectObject($hDC, $hSource)
							If _WinAPI_DrawBitmap($hDC, 0, 0, $hBitmap) Then
								$hBitmap = $hSource
							Else
								$hBitmap = 0
							EndIf
							_WinAPI_SelectObject($hDC, $hSv)
							_WinAPI_DeleteDC($hDC)
						Else
							$hBitmap = 0
						EndIf
						ContinueLoop
					EndIf
				Case Else

			EndSwitch
			If (Not DllStructGetData($tDIB, 'bmBits')) Or (Not DllStructGetData($tDIB, 'biSizeImage')) Then
				If Not $hSource Then
					$hBitmap = _WinAPI_CopyBitmap($hBitmap)
					$hSource = $hBitmap
				Else
					$hBitmap = 0
				EndIf
			Else
				ExitLoop
			EndIf
		EndIf
	WEnd
	Do
		If Not $hBitmap Then
			ExitLoop
		EndIf
		$Data[0][0] = DllStructGetPtr($tBMP)
		$Data[0][1] = DllStructGetSize($tBMP)
		$Data[1][0] = DllStructGetPtr($tDIB, 'biSize')
		$Data[1][1] = 40
		$Data[2][1] = DllStructGetData($tDIB, 'biClrUsed') * 4
		If $Data[2][1] Then
			$tTable = _WinAPI_GetDIBColorTable($hBitmap)
			If (@error) Or (@extended <> $Data[2][1] / 4) Then
				ExitLoop
			EndIf
		EndIf
		$Data[2][0] = DllStructGetPtr($tTable)
		$Data[3][0] = DllStructGetData($tDIB, 'bmBits')
		$Data[3][1] = DllStructGetData($tDIB, 'biSizeImage')
		DllStructSetData($tBMP, 'bfType', 0x4D42)
		DllStructSetData($tBMP, 'bfSize', $Data[0][1] + $Data[1][1] + $Data[2][1] + $Data[3][1])
		DllStructSetData($tBMP, 'bfReserved1', 0)
		DllStructSetData($tBMP, 'bfReserved2', 0)
		DllStructSetData($tBMP, 'bfOffset', $Data[0][1] + $Data[1][1] + $Data[2][1])
		$hDC = _WinAPI_GetDC(0)
		If IsKeyword($iXPelsPerMeter) Then
			If Not DllStructGetData($tDIB, 'biXPelsPerMeter') Then
				DllStructSetData($tDIB, 'biXPelsPerMeter', _WinAPI_GetDeviceCaps($hDC,  8) / _WinAPI_GetDeviceCaps($hDC, 4) * 1000)
			EndIf
		Else
			DllStructSetData($tDIB, 'biXPelsPerMeter', $iXPelsPerMeter)
		EndIf
		If IsKeyword($iYPelsPerMeter) Then
			If Not DllStructGetData($tDIB, 'biYPelsPerMeter') Then
				DllStructSetData($tDIB, 'biYPelsPerMeter', _WinAPI_GetDeviceCaps($hDC, 10) / _WinAPI_GetDeviceCaps($hDC, 6) * 1000)
			EndIf
		Else
			DllStructSetData($tDIB, 'biYPelsPerMeter', $iYPelsPerMeter)
		EndIf
		_WinAPI_ReleaseDC(0, $hDC)
		$hFile = _WinAPI_CreateFileEx($sFile, 2, 0x40000000, 0)
		If @error Then
			ExitLoop
		EndIf
		For $i = 0 To 3
			If $Data[$i][1] Then
				If Not _WinAPI_WriteFile($hFile, $Data[$i][0], $Data[$i][1], $Bytes) Then
					ExitLoop 2
				EndIf
			EndIf
		Next
		$Result = 1
	Until 1
	If $hSource Then
		_WinAPI_DeleteObject($hSource)
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not $Result Then
		FileDelete($sFile)
	EndIf
	Return SetError(Number(Not $Result), 0, $Result)
EndFunc   ;==>_WinAPI_SaveHBITMAPToFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SaveHICONToFile
; Description....: Saves a 32 bits-per-pixel single or multiple icon (HICON) to the specified icon (.ico) file.
; Syntax.........: _WinAPI_SaveHICONToFile ( $sFile, $aIcon [, $iStart [, $iEnd]] )
; Parameters.....: $sFile  - The name of the icon file.
;                  $aIcon  - Handle to the icon or array of the icon handles to be save.
;                  $iStart - The index of array to start saving at.
;                  $iEnd   - The index of array to stop saving at.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function only works with 32 bits-per-pixel (RGB + Alpha) icons. If you do not know exactly which color
;                  depth is there an icon, use the _WinAPI_Create32BitHICON() function to convert its.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SaveHICONToFile($sFile, $aIcon, $iStart = 0, $iEnd = -1)

	Local $Icon, $Count = 1

	If IsArray($aIcon) Then
		If UBound($aIcon, 2) Then
			Return SetError(2, 0, 0)
		EndIf
		If $iStart < 0 Then
			$iStart = 0
		EndIf
		If ($iEnd < 0) Or ($iEnd > UBound($aIcon) - 1) Then
			$iEnd = UBound($aIcon) - 1
		EndIf
		$Count = $iEnd - $iStart + 1
		If $Count < 1 Then
			Return SetError(1, 0, 0)
		EndIf
		Dim $Icon[$Count]
		For $i = 0 To $Count - 1
			$Icon[$i] = $aIcon[$iStart + $i]
		Next
	Else
		Dim $Icon[1] = [$aIcon]
	EndIf

	Local $hFile = _WinAPI_CreateFileEx($sFile, 2, 0x40000000, 0)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tData, $W, $H, $Info, $Bytes, $Error, $Result = 0
	Local $tIco = DllStructCreate('ushort Reserved;ushort Type;ushort Count;byte Data[' & (16 * $Count) & ']')
	Local $Lenght = DllStructGetSize($tIco)
	Local $pIco = DllStructGetPtr($tIco)
	Local $tBI = DllStructCreate($tagBITMAPINFOHEADER)
	Local $pBI = DllStructGetPtr($tBI)
	Local $tDIB = DllStructCreate($tagDIBSECTION)
	Local $Size = DllStructGetSize($tDIB)
	Local $pDIB = DllStructGetPtr($tDIB)
	Local $Offset = $Lenght

	DllStructSetData($tIco, 'Reserved', 0)
	DllStructSetData($tIco, 'Type', 1)
	DllStructSetData($tIco, 'Count', $Count)

	DllStructSetData($tBI, 'biSize', 40)
	DllStructSetData($tBI, 'biPlanes', 1)
	DllStructSetData($tBI, 'biBitCount', 32)
	DllStructSetData($tBI, 'biCompression', 0)
	DllStructSetData($tBI, 'biXPelsPerMeter', 0)
	DllStructSetData($tBI, 'biYPelsPerMeter', 0)
	DllStructSetData($tBI, 'biClrUsed', 0)
	DllStructSetData($tBI, 'biClrImportant', 0)

	Do
		If Not _WinAPI_WriteFile($hFile, $pIco, $Lenght, $Bytes) Then
			ExitLoop
		EndIf
		For $i = 0 To $Count - 1
			$Info = _WinAPI_GetIconInfo($Icon[$i])
			If Not IsArray($Info) Then
				ExitLoop 2
			EndIf
			For $j = 4 To 5
				$Info[$j] = _WinAPI_CopyImage($Info[$j], 0, 0, 0, BitOR(0x2000, 0x0008))
				If _WinAPI_GetObject($Info[$j], $Size, $pDIB) Then
					$Info[$j - 4] = DllStructGetData($tDIB, 'biSizeImage')
					$Info[$j - 2] = DllStructGetData($tDIB, 'bmBits')
				Else
					$Info[$j - 4] = 0
					$Info[$j - 2] = 0
				EndIf
			Next
			$W = DllStructGetData($tDIB, 'bmWidth')
			$H = DllStructGetData($tDIB, 'bmHeight')
			$tData = DllStructCreate('byte Width;byte Height;byte Colors;byte Reserved;word Planes;word BPP;long Size;long Offset', $pIco + 6 + 16 * $i)
			DllStructSetData($tData, 'Width', $W)
			DllStructSetData($tData, 'Height', $H)
			DllStructSetData($tData, 'Colors', 0)
			DllStructSetData($tData, 'Reserved', 0)
			DllStructSetData($tData, 'Planes', 1)
			DllStructSetData($tData, 'BPP', 32)
			DllStructSetData($tData, 'Size', 40 + $Info[0] + $Info[1])
			DllStructSetData($tData, 'Offset', $Offset)
			DllStructSetData($tBI, 'biWidth', $W)
			DllStructSetData($tBI, 'biHeight', 2 * $H)
			DllStructSetData($tBI, 'biSizeImage', $Info[0] + $Info[1])
			$Offset += 40 + $Info[0] + $Info[1]
			Do
				$Error = 1
				If Not _WinAPI_WriteFile($hFile, $pBI, 40, $Bytes) Then
					ExitLoop
				EndIf
				For $j = 1 To 0 Step -1
					If Not _WinAPI_WriteFile($hFile, $Info[$j + 2], $Info[$j], $Bytes) Then
						ExitLoop 2
					EndIf
				Next
				$Error = 0
			Until 1
			For $j = 4 To 5
				_WinAPI_DeleteObject($Info[$j])
			Next
			If $Error Then
				ExitLoop 2
			EndIf
		Next
		_WinAPI_SetFilePointer($hFile, 0)
		If Not _WinAPI_WriteFile($hFile, $pIco, $Lenght, $Bytes) Then
			ExitLoop
		EndIf
		$Result = 1
	Until 1
	_WinAPI_CloseHandle($hFile)
	If Not $Result Then
		FileDelete($sFile)
	EndIf
	Return SetError(Number(Not $Result), 0, $Result)
EndFunc   ;==>_WinAPI_SaveHICONToFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ScaleWindowExt
; Description....: Modifies the window for a device context using the ratios formed by the specified multiplicands and divisors.
; Syntax.........: _WinAPI_ScaleWindowExt ( $hDC, $iXNum, $iXDenom, $iYNum, $iYDenom )
; Parameters.....: $hDC     - Handle to the device context.
;                  $iXNum   - The amount by which to multiply the current horizontal extent.
;                  $iXDenom - The amount by which to divide the current horizontal extent.
;                  $iYNum   - The amount by which to divide the current vertical extent.
;                  $iYDenom - The amount by which to divide the current vertical extent.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ScaleWindowExtEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ScaleWindowExt($hDC, $iXNum, $iXDenom, $iYNum, $iYDenom)

	$__Ext = DllStructCreate($tagSIZE)

	Local $Ret = DllCall('gdi32.dll', 'int', 'ScaleWindowExtEx', 'hwnd', $hDC, 'int', $iXNum, 'int', $iXDenom, 'int', $iYNum, 'int', $iYDenom, 'ptr', DllStructGetPtr($__Ext))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ScaleWindowExt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SelectClipPath
; Description....: Selects the current path as a clipping region, combining the new region with any existing clipping region.
; Syntax.........: _WinAPI_SelectClipPath ( $hDC [, $iMode] )
; Parameters.....: $hDC    - Handle to the device context of the path.
;                  $iMode  - The way to use the path. This parameter can be one of the following values.
;
;                            $RGN_AND
;                            $RGN_COPY
;                            $RGN_DIFF
;                            $RGN_OR
;                            $RGN_XOR
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SelectClipPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SelectClipPath($hDC, $iMode = 5)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SelectClipPath', 'hwnd', $hDC, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SelectClipPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SelectClipRgn
; Description....: Selects a region as the current clipping region for the specified device context.
; Syntax.........: _WinAPI_SelectClipRgn ( $hDC, $hRgn )
; Parameters.....: $hDC    - Handle to the device context.
;                  $hRgn   - Handle to the region to be selected. To remove a device-context's clipping region, set this parameter to 0.
; Return values..: Success - The value that specifies the new clipping region's complexity; it can be one of the following values.
;
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Only a copy of the selected region is used. The region itself can be selected for any number of other device
;                  contexts or it can be deleted.
; Related........:
; Link...........: @@MsdnLink@@ SelectClipRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SelectClipRgn($hDC, $hRgn)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SelectClipRgn', 'hwnd', $hDC, 'ptr', $hRgn)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SelectClipRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SendMessageTimeout
; Description....: Sends the specified message to one of more windows.
; Syntax.........: _WinAPI_SendMessageTimeout ( $hWnd, $iMessage [, $wParam [, $lParam [, $iTimeout [, $iFlags]]]] )
; Parameters.....: $hWnd     - Handle to the window whose window procedure will receive the message.
;                  $iMessage - The message to be sent.
;                  $wParam   - Additional message-specific information.
;                  $lParam   - Additional message-specific information.
;                  $iTimeout - The duration, in milliseconds, of the time-out period. If the message is a broadcast message, each
;                              window can use the full time-out period. Default is 1000.
;                  $iFlags   - The flags that specifies how to send the message. This parameter can be one or more of the
;                              following values.
;
;                              $SMTO_BLOCK
;                              $SMTO_NORMAL
;                              $SMTO_ABORTIFHUNG
;                              $SMTO_NOTIMEOUTIFNOTHUNG
;                              $SMTO_ERRORONEXIT
;
; Return values..: Success   - The result of the message processing, depends on the message sent.
;                  Failure   - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not provide information about individual windows timing out if $HWND_BROADCAST is used.
;
;                  If times out, function fails. To get extended error information, call _WinAPI_GetLastError(). If _WinAPI_GetLastError()
;                  returns ERROR_TIMEOUT, then the function timed out. This function considers a thread is not responding if it has
;                  not responds within five seconds.
;
;                  The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages
;                  (those >= WM_USER) to another process, you must do custom marshalling.
; Related........:
; Link...........: @@MsdnLink@@ SendMessageTimeout
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SendMessageTimeout($hWnd, $iMessage, $wParam = 0, $lParam = 0, $iTimeout = 1000, $iFlags = 0)

	Local $Ret = DllCall('user32.dll', 'lresult', 'SendMessageTimeoutW', 'hwnd', $hWnd, 'uint', $iMessage, 'wparam', $wParam, 'lparam', $lParam, 'uint', $iFlags, 'uint', $iTimeout, 'dword_ptr*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[7]
EndFunc   ;==>_WinAPI_SendMessageTimeout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetActiveWindow
; Description....: Activates the specified window.
; Syntax.........: _WinAPI_SetActiveWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the top-level window to be activated.
; Return values..: Success - Handle to the window that was previously active.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetActiveWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetActiveWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'SetActiveWindow', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetActiveWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetArcDirection
; Description....: Sets the drawing arc direction.
; Syntax.........: _WinAPI_SetArcDirection ( $hDC, $iDirection )
; Parameters.....: $hDC        - Handle to the device context.
;                  $iDirection - The new arc direction. This parameter can be one of the following values.
;
;                                $AD_COUNTERCLOCKWISE
;                                $AD_CLOCKWISE
;
; Return values..: Success     - The previous arc direction.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The default direction is counterclockwise.
; Related........:
; Link...........: @@MsdnLink@@ SetArcDirection
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetArcDirection($hDC, $iDirection)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetArcDirection', 'hwnd', $hDC, 'int', $iDirection)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetArcDirection

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetBitmapBits
; Description....: Sets the bits of color data for a bitmap to the specified values.
; Syntax.........: _WinAPI_SetBitmapBits ( $hBitmap, $iSize, $pBits )
; Parameters.....: $hBitmap - Handle to the bitmap to be set. This must be a compatible bitmap (DDB).
;                  $iSize   - The number of bytes pointed to by the $pBits parameter.
;                  $pBits   - A pointer to an array of bytes that contain color data for the specified bitmap.
; Return values..: Success  - The number of bytes used in setting the bitmap bits.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetBitmapBits
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetBitmapBits($hBitmap, $iSize, $pBits)

	Local $Ret = DllCall('gdi32.dll', 'dword', 'SetBitmapBits', 'ptr', $hBitmap, 'dword', $iSize, 'ptr', $pBits)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetBitmapBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetBitmapDimensionEx
; Description....: Assigns preferred dimensions to a compatible bitmap.
; Syntax.........: _WinAPI_SetBitmapDimensionEx ( $hBitmap, $iWidth, $iHeight )
; Parameters.....: $hBitmap - Handle to the bitmap. This bitmap cannot be a DIB-section bitmap.
;                  $iWidth  - The width, in 0.1-millimeter units, of the bitmap.
;                  $iHeight - The height, in 0.1-millimeter units, of the bitmap.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The bitmap cannot be a DIB section, which is a bitmap created by the _WinAPI_CreateDIB() or _WinAPI_CreateDIBSection()
;                  functions. If the bitmap is a DIB section, the _WinAPI_SetBitmapDimensionEx() function fails.
;
;                  Call _WinAPI_GetExtended() to retrieve a $tagSIZE structure containing the previous dimensions of the bitmap.
; Related........:
; Link...........: @@MsdnLink@@ SetBitmapDimensionEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetBitmapDimensionEx($hBitmap, $iWidth, $iHeight)

	Local $__Ext = DllStructCreate($tagSIZE)
	Local $Ret = DllCall('gdi32.dll', 'int', 'SetBitmapDimensionEx', 'ptr', $hBitmap, 'int', $iWidth, 'int', $iHeight, 'ptr', DllStructGetPtr($__Ext))

	If (@error) Or (Not $Ret[0]) Then
		$__Ext = 0
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetBitmapDimensionEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetBoundsRect
; Description....: Controls the accumulation of bounding rectangle information for the specified device context.
; Syntax.........: _WinAPI_SetBoundsRect ( $hDC, $iFlags [, $tRECT] )
; Parameters.....: $hDC    - Handle to the device context for which to accumulate bounding rectangles.
;                  $iFlags - The flags that specifies how the new rectangle will be combined with the accumulated rectangle.
;                            This parameter can be one of more of the following values.
;
;                            $DCB_ACCUMULATE
;                            $DCB_DISABLE
;                            $DCB_ENABLE
;                            $DCB_RESET
;
;                  $tRECT  - $tagRECT structure used to set the bounding rectangle in logical coordinates.
; Return values..: Success - The value specifies the previous state of the bounding rectangle ($DCB_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetBoundsRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetBoundsRect($hDC, $iFlags, $tRECT = 0)

	Local $Ret = DllCall('gdi32.dll', 'uint', 'SetBoundsRect', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT), 'uint', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetBoundsRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetCaretBlinkTime
; Description....: Sets the caret blink time.
; Syntax.........: _WinAPI_SetCaretBlinkTime ( $iDuration )
; Parameters.....: $iDuration - The new blink time, in milliseconds. If this parameter is (-1), caret does not blink.
; Return values..: Success    - The previous blink time, in milliseconds.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The user can set the blink time using the Control Panel. Applications should respect the setting that the user
;                  has chosen. This function should only be used by application that allow the user to set the blink time, such
;                  as a Control Panel applet.
; Related........:
; Link...........: @@MsdnLink@@ SetCaretBlinkTime
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetCaretBlinkTime($iDuration)

	Local $Prev = _WinAPI_GetCaretBlinkTime()

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('user32.dll', 'int', 'SetCaretBlinkTime', 'uint', $iDuration)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Prev
EndFunc   ;==>_WinAPI_SetCaretBlinkTime

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetCaretPos
; Description....: Moves the caret to the specified coordinates.
; Syntax.........: _WinAPI_SetCaretPos ( $iX, $iY )
; Parameters.....: $iX     - The new x-coordinate of the caret.
;                  $iY     - The new y-coordinate of the caret.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetCaretPos
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetCaretPos($iX, $iY)

	Local $Ret = DllCall('user32.dll', 'int', 'SetCaretPos', 'int', $iX, 'int', $iY)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetCaretPos

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetClassLongEx
; Description....: Replaces the specified value into the specified window belongs.
; Syntax.........: _WinAPI_SetClassLongEx ( $hWnd, $iIndex, $iNewLong )
; Parameters.....: $hWnd     - Handle to the window.
;                  $iIndex   - The value to be replaced. This parameter can be one of the following values.
;
;                              $GCL_CBCLSEXTRA
;                              $GCL_CBWNDEXTRA
;                              $GCL_HBRBACKGROUND
;                              $GCL_HCURSOR
;                              $GCL_HICON
;                              $GCL_HICONSM
;                              $GCL_HMODULE
;                              $GCL_MENUNAME
;                              $GCL_STYLE
;                              $GCL_WNDPROC
;
;                  $iNewLong - The replacement value.
; Return values..: Success   - The previous value.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetClassLong
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetClassLongEx($hWnd, $iIndex, $iNewLong)

	Local $Ret

	If StringInStr(@OSArch, '64') Then
		$Ret = DllCall('user32.dll', 'ulong_ptr', 'SetClassLongPtrW', 'hwnd', $hWnd, 'int', $iIndex, 'long_ptr', $iNewLong)
	Else
		$Ret = DllCall('user32.dll', 'ulong', 'SetClassLongW', 'hwnd', $hWnd, 'int', $iIndex, 'long', $iNewLong)
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetClassLongEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetCompression
; Description....: Sets the compression state of a file or directory.
; Syntax.........: _WinAPI_SetCompression ( $sPath, $iCompression )
; Parameters.....: $sPath        - Path to file or directory to be compressed.
;                  $iCompression - One of the following compression constants.
;
;                                  $COMPRESSION_FORMAT_NONE
;                                  $COMPRESSION_FORMAT_DEFAULT
;                                  $COMPRESSION_FORMAT_LZNT1
;
; Return values..: Success       - 1.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the file system of the volume containing the specified file or directory does not support per-file or
;                  per-directory compression, the function fails. File compression is supported for files of a maximum uncompressed
;                  size of 30 gigabytes.
; Related........:
; Link...........: @@MsdnLink@@ FSCTL_SET_COMPRESSION
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetCompression($sPath, $iCompression)

	Local $hFile = _WinAPI_CreateFileEx($sPath, 3, 0xC0000000, 0x03, 0x02000000)

	If Not $hFile Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tData = DllStructCreate('ushort')

	DllStructSetData($tData, 1, $iCompression)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', $FSCTL_SET_COMPRESSION, 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData), 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetCompression

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetCurrentDirectory
; Description....: Changes the current directory for the current process.
; Syntax.........: _WinAPI_SetCurrentDirectory ( $sDir )
; Parameters.....: $sDir   - The path to the new current directory.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetCurrentDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetCurrentDirectory($sDir)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetCurrentDirectoryW', 'wstr', $sDir)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetCurrentDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetCurrentProcessExplicitAppUserModelID
; Description....: Specifies a unique application-defined Application User Model ID that identifies the current process to the taskbar.
; Syntax.........: _WinAPI_SetCurrentProcessExplicitAppUserModelID ( $sAppID )
; Parameters.....: $sAppID - The string that represents an Application User Model ID (AppUserModelID). This identifier allows an
;                            application to group its associated processes and windows under a single taskbar button. An application
;                            must provide its AppUserModelID in the following form and can have no more than 128 characters and
;                            cannot contain spaces.
;
;                            CompanyName.ProductName.SubProduct.VersionInformation
;
;                            (See MSDN for more information)
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This method must be called during an application's initial startup routine before the application presents any
;                  UI or makes any manipulation of its Jump Lists.
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ SetCurrentProcessExplicitAppUserModelID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetCurrentProcessExplicitAppUserModelID($sAppID)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SetCurrentProcessExplicitAppUserModelID', 'wstr', $sAppID)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetCurrentProcessExplicitAppUserModelID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDCBrushColor
; Description....: Sets the current device context (DC) brush color to the specified color value.
; Syntax.........: _WinAPI_SetDCBrushColor ( $hDC, $iRGB )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iRGB   - The new brush color, in RGB.
; Return values..: Success - The value that specifies the previous DC brush color, in RGB.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function returns the previous $DC_BRUSH color, even if the stock brush $DC_BRUSH is not selected in the DC:
;                  however, this will not be used in drawing operations until the stock $DC_BRUSH is selected in the DC.
; Related........:
; Link...........: @@MsdnLink@@ SetDCBrushColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetDCBrushColor($hDC, $iRGB)

	Local $Ret = DllCall('gdi32.dll', 'dword', 'SetDCBrushColor', 'hwnd', $hDC, 'dword', __RGB($iRGB))

	If (@error) Or ($Ret[0] = 0xFFFFFFFF) Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_SetDCBrushColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDCPenColor
; Description....: Sets the current device context (DC) pen color to the specified color value.
; Syntax.........: _WinAPI_SetDCPenColor ( $hDC, $iRGB )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iRGB   - The new pen color, in RGB.
; Return values..: Success - The value that specifies the previous DC pen color, in RGB.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function returns the previous $DC_PEN color, even if the stock pen $DC_PEN is not selected in the DC;
;                  however, this will not be used in drawing operations until the stock $DC_PEN is selected in the DC.
; Related........:
; Link...........: @@MsdnLink@@ SetDCPenColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetDCPenColor($hDC, $iRGB)

	Local $Ret = DllCall('gdi32.dll', 'dword', 'SetDCPenColor', 'hwnd', $hDC, 'dword', __RGB($iRGB))

	If (@error) Or ($Ret[0] = 0xFFFFFFFF) Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_SetDCPenColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDeviceGammaRamp
; Description....: Sets the gamma ramp on direct color display boards that support downloadable gamma ramps in hardware.
; Syntax.........: _WinAPI_SetDeviceGammaRamp ( $hDC, ByRef $aRamp )
; Parameters.....: $hDC    - Handle to a device context of the direct color display board in question.
;                  $aRamp  - The 2D array ([r1, g1, b1], [r2, g2, b2], ... [r256, g256, b256]) that contains the gamma ramp to be set.
;                            Each element in this array is an integer value with a range from 0 to 65535 which is a mapping between
;                            RGB values in the frame buffer and digital-analog-converter (DAC) values. The RGB values must be stored
;                            in the most significant bits of each WORD to increase DAC independence.
;
;                            (See MSDN for more information)
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Direct color display modes do not use color lookup tables and are usually 16, 24, or 32 bit. Not all direct color
;                  video boards support loadable gamma ramps. _WinAPI_SetDeviceGammaRamp() succeeds only for devices with drivers
;                  that support downloadable gamma ramps in hardware.
; Related........:
; Link...........: @@MsdnLink@@ SetDeviceGammaRamp
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetDeviceGammaRamp($hDC, ByRef $aRamp)

	If (UBound($aRamp, 0) <> 2) Or (UBound($aRamp, 1) <> 256) Or (UBound($aRamp, 2) <> 3) Then
		Return SetError(2, 0, 0)
	EndIf

	Local $tData = DllStructCreate('ushort[256];ushort[256];ushort[256]')

	For $i = 0 to 2
		For $j = 0 To 255
			DllStructSetData($tData, $i + 1, $aRamp[$j][$i], $j + 1)
		Next
	Next

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetDeviceGammaRamp', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetDeviceGammaRamp

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDIBColorTable
; Description....: Sets RGB color table in the DIB section bitmap.
; Syntax.........: _WinAPI_SetDIBColorTable ( $hBitmap, $tColorTable, $iColorCount )
; Parameters.....: $hBitmap     - A DIB section bitmap in which to set the color table.
;                  $tColorTable - "dword[n]" structure that represents a DIB color table that to be set.
; Return values..: Success      - The number of color table entries that the function sets.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_GetDIBColorTable() function sets a color table for DIB section bitmaps that use 1, 4, or 8 bits-per-pixel.
;                  A DIB section bitmaps that use bits-per-pixel value greater than eight do not have a color table.
; Related........:
; Link...........: @@MsdnLink@@ SetDIBColorTable
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetDIBColorTable($hBitmap, $tColorTable, $iColorCount)

	If $iColorCount > DllStructGetSize($tColorTable) / 4 Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hDC, $hSv, $Ret

	$hDC = _WinAPI_CreateCompatibleDC(0)
	$hSv = _WinAPI_SelectObject($hDC, $hBitmap)
	$Ret = DllCall('gdi32.dll', 'uint', 'SetDIBColorTable', 'hwnd', $hDC, 'uint', 0, 'uint', $iColorCount, 'ptr', DllStructGetPtr($tColorTable))
	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_SelectObject($hDC, $hSv)
	_WinAPI_DeleteDC($hDC)
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetDIBColorTable

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDIBitsToDevice
; Description....: Sets the pixels in the specified rectangle on the device.
; Syntax.........: _WinAPI_SetDIBitsToDevice ( $hDC, $iXDest, $iYDest, $iWidth, $iHeight, $iXSrc, $iYSrc, $iStartScan, $iScanLines, ByRef $tBITMAPINFO, $iUsage, $pBits )
; Parameters.....: $hDC         - Handle to a device context.
;                  $iXDest      - The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iYDest      - The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iWidth      - The width, in logical units, of the image.
;                  $iHeight     - The height, in logical units, of the image.
;                  $iXSrc       - The x-coordinate, in logical units, of the lower-left corner of the image.
;                  $iYSrc       - The y-coordinate, in logical units, of the lower-left corner of the image.
;                  $iStartScan  - The starting scan line in the image.
;                  $iScanLines  - The number of DIB scan lines.
;                  $tBITMAPINFO - $tagBITMAPINFO structure that contains information about the DIB.
;                  $iUsage      - The type of colors used. (either logical palette indexes or literal RGB values). The following
;                                 values are defined.
;
;                                 $DIB_PAL_COLORS
;                                 $DIB_RGB_COLORS
;
;                  $pBits       - A pointer to the color data stored as an array of bytes.
; Return values..: Success      - The number of scan lines set.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Luke
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetDIBitsToDevice
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetDIBitsToDevice($hDC, $iXDest, $iYDest, $iWidth, $iHeight, $iXSrc, $iYSrc, $iStartScan, $iScanLines, ByRef $tBITMAPINFO, $iUsage, $pBits)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetDIBitsToDevice', 'hwnd', $hDC, 'int', $iYDest, 'int', $iYDest, 'dword', $iWidth, 'dword', $iHeight, 'int', $iXSrc, 'int', $iYSrc, 'uint', $iStartScan, 'uint', $iScanLines, 'ptr', $pBits, 'ptr', DllStructGetPtr($tBITMAPINFO), 'uint', $iUsage)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetDIBitsToDevice

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDllDirectory
; Description....: Adds a directory to the search path used to locate DLLs for the application.
; Syntax.........: _WinAPI_SetDllDirectory ( $sPath )
; Parameters.....: $sPath  - The directory to be added to the search path. If this parameter is an empty string (""), the call
;                            removes the current directory from the default DLL search order. If this parameter is not specified,
;                            the function restores the default search order.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function affects all subsequent calls to the _WinAPI_LoadLibrary() and _WinAPI_LoadLibraryEx() functions.
;                  It also effectively disables safe DLL search mode while the specified directory is in the search path.
;
;                  After calling _WinAPI_SetDllDirectory(), the DLL search path is:
;
;                  1. The directory from which the application was loaded.
;                  2. The directory specified by the $sPath parameter.
;                  3. The system directory.
;                  4. The 16-bit system directory.
;                  5. The Windows directory.
;                  6. The directories that are listed in the PATH environment variable.
;
; Related........:
; Link...........: @@MsdnLink@@ SetDllDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetDllDirectory($sPath = Default)

	Local $TypeOfPath = 'wstr'

	If $sPath = Default Then
		$TypeOfPath = 'ptr'
		$sPath = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetDllDirectoryW', $TypeOfPath, $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetDllDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDriverSigning
; Description ...: Sets driver signing policy on Microsoft Windows operating systems
; Syntax.........: _WinAPI_SetDriverSigning([$iLM, $iCU, $sComputer])
; Parameters ....: $iLM - [Optional] Set at the machine level
;                           0 - Ignore
;                           1 - Warn
;                           2 - Block
;                           3 - Ignore only for current user
;                           Default is Ignore
;                  $iCU - [Optional] Set at the user level
;                           0 - $iLM setting takes precedence
;                           1 - Warn only for current user if greater than $iLM setting
;                           2 - Block only for current user if greater than $iLM setting
;                  $sComputer - [Optional] Computer name, The local computer is default
; Return values .: Success - Returns 1
;                  Failure - Returns 0 and sets @error to:
;                              -1 - Failure to read the registry
;                              -2 - Failure to compute the cryptographic hash
;                              -3 - Failure to write to the registry
; Author ........: engine
; Modified.......:
; Remarks .......:
; Related .......:
; Link ..........;
; Example .......;
; ===============================================================================================================================

Func _WinAPI_SetDriverSigning($iLM = 0, $iCU = 0, $sComputer = @ComputerName)
	Local Const $PROV_RSA_FULL = 0x00000001
	Local Const $CRYPT_VERIFYCONTEXT = 0xf0000000
	Local Const $ALG_CLASS_HASH = 0x00008000
	Local Const $ALG_TYPE_ANY = 0x00000000
	Local Const $ALG_SID_MD5 = 0x00000003
	Local Const $CALG_MD5 = BitOR($ALG_CLASS_HASH, $ALG_TYPE_ANY, $ALG_SID_MD5)
	Local Const $HP_HASHVAL = 0x00000002

	Local $iSeed = RegRead("\\" & $sComputer & "\HKLM\SYSTEM\WPA\PnP", "seed")

	If @error Then Return SetError(-1, 0, 0)

	Local $hAdvapi32 = DllOpen("Advapi32.dll")
	Local $avProv = DllCall($hAdvapi32, "int", "CryptAcquireContext", "hwnd*", 0, "ptr", 0, "ptr", 0, "dword", $PROV_RSA_FULL, "dword", $CRYPT_VERIFYCONTEXT)
	Local $avHash = DllCall($hAdvapi32, "int", "CryptCreateHash", "hwnd", $avProv[1], "dword", $CALG_MD5, "hwnd", 0, "dword", 0, "hwnd*", 0)
	Local $tIMPUT = DllStructCreate("char[4]")

	DllStructSetData($tIMPUT, 1, $iLM, 2)
	DllCall($hAdvapi32, "int", "CryptHashData", "hwnd", $avHash[5], "ptr", DllStructGetPtr($tIMPUT), "dword", DllStructGetSize($tIMPUT), "dword", 0)
	DllCall($hAdvapi32, "int", "CryptHashData", "hwnd", $avHash[5], "dword*", $iSeed, "dword", 4, "dword", 0)

	Local $tData = DllStructCreate("byte[16]")

	DllCall($hAdvapi32, "int", "CryptGetHashParam", "hwnd", $avHash[5], "dword", $HP_HASHVAL, "ptr", DllStructGetPtr($tData), "dword*", DllStructGetSize($tData), "dword", 0)
	DllCall($hAdvapi32, "int", "CryptDestroyHash", "hwnd", $avHash[5])
	DllCall($hAdvapi32, "int", "CryptReleaseContext", "hwnd", $avProv[1], "dword", 0)
	DllClose($hAdvapi32)

	Local $aiGLE = DllCall("Kernel32.dll", "dword", "GetLastError")

	If $aiGLE[0] <> 0 Then Return SetError(-2, 0, 0)

	If Not RegWrite("\\" & $sComputer & "\HKLM\Software\Microsoft\Windows\CurrentVersion\Setup", "PrivateHash", "REG_BINARY", DllStructGetData($tData, 1)) _
			Or Not RegWrite("\\" & $sComputer & "\HKLM\SOFTWARE\Microsoft\Driver Signing", "Policy", "REG_BINARY", Binary($iLM)) _
			Or Not RegWrite("\\" & $sComputer & "\HKCU\Software\Policies\Microsoft\Windows NT\Driver Signing", "BehaviorOnFailedVerify", "REG_DWORD", $iCU) _
			Then Return SetError(-3, 0, 0)
	Return 1
EndFunc   ;==>_WinAPI_SetDriverSigning

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetEnhMetaFileBits
; Description....: Creates a memory-based enhanced-format metafile from the specified data.
; Syntax.........: _WinAPI_SetEnhMetaFileBits ( ByRef $tBits )
; Parameters.....: $tBits  - A structure (buffer) that contains the enhanced-metafile data.
; Return values..: Success - Handle to a memory-based enhanced metafile.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the
;                  _WinAPI_DeleteEnhMetaFile() function.
; Related........:
; Link...........: @@MsdnLink@@ SetEnhMetaFileBits
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetEnhMetaFileBits(ByRef $tBits)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'SetEnhMetaFileBits', 'uint', DllStructGetSize($tBits), 'ptr', DllStructGetPtr($tBits))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetEnhMetaFileBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetErrorMode
; Description....: Controls whether the system will handle the specified types of serious errors or whether the process will handle them.
; Syntax.........: _WinAPI_SetErrorMode ( $iMode )
; Parameters.....: $iMode  - The process error mode. This parameter can be one or more of the following values.
;
;                            $SEM_FAILCRITICALERRORS
;                            $SEM_NOALIGNMENTFAULTEXCEPT
;                            $SEM_NOGPFAULTERRORBOX
;                            $SEM_NOOPENFILEERRORBOX
;
; Return values..: Success - The previous state of the error-mode bit flags ($SEM_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetErrorMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetErrorMode($iMode)

	Local $Ret = DllCall('kernel32.dll', 'uint', 'SetErrorMode', 'uint', $iMode)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetErrorMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetFileAttributes
; Description....: Sets the attributes for a file or directory.
; Syntax.........: _WinAPI_SetFileAttributes ( $sFile, $iAttributes )
; Parameters.....: $sFile       - The name of the file whose attributes are to be set.
;                  $iAttributes - The file attributes to set for the file. This parameter can be one or more of the following values.
;
;                                 $FILE_ATTRIBUTE_READONLY
;                                 $FILE_ATTRIBUTE_HIDDEN
;                                 $FILE_ATTRIBUTE_SYSTEM
;                                 $FILE_ATTRIBUTE_ARCHIVE
;                                 $FILE_ATTRIBUTE_NORMAL
;                                 $FILE_ATTRIBUTE_TEMPORARY
;                                 $FILE_ATTRIBUTE_OFFLINE
;                                 $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
;
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Not all attributes are supported by this function. For more information, see MSDN library.
; Related........:
; Link...........: @@MsdnLink@@ SetFileAttributes
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetFileAttributes($sFile, $iAttributes)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetFileAttributesW', 'wstr', $sFile, 'dword', $iAttributes)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetFileAttributes

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetFilePointerEx
; Description....: Moves the file pointer of the specified file.
; Syntax.........: _WinAPI_SetFilePointerEx ( $hFile, $iPos [, $iMethod] )
; Parameters.....: $hFile   - Handle to the file.
;                  $iPos    - The number of bytes to move the file pointer. A positive value moves the pointer forward in the
;                             file and a negative value moves the file pointer backward.
;                  $iMethod - The starting point for the file pointer move. This parameter can be one of the following values.
;
;                             $FILE_BEGIN
;                             $FILE_CURRENT
;                             $FILE_END
;
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetFilePointerEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetFilePointerEx($hFile, $iPos, $iMethod = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetFilePointerEx', 'ptr', $hFile, 'int64', $iPos, 'int64*', 0, 'dword', $iMethod)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetFilePointerEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetForegroundWindow
; Description....: Puts the specified window into the foreground and activates its.
; Syntax.........: _WinAPI_SetForegroundWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window that should be activated and brought to the foreground.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetForegroundWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetForegroundWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'SetForegroundWindow', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetForegroundWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetFRBuffer
; Description....: Sets the size of the internal buffer that used the _WinAPI_FindTextDlg() and _WinAPI_ReplaceTextDlg() functions.
; Syntax.........: _WinAPI_SetFRBuffer ( $iChars )
; Parameters.....: $iChars - The size, in TCHARs, of the internal buffer. The buffer should be at least 80 characters long.
;                            The default buffer size is 8192 chars (16 KB).
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not initialize the buffer, just sets its size. Actually, this buffer is initialized only by
;                  _WinAPI_FindTextDlg() and _WinAPI_ReplaceTextDlg() functions. The _WinAPI_SetFRBuffer() must be called before
;                  using the _WinAPI_FindTextDlg() or _WinAPI_ReplaceTextDlg().
;
;                  You can destroy the internal buffer by calling the _WinAPI_FlushFRBuffer() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetFRBuffer($iChars)
	$iChars = Number($iChars)
	If $iChars < 80 Then
		Return SetError(_WinAPI_SetLastError(122), 0, 0)
	EndIf
	$__Buff = $iChars + 1
	Return 1
EndFunc   ;==>_WinAPI_SetFRBuffer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetGraphicsMode
; Description....: Sets the graphics mode for the specified device context.
; Syntax.........: _WinAPI_SetGraphicsMode ( $hDC, $iMode )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iMode  - The graphics mode. This parameter can be one of the following values.
;
;                            $GM_COMPATIBLE
;                            $GM_ADVANCED
;
; Return values..: Success - The previous graphics mode.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetGraphicsMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetGraphicsMode($hDC, $iMode)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetGraphicsMode', 'hwnd', $hDC, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetGraphicsMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetInformationJobObject
; Description....: Sets limits for a job object.
; Syntax.........: _WinAPI_SetInformationJobObject ( $hJob, $iJobObjectInfoClass, $tJobObjectInfo )
; Parameters.....: $hJob                - Handle to the job whose limits are being set. The handle must have the
;                                         $JOB_OBJECT_SET_ATTRIBUTES access right.
;                  $iJobObjectInfoClass - The information class for the limits to be set. This parameter specifies the type
;                                         of $tJobObjectInfo structure, valid values:
;                  |2  - $tagJOBOBJECT_BASIC_LIMIT_INFORMATION
;                  |4  - $tagJOBOBJECT_BASIC_UI_RESTRICTIONS
;                  |5  - $tagJOBOBJECT_SECURITY_LIMIT_INFORMATION
;                  |6  - $tagJOBOBJECT_END_OF_JOB_TIME_INFORMATION
;                  |7  - $tagJOBOBJECT_ASSOCIATE_COMPLETION_PORT
;                  |9  - $tagJOBOBJECT_EXTENDED_LIMIT_INFORMATION
;                  |11 - $tagJOBOBJECT_GROUP_INFORMATION
;                  $tJobObjectInfo      - $tagJOBOBJECT_* structure that sets the limit and job state information.
; Return values..: Success              - 1.
;                  Failure              - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetInformationJobObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetInformationJobObject($hJob, $iJobObjectInfoClass, $tJobObjectInfo)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetInformationJobObject', 'ptr', $hJob, 'int', $iJobObjectInfoClass, 'ptr', DllStructGetPtr($tJobObjectInfo), 'dword', DllStructGetSize($tJobObjectInfo))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetInformationJobObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetKeyboardLayout
; Description....: Sets an input locale identifier to the specified window.
; Syntax.........: _WinAPI_SetKeyboardLayout ( $hWnd, $iLanguage [, $iFlags] )
; Parameters.....: $hWnd      - Handle to the window to set input locale identifier.
;                  $iLanguage - The name of the input locale identifier (LCID).
;
;                               0x0436 - Afrikaans
;                               0x041C - Albanian
;                               0x0401 - Arabic
;                               0x1401 - Arabic Algeria
;                               0x3C01 - Arabic Bahrain
;                               0x0C01 - Arabic Egypt
;                               0x0801 - Arabic Iraq
;                               0x2C01 - Arabic Jordan
;                               0x3401 - Arabic Kuwait
;                               0x3001 - Arabic Lebanon
;                               0x1001 - Arabic Libya
;                               0x1801 - Arabic Morocco
;                               0x2001 - Arabic Oman
;                               0x4001 - Arabic Qatar
;                               0x0401 - Arabic Saudi Arabia
;                               0x2801 - Arabic Syria
;                               0x1C01 - Arabic Tunisia
;                               0x3801 - Arabic U.A.E
;                               0x2401 - Arabic Yemen
;                               0x042B - Armenian
;                               0x044D - Assamese
;                               0x082C - Azeri Cyrillic
;                               0x042C - Azeri Latin
;                               0x042D - Basque
;                               0x0813 - Belgian Dutch
;                               0x080C - Belgian French
;                               0x0445 - Bengali
;                               0x0416 - Portuguese (Brazil)
;                               0x0402 - Bulgarian
;                               0x0455 - Burmese
;                               0x0423 - Byelorussian (Belarusian)
;                               0x0403 - Catalan
;                               0x0C04 - Chinese Hong Kong SAR
;                               0x1404 - Chinese Macau SAR
;                               0x0804 - Chinese Simplified
;                               0x1004 - Chinese Singapore
;                               0x0404 - Chinese Traditional
;                               0x041A - Croatian
;                               0x0405 - Czech
;                               0x0406 - Danish
;                               0x0413 - Dutch
;                               0x0C09 - English Australia
;                               0x2809 - English Belize
;                               0x1009 - English Canadian
;                               0x2409 - English Caribbean
;                               0x1813 - English Ireland
;                               0x2009 - English Jamaica
;                               0x1409 - English New Zealand
;                               0x3409 - English Philippines
;                               0x1C09 - English South Africa
;                               0x2C09 - English Trinidad
;                               0x0809 - English U.K.
;                               0x0409 - English U.S.
;                               0x3009 - English Zimbabwe
;                               0x0425 - Estonian
;                               0x0438 - Faeroese
;                               0x0429 - Farsi
;                               0x040B - Finnish
;                               0x040C - French
;                               0x2C0C - French Cameroon
;                               0x0C0C - French Canadian
;                               0x300C - French Cote d'Ivoire
;                               0x140C - French Luxembourg
;                               0x340C - French Mali
;                               0x180C - French Monaco
;                               0x200C - French Reunion
;                               0x280C - French Senegal
;                               0x1C0C - French West Indies
;                               0x240C - French Congo (DRC)
;                               0x0462 - Frisian Netherlands
;                               0x083C - Gaelic Ireland
;                               0x043C - Gaelic Scotland
;                               0x0456 - Galician
;                               0x0437 - Georgian
;                               0x0407 - German
;                               0x0C07 - German Austria
;                               0x1407 - German Liechtenstein
;                               0x1007 - German Luxembourg
;                               0x0408 - Greek
;                               0x0447 - Gujarati
;                               0x040D - Hebrew
;                               0x0439 - Hindi
;                               0x040E - Hungarian
;                               0x040F - Icelandic
;                               0x0421 - Indonesian
;                               0x0410 - Italian
;                               0x0411 - Japanese
;                               0x044B - Kannada
;                               0x0460 - Kashmiri
;                               0x043F - Kazakh
;                               0x0453 - Khmer
;                               0x0440 - Kirghiz
;                               0x0457 - Konkani
;                               0x0412 - Korean
;                               0x0454 - Lao
;                               0x0426 - Latvian
;                               0x0427 - Lithuanian
;                               0x042F - FYRO Macedonian
;                               0x044C - Malayalam
;                               0x083E - Malay Brunei Darussalam
;                               0x043E - Malaysian
;                               0x043A - Maltese
;                               0x0458 - Manipuri
;                               0x044E - Marathi
;                               0x0450 - Mongolian
;                               0x0461 - Nepali
;                               0x0414 - Norwegian Bokmol
;                               0x0814 - Norwegian Nynorsk
;                               0x0448 - Oriya
;                               0x0415 - Polish
;                               0x0816 - Portuguese
;                               0x0446 - Punjabi
;                               0x0417 - Rhaeto-Romanic
;                               0x0418 - Romanian
;                               0x0818 - Romanian Moldova
;                               0x0419 - Russian
;                               0x0819 - Russian Moldova
;                               0x043B - Sami Lappish
;                               0x044F - Sanskrit
;                               0x0C1A - Serbian Cyrillic
;                               0x081A - Serbian Latin
;                               0x0430 - Sesotho
;                               0x0459 - Sindhi
;                               0x041B - Slovak
;                               0x0424 - Slovenian
;                               0x042E - Sorbian
;                               0x040A - Spanish (Traditional)
;                               0x2C0A - Spanish Argentina
;                               0x400A - Spanish Bolivia
;                               0x340A - Spanish Chile
;                               0x240A - Spanish Colombia
;                               0x140A - Spanish Costa Rica
;                               0x1C0A - Spanish Dominican Republic
;                               0x300A - Spanish Ecuador
;                               0x440A - Spanish El Salvador
;                               0x100A - Spanish Guatemala
;                               0x480A - Spanish Honduras
;                               0x4C0A - Spanish Nicaragua
;                               0x180A - Spanish Panama
;                               0x3C0A - Spanish Paraguay
;                               0x280A - Spanish Peru
;                               0x500A - Spanish Puerto Rico
;                               0x0C0A - Spanish Spain (Modern Sort)
;                               0x380A - Spanish Uruguay
;                               0x200A - Spanish Venezuela
;                               0x0430 - Sutu
;                               0x0441 - Swahili
;                               0x041D - Swedish
;                               0x081D - Swedish Finland
;                               0x100C - Swiss French
;                               0x0807 - Swiss German
;                               0x0810 - Swiss Italian
;                               0x0428 - Tajik
;                               0x0449 - Tamil
;                               0x0444 - Tatar
;                               0x044A - Telugu
;                               0x041E - Thai
;                               0x0451 - Tibetan
;                               0x0431 - Tsonga
;                               0x0432 - Tswana
;                               0x041F - Turkish
;                               0x0442 - Turkmen
;                               0x0422 - Ukrainian
;                               0x0420 - Urdu
;                               0x0843 - Uzbek Cyrillic
;                               0x0443 - Uzbek Latin
;                               0x0433 - Venda
;                               0x042A - Vietnamese
;                               0x0452 - Welsh
;                               0x0434 - Xhosa
;                               0x0435 - Zulu
;
;                  $iFlags    - The new input locale. This parameter can be one or more of the following values.
;
;                               $INPUTLANGCHANGE_BACKWARD
;                               $INPUTLANGCHANGE_FORWARD
;                               $INPUTLANGCHANGE_SYSCHARSET
;
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetKeyboardLayout($hWnd, $iLanguage, $iFlags = 0)

	If Not _WinAPI_IsWindow($hWnd) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hLocale = 0

	If $iLanguage Then
		$hLocale = _WinAPI_LoadKeyboardLayout($iLanguage)
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	DllCall('user32.dll', 'none', 'SendMessage', 'hwnd', $hWnd, 'uint', 0x0050, 'uint', $iFlags, 'ptr', $hLocale)
	Return 1
EndFunc   ;==>_WinAPI_SetKeyboardLayout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetKeyboardState
; Description....: Copies a 256-byte array of keyboard key states into the calling process's keyboard input-state table.
; Syntax.........: _WinAPI_SetKeyboardState ( $tState )
; Parameters.....: $tData  - "byte[256]" structure that contains keyboard key states.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function alters the input state of the calling process and not the global input state of the system.
;                  You cannot use this function to set the NUM LOCK, CAPS LOCK, or SCROLL LOCK indicator lights on the
;                  keyboard.
; Related........:
; Link...........: @@MsdnLink@@ SetKeyboardState
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetKeyboardState($tData)

	Local $Ret = DllCall('user32.dll', 'int', 'SetKeyboardState', 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetKeyboardState

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetLocaleInfo
; Description....: Sets an item of information in the user override portion of the current locale.
; Syntax.........: _WinAPI_SetLocaleInfo ( $LCID, $iType, $sData )
; Parameters.....: $LCID   - Locale identifier for which to set information or one of the following predefined values.
;
;                            $LOCALE_CUSTOM_DEFAULT
;                            $LOCALE_CUSTOM_UI_DEFAULT
;                            $LOCALE_CUSTOM_UNSPECIFIED
;
;                            $LOCALE_INVARIANT
;                            $LOCALE_SYSTEM_DEFAULT
;                            $LOCALE_USER_DEFAULT
;
;                  $iType  - Type of locale information to set. This parameter can be one of the $LOCALE_* constants.
;                  $sData  - The string containing the locale information to set. The information must be in the format specific to
;                            the specified constant.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetLocaleInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetLocaleInfo($LCID, $iType, $sData)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetLocaleInfoW', 'long', $LCID, 'dword', $iType, 'wstr', $sData)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetLocaleInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetMapMode
; Description....: Sets the mapping mode of the specified device context.
; Syntax.........: _WinAPI_SetMapMode ( $hDC, $iMode )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iMode  - The new mapping mode. This parameter can be one of the following values.
;
;                            $MM_ANISOTROPIC
;                            $MM_HIENGLISH
;                            $MM_HIMETRIC
;                            $MM_ISOTROPIC
;                            $MM_LOENGLISH
;                            $MM_LOMETRIC
;                            $MM_TEXT
;                            $MM_TWIPS
;
; Return values..: Success - The previous mapping mode.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetMapMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetMapMode($hDC, $iMode)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetMapMode', 'hwnd', $hDC, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetMapMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetMetaFileBitsEx
; Description ...: Creates a memory-based Windows-format metafile from the supplied data
; Syntax.........: _WinAPI_SetMetaFileBitsEx($iSize, $pData)
; Parameters ....: $iSize - Specifies the size, in bytes, of the Windows-format metafile
;                  $pData - Pointer to a buffer that contains the Windows-format metafile
; Return values .: Success      - A handle to a memory-based Windows-format metafile
;                  Failure      - 0
; Remarks .......: None
; Related .......: _GDIPlus_MetafileEmfToWmfBits, _WinAPI_DeleteMetaFile
; Link ..........; @@MsdnLink@@ SetMetaFileBitsEx
; Example .......; No
; ===============================================================================================================================
Func _WinAPI_SetMetaFileBitsEx($iSize, $pData)
	Local $aResult = DllCall("gdi32.dll", "hwnd", "SetMetaFileBitsEx", "uint", $iSize, "ptr", $pData)

	If @error Then Return SetError(@error, @extended, 0)
	Return $aResult[0]
EndFunc   ;==>_WinAPI_SetMetaFileBitsEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetMessageExtraInfo
; Description....: Sets the extra message information for the current thread.
; Syntax.........: _WinAPI_SetMessageExtraInfo ( $lParam )
; Parameters.....: $lParam - The value of LPARAM type to be associated with the current thread.
; Return values..: Success - The previous value associated with the current thread.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetMessageExtraInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetMessageExtraInfo($lParam)

	Local $Ret = DllCall('user32.dll', 'lparam', 'SetMessageExtraInfo', 'lparam', $lParam)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetMessageExtraInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetPixel
; Description....: Sets the pixel at the specified coordinates to the specified color.
; Syntax.........: _WinAPI_SetPixel ( $hDC, $iX, $iY, $iRGB )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical units, of the point to be set.
;                  $iY     - The y-coordinate, in logical units, of the point to be set.
;                  $iRGB   - The color to be used to paint the point.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetPixelV
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetPixel($hDC, $iX, $iY, $iRGB)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetPixelV', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'dword', __RGB($iRGB))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetPixel

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetPolyFillMode
; Description....: Sets the polygon fill mode for functions that fill polygons.
; Syntax.........: _WinAPI_SetPolyFillMode ( $hDC [, $iMode] )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iMode  - The new fill mode. This parameter can be one of the following values.
;
;                            $ALTERNATE
;                            $WINDING
;
; Return values..: Success - The previous filling mode.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetPolyFillMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetPolyFillMode($hDC, $iMode = 1)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetPolyFillMode', 'hwnd', $hDC, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetPolyFillMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetProcessShutdownParameters
; Description....: Sets a shutdown order for a process relative to the other processes in the system.
; Syntax.........: _WinAPI_SetProcessShutdownParameters ( $iLevel [, $fDialog] )
; Parameters.....: $iLevel -  The shutdown priority. The system shuts down processes from high $iLevel values to low. The highest
;                             and lowest shutdown priorities are reserved for system components. This parameter must be in the
;                             following range of values.
;
;                             0x0000-0x00FF - System reserved last shutdown range.
;                             0x0100-0x01FF - Application reserved last shutdown range.
;                             0x0200-0x02FF - Application reserved "in between" shutdown range.
;                             0x0300-0x03FF - Application reserved first shutdown range.
;                             0x0400-0x04FF - System reserved first shutdown range.
;
;                             All processes start at shutdown level 0x0280.
;
;                  $fDialog - Specifies whether display a retry dialog box for the user, valid values:
;                  |TRUE    - Display a retry dialog box if process takes longer than the specified timeout to shutdown.
;                  |FALSE   - Directly terminates the process. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetProcessShutdownParameters
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetProcessShutdownParameters($iLevel, $fDialog = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetProcessShutdownParameters', 'dword', $iLevel, 'dword', Not $fDialog)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetProcessShutdownParameters

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetRectRgn
; Description....: Converts a region into a rectangular region with the specified coordinates.
; Syntax.........: _WinAPI_SetRectRgn ( $hRgn, $tRECT )
; Parameters.....: $hRgn   - Handle to the region.
;                  $tRECT  - $tagRECT structure that contains the coordinates of the rectangular region in logical units.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetRectRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetRectRgn($hRgn, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetRectRgn', 'ptr', $hRgn, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetRectRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetROP2
; Description....: Retrieves the foreground mix mode of the specified device context.
; Syntax.........: _WinAPI_SetROP2 ( $hDC, $iMode )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iMode  - The mix mode. This parameter can be one of the following values.
;
;                            $R2_BLACK
;                            $R2_COPYPEN
;                            $R2_LAST
;                            $R2_MASKNOTPEN
;                            $R2_MASKPEN
;                            $R2_MASKPENNOT
;                            $R2_MERGENOTPEN
;                            $R2_MERGEPEN
;                            $R2_MERGEPENNOT
;                            $R2_NOP
;                            $R2_NOT
;                            $R2_NOTCOPYPEN
;                            $R2_NOTMASKPEN
;                            $R2_NOTMERGEPEN
;                            $R2_NOTXORPEN
;                            $R2_WHITE
;                            $R2_XORPEN
;
; Return values..: Success - The value that specifies the previous mix mode.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Mix modes define how GDI combines source and destination colors when drawing with the current pen. The mix modes
;                  are binary raster operation codes, representing all possible Boolean functions of two variables, using the binary
;                  operations AND, OR, and XOR (exclusive OR), and the unary operation NOT. The mix mode is for raster devices only;
;                  it is not available for vector devices.
; Related........:
; Link...........: @@MsdnLink@@ SetROP2
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetROP2($hDC, $iMode)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetROP2', 'hwnd', $hDC, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetROP2

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetStretchBltMode
; Description....: Sets the bitmap stretching mode in the specified device context.
; Syntax.........: _WinAPI_SetStretchBltMode ( $hDC, $iMode )
; Parameters.....: $hDC     - Handle to the device context.
;                  $iMode   - The stretching mode. This parameter can be one of the following values.
;
;                             $BLACKONWHITE
;                             $COLORONCOLOR
;                             $HALFTONE
;                             $WHITEONBLACK
;                             $STRETCH_ANDSCANS
;                             $STRETCH_DELETESCANS
;                             $STRETCH_HALFTONE
;                             $STRETCH_ORSCANS
;
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The $BLACKONWHITE ($STRETCH_ANDSCANS) and $WHITEONBLACK ($STRETCH_ORSCANS) modes are typically used to
;                  preserve foreground pixels in monochrome bitmaps. The $COLORONCOLOR ($STRETCH_DELETESCANS) mode is typically
;                  used to preserve color in color bitmaps. The $HALFTONE ($STRETCH_HALFTONE) mode is slower and requires more
;                  processing of the source image than the other three modes; but produces higher quality images.
; Related........:
; Link...........: @@MsdnLink@@ SetStretchBltMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetStretchBltMode($hDC, $iMode)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetStretchBltMode', 'hwnd', $hDC, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetStretchBltMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetSystemCursor
; Description....: Enables an application to customize the system cursors.
; Syntax.........: _WinAPI_SetSystemCursor ( $hCursor, $ID [, $fCopy] )
; Parameters.....: $hCursor - Handle to a cursor.
;                  $ID      - This parameter specifies the system cursor to replace with the contents of $hCursor, and can be
;                             one of the following values.
;
;                             $OCR_APPSTARTING
;                             $OCR_NORMAL
;                             $OCR_CROSS
;                             $OCR_HAND
;                             $OCR_IBEAM
;                             $OCR_NO
;                             $OCR_SIZEALL
;                             $OCR_SIZENESW
;                             $OCR_SIZENS
;                             $OCR_SIZENWSE
;                             $OCR_SIZEWE
;                             $OCR_UP
;                             $OCR_WAIT
;                             $OCR_ICON
;                             $OCR_SIZE
;
;                  $fCopy   - Specifies whether the cursor should be duplicated, valid values:
;                  |TRUE    - The cursor is duplicated.
;                  |FALSE   - The cursor is not duplicated. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function replaces the contents of the system cursor specified by ID with the contents of the cursor handled
;                  by $hCursor. The system destroys $hCursor by calling the _WinAPI_DestroyCursor() function. Therefore, $hCursor cannot
;                  be a cursor loaded using the _WinAPI_LoadCursor() function. To specify a cursor loaded from a resource, copy the
;                  cursor using the _WinAPI_CopyCursor() function, then pass the copy to _WinAPI_SetSystemCursor().
; Related........:
; Link...........: @@MsdnLink@@ SetSystemCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetSystemCursor($hCursor, $ID, $fCopy = 0)

	If $fCopy Then
		$hCursor = _WinAPI_CopyCursor($hCursor)
	EndIf

	Local $Ret = DllCall('user32.dll', 'int', 'SetSystemCursor', 'ptr', $hCursor, 'dword', $ID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetSystemCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetTextAlign
; Description....: Sets the text-alignment flags for the specified device context.
; Syntax.........: _WinAPI_SetTextAlign ($hDC [, $iMode] )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iMode  - The text alignment by using a mask of the values in the following list. Only one flag can be chosen
;                            from those that affect horizontal and vertical alignment. In addition, only one of the two flags that
;                            alter the current position can be chosen.
;
;                            $TA_BASELINE
;                            $TA_BOTTOM
;                            $TA_TOP
;                            $TA_CENTER
;                            $TA_LEFT
;                            $TA_RIGHT
;                            $TA_NOUPDATECP
;                            $TA_RTLREADING
;                            $TA_UPDATECP
;
;                            When the current font has a vertical default base line, as with Kanji, the following values must be
;                            used instead of $TA_BASELINE and $TA_CENTER.
;
;                            $VTA_BASELINE
;                            $VTA_CENTER
;
;                            The default values are $TA_LEFT, $TA_TOP, and $TA_NOUPDATECP.
;
; Return values..: Success - The previous text-alignment setting ($TA_* and $VTA_*).
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetTextAlign
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetTextAlign($hDC, $iMode = 0)

	Local $Ret = DllCall('gdi32.dll', 'uint', 'SetTextAlign', 'hwnd', $hDC, 'uint', $iMode)

	If (@error) Or ($Ret[0] = 0xFFFFFFFF) Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetTextAlign

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetTextCharacterExtra
; Description....: Sets the intercharacter spacing for the specified device context.
; Syntax.........: _WinAPI_SetTextCharacterExtra ( $hDC, $iCharExtra )
; Parameters.....: $hDC        - Handle to the device context.
;                  $iCharExtra - The amount of extra space, in logical units, to be added to each character.
; Return values..: Success     - The previous intercharacter spacing.
;                  Failure     - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetTextCharacterExtra
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetTextCharacterExtra($hDC, $iCharExtra)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetTextCharacterExtra', 'hwnd', $hDC, 'int', $iCharExtra)

	If (@error) Or ($Ret[0] = 0x80000000) Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetTextCharacterExtra

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetTextJustification
; Description....: Specifies the amount of space the system should add to the break characters in a string of text.
; Syntax.........: _WinAPI_SetTextJustification ( $hDC, $iBreakExtra, $iBreakCount )
; Parameters.....: $hDC         - Handle to the device context.
;                  $iBreakExtra - The total extra space, in logical units, to be added to the line of text.
;                  $iBreakCount - The number of break characters in the line.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetTextJustification
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetTextJustification($hDC, $iBreakExtra, $iBreakCount)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetTextJustification', 'hwnd', $hDC, 'int', $iBreakExtra, 'int', $iBreakCount)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetTextJustification

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetThemeAppProperties
; Description....: Sets the flags that determine how visual styles are implemented in the calling application.
; Syntax.........: _WinAPI_SetThemeAppProperties ( $iFlags )
; Parameters.....: $iFlags  - This parameter can be one or more of the following values.
;
;                            $STAP_ALLOW_NONCLIENT
;                            $STAP_ALLOW_CONTROLS
;                            $STAP_ALLOW_WEBCONTENT
;
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After you set the flags, you must send a WM_THEMECHANGED message for the changes to take effect.
; Related........:
; Link...........: @@MsdnLink@@ SetThemeAppProperties
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetThemeAppProperties($iFlags)
	DllCall('uxtheme.dll', 'none', 'SetThemeAppProperties', 'dword', $iFlags)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetThemeAppProperties

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetThreadDesktop
; Description....: Assigns the specified desktop to the calling thread.
; Syntax.........: _WinAPI_SetThreadDesktop ( $hDesktop )
; Parameters.....: $hDesktop - Handle to the desktop to be assigned to the calling thread. This desktop must be associated with the
;                              current window station for the process.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_SetThreadDesktop() function will fail if the calling thread has any windows or hooks on its current
;                  desktop (unless the hDesktop parameter is a handle to the current desktop).
; Related........:
; Link...........: @@MsdnLink@@ SetThreadDesktop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetThreadDesktop($hDesktop)

	Local $Ret = DllCall('user32.dll', 'int', 'SetThreadDesktop', 'ptr', $hDesktop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetThreadDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetThreadErrorMode
; Description....: Controls whether the system will handle the specified types of serious errors or whether the calling thread will handle them.
; Syntax.........: _WinAPI_SetThreadErrorMode ( $iMode )
; Parameters.....: $iMode  - The thread error mode. This parameter can be one or more of the following values.
;
;                            $SEM_FAILCRITICALERRORS
;                            $SEM_NOGPFAULTERRORBOX
;                            $SEM_NOOPENFILEERRORBOX
;
; Return values..: Success - The thread's previous error mode ($SEM_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ SetThreadErrorMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetThreadErrorMode($iMode)

	Local $Ret = DllCall('kernel32.dll', 'uint', 'SetThreadErrorMode', 'uint', $iMode, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_SetThreadErrorMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetThreadExecutionState
; ===============================================================================================================================
Func _WinAPI_SetThreadExecutionState($iFlag)
	Local $Ret = DllCall("Kernel32.dll", "long", "SetThreadExecutionState", "long", $iFlag)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetThreadExecutionState


; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetTimer
; Description....: Creates a timer with the specified time-out value.
; Syntax.........: _WinAPI_SetTimer ( $hWnd, $iTimerID, $iElapse, $pTimerFunc )
; Parameters.....: $hWnd       - Handle to the window to be associated with the timer. This window must be owned by the calling
;                                process. If a 0 value for $hWnd is passed in along with an $iTimerID of an existing timer, that
;                                timer will be replaced in the same way that an existing non-zero $hWnd timer will be.
;                  $iTimerID   - The timer identifier. If the $hWnd parameter is 0, and the $iTimerID does not match an existing
;                                timer then it is ignored and a new timer ID is generated. If the $hWnd parameter is not 0 and
;                                the window specified by $hWnd already has a timer with the value $iTimerID, then the existing
;                                timer is replaced by the new timer. When _WinAPI_SetTimer() replaces a timer, the timer is reset.
;                                Therefore, a message will be sent after the current time-out value elapses, but the previously
;                                set time-out value is ignored. If the call is not intended to replace an existing timer,
;                                $iTimerID should be 0 if the $hWnd is 0.
;                  $iElapse    - The time-out value, in milliseconds.
;                  $pTimerFunc - The address of a callback function to be notified when the time-out value elapses. If this
;                                parameter is 0, the system posts a WM_TIMER message to the application queue.
;
;                                (See MSDN for more information)
;
; Return values..: Success     - The timer identifier. An application can pass this value to the _WinAPI_KillTimer() function to
;                                destroy the timer.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The timer identifier, $iTimerID, is specific to the associated window. Another window can have its own timer
;                  which has the same identifier as a timer owned by another window. The timers are distinct.
; Related........:
; Link...........: @@MsdnLink@@ SetTimer
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetTimer($hWnd, $iTimerID, $iElapse, $pTimerFunc)

	Local $Ret = DllCall('user32.dll', 'uint_ptr', 'SetTimer', 'hwnd', $hWnd, 'uint_ptr', $iTimerID, 'uint', $iElapse, 'ptr', $pTimerFunc)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetTimer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetVolumeMountPoint
; Description....: Associates a volume with a drive letter or a directory on another volume.
; Syntax.........: _WinAPI_SetVolumeMountPoint ( $sPath, $GUID )
; Parameters.....: $sPath  - The user-mode path to be associated with the volume. This may be a drive letter (for example, X:\)
;                            or a directory on another volume (for example, Y:\MountX).
;                  $GUID   - The volume GUID path for the volume. This string must be of the form "\\?\Volume{GUID}\" where
;                            GUID is a GUID that identifies the volume. The \\?\ turns off path parsing and is ignored as part
;                            of the path.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: It is an error to associate a volume with a directory that has any files or subdirectories in it. This error
;                  occurs for system and hidden directories as well as other directories, and it occurs for system and hidden
;                  files.
; Related........:
; Link...........: @@MsdnLink@@ SetVolumeMountPoint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetVolumeMountPoint($sPath, $GUID)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetVolumeMountPointW', 'wstr', $sPath, 'wstr', $GUID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetVolumeMountPoint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWindowDisplayAffinity
; Description....: Stores the display affinity setting in kernel mode on the specified window.
; Syntax.........: _WinAPI_SetWindowDisplayAffinity ( $hWnd, $iAffinity )
; Parameters.....: $hWnd      - Handle to the window.
;                  $iAffinity - The display affinity setting. This setting specifies where the window's contents are allowed
;                               to be displayed. This parameter can be a combination of the following values.
;
;                               $WDA_MONITOR
;
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_SetWindowDisplayAffinity() are designed to support the window content protection. This functions
;                  enables applications to protect their own onscreen window content from being captured or copied through a specific
;                  set of public operating system features and APIs. However, it works only when the Desktop Window Manager(DWM)
;                  is composing the desktop.
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ SetWindowDisplayAffinity
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWindowDisplayAffinity($hWnd, $iAffinity)

	Local $Ret = DllCall('user32.dll', 'int', 'SetWindowDisplayAffinity', 'hwnd', $hWnd, 'dword', $iAffinity)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetWindowDisplayAffinity

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWindowExt
; Description....: Sets the horizontal and vertical extents of the window for a device context by using the specified values.
; Syntax.........: _WinAPI_SetWindowExt ( $hDC, $iXExtent, $iYExtent )
; Parameters.....: $hDC      - Handle to the device context.
;                  $iXExtent - The window's horizontal extent in logical units.
;                  $iYExtent - The window's vertical extent in logical units.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_SetWindowExt() works only if $MM_ANISOTROPIC or $MM_ISOTROPIC mapping modes are set,  otherwise,
;                  calls to this function are ignored.
; Related........:
; Link...........: @@MsdnLink@@ SetWindowExtEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWindowExt($hDC, $iXExtent, $iYExtent)

	$__Ext = DllStructCreate($tagSIZE)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetWindowExtEx', 'hwnd', $hDC, 'int', $iXExtent, 'int', $iYExtent, 'ptr', DllStructGetPtr($__Ext))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetWindowExt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWindowLongEx
; Description....: Changes an attribute of the specified window.
; Syntax.........: _WinAPI_SetWindowLongEx ( $hWnd, $iIndex, $iNewLong )
; Parameters.....: $hWnd     - Handle to the window.
;                  $iIndex   - The zero-based offset to the value to be set. Valid values are in the range zero through the
;                              number of bytes of extra window memory, minus the size of an integer. To set any other value,
;                              specify one of the following values.
;
;                              $GWL_EXSTYLE
;                              $GWL_HINSTANCE
;                              $GWL_ID
;                              $GWL_STYLE
;                              $GWL_USERDATA
;                              $GWL_WNDPROC
;
;                  $iNewLong - The replacement value.
; Return values..: Success   - The previous value.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetWindowLong
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWindowLongEx($hWnd, $iIndex, $iNewLong)

	Local $Ret

	If StringInStr(@OSArch, '64') Then
		$Ret = DllCall('user32.dll', 'long_ptr', 'SetWindowLongPtrW', 'hwnd', $hWnd, 'int', $iIndex, 'long_ptr', $iNewLong)
	Else
		$Ret = DllCall('user32.dll', 'long', 'SetWindowLongW', 'hwnd', $hWnd, 'int', $iIndex, 'long', $iNewLong)
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetWindowLongEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWindowOrg
; Description....: Specifies which window point maps to the viewport origin (0,0).
; Syntax.........: _WinAPI_SetWindowOrg ( $hDC, $iX, $iY )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical units, of the new window origin.
;                  $iY     - The y-coordinate, in logical units, of the new window origin.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetWindowOrgEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWindowOrg($hDC, $iX, $iY)

	$__Ext = DllStructCreate($tagPOINT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetWindowOrgEx', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'ptr', DllStructGetPtr($__Ext))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetWindowOrg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWindowSubclass
; Description....: Installs or updates a window subclass callback.
; Syntax.........: _WinAPI_SetWindowSubclass ( $hWnd, $pSubclassProc, $ID [, $pData] )
; Parameters.....: $hWnd          - Handle of the window being subclassed.
;                  $pSubclassProc - A pointer to a window procedure. This pointer and the subclass ID uniquely identify this subclass callback.
;
;                                   (See MSDN for more information)
;
;                  $ID            - The subclass ID.
;                  $pData         - The reference data. This value is passed to the subclass procedure. The meaning of this value is
;                                   determined by the calling application.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Subclass callbacks are identified by the combination of the callback address and the caller-defined subclass ID.
;                  If the callback address and ID pair have not yet been installed, then this function installs the subclass, otherwise,
;                  this function just updates the reference data.
; Related........:
; Link...........: @@MsdnLink@@ SetWindowSubclass
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWindowSubclass($hWnd, $pSubclassProc, $ID, $pData = 0)

	Local $Ret = DllCall('comctl32.dll', 'int', 'SetWindowSubclass', 'hwnd', $hWnd, 'ptr', $pSubclassProc, 'uint_ptr', $ID, 'dword_ptr', $pData)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetWindowSubclass

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWindowTheme
; Description....: Causes a window to use a different set of visual style information than its class normally uses.
; Syntax.........: _WinAPI_SetWindowTheme ( $hWnd [, $sName [, $sList]] )
; Parameters.....: $hWnd   - Handle to the window whose visual style information is to be changed.
;                  $sName  - A string that contains the application name. If this parameter is 0, the calling application's name is used.
;                  $sList  - A string that contains a semicolon-separated list of CLSID names to use in place of the actual list
;                            passed by the window's class. If this parameter is 0, the ID list from the calling class is used.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The theme manager retains the $sName and the $sList associations through the lifetime of the window, even
;                  if visual styles subsequently change.
;
;                  When $sName and $sList are 0, the theme manager removes the previously applied associations. To prevent visual
;                  styles from being applied to a specified window, pass an empty string ("") which will not match any section
;                  entries.
; Related........:
; Link...........: @@MsdnLink@@ SetWindowTheme
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWindowTheme($hWnd, $sName = 0, $sList = 0)

	Local $TypeOfName = 'wstr', $TypeOfList = 'wstr'

	If Not IsString($sName) Then
		$TypeOfName = 'ptr'
		$sName = 0
	EndIf
	If Not IsString($sList) Then
		$TypeOfList = 'ptr'
		$sList = 0
	EndIf

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'SetWindowTheme', 'hwnd', $hWnd, $TypeOfName, $sName, $TypeOfList, $sList)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetWindowTheme

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWinEventHook
; Description....: Sets an event hook function for a range of events.
; Syntax.........: _WinAPI_SetWinEventHook( $iEventMin, $iEventMax, $pWinEventProc [, $iProcessID [, $iThreadID [, $iFlags]]] )
; Parameters.....: $iEventMin  - The lowest event value in the range of events ($EVENT_*) that are handled by the hook function.
;                  $iEventMax  - The highest event value in the range of events ($EVENT_*) that are handled by the hook function.
;                  $pEventProc - The address of an application-defined hook function that the system calls in response to
;                                events generated by an accessible object.
;                  $iProcessID - The ID of the process from which the hook function receives events. If this parameter is 0,
;                                the hook function is associated with all existing processes on the current desktop.
;                  $iThreadID  - The ID of the thread from which the hook function receives events. If this parameter is 0,
;                                the hook function is associated with all existing threads on the current desktop.
;                  $iFlags     - The flags that specify the location of the hook function and of the events to be skipped.
;                                The following flags are valid:
;
;                                $WINEVENT_INCONTEXT
;                                $WINEVENT_OUTOFCONTEXT
;                                $WINEVENT_SKIPOWNPROCESS
;                                $WINEVENT_SKIPOWNTHREAD
;
;                                The following single flags, or flag combinations are valid:
;
;                                $WINEVENT_INCONTEXT
;                                $WINEVENT_OUTOFCONTEXT
;                                $WINEVENT_INCONTEXT | $WINEVENT_SKIPOWNPROCESS
;                                $WINEVENT_INCONTEXT | $WINEVENT_SKIPOWNTHREAD
;                                $WINEVENT_OUTOFCONTEXT | $WINEVENT_SKIPOWNPROCESS
;                                $WINEVENT_OUTOFCONTEXT | $WINEVENT_SKIPOWNTHREAD
;
; Return values..: Success     - A value that identifies this event hook instance.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: Clients can call _WinAPI_SetWinEventHook() multiple times if they want to register additional hook functions
;                  or listen for additional events.
; Related........:
; Link...........: @@MsdnLink@@ SetWinEventHook
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWinEventHook($iEventMin, $iEventMax, $pEventProc, $iProcessID = 0, $iThreadID = 0, $iFlags = 0)

	Local $Ret = DllCall('user32.dll', 'ptr', 'SetWinEventHook', 'uint', $iEventMin, 'uint', $iEventMax, 'ptr', 0, 'ptr', $pEventProc, 'dword', $iProcessID, 'dword', $iThreadID, 'uint', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetWinEventHook

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWorldTransform
; Description....: Sets a two-dimensional linear transformation between world space and page space for the specified device context.
; Syntax.........: _WinAPI_SetWorldTransform ( $hDC, $tXFORM )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tXFORM - $tagXFORM structure that contains the transformation data.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_SetWorldTransform() will fail unless the graphics mode for the given device context has been set
;                  to $GM_ADVANCED by previously calling the _WinAPI_SetGraphicsMode(). Likewise, it will not be possible to reset
;                  the graphics mode for the device context to the default $GM_COMPATIBLE mode, unless the world transformation
;                  has first been reset to the default identity transformation by calling _WinAPI_SetWorldTransform().
;
;                  For any coordinates (x, y) in world space, the transformed coordinates in page space (x', y') can be
;                  determined by the following algorithm:
;
;                  x' = x * eM11 + y * eM21 + eDx
;                  y' = x * eM12 + y * eM22 + eDy
;
; Related........:
; Link...........: @@MsdnLink@@ SetWorldTransform
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWorldTransform($hDC, $tXFORM )

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetWorldTransform', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tXFORM))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetWorldTransform

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SfcIsFileProtected
; Description....: Determines whether the specified file is protected.
; Syntax.........: _WinAPI_SfcIsFileProtected ( $sFile )
; Parameters.....: $sFile  - The name of the file to test.
; Return values..: Success - 1 - The file is protected.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SfcIsFileProtected
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SfcIsFileProtected($sFile)

	If Not __DLL('sfc.dll') Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('sfc.dll', 'int', 'SfcIsFileProtected', 'ptr', 0, 'wstr', $sFile)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SfcIsFileProtected

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SfcIsKeyProtected
; Description....: Determines whether the specified registry key is protected.
; Syntax.........: _WinAPI_SfcIsKeyProtected ( $hKey [, $sSubKey [, $iFlag]] )
; Parameters.....: $hKey    - Handle to the root registry key or one of the following predefined keys.
;
;                             $HKEY_CLASSES_ROOT
;                             $HKEY_CURRENT_USER
;                             $HKEY_LOCAL_MACHINE
;                             $HKEY_USERS
;
;                  $sSubKey -
;                  $iFlag   - The flag that specifies the alternate registry view that should be used by applications that run on
;                             64-bit Windows. This flag is ignored on the x86 platform. It can be one of the following values.
;
;                             $KEY_WOW64_32KEY
;                             $KEY_WOW64_64KEY
;
; Return values..: Success  - 1 - The key is protected
;                             0 - Otherwise.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SfcIsKeyProtected
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SfcIsKeyProtected($hKey, $sSubKey = '', $iFlag = 0)

	If Not __DLL('sfc.dll') Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('sfc.dll', 'int', 'SfcIsKeyProtected', 'ulong_ptr', $hKey, 'wstr', $sSubKey, 'dword', $iFlag)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SfcIsKeyProtected

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShareFolderDlg
; Description....: Displays the Folder Sharing tab on the properties sheet for the specified folder.
; Syntax.........: _WinAPI_ShareFolderDlg ( $sPath [, $hParent] )
; Parameters.....: $sPath   - The path to the folder that displays its Folder Sharing tab.
;                  $hParent - Handle to a parent window for the property sheet.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ShowShareFolderUI
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShareFolderDlg($sPath, $hParent = 0)

	Local $Ret = DllCall('ntshrui.dll', 'int', 'ShowShareFolderUIW', 'hwnd', $hParent, 'wstr', $sPath)
	If @error Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShareFolderDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellAddToRecentDocs
; Description....: Adds a file to the most recently and frequently item list.
; Syntax.........: _WinAPI_ShellAddToRecentDocs ( $sFile )
; Parameters.....: $sFile  - The name of the file to be added. Set this parameter to empty string to clear all usage data on all items.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHAddToRecentDocs
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellAddToRecentDocs($sFile)

	Local $TypeOfFile = 'wstr'

	If StringStripWS($sFile, 3) Then
		$sFile = _WinAPI_PathSearchAndQualify($sFile, 1)
		If Not $sFile Then
			Return SetError(1, 0, 0)
		EndIf
	Else
		$TypeOfFile = 'ptr'
		$sFile = 0
	EndIf
	DllCall('shell32.dll', 'none', 'SHAddToRecentDocs', 'uint', 3, $TypeOfFile, $sFile)
	If @error Then
		Return SetError(2, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellAddToRecentDocs

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellAppBarMessage
; ===============================================================================================================================
Func _WinAPI_ShellAppBarMessage($Message)

	Local $tAPPBARAPPBARDATA = DllStructCreate($tagAPPBARAPPBARDATA)
	Local $hAPPBAR = WinGetHandle("[CLASS:Shell_TrayWnd]", "") ; Get handle of taskbar
	
	DllStructSetData($tAPPBARAPPBARDATA, "hWnd", $hAPPBAR) ; Set handle to taskbar
	DllStructSetData($tAPPBARAPPBARDATA, "cbSize", DllStructGetSize($tAPPBARAPPBARDATA)) ; Set size of struct

	Local $Ret = DllCall("shell32.dll", "int", "SHAppBarMessage", "int", $Message, "ptr", DllStructGetPtr($tAPPBARAPPBARDATA))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Local $Result[5]
	$Result[0] = DllStructGetData($tAPPBARAPPBARDATA, 'uEdge')
	$Result[1] = DllStructGetData($tAPPBARAPPBARDATA, 'Left')
	$Result[2] = DllStructGetData($tAPPBARAPPBARDATA, 'Top')
	$Result[3] = DllStructGetData($tAPPBARAPPBARDATA, 'Right')
	$Result[4] = DllStructGetData($tAPPBARAPPBARDATA, 'Bottom')

	Return $Result
EndFunc   ;==>_WinAPI_ShellAppBarMessage


; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellChangeNotify
; Description....: Notifies the system of an event that an application has performed.
; Syntax.........: _WinAPI_ShellChangeNotify ( $iEvent, $iFlags [, $iItem1 [, $iItem2]] )
; Parameters.....: $iEvent - Describes the event that has occurred. Typically, only one event is specified at a time. If more than
;                            one event is specified, the values contained in the $iItem2 and $iItem2 parameters must be the same,
;                            respectively, for all specified events. This parameter can be one or more of the following values.
;
;                            $SHCNE_ALLEVENTS
;                            $SHCNE_ASSOCCHANGED
;                            $SHCNE_ATTRIBUTES
;                            $SHCNE_CREATE
;                            $SHCNE_DELETE
;                            $SHCNE_DRIVEADD
;                            $SHCNE_DRIVEADDGUI
;                            $SHCNE_DRIVEREMOVED
;                            $SHCNE_EXTENDED_EVENT
;                            $SHCNE_FREESPACE
;                            $SHCNE_MEDIAINSERTED
;                            $SHCNE_MEDIAREMOVED
;                            $SHCNE_MKDIR
;                            $SHCNE_NETSHARE
;                            $SHCNE_NETUNSHARE
;                            $SHCNE_RENAMEFOLDER
;                            $SHCNE_RENAMEITEM
;                            $SHCNE_RMDIR
;                            $SHCNE_SERVERDISCONNECT
;                            $SHCNE_UPDATEDIR
;                            $SHCNE_UPDATEIMAGE
;                            $SHCNE_UPDATEITEM
;                            $SHCNE_DISKEVENTS
;                            $SHCNE_GLOBALEVENTS
;                            $SHCNE_INTERRUPT
;
;                            (See MSDN for more information)
;
;                  $iFlags - Flags that indicate the meaning of the $iItem1 and $iItem2 parameters. This parameter must be one
;                            of the following values.
;
;                            $SHCNF_DWORD
;                            $SHCNF_IDLIST
;                            $SHCNF_PATH
;                            $SHCNF_PRINTER
;                            $SHCNF_FLUSH
;                            $SHCNF_FLUSHNOWAIT
;                            $SHCNF_NOTIFYRECURSIVE
;
;                            (See MSDN for more information)
;
;                  $iItem1 - First event-dependent value.
;                  $iItem2 - Second event-dependent value.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHChangeNotify
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellChangeNotify($iEvent, $iFlags, $iItem1 = 0, $iItem2 = 0)

	Local $TypeOfItem1 = 'dword_ptr', $TypeOfItem2 = 'dword_ptr'

	If IsString($iItem1) Then
		$TypeOfItem1 = 'wstr'
	EndIf
	If IsString($iItem2) Then
		$TypeOfItem2 = 'wstr'
	EndIf
	DllCall('shell32.dll', 'none', 'SHChangeNotify', 'long', $iEvent, 'uint', $iFlags, $TypeOfItem1, $iItem1, $TypeOfItem2, $iItem2)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellChangeNotify

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellChangeNotifyDeregister
; Description....: Unregisters the client's window.
; Syntax.........: _WinAPI_ShellChangeNotifyDeregister ( $ID )
; Parameters.....: $ID     - The value that specifies the registration ID returned by _WinAPI_ShellChangeNotifyRegister().
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHChangeNotifyDeregister
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellChangeNotifyDeregister($ID)

	Local $Ret = DllCall('shell32.dll', 'int', 'SHChangeNotifyDeregister', 'ulong', $ID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellChangeNotifyDeregister

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellChangeNotifyRegister
; Description....: Registers a window to receive notifications from the file system or Shell.
; Syntax.........: _WinAPI_ShellChangeNotifyRegister ( $hWnd, $iMsg, $iEvents, $iSources, $aPaths [, $fRecursive] )
; Parameters.....: $hWnd       - Handle to the window that receives the change or notification messages.
;                  $iMsg       - Message to be posted to the window procedure.
;                  $iEvents    - Change notification events for which to receive notification. This parameter can be one or more
;                                of the $SHCNE_* values.
;                  $iSources   - One or more of the following values that indicate the type of events for which to receive
;                                notifications.
;
;                                $SHCNRF_INTERRUPTLEVEL
;                                $SHCNRF_SHELLLEVEL
;                                $SHCNRF_RECURSIVEINTERRUPT
;                                $SHCNRF_NEWDELIVERY
;
;                  $aPaths     - Single path or array of paths for which to receive notifications. These names should be
;                                fully-qualified paths to prevent unexpected results.
;                  $fRecursive - Specifies whether to post notifications for children paths in $aPaths parameter, valid values:
;                  |TRUE       - Notifications would come from the folder's children.
;                  |FALSE      - Notifications would come from the specified folder's only. (Default)
; Return values..: Success     - The registration ID.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When a change notification event is raised, the message indicated by $iMsg is delivered to the window specified
;                  by the $hWnd parameter. (See example)
;
;                  For performance reasons, multiple notifications can be combined into a single notification. For example,
;                  if a large number of $SHCNE_UPDATEITEM notifications are generated for files in the same folder, they can be
;                  joined into a single $SHCNE_UPDATEDIR notification.
; Related........:
; Link...........: @@MsdnLink@@ SHChangeNotifyRegister
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellChangeNotifyRegister($hWnd, $iMsg, $iEvents, $iSources, $aPaths, $fRecursive = 0)

	Local $tEntry, $Path = $aPaths, $Struct = ''

	If IsArray($aPaths) Then
		If UBound($aPaths, 2) Then
			Return SetError(1, 0, 0)
		EndIf
	Else
		Dim $aPaths[1] = [$Path]
	EndIf
	For $i = 0 To UBound($aPaths) - 1
		If Not _WinAPI_PathIsDirectory($aPaths[$i]) Then
			Return SetError(1, 0, 0)
		EndIf
	Next
	For $i = 0 To UBound($aPaths) - 1
		$Struct &= 'ptr;int;'
	Next
	$tEntry = DllStructCreate($Struct)
	For $i = 0 To UBound($aPaths) - 1
		$aPaths[$i] = _WinAPI_ShellILCreateFromPath(_WinAPI_PathSearchAndQualify($aPaths[$i]))
		DllStructSetData($tEntry, 2 * $i + 1, $aPaths[$i])
		DllStructSetData($tEntry, 2 * $i + 2, $fRecursive)
	Next

	Local $Ret = DllCall('shell32.dll', 'ulong', 'SHChangeNotifyRegister', 'hwnd', $hWnd, 'int', $iSources, 'long', $iEvents, 'uint', $iMsg, 'int', UBound($aPaths), 'ptr', DllStructGetPtr($tEntry))

	If (Not @error) And ($Ret[0]) Then
		$Ret = $Ret[0]
	Else
		$Ret = 0
	EndIf
	For $i = 0 To UBound($aPaths) - 1
		_WinAPI_CoTaskMemFree($aPaths[$i])
	Next
	Return SetError(Number($Ret = 0), 0, $Ret)
EndFunc   ;==>_WinAPI_ShellChangeNotifyRegister

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellEmptyRecycleBin
; Description....: Empties the Recycle Bin on the specified drive.
; Syntax.........: _WinAPI_ShellEmptyRecycleBin ( $sRoot [, $iFlags [, $hParent]] )
; Parameters.....: $sRoot   - The string that contains the path of the root drive on which the Recycle Bin is located. This string
;                             can be formatted with the drive, folder, and subfolder names, for example "c:\windows\system\".
;                             If this parameter is empty string, all Recycle Bins on all drives will be emptied.
;                  $iFlags  - This parameter can be one or more of the following values.
;
;                             $SHERB_NOCONFIRMATION
;                             $SHERB_NOPROGRESSUI
;                             $SHERB_NOSOUND
;                             $SHERB_NO_UI
;
;                  $hParent - Handle to the parent window of any dialog boxes that might be displayed during the operation.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHEmptyRecycleBin
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellEmptyRecycleBin($sRoot, $iFlags = 0, $hParent = 0)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHEmptyRecycleBinW', 'hwnd', $hParent, 'wstr', $sRoot, 'dword', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellEmptyRecycleBin

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellExecute
; Description....: Performs an operation on a specified file.
; Syntax.........: _WinAPI_ShellExecute ( $sFile [, $sArgs [, $sDir [, $sVerb [, $iShow [, $hParent]]]]] )
; Parameters.....: $sFile   - The string that specifies the file or object on which to execute the specified verb. Note that not all
;                             verbs are supported on all objects. For example, not all document types support the "print" verb.
;                  $sArgs   - The string that specifies the parameters to be passed to the application.
;                  $sDir    - The string that specifies the working directory for the action.
;                  $sVerb   - The string, referred to as a verb, that specifies the action to be performed. The set of available verbs
;                             depends on the particular file or folder. Generally, the actions available from an object's shortcut
;                             menu are available verbs. The following verbs are commonly used:
;
;                             "edit"
;                             "explore"
;                             "find"
;                             "open"
;                             "edit"
;                             "print"
;
;                  $iShow   - The flags that specify how an application is to be displayed when it is opened ($SW_*).
;                  $hParent - Handle to the owner window used for displaying a UI or error messages.
; Return values..: Success  - A positive value greater than 32.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain an error value that indicates the
;                             cause of the failure. It can be one of the following values.
;
;                             ERROR_OUT_OF_MEM (0)
;                             ERROR_FILE_NOT_FOUND (2)
;                             ERROR_PATH_NOT_FOUND (3)
;                             ERROR_BAD_FORMAT (11)
;                             SE_ERR_*
;
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ShellExecute
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellExecute($sFile, $sArgs = '', $sDir = '', $sVerb = '', $iShow = 1, $hParent = 0)

	Local $TypeOfArgs = 'wstr', $TypeOfDir = 'wstr', $TypeOfVerb = 'wstr'

	If Not StringStripWS($sArgs, 3) Then
		$TypeOfArgs = 'ptr'
		$sArgs = 0
	EndIf
	If Not StringStripWS($sDir, 3) Then
		$TypeOfDir = 'ptr'
		$sDir = 0
	EndIf
	If Not StringStripWS($sVerb, 3) Then
		$TypeOfVerb = 'ptr'
		$sVerb = 0
	EndIf

	Local $Ret = DllCall('shell32.dll', 'uint_ptr', 'ShellExecuteW', 'hwnd', $hParent, $TypeOfVerb, $sVerb, 'wstr', $sFile, $TypeOfArgs, $sArgs, $TypeOfDir, $sDir, 'int', $iShow)

	If @error Then
		Return SetError(1, -1, 0)
	Else
		If $Ret[0] <= 32 Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ShellExecute

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellExtractAssociatedIcon
; Description....: Returns a handle to the icon that associated with the specified file's.
; Syntax.........: _WinAPI_ShellExtractAssociatedIcon ( $sFile [, $fSmall] )
; Parameters.....: $sFile  - The full path and file name of the file that contains the icon, or its extension, such as ".txt".
;                  $fSmall - Specifies whether extract a small icon, valid values:
;                  |TRUE   - Extract a small icon.
;                  |FALSE  - Extract a large icon. (Default)
; Return values..: Success - The icon handle.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellExtractAssociatedIcon($sFile, $fSmall = 0)

	Local $Flags = $SHGFI_ICON

	If Not _WinAPI_PathIsDirectory($sFile) Then
		$Flags = BitOR($Flags, $SHGFI_USEFILEATTRIBUTES)
	EndIf
	If $fSmall Then
		$Flags = BitOR($Flags, $SHGFI_SMALLICON)
	EndIf

	Local $tSHFILEINFO = DllStructCreate($tagSHFILEINFO)

	If Not _WinAPI_ShellGetFileInfo($sFile, $Flags, 0, $tSHFILEINFO) Then
		Return SetError(1, 0, 0)
	EndIf
	Return DllStructGetData($tSHFILEINFO, 'hIcon')
EndFunc   ;==>_WinAPI_ShellExtractAssociatedIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellExtractIcon
; Description....: Extracts the icon with the specified dimension from the specified file.
; Syntax.........: _WinAPI_ShellExtractIcon ( $sIcon, $iIndex, $iWidth, $iHeight )
; Parameters.....: $sIcon   - Path and name of the file from which the icon are to be extracted.
;                  $iIndex  - The zero-based index of the icon to extract. If this value is a negative number, the function extracts
;                             the icon whose resource identifier is equal to the absolute value of $iIndex.
;                  $iWidth  - Horizontal icon size wanted.
;                  $iHeight - Vertical icon size wanted.
; Return values..: Success  - Handle to the extracted icon.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the icon with the specified dimension is not found in the file, it will choose the nearest appropriate icon
;                  and change to the specified dimension. When you are finished using the icon, destroy it using the
;                  _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: @@MsdnLink@@ SHExtractIcons
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellExtractIcon($sIcon, $iIndex, $iWidth, $iHeight)

	Local $Ret = DllCall('shell32.dll', 'int', 'SHExtractIconsW', 'wstr', $sIcon, 'int', $iIndex, 'int', $iWidth, 'int', $iHeight, 'ptr*', 0, 'ptr*', 0, 'int', 1, 'int', 0)

	If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_ShellExtractIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellFileOperation
; Description....: Copies, moves, renames, or deletes a file system object.
; Syntax.........: _WinAPI_ShellFileOperation ( $sFrom, $sTo, $iFunc, $iFlags [, $sTitle [, $hParent]] )
; Parameters.....: $sFrom   - Single string or array of string that contains the source file name(s). These names should be
;                             fully-qualified paths to prevent unexpected results.
;                  $sTo     - Single string or array of string that contains the destination file or directory name(s) (if used).
;                             These names should be fully-qualified paths to prevent unexpected results.
;                  $iFunc   - A value that indicates which operation to perform. This parameter can be one of the following values.
;
;                             $FO_COPY
;                             $FO_DELETE
;                             $FO_MOVE
;                             $FO_RENAME
;
;                  $iFlags  - Flags that control the file operation. This parameter can be one of the following values.
;
;                             $FOF_ALLOWUNDO
;                             $FOF_CONFIRMMOUSE
;                             $FOF_FILESONLY
;                             $FOF_MULTIDESTFILES
;                             $FOF_NOCONFIRMATION
;                             $FOF_NOCONFIRMMKDIR
;                             $FOF_NO_CONNECTED_ELEMENTS
;                             $FOF_NOCOPYSECURITYATTRIBS
;                             $FOF_NOERRORUI
;                             $FOF_NORECURSEREPARSE
;                             $FOF_NORECURSION
;                             $FOF_RENAMEONCOLLISION
;                             $FOF_SILENT
;                             $FOF_SIMPLEPROGRESS
;                             $FOF_WANTMAPPINGHANDLE
;                             $FOF_WANTNUKEWARNING
;                             $FOF_NO_UI
;
;                  $sTitle  - The title of a progress dialog box. This parameter is used only if $iFlags includes the $FOF_SIMPLEPROGRESS flag.
;                  $hParent - Handle to the dialog box to display information about the status of the file operation.
; Return values..: Success  - $tagSHFILEOPSTRUCT structure that contains the additional information.
;                  Failure  - 0 and sets the @error flag to the one of the following values.
;
;                              -1 - AutoIt inherent error.
;                             113 - The source and destination files are the same file.
;                             114 - Multiple file paths were specified in the source buffer, but only one destination file path.
;                             115 - Rename operation was specified but the destination path is a different directory. Use the move operation instead.
;                             116 - The source is a root directory, which cannot be moved or renamed.
;                             117 - The operation was cancelled by the user, or silently cancelled if the appropriate flags were supplied to _WinAPI_ShellFileOperation().
;                             118 - The destination is a subtree of the source.
;                             120 - Security settings denied access to the source.
;                             121 - The source or destination path exceeded or would exceed MAX_PATH.
;                             122 - The operation involved multiple destination paths, which can fail in the case of a move operation.
;                             124 - The path in the source or destination or both was invalid.
;                             125 - The source and destination have the same parent folder.
;                             126 - The destination path is an existing file.
;                             128 - The destination path is an existing folder.
;                             129 - The name of the file exceeds MAX_PATH.
;                             130 - The destination is a read-only CD-ROM, possibly unformatted.
;                             131 - The destination is a read-only DVD, possibly unformatted.
;                             132 - The destination is a writable CD-ROM, possibly unformatted.
;                             133 - The file involved in the operation is too large for the destination media or file system.
;                             134 - The source is a read-only CD-ROM, possibly unformatted.
;                             135 - The source is a read-only DVD, possibly unformatted.
;                             136 - The source is a writable CD-ROM, possibly unformatted.
;                             183 - MAX_PATH was exceeded during the operation.
;                            1026 - An unknown error occurred. This is typically due to an invalid path in the source or destination.
;                           65536 - An unspecified error occurred on the destination.
;                           65652 - Destination is a root directory and cannot be renamed.
;
; Author.........: Yashied
; Modified.......:
; Remarks........: You should use fully-qualified path names with this function. Using it with relative path names is not thread safe.
; Related........:
; Link...........: @@MsdnLink@@ SHFileOperation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellFileOperation($sFrom, $sTo, $iFunc, $iFlags, $sTitle = '', $hParent = 0)

	Local $tFrom, $tTo, $Data

	If Not IsArray($sFrom) Then
		$Data = $sFrom
		Dim $sFrom[1] = [$Data]
	EndIf
	$tFrom = _WinAPI_ArrayToStruct($sFrom)
	If @error Then
		Return SetError(-1, 0, 0)
	EndIf
	If Not IsArray($sTo) Then
		$Data = $sTo
		Dim $sTo[1] = [$Data]
	EndIf
	$tTo = _WinAPI_ArrayToStruct($sTo)
	If @error Then
		Return SetError(-1, 0, 0)
	EndIf

	Local $tSHFILEOPSTRUCT = DllStructCreate($tagSHFILEOPSTRUCT)

	DllStructSetData($tSHFILEOPSTRUCT, 'hWnd', $hParent)
	DllStructSetData($tSHFILEOPSTRUCT, 'Func', $iFunc)
	DllStructSetData($tSHFILEOPSTRUCT, 'From', DllStructGetPtr($tFrom))
	DllStructSetData($tSHFILEOPSTRUCT, 'To', DllStructGetPtr($tTo))
	DllStructSetData($tSHFILEOPSTRUCT, 'Flags', $iFlags)
	DllStructSetData($tSHFILEOPSTRUCT, 'ProgressTitle', $sTitle)

	Local $Ret = DllCall('shell32.dll', 'int', 'SHFileOperationW', 'ptr', DllStructGetPtr($tSHFILEOPSTRUCT))

	If @error Then
		Return SetError(-1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError($Ret[0], 0, 0)
		EndIf
	EndIf
	Return $tSHFILEOPSTRUCT
EndFunc   ;==>_WinAPI_ShellFileOperation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetFileInfo
; Description....: Retrieves information about an object in the file system.
; Syntax.........: _WinAPI_ShellGetFileInfo ( $sPath, $iFlags, $iAttributes, ByRef $tSHFILEINFO )
; Parameters.....: $sPath       - String that contains the absolute or relative path and file name. This string can use either
;                                 short (the 8.3 form) or long file names.
;
;                                 If the $iFlags parameter includes the $SHGFI_PIDL flag, this parameter must be the address of an
;                                 ITEMIDLIST (PIDL) structure that contains the list of item identifiers that uniquely identifies the
;                                 file within the Shell's namespace. The pointer to an item identifier list (PIDL) must be a fully
;                                 qualified PIDL. Relative PIDLs are not allowed.
;
;                                 If the $iFlags parameter includes the $SHGFI_USEFILEATTRIBUTES flag, this parameter does not have
;                                 to be a valid file name. The function will proceed as if the file exists with the specified name and
;                                 with the file attributes passed in the $iAttributes parameter. This allows you to obtain information
;                                 about a file type by passing just the extension for $sPath and passing $FILE_ATTRIBUTE_NORMAL
;                                 in $iAttributes.
;
;                  $iFlags      - The flags that specify the file information to retrieve. This parameter can be a combination of the
;                                 following values.
;
;                                 $SHGFI_ATTR_SPECIFIED
;                                 $SHGFI_ATTRIBUTES
;                                 $SHGFI_DISPLAYNAME
;                                 $SHGFI_EXETYPE
;                                 $SHGFI_ICON
;                                 $SHGFI_ICONLOCATION
;                                 $SHGFI_LARGEICON
;                                 $SHGFI_LINKOVERLAY
;                                 $SHGFI_OPENICON
;                                 $SHGFI_OVERLAYINDEX
;                                 $SHGFI_PIDL
;                                 $SHGFI_SELECTED
;                                 $SHGFI_SHELLICONSIZE
;                                 $SHGFI_SMALLICON
;                                 $SHGFI_SYSICONINDEX
;                                 $SHGFI_TYPENAME
;                                 $SHGFI_USEFILEATTRIBUTES
;
;                  $iAttributes - A combination of one or more file attribute flags ($FILE_ATTRIBUTE_*).
;                  $tSHFILEINFO - $tagSHFILEINFO structure to receive the file information.
; Return values..: Success      - If $iFlags contains the $SHGFI_EXETYPE flag, return type of the executable file. If $iFlags contains the
;                                 $SHGFI_SYSICONINDEX flag, return handle to the system image list. Otherwise - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If this function returns an icon handle in the hIcon member of the $tagSHFILEINFO structure, you are responsible
;                  for freeing it with _WinAPI_DestroyIcon() when you no longer need it.
; Related........:
; Link...........: @@MsdnLink@@ SHGetFileInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetFileInfo($sPath, $iFlags, $iAttributes, ByRef $tSHFILEINFO)

	Local $Ret = DllCall('shell32.dll', 'dword_ptr', 'SHGetFileInfoW', 'wstr', $sPath, 'dword', $iAttributes, 'ptr', DllStructGetPtr($tSHFILEINFO), 'uint', DllStructGetSize($tSHFILEINFO), 'uint', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ShellGetFileInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetKnownFolderPath
; Description....: Retrieves the full path of a known folder identified.
; Syntax.........: _WinAPI_ShellGetKnownFolderPath ( $GUID [, $iFlags [, $hToken]] )
; Parameters.....: $GUID   - The GUID ($FOLDERID_*) that identifies the standard folders registered with the system.
;                  $iFlags - The flags that specify special retrieval options. This parameter can be one or more of the following values.
;
;                            $KF_FLAG_CREATE
;                            $KF_FLAG_DONT_VERIFY
;                            $KF_FLAG_DONT_UNEXPAND
;                            $KF_FLAG_NO_ALIAS
;                            $KF_FLAG_INIT
;                            $KF_FLAG_DEFAULT_PATH
;                            $KF_FLAG_NOT_PARENT_RELATIVE
;                            $KF_FLAG_SIMPLE_IDLIST
;
;                            *Windows 7 or later
;
;                            $KF_FLAG_ALIAS_ONLY
;
;                  $hToken - The access token that represents a particular user. If this parameter is 0, the function requests
;                            the known folder for the current user. Assigning the $hToken parameter a value of (-1) indicates the
;                            Default User. Note that access to the Default User folders requires administrator privileges.
; Return values..: Success - The path of the known folder.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHGetKnownFolderPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetKnownFolderPath($GUID, $iFlags = 0, $hToken = 0)

	Local $Ret, $Result, $tGUID, $tData

	$tGUID = DllStructCreate($tagGUID)
	$Ret = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', $GUID, 'ptr', DllStructGetPtr($tGUID))
	If (@error) Or ($Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	$Ret = DllCall('shell32.dll', 'uint', 'SHGetKnownFolderPath', 'ptr', DllStructGetPtr($tGUID), 'dword', $iFlags, 'ptr', $hToken, 'ptr*', 0)
	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	$tData = DllStructCreate('wchar[' & (_WinAPI_StrLen($Ret[4]) + 1) & ']', $Ret[4])
	$Result = DllStructGetData($tData, 1)
	_WinAPI_CoTaskMemFree($Ret[4])
	Return $Result
EndFunc   ;==>_WinAPI_ShellGetKnownFolderPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetLocalizedName
; Description....: Retrieves the localized name of a file in a Shell folder.
; Syntax.........: _WinAPI_ShellGetLocalizedName ( $sPath )
; Parameters.....: $sPath  - The path to the target file.
; Return values..: Success - The array that contains the following information:
;
;                            [0] - The path to the module containing string resource that specifies the localized version of the file name.
;                            [1] - ID of the localized file name resource.
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHGetLocalizedName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetLocalizedName($sPath)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('shell32.dll', 'uint', 'SHGetLocalizedName', 'wstr', $sPath, 'ptr', DllStructGetPtr($tData), 'uint*', 0, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[2]

	$Result[0] = _WinAPI_ExpandEnvironmentStrings(DllStructGetData($tData, 1))
	$Result[1] = $Ret[4]

	Return $Result
EndFunc   ;==>_WinAPI_ShellGetLocalizedName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetPathFromIDList
; Description....: Converts an item identifier list to a file system path.
; Syntax.........: _WinAPI_ShellGetPathFromIDList ( $PIDL )
; Parameters.....: $PIDL   - The address of an item identifier list that specifies a file or directory location relative to the
;                            root of the namespace (the desktop).
; Return values..: Success - The file system path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHGetPathFromIDList
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetPathFromIDList($PIDL)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('shell32.dll', 'int', 'SHGetPathFromIDListW', 'ptr', $PIDL, 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_ShellGetPathFromIDList

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetSetFolderCustomSettings
; Description....: Sets or retrieves custom folder settings.
; Syntax.........: _WinAPI_ShellGetSetFolderCustomSettings ( $sPath, $iFlag, ByRef $tSHFCS )
; Parameters.....: $sPath  - The path to the folder.
;                  $iFlag  - A flag controlling the action of the function. It may be one of the following values.
;
;                            $FCS_READ
;                            $FCS_FORCEWRITE
;                            $FCS_WRITE
;
;                  $tSHFCS - $tagSHFOLDERCUSTOMSETTINGS structure that provides or receives the custom folder settings.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function reads from and writes to Desktop.ini.
; Related........:
; Link...........: @@MsdnLink@@ SHGetSetFolderCustomSettings
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetSetFolderCustomSettings($sPath, $iFlag, ByRef $tSHFCS)

	Local $Proc = 'SHGetSetFolderCustomSettings'

	If _WinAPI_GetVersion() < '6.0' Then
		$Proc &= 'W'
	EndIf

	Local $Ret = DllCall('shell32.dll', 'uint', $Proc, 'ptr', DllStructGetPtr($tSHFCS), 'wstr', $sPath, 'dword', $iFlag)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellGetSetFolderCustomSettings

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetSettings
; Description....: Retrieves Shell state settings.
; Syntax.........: _WinAPI_ShellGetSettings ( $iFlags )
; Parameters.....: $iFlags - The flags that indicate which settings should be retrieved. This parameter can be one or
;                            more of the following values (use ONLY this flags).
;
;                            $SSF_SHOWALLOBJECTS
;                            $SSF_SHOWEXTENSIONS
;                            $SSF_SHOWCOMPCOLOR
;                            $SSF_SHOWSYSFILES
;                            $SSF_DOUBLECLICKINWEBVIEW
;                            $SSF_DESKTOPHTML
;                            $SSF_WIN95CLASSIC
;                            $SSF_DONTPRETTYPATH
;                            $SSF_MAPNETDRVBUTTON
;                            $SSF_SHOWINFOTIP
;                            $SSF_HIDEICONS
;                            $SSF_NOCONFIRMRECYCLE
;                            $SSF_WEBVIEW
;                            $SSF_SHOWSUPERHIDDEN
;                            $SSF_SEPPROCESS
;                            $SSF_NONETCRAWLING
;                            $SSF_STARTPANELON
;
;                            *Windows Vista or later
;
;                            $SSF_AUTOCHECKSELECT
;                            $SSF_ICONSONLY
;                            $SSF_SHOWTYPEOVERLAY
;
; Return values..: Success - The value that contains a combination of flags specified in the $iFlags parameter. If flag is set,
;                            appropriate setting is enabled, otherwise disabled. The function checks only flags that were
;                            specified in the $iFlags parameter.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHGetSetSettings
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetSettings($iFlags)

	Local $tSHELLSTATE = DllStructCreate('uint[8]')

	DllCall('shell32.dll', 'none', 'SHGetSetSettings', 'ptr', DllStructGetPtr($tSHELLSTATE), 'dword', $iFlags, 'int', 0)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Val1 = DllStructGetData($tSHELLSTATE, 1, 1)
	Local $Val2 = DllStructGetData($tSHELLSTATE, 1, 8)
	Local $Result = 0

	If BitAND($Val1, 0x00000001) Then
		$Result += $SSF_SHOWALLOBJECTS
	EndIf
	If BitAND($Val1, 0x00000002) Then
		$Result += $SSF_SHOWEXTENSIONS
	EndIf
	If BitAND($Val1, 0x00000004) Then
		$Result += $SSF_NOCONFIRMRECYCLE
	EndIf
	If BitAND($Val1, 0x00000008) Then
		$Result += $SSF_SHOWSYSFILES
	EndIf
	If BitAND($Val1, 0x00000010) Then
		$Result += $SSF_SHOWCOMPCOLOR
	EndIf
	If BitAND($Val1, 0x00000020) Then
		$Result += $SSF_DOUBLECLICKINWEBVIEW
	EndIf
	If BitAND($Val1, 0x00000040) Then
		$Result += $SSF_DESKTOPHTML
	EndIf
	If BitAND($Val1, 0x00000080) Then
		$Result += $SSF_WIN95CLASSIC
	EndIf
	If BitAND($Val1, 0x00000100) Then
		$Result += $SSF_DONTPRETTYPATH
	EndIf
	If BitAND($Val1, 0x00000400) Then
		$Result += $SSF_MAPNETDRVBUTTON
	EndIf
	If BitAND($Val1, 0x00000800) Then
		$Result += $SSF_SHOWINFOTIP
	EndIf
	If BitAND($Val1, 0x00001000) Then
		$Result += $SSF_HIDEICONS
	EndIf
	If BitAND($Val1, 0x00002000) Then
		$Result += $SSF_WEBVIEW
	EndIf
	If BitAND($Val1, 0x00008000) Then
		$Result += $SSF_SHOWSUPERHIDDEN
	EndIf
	If BitAND($Val1, 0x00010000) Then
		$Result += $SSF_NONETCRAWLING
	EndIf
	If BitAND($Val2, 0x00000001) Then
		$Result += $SSF_SEPPROCESS
	EndIf
	If BitAND($Val2, 0x00000002) Then
		$Result += $SSF_STARTPANELON
	EndIf
	If BitAND($Val2, 0x00000008) Then
		$Result += $SSF_AUTOCHECKSELECT
	EndIf
	If BitAND($Val2, 0x00000010) Then
		$Result += $SSF_ICONSONLY
	EndIf
	If BitAND($Val2, 0x00000020) Then
		$Result += $SSF_SHOWTYPEOVERLAY
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_ShellGetSettings

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetSpecialFolderLocation
; Description....: Retrieves a PIDL structure of a special folder.
; Syntax.........: _WinAPI_ShellGetSpecialFolderLocation ( $CSIDL )
; Parameters.....: $CSIDL  - The CSIDL ($CSIDL_*) that identifies the folder of interest.
; Return values..: Success - The PIDL specifying the folder's location relative to the root of the namespace (the desktop).
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: To free the returned PIDL, call the _WinAPI_CoTaskMemFree() function.
; Related........:
; Link...........: @@MsdnLink@@ SHGetSpecialFolderLocation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetSpecialFolderLocation($CSIDL)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHGetSpecialFolderLocation', 'hwnd', 0, 'int', $CSIDL, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_ShellGetSpecialFolderLocation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetSpecialFolderPath
; Description....: Retrieves the path of a special folder.
; Syntax.........: _WinAPI_ShellGetSpecialFolderPath ( $CSIDL [, $fCreate] )
; Parameters.....: $CSIDL   - The CSIDL ($CSIDL_*) that identifies the folder of interest.
;                  $fCreate - Specifies whether the folder should be created if it does not already exist, valid values:
;                  |TRUE    - The folder is created.
;                  |FALSE   - The folder is not created. (Default)
; Return values..: Success  - The full path of a special folder.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHGetSpecialFolderPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetSpecialFolderPath($CSIDL, $fCreate = 0)

	Local $tPath = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('shell32.dll', 'int', 'SHGetSpecialFolderPathW', 'hwnd', 0, 'ptr', DllStructGetPtr($tPath), 'int', $CSIDL, 'int', $fCreate)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tPath, 1)
EndFunc   ;==>_WinAPI_ShellGetSpecialFolderPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetStockIconInfo
; Description....: Retrieves information about system-defined Shell icons.
; Syntax.........: _WinAPI_ShellGetStockIconInfo ( $SIID, $iFlags )
; Parameters.....: $SIID   - One of the $SIID_* constants that specifies which icon should be retrieved.
;                  $iFlags - The flags that specify which information is requested. This parameter can be a combination of the
;                            following values.
;
;                            $SHGSI_ICONLOCATION
;                            $SHGSI_ICON
;                            $SHGSI_SYSICONINDEX
;                            $SHGSI_LINKOVERLAY
;                            $SHGSI_SELECTED
;                            $SHGSI_LARGEICON
;                            $SHGSI_SMALLICON
;                            $SHGSI_SHELLICONSIZE
;
; Return values..: Success - $tagSHSTOCKICONINFO structure that contains the requested information.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If this function returns an icon handle in the "hIcon" member of the $tagSHSTOCKICONINFO structure, you are
;                  responsible for freeing the icon with _WinAPI_DestroyIcon() when you no longer need it.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHGetStockIconInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetStockIconInfo($SIID, $iFlags)

	Local $tSHSTOCKICONINFO = DllStructCreate($tagSHSTOCKICONINFO)

	DllStructSetData($tSHSTOCKICONINFO, 'Size', DllStructGetSize($tSHSTOCKICONINFO))

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHGetStockIconInfo', 'int', $SIID, 'uint', $iFlags, 'ptr', DllStructGetPtr($tSHSTOCKICONINFO))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tSHSTOCKICONINFO
EndFunc   ;==>_WinAPI_ShellGetStockIconInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellILCreateFromPath
; Description....: Creates a pointer to an item identifier list (PIDL) from a path.
; Syntax.........: _WinAPI_ShellILCreateFromPath ( $sPath )
; Parameters.....: $sPath  - The path to be converted.
; Return values..: Success - The path in $sPath expressed as a PIDL.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: To free the returned PIDL, call the _WinAPI_CoTaskMemFree() function.
; Related........:
; Link...........: @@MsdnLink@@ SHILCreateFromPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellILCreateFromPath($sPath)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHILCreateFromPath', 'wstr', $sPath, 'ptr*', 0, 'dword*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_ShellILCreateFromPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellNotifyIcon
; Description....: Sends a message to the taskbar's status area.
; Syntax.........: _WinAPI_ShellNotifyIcon ( $iMessage, $tNOTIFYICONDATA )
; Parameters.....: $iMessage        - The variable that specifies the action to be taken. It can have one of the following values.
;
;                                     $NIM_ADD
;                                     $NIM_MODIFY
;                                     $NIM_DELETE
;                                     $NIM_SETFOCUS
;                                     $NIM_SETVERSION
;
;                  $tNOTIFYICONDATA - $tagNOTIFYICONDATA structure. The content and size of this structure depends on the value
;                                     of the $iMessage and version of the operating system.
; Return values..: Success          - 1.
;                  Failure          - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ Shell_NotifyIcon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellNotifyIcon($iMessage, $tNOTIFYICONDATA)

	Local $Ret = DllCall('shell32.dll', 'int', 'Shell_NotifyIconW', 'dword', $iMessage, 'ptr', DllStructGetPtr($tNOTIFYICONDATA))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellNotifyIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellNotifyIconGetRect
; Description....: Gets the screen coordinates of the bounding rectangle of a notification icon.
; Syntax.........: _WinAPI_ShellNotifyIconGetRect ( $hWnd, $ID [, $tGUID] )
; Parameters.....: $hWnd   - Handle to the parent window used by the notification's callback function. For more information,
;                            see the "hWnd" member of the $tagNOTIFYICONDATA structure.
;                  $ID     - Application-defined identifier of the notification icon. Multiple icons can be associated with a single
;                            $hWnd, each with their own $ID.
;                  $tGUID  - $tagGUID structure that identifies the icon.
; Return values..: Success - $tagRECT structure that contains the coordinates of the icon.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The icon can be identified through $hWnd plus $ID, or $tGUID alone (recommended).
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ Shell_NotifyIconGetRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellNotifyIconGetRect($hWnd, $ID, $tGUID = 0)

	Local $tNII = DllStructCreate('dword;hwnd;uint;' & $tagGUID)

	DllStructSetData($tNII, 1, DllStructGetSize($tNII))
	If IsDllStruct($tGUID) Then
		_WinAPI_MoveMemory(DllStructGetPtr($tNII, 4), DllStructGetPtr($tGUID), 16)
	Else
		_WinAPI_FillMemory(DllStructGetPtr($tNII, 4), 16)
		DllStructSetData($tNII, 2, $hWnd)
		DllStructSetData($tNII, 3, $ID)
	EndIf

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('shell32.dll ', 'uint', 'Shell_NotifyIconGetRect', 'ptr', DllStructGetPtr($tNII), 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_ShellNotifyIconGetRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellObjectProperties
; Description....: Invokes the Properties context menu command on a Shell object.
; Syntax.........: _WinAPI_ShellObjectProperties ( $sPath [, $iType [, $sProperty [, $hParent]]] )
; Parameters.....: $sPath     - The object name.
;                  $iType     - The value that specifies the type of object.
;
;                               $SHOP_PRINTERNAME
;                               $SHOP_FILEPATH
;                               $SHOP_VOLUMEGUID
;
;                  $sProperty - The name of the property sheet page to be opened initially.
;                  $hParent   - Handle of the parent window of the dialog box.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHObjectProperties
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellObjectProperties($sPath, $iType = 2, $sProperty = '', $hParent = 0)

	Local $TypeOfProperty = 'wstr'

	If Not StringStripWS($sProperty, 3) Then
		$TypeOfProperty = 'ptr'
		$sProperty = 0
	EndIf

	Local $Ret = DllCall('shell32.dll', 'int', 'SHObjectProperties', 'hwnd', $hParent, 'dword', $iType, 'wstr', $sPath, $TypeOfProperty, $sProperty)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellObjectProperties

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellOpenFolderAndSelectItems
; Description....: Opens a Windows Explorer window with specified items in a particular folder selected.
; Syntax.........: _WinAPI_ShellOpenFolderAndSelectItems ( $sPath [, $aNames [, $iStart [, $iEnd [, $iFlags]]]] )
; Parameters.....: $sPath  - The fully qualified path that specifies the folder or file. If $aNames parameter is used, $sPath should
;                            specified only to a folder, otherwise, the function fails. This parameter can be an empty string.
;                  $aNames - The array of the folder or file names to be selected. It should be just names inside the folder.
;                  $iStart - The index of array to start selecting at.
;                  $iEnd   - The index of array to stop selecting at.
;                  $iFlags - The optional flags. This parameter can be one or more of the following values.
;
;                            *Windows Vista or later
;
;                            $OFASI_EDIT
;                            $OFASI_OPENDESKTOP
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHOpenFolderAndSelectItems
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellOpenFolderAndSelectItems($sPath, $aNames = 0, $iStart = 0, $iEnd = -1, $iFlags = 0)

	$sPath = StringRegExpReplace(_WinAPI_PathSearchAndQualify($sPath), '\\*\Z', '')
	If $sPath Then
		If (IsArray($aNames)) And (Not _WinAPI_PathIsDirectory($sPath)) Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $PIDL = _WinAPI_ShellILCreateFromPath($sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $sNames = '', $tNames = 0, $Ret, $Count = 0

	If IsArray($aNames) Then
		If $iStart < 0 Then
			$iStart = 0
		EndIf
		If ($iEnd < 0) Or ($iEnd > UBound($aNames) - 1) Then
			$iEnd = UBound($aNames) - 1
		EndIf
		For $i = $iStart To $iEnd
			$sNames &= 'ptr;'
		Next
		$tNames = DllStructCreate($sNames)
		If @error Then

		EndIf
		For $i = $iStart To $iEnd
			$Count += 1
			If $aNames[$i] Then
				DllStructSetData($tNames, $Count, _WinAPI_ShellILCreateFromPath($sPath & '\' & $aNames[$i]))
			Else
				DllStructSetData($tNames, $Count, 0)
			EndIf
		Next
	EndIf
	_WinAPI_CoInitialize()
	$Ret = DllCall('shell32.dll', 'uint', 'SHOpenFolderAndSelectItems', 'ptr', $PIDL, 'uint', $Count, 'ptr', DllStructGetPtr($tNames), 'dword', $iFlags)
	If @error Then
		$Ret = 0
	Else
		If $Ret[0] Then
			$Ret = $Ret[0]
		EndIf
	EndIf
	_WinAPI_CoUninitialize()
	_WinAPI_CoTaskMemFree($PIDL)
	For $i = 1 To $Count
		$PIDL = DllStructGetData($tNames, $i)
		If $PIDL Then
			_WinAPI_CoTaskMemFree($PIDL)
		EndIf
	Next
	If Not IsArray($Ret) Then
		Return SetError(1, $Ret, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellOpenFolderAndSelectItems

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellOpenWithDlg
; Description....: Displays the Open With dialog box.
; Syntax.........: _WinAPI_ShellOpenWithDlg ( $sFile [, $iFlags [, $hParent]] )
; Parameters.....: $sFile   - The file name.
;                  $iFlags  - The characteristics of the Open With dialog box. This parameter can be one or more of the following values.
;
;                             $OAIF_ALLOW_REGISTRATION
;                             $OAIF_REGISTER_EXT
;                             $OAIF_EXEC
;                             $OAIF_FORCE_REGISTRATION
;                             $OAIF_HIDE_REGISTRATION
;                             $OAIF_URL_PROTOCOL
;
;                  $hParent - Handle of the parent window.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHOpenWithDialog
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellOpenWithDlg($sFile, $iFlags = 0, $hParent = 0)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $tOPENASINFO = DllStructCreate('ptr;ptr;dword')

	DllStructSetData($tData, 1, $sFile)
	DllStructSetData($tOPENASINFO, 1, DllStructGetPtr($tData))
	DllStructSetData($tOPENASINFO, 2, 0)
	DllStructSetData($tOPENASINFO, 3, $iFlags)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHOpenWithDialog', 'hwnd', $hParent, 'ptr', DllStructGetPtr($tOPENASINFO))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellOpenWithDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellQueryRecycleBin
; Description....: Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive.
; Syntax.........: _WinAPI_ShellQueryRecycleBin ( $sRoot )
; Parameters.....: $sRoot  - The string that contains the path of the root drive on which the Recycle Bin is located. This string
;                            can be formatted with the drive, folder, and subfolder names, for example "c:\windows\system\".
;                            If this parameter is empty string, information is retrieved for all Recycle Bins on all drives.
; Return values..: Success - The array that contains the following information.
;
;                            [0] - The total size of all the objects in the specified Recycle Bin, in bytes.
;                            [1] - The total number of items in the specified Recycle Bin.
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHQueryRecycleBin
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellQueryRecycleBin($sRoot)

	Local $tSHQRBI = DllStructCreate('align 4;dword_ptr;int64;int64')

	DllStructSetData($tSHQRBI, 1, DllStructGetSize($tSHQRBI))

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHQueryRecycleBinW', 'wstr', $sRoot, 'ptr', DllStructGetPtr($tSHQRBI))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[2]

	$Result[0] = DllStructGetData($tSHQRBI, 2)
	$Result[1] = DllStructGetData($tSHQRBI, 3)

	Return $Result
EndFunc   ;==>_WinAPI_ShellQueryRecycleBin

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellQueryUserNotificationState
; Description....: Checks the state of the computer for the current user.
; Syntax.........: _WinAPI_ShellQueryUserNotificationState ( )
; Parameters.....: None
; Return values..: Success  - The current computer state ($QUNS_*).
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHQueryUserNotificationState
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellQueryUserNotificationState()

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHQueryUserNotificationState', 'uint*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_ShellQueryUserNotificationState

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellRemoveLocalizedName
; Description....: Removes the localized name of a file in a Shell folder.
; Syntax.........: _WinAPI_ShellRemoveLocalizedName ( $sPath )
; Parameters.....: $sPath   - The path to the target file.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHRemoveLocalizedName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellRemoveLocalizedName($sPath)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHRemoveLocalizedName', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellRemoveLocalizedName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellRestricted
; Description....: Determines whether a specified administrator policy is in effect.
; Syntax.........: _WinAPI_ShellRestricted ( $iRestriction )
; Parameters.....: $iRestriction - A restriction. This parameter can be one of the $REST_* constants.
; Return values..: Success - Nonzero - The specified restriction is in effect.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHRestricted
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellRestricted($iRestriction)

	Local $Ret = DllCall('shell32.dll', 'dword', 'SHRestricted', 'uint', $iRestriction)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ShellRestricted

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellSetLocalizedName
; Description....: Sets the localized name of a file in a Shell folder.
; Syntax.........: _WinAPI_ShellSetLocalizedName ( $sPath, $sModule, $iResID )
; Parameters.....: $sPath   - The path to the target file.
;                  $sModule - The path to the module containing string resource that specifies the localized version of the file name.
;                  $iResID  - ID of the localized file name resource.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: When this string is set, Windows Explorer displays this string instead of the file name. The path to the file
;                  is unchanged.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHSetLocalizedName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellSetLocalizedName($sPath, $sModule, $iResID)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHSetLocalizedName', 'wstr', $sPath, 'wstr', $sModule, 'int', $iResID)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellSetLocalizedName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellSetSettings
; Description....: Sets Shell state settings.
; Syntax.........: _WinAPI_ShellSetSettings ( $iFlags, $fSet )
; Parameters.....: $iFlags - The flags that indicate which settings should be set. This parameter can be one or
;                            more of the following values (use ONLY this flags).
;
;                            $SSF_SHOWALLOBJECTS
;                            $SSF_SHOWEXTENSIONS
;                            $SSF_SHOWCOMPCOLOR
;                            $SSF_SHOWSYSFILES
;                            $SSF_DOUBLECLICKINWEBVIEW
;                            $SSF_DESKTOPHTML
;                            $SSF_WIN95CLASSIC
;                            $SSF_DONTPRETTYPATH
;                            $SSF_MAPNETDRVBUTTON
;                            $SSF_SHOWINFOTIP
;                            $SSF_HIDEICONS
;                            $SSF_NOCONFIRMRECYCLE
;                            $SSF_WEBVIEW
;                            $SSF_SHOWSUPERHIDDEN
;                            $SSF_SEPPROCESS
;                            $SSF_NONETCRAWLING
;                            $SSF_STARTPANELON
;
;                            *Windows Vista or later
;
;                            $SSF_AUTOCHECKSELECT
;                            $SSF_ICONSONLY
;                            $SSF_SHOWTYPEOVERLAY
;
;                  $fSet   - Specifies whether a settings ($SSF_*) is enable or disable, valid values:
;                  |TRUE   - Enable.
;                  |FALSE  - Disable.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHGetSetSettings
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellSetSettings($iFlags, $fSet)

	Local $Val1 = 0, $Val2 = 0

	If $fSet Then
		If BitAND($iFlags, $SSF_SHOWALLOBJECTS) Then
			$Val1 += 0x00000001
		EndIf
		If BitAND($iFlags, $SSF_SHOWEXTENSIONS) Then
			$Val1 += 0x00000002
		EndIf
		If BitAND($iFlags, $SSF_NOCONFIRMRECYCLE) Then
			$Val1 += 0x00000004
		EndIf
		If BitAND($iFlags, $SSF_SHOWSYSFILES) Then
			$Val1 += 0x00000008
		EndIf
		If BitAND($iFlags, $SSF_SHOWCOMPCOLOR) Then
			$Val1 += 0x00000010
		EndIf
		If BitAND($iFlags, $SSF_DOUBLECLICKINWEBVIEW) Then
			$Val1 += 0x00000020
		EndIf
		If BitAND($iFlags, $SSF_DESKTOPHTML) Then
			$Val1 += 0x00000040
		EndIf
		If BitAND($iFlags, $SSF_WIN95CLASSIC) Then
			$Val1 += 0x00000080
		EndIf
		If BitAND($iFlags, $SSF_DONTPRETTYPATH) Then
			$Val1 += 0x00000100
		EndIf
		If BitAND($iFlags, $SSF_MAPNETDRVBUTTON) Then
			$Val1 += 0x00000400
		EndIf
		If BitAND($iFlags, $SSF_SHOWINFOTIP) Then
			$Val1 += 0x00000800
		EndIf
		If BitAND($iFlags, $SSF_HIDEICONS) Then
			$Val1 += 0x00001000
		EndIf
		If BitAND($iFlags, $SSF_WEBVIEW) Then
			$Val1 += 0x00002000
		EndIf
		If BitAND($iFlags, $SSF_SHOWSUPERHIDDEN) Then
			$Val1 += 0x00008000
		EndIf
		If BitAND($iFlags, $SSF_NONETCRAWLING) Then
			$Val1 += 0x00010000
		EndIf
		If BitAND($iFlags, $SSF_SEPPROCESS) Then
			$Val2 += 0x00000001
		EndIf
		If BitAND($iFlags, $SSF_STARTPANELON) Then
			$Val2 += 0x00000002
		EndIf
		If BitAND($iFlags, $SSF_AUTOCHECKSELECT) Then
			$Val2 += 0x00000008
		EndIf
		If BitAND($iFlags, $SSF_ICONSONLY) Then
			$Val2 += 0x00000010
		EndIf
		If BitAND($iFlags, $SSF_SHOWTYPEOVERLAY) Then
			$Val2 += 0x00000020
		EndIf
	EndIf

	Local $tSHELLSTATE = DllStructCreate('uint[8]')

	DllStructSetData($tSHELLSTATE, 1, $Val1, 1)
	DllStructSetData($tSHELLSTATE, 1, $Val2, 8)
	DllCall('shell32.dll', 'none', 'SHGetSetSettings', 'ptr', DllStructGetPtr($tSHELLSTATE), 'dword', $iFlags, 'int', 1)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellSetSettings

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShowCaret
; Description....: Makes the caret visible on the screen at the caret's current position.
; Syntax.........: _WinAPI_ShowCaret ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window that owns the caret. If this parameter is 0, _WinAPI_ShowCaret() searches the
;                            current task for the window that owns the caret.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_ShowCaret() shows the caret only if the specified window owns the caret, the caret has a shape,
;                  and the caret has not been hidden two or more times in a row. If one or more of these conditions is not met,
;                  _WinAPI_ShowCaret() does nothing and returns 0.
;
;                  Hiding is cumulative. If your application calls _WinAPI_HideCaret() five times in a row, it must also call
;                  _WinAPI_ShowCaret() five times before the caret reappears.
; Related........:
; Link...........: @@MsdnLink@@ ShowCaret
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShowCaret($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'ShowCaret', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShowCaret

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShowLastError
; Description....: Shows the last error code and message.
; Syntax.........: _WinAPI_ShowLastError ( )
; Parameters.....: None
; Return values..: None
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShowLastError()
	MsgBox(0, _WinAPI_GetLastError(), _WinAPI_GetLastErrorMessage())
EndFunc   ;==>_WinAPI_ShowLastError

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShowOwnedPopups
; Description....: Shows or hides all pop-up windows owned by the specified window.
; Syntax.........: _WinAPI_ShowOwnedPopups ( $hWnd , $fShow )
; Parameters.....: $hWnd   - Handle to the window that owns the pop-up windows to be shown or hidden.
;                  $fShow  - Specifies whether pop-up windows are to be shown or hidden.
;                  |TRUE   - All hidden pop-up windows are shown.
;                  |FALSE  - All visible pop-up windows are hidden.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function shows only windows hidden by a previous call to _WinAPI_ShowOwnedPopups().
; Related........:
; Link...........: @@MsdnLink@@ ShowOwnedPopups
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShowOwnedPopups($hWnd, $fShow)

	Local $Ret = DllCall('user32.dll', 'int', 'ShowOwnedPopups', 'hwnd', $hWnd, 'int', $fShow)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShowOwnedPopups

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShowShareFolderUI
; Description....: Displays the Folder Sharing tab on the properties sheet for the specified folder.
; Syntax.........: _WinAPI_ShowShareFolderUI ( $sPath [, $hParent] )
; Parameters.....: $sPath   - The path to the folder that displays its Folder Sharing tab.
;                  $hParent - Handle to the parent window for the property sheet.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ShowShareFolderUI
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShowShareFolderUI($sPath, $hParent = 0)
	DllCall('ntshrui.dll', 'int', 'ShowShareFolderUIW', 'hwnd', $hParent, 'wstr', $sPath)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShowShareFolderUI

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShutdownBlockReasonCreate
; Description....: Indicates that the system cannot be shut down and sets a reason string to be displayed to the user if system shutdown is initiated.
; Syntax.........: _WinAPI_ShutdownBlockReasonCreate ( $hWnd, $sText )
; Parameters.....: $hWnd   - Handle to the main window of the application.
;                  $sText  - The string which explaining the reason the application must block system shutdown.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function can only be called from the thread that created the window specified by the $hWnd parameter,
;                  otherwise, the function fails and the last error code is ERROR_ACCESS_DENIED (5).
;
;                  Applications should call this function as they begin an operation that cannot be interrupted, such as burning
;                  a CD or DVD. When the operation has completed, call the _WinAPI_ShutdownBlockReasonDestroy() function to
;                  indicate that the system can be shut down.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ ShutdownBlockReasonCreate
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShutdownBlockReasonCreate($hWnd, $sText)

	Local $Ret = DllCall('user32.dll', 'int', 'ShutdownBlockReasonCreate', 'hwnd', $hWnd, 'wstr', $sText)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShutdownBlockReasonCreate

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShutdownBlockReasonDestroy
; Description....: Indicates that the system can be shut down and frees the reason string.
; Syntax.........: _WinAPI_ShutdownBlockReasonDestroy ( $hWnd )
; Parameters.....: $hWnd   - Handle to the main window of the application.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function can only be called from the thread that created the window specified by the $hWnd parameter,
;                  otherwise, the function fails and the last error code is ERROR_ACCESS_DENIED (5).
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ ShutdownBlockReasonDestroy
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShutdownBlockReasonDestroy($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'ShutdownBlockReasonDestroy', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShutdownBlockReasonDestroy

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShutdownBlockReasonQuery
; Description....: Retrieves the reason string set by the _WinAPI_ShutdownBlockReasonCreate() function.
; Syntax.........: _WinAPI_ShutdownBlockReasonQuery ( $hWnd )
; Parameters.....: $hWnd   - Handle to the main window of the application.
; Return values..: Success - The reason string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function can only be called from the thread that created the window specified by the $hWnd parameter,
;                  otherwise, the function fails and the last error code is ERROR_ACCESS_DENIED (5).
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ ShutdownBlockReasonQuery
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShutdownBlockReasonQuery($hWnd)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('user32.dll', 'int', 'ShutdownBlockReasonQuery', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tData), 'dword*', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_ShutdownBlockReasonQuery

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SizeofResource
; Description....: Returns the size, in bytes, of the specified resource.
; Syntax.........: _WinAPI_SizeofResource ( $hInstance, $hResource )
; Parameters.....: $hInstance - Handle to the module whose executable file contains the resource.
;                  $hResource - Handle to the resource. This handle must be created by using the _WinAPI_FindResource() or _WinAPI_FindResourceEx()
;                               function.
; Return values..: Success    - The number of bytes in the resource.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SizeofResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SizeofResource($hInstance, $hResource)

	Local $Ret = DllCall('kernel32.dll', 'dword', 'SizeofResource', 'ptr', $hInstance, 'ptr', $hResource)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SizeofResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StretchBlt
; Description....: Copies a bitmap from a source rectangle into a destination rectangle, stretching or compressing the bitmap
;                  to fit the dimensions of the destination rectangle, if necessary.
; Syntax.........: _WinAPI_StretchBlt ( $hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRop )
; Parameters.....: $hDestDC     - Handle to the destination device context.
;                  $iXDest      - The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iYDest      - The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iWidthDest  - The width, in logical units, of the destination rectangle.
;                  $iHeightDest - The height, in logical units, of the destination rectangle.
;                  $hSrcDC      - Handle to the source device context.
;                  $iXSrc       - The x-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iYSrc       - The y-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iWidthSrc   - The width, in logical units, of the source rectangle.
;                  $iHeightSrc  - The height, in logical units, of the source rectangle.
;                  $iRop        - The raster-operation code. These codes define how the color data for the source rectangle is
;                                 to be combined with the color data for the destination rectangle to achieve the final color.
;                                 This parameter must be 0 or one of the following values.
;
;                                 $BLACKNESS
;                                 $CAPTUREBLT
;                                 $DSTINVERT
;                                 $MERGECOPY
;                                 $MERGEPAINT
;                                 $NOMIRRORBITMAP
;                                 $NOTSRCCOPY
;                                 $NOTSRCERASE
;                                 $PATCOPY
;                                 $PATINVERT
;                                 $PATPAINT
;                                 $SRCAND
;                                 $SRCCOPY
;                                 $SRCERASE
;                                 $SRCINVERT
;                                 $SRCPAINT
;                                 $WHITENESS
;
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The system stretches or compresses the bitmap according to the stretching mode currently set in the
;                  destination device context.
; Related........:
; Link...........: @@MsdnLink@@ StretchBlt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StretchBlt($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRop)

	Local $Ret = DllCall('gdi32.dll', 'int', 'StretchBlt', 'hwnd', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidthDest, 'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', $iRop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_StretchBlt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StretchDIBits
; Description....: Copies the color data for a rectangle of pixels in a DIB, JPEG, or PNG image to the specified destination rectangle,
;                  stretching or compressing the rows and columns by using the specified raster operation, if necessary.
; Syntax.........: _WinAPI_StretchDIBits ( $hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, ByRef $tBITMAPINFO, $iUsage, $pBits, $iRop )
; Parameters.....: $hDestDC     - Handle to the destination device context.
;                  $iXDest      - The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iYDest      - The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iWidthDest  - The width, in logical units, of the destination rectangle.
;                  $iHeightDest - The height, in logical units, of the destination rectangle.
;                  $iXSrc       - The x-coordinate, in pixels, of the source rectangle in the image.
;                  $iYSrc       - The y-coordinate, in pixels, of the source rectangle in the image.
;                  $iWidthSrc   - The width, in pixels, of the source rectangle in the image.
;                  $iHeightSrc  - The height, in pixels, of the source rectangle in the image.
;                  $tBITMAPINFO - $tagBITMAPINFO structure that contains information about the DIB.
;                  $iUsage      - The type of colors used. (either logical palette indexes or literal RGB values). The following
;                                 values are defined.
;
;                                 $DIB_PAL_COLORS
;                                 $DIB_RGB_COLORS
;
;                  $pBits       - A pointer to the image bits, which are stored as an array of bytes.
;                  $iRop        - The raster-operation code that specifies how the source pixels, the destination device context's
;                                 current brush, and the destination pixels are to be combined to form the new image. It must be
;                                 0 or one of the following values.
;
;                                 $BLACKNESS
;                                 $CAPTUREBLT
;                                 $DSTINVERT
;                                 $MERGECOPY
;                                 $MERGEPAINT
;                                 $NOMIRRORBITMAP
;                                 $NOTSRCCOPY
;                                 $NOTSRCERASE
;                                 $PATCOPY
;                                 $PATINVERT
;                                 $PATPAINT
;                                 $SRCAND
;                                 $SRCCOPY
;                                 $SRCERASE
;                                 $SRCINVERT
;                                 $SRCPAINT
;                                 $WHITENESS
;
; Return values..: Success      - The number of scan lines copied. Note that this value can be negative for mirrored content.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Jscript
; Modified.......: Yashied
; Remarks........: _WinAPI_StretchDIBits() creates a mirror image of a bitmap if the signs of the $iWidthSrc and $iWidthDest parameters,
;                  or if the $iHeightSrc and $iHeightDest parameters differ. If $iWidthSrc and $iWidthDest have different signs,
;                  the function creates a mirror image of the bitmap along the x-axis. If $iHeightSrc and $iHeightDest have different
;                  signs, the function creates a mirror image of the bitmap along the y-axis.
; Related........:
; Link...........: @@MsdnLink@@ StretchDIBits
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StretchDIBits($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, ByRef $tBITMAPINFO, $iUsage, $pBits, $iRop)

	Local $Ret  = DllCall('gdi32.dll', 'int', 'StretchDIBits', 'hwnd', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidthDest, 'int', $iHeightDest, 'int', $iXSrc, 'int', $iYSrc, 'int', $iWidthSrc, 'int', $iHeightSrc, 'ptr', $pBits, 'ptr', DllStructGetPtr($tBITMAPINFO), 'uint', $iUsage, 'dword', $iRop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_StretchDIBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrFormatByteSize
; Description....: Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes.
; Syntax.........: _WinAPI_StrFormatByteSize ( $iSize [, $iFlag] )
; Parameters.....: $iSize  - The numeric value to be converted.
;                  $iFlag  - Specifies whether to round or truncate undisplayed digits, valid values:
;                  |0 - Truncate. (Default)
;                  |1 - Round.
; Return values..: Success - The converted string.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ StrFormatByteSizeEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrFormatByteSize($iSize, $iFlag = 0)

	If $iFlag Then
		$iFlag = 1
	Else
		$iFlag = 2
	EndIf

	Local $tData = DllStructCreate('wchar[80]')
	Local $Ret = DllCall('shlwapi.dll', 'uint', 'StrFormatByteSizeEx', 'uint64', $iSize, 'uint', $iFlag, 'ptr', DllStructGetPtr($tData), 'uint', 80)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_StrFormatByteSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrFormatByteSizeEx
; Description....: Converts a numeric value into a string that represents the number expressed as separated groups of digits to the left of the decimal.
; Syntax.........: _WinAPI_StrFormatByteSizeEx ( $iSize )
; Parameters.....: $iSize  - The numeric value to be converted.
; Return values..: Success - The converted string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrFormatByteSizeEx($iSize)

	Local $Symbol, $Size

	$Symbol = _WinAPI_GetLocaleInfo(0x0400, 0x000F)
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	$Size = _WinAPI_StrFormatByteSize(0)
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return StringReplace($Size, '0', StringRegExpReplace(Number($iSize), '(?<=\d)(?=(\d{3})+\z)', $Symbol))
EndFunc   ;==>_WinAPI_StrFormatByteSizeEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrFormatKBSize
; Description....: Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.
; Syntax.........: _WinAPI_StrFormatKBSize ( $iSize )
; Parameters.....: $iSize  - The numeric value to be converted.
; Return values..: Success - The converted string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ StrFormatKBSize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrFormatKBSize($iSize)

	Local $tData = DllStructCreate('wchar[80]')
	Local $Ret = DllCall('shlwapi.dll', 'ptr', 'StrFormatKBSizeW', 'uint64', $iSize, 'ptr', DllStructGetPtr($tData), 'uint', 80)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_StrFormatKBSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrFromTimeInterval
; Description....: Converts a time interval to a string.
; Syntax.........: _WinAPI_StrFromTimeInterval ( $iTime [, $iDigits] )
; Parameters.....: $iTime   - The time interval, in milliseconds.
;                  $iDigits - The maximum number of significant digits to be represented in converted string.
; Return values..: Success  - The converted string.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The time value returned in converted string will always be in the form (hh) hours (mm) minutes (ss) seconds.
;                  Times that exceed twenty four hours are not converted to days or months.
; Related........:
; Link...........: @@MsdnLink@@ StrFromTimeInterval
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrFromTimeInterval($iTime, $iDigits = 7)

	Local $tData = DllStructCreate('wchar[80]')
	Local $Ret = DllCall('shlwapi.dll', 'int', 'StrFromTimeIntervalW', 'ptr', DllStructGetPtr($tData), 'uint', 80, 'dword', $iTime, 'int', $iDigits)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return StringStripWS(DllStructGetData($tData, 1), 3)
EndFunc   ;==>_WinAPI_StrFromTimeInterval

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrLen
; Description....: Returns the length of the specified string.
; Syntax.........: _WinAPI_StrLen ( $pString [, $fUnicode] )
; Parameters.....: $pString  - Pointer to a null-terminated string.
;                  $fUnicode - Specifies whether a string is Unicode or ASCII code of a character, valid values:
;                  |TRUE     - Unicode. (Default)
;                  |FALSE    - ASCII.
; Return values..: Success   - The length of the string, in TCHAR values (not including the null-terminating character).
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ lstrlen
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrLen($pString, $fUnicode = 1)

	Local $W = ''

	If $fUnicode Then
		$W = 'W'
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'lstrlen' & $W, 'ptr', $pString)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_StrLen

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrokeAndFillPath
; Description....: Closes any open figures in a path, strokes the outline of the path, and fills its interior.
; Syntax.........: _WinAPI_StrokeAndFillPath ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The device context identified by the $hDC parameter must contain a closed path.
; Related........:
; Link...........: @@MsdnLink@@ StrokeAndFillPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrokeAndFillPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'StrokeAndFillPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_StrokeAndFillPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrokePath
; Description....: Renders the specified path by using the current pen.
; Syntax.........: _WinAPI_StrokePath ( $hDC )
; Parameters.....: $hDC    - Handle to a device context that contains the completed path.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The path, if it is to be drawn by this function, must have been completed through a call to _WinAPI_EndPath().
;                  Unlike other path drawing functions such as _WinAPI_StrokeAndFillPath(), _WinAPI_StrokePath() will not attempt
;                  to close the path by drawing a straight line from the first point on the path to the last point on the path.
; Related........:
; Link...........: @@MsdnLink@@ StrokePath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrokePath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'StrokePath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_StrokePath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StructToArray
; Description....: Converts the structure to the array of strings.
; Syntax.........: _WinAPI_StructToArray ( $pStruct [, $iItems] )
; Parameters.....: $pStruct - The pointer to the structure to convert. This structure should be same as for _WinAPI_ArrayToStruct().
;                  $iItems  - The number of strings that contains the structure. If this parameter is 0, the end of the structure
;                             determined by a double null-terminated character ("... ;{0};{0}").
; Return values..: Success  - The array of strings. The zeroth array element contains the number of strings.
;                  Failure  - 0 and sets the @error flag to one of the following values:
;                  |1 - $pStruct is not a correct pointer.
;                  |2 - Failed to allocate the memory.
;                  |3 - Size of the structure exceeds the allowable size (32 KB).
; Author.........: Yashied
; Modified.......:
; Remarks........: This function works for Unicode strings only.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StructToArray($pStruct, $iItems = 0)

	Local $tData, $Count = 0, $Index = 1, $Lenght = 32 * 1024 / 2, $Struct = ''
	Local $Result[101] = [1, 0]

	$tData = DllStructCreate('wchar[' & $Lenght & ']', $pStruct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	While 1
		If Not AscW(DllStructGetData($tData, 1, $Index)) Then
			$Count += 1
			If $Count > 1 Then
				ExitLoop
			EndIf
			$Result[0] += 1
			If ($iItems) And ($Result[0] > $iItems) Then
				ExitLoop
			EndIf
			If $Result[0] > UBound($Result) - 1 Then
				ReDim $Result[$Result[0] + 100]
			EndIf
			$Result[$Result[0]] = 0
		Else
			$Result[$Result[0]] += 1
			$Count = 0
		EndIf
		$Index += 1
		If $Index > $Lenght Then
			Return SetError(2, 0, 0)
		EndIf
	WEnd
	ReDim $Result[$Result[0]]
	$Result[0] -= 1
	For $i = 1 To $Result[0]
		$Struct &= 'wchar[' & ($Result[$i] + 1) & '];'
	Next
	$tData = DllStructCreate($Struct, $pStruct)
	If @error Then
		Return SetError(3, 0, 0)
	EndIf
	For $i = 1 To $Result[0]
		$Result[$i] = DllStructGetData($tData, $i)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_StructToArray

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SubtractRect
; Description....: Determines the coordinates of a rectangle formed by subtracting one rectangle from another.
; Syntax.........: _WinAPI_SubtractRect ( $tRECT1, $tRECT2 )
; Parameters.....: $tRECT1 - $tagRECT structure from which the function subtracts the rectangle specified by $tRECT2.
;                  $tRECT2 - $tagRECT structure that the function subtracts from the rectangle specified by $tRECT1.
; Return values..: Success - $tagRECT structure that contains the rectangle determined by subtracting the rectangle specified by
;                            $tRECT2 from the rectangle specified by $tRECT1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function only subtracts the rectangle specified by $tRECT2 from the rectangle specified by $tRECT1 when the
;                  rectangles intersect completely in either the x- or y-direction. For example, if $tRECT1 has the coordinates
;                  (10, 10, 100, 100) and $tRECT2 has the coordinates (50, 50, 150, 150), the function returns the rectangle with
;                  the coordinates (10, 10, 100, 100). If $tRECT1 has the coordinates (10, 10, 100, 100) and $tRECT2 has the
;                  coordinates (50, 10, 150, 150), however, the function returns the rectangle with the coordinates (10, 10, 50, 100).
;                  In other words, the resulting rectangle is the bounding box of the geometric difference.
; Related........:
; Link...........: @@MsdnLink@@ SubtractRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SubtractRect($tRECT1, $tRECT2)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'SubtractRect', 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tRECT1), 'ptr', DllStructGetPtr($tRECT2))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_SubtractRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SuspendProcess
; Description....: suspend a process
; Syntax.........: _WinAPI_SuspendProcess ( $hProcess )
; Parameters.....: $process - process name.
; Return values..: Success - 1
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SuspendProcess
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SuspendProcess($hProcess)
	Local $Handle = DllCall("kernel32.dll", 'int', 'OpenProcess', 'int', 0x1f0fff, 'int', False, 'int', $hProcess)
	Local $Ret = DllCall("ntdll.dll", "int", "NtSuspendProcess", "int", $Handle[0])
	DllCall('kernel32.dll', 'ptr', 'CloseHandle', 'ptr', $Handle)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
EndFunc   ;==>_WinAPI_SuspendProcess

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SwapDWord
; Description....: Swaps high-order and low-order bits of the 32-bit value.
; Syntax.........: _WinAPI_SwapDWord ( $iValue )
; Parameters.....: $iValue - 32-bit value.
; Return values..: Swapped value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SwapDWord($iValue)
	Return _WinAPI_MakeLong(_WinAPI_HiWord($iValue), _WinAPI_LoWord($iValue))
EndFunc   ;==>_WinAPI_SwapDWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SwapQWord
; Description....: Converts a ULONGLONG from little-endian to big-endian, and vice versa.
; Syntax.........: _WinAPI_SwapQWord ( $iValue )
; Parameters.....: $iValue - The ULONGLONG value to convert.
; Return values..: Success - The converted value.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SwapQWord($iValue)

	Local $tStruct1 = DllStructCreate('int64;int64')
	Local $tStruct2 = DllStructCreate('byte[8];byte[8]', DllStructGetPtr($tStruct1))

	DllStructSetData($tStruct1, 1, $iValue)
	For $i = 1 To 8
		DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 9 - $i), $i)
	Next
	Return DllStructGetData($tStruct1, 2)
EndFunc   ;==>_WinAPI_SwapQWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SwapWord
; Description....: Converts a USHORT from little-endian to big-endian, and vice versa.
; Syntax.........: _WinAPI_SwapWord ( $iValue )
; Parameters.....: $iValue - The USHORT value to convert.
; Return values..: Success - The converted value.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlUshortByteSwap
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SwapWord($iValue)

	Local $tStruct1 = DllStructCreate('ushort;ushort')
	Local $tStruct2 = DllStructCreate('byte[2];byte[2]', DllStructGetPtr($tStruct1))

	DllStructSetData($tStruct1, 1, $iValue)
	For $i = 1 To 2
		DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 3 - $i), $i)
	Next
	Return DllStructGetData($tStruct1, 2)
EndFunc   ;==>_WinAPI_SwapWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SwitchColor
; Description....: Converts a color from BGR to RGB and vice versa.
; Syntax.........: _WinAPI_SwitchColor ( $iColor )
; Parameters.....: $iColor - The color to conversion.
; Return values..: Converted color (RGB or BGR - depends on the $iColor value, BGR > RGB > BGR etc).
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SwitchColor($iColor)
	Return BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndFunc   ;==>_WinAPI_SwitchColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SwitchDesktop
; Description....: Makes the specified desktop visible and activates it.
; Syntax.........: _WinAPI_SwitchDesktop ( $hDesktop )
; Parameters.....: $hDesktop - Handle to the desktop. This desktop must be associated with the current window station for the process.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_SwitchDesktop() function fails if the desktop belongs to an invisible window station. This function
;                  also fails when called from a process that is associated with a secured desktop such as the WinLogon and ScreenSaver
;                  desktops. Processes that are associated with a secured desktop include custom UserInit processes. Such calls
;                  typically fail with an "access denied" error.
; Related........:
; Link...........: @@MsdnLink@@ SwitchDesktop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SwitchDesktop($hDesktop)

	Local $Ret = DllCall('user32.dll', 'int', 'SwitchDesktop', 'ptr', $hDesktop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SwitchDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SwitchToThisWindow
; Description....: Switches the focus to a specified window and bring it to the foreground.
; Syntax.........: _WinAPI_SwitchToThisWindow ( $hWnd [, $fAltTab] )
; Parameters.....: $hWnd    - Handle to the window being switched to.
;                  $fAltTab - Specifies whether switches to using the Alt/Ctl+Tab key sequence, valid values:
;                  |TRUE    - The window is being switched to using the Alt/Ctl+Tab key sequence.
;                  |FALSE   - Otherwise. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SwitchToThisWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SwitchToThisWindow($hWnd, $fAltTab = 0)
	DllCall('user32.dll', 'none', 'SwitchToThisWindow', 'hwnd', $hWnd, 'int', $fAltTab)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SwitchToThisWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_TextOut
; Description....: Writes a string at the specified location, using the currently selected font, background color, and text color.
; Syntax.........: _WinAPI_TextOut ( $hDC, $iX, $iY, $sText )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical coordinates, of the reference point that the system uses to align the string.
;                  $iY     - The y-coordinate, in logical coordinates, of the reference point that the system uses to align the string.
;                  $sText  - The string to be drawn.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function using the currently selected font, background color, and text color.
; Related........:
; Link...........: @@MsdnLink@@ TextOut
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_TextOut($hDC, $iX, $iY, $sText)

	Local $Ret = DllCall('gdi32.dll', 'int', 'TextOutW', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'wstr', $sText, 'int', StringLen($sText))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_TextOut

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_TileWindows
; Description....: Tiles the specified child windows of the specified parent window.
; Syntax.........: _WinAPI_TileWindows ( $aWnds [, $tRECT [, $hParent [, $iFlags [, $iStart [, $iEnd]]]]] )
; Parameters.....: $aWnds   - The array of handles to the child windows to arrange. If a specified child window is a top-level window
;                             with the style $WS_EX_TOPMOST or $WS_EX_TOOLWINDOW, the child window is not arranged. If this parameter
;                             is 0, all child windows of the specified parent window (or of the desktop window) are arranged.
;                  $tRECT   - $tagRECT structure that specifies the rectangular area, in client coordinates, within which the windows
;                             are arranged. If this parameter is 0, the client area of the parent window is used.
;                  $hParent - Handle to the parent window. If this parameter is 0, the desktop window is assumed.
;                  $iFlags  - A cascade flag. This parameter can be one or more of the following values.
;
;                             $MDITILE_HORIZONTAL
;                             $MDITILE_VERTICAL
;
;                  $iStart  - The index of array to start arranging at.
;                  $iEnd    - The index of array to stop arranging at.
; Return values..: Success  - The value is the number of windows arranged.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ TileWindows
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_TileWindows($aWnds, $tRECT = 0, $hParent = 0, $iFlags = 0, $iStart = 0, $iEnd = -1)

	Local $Count, $tWnds

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aWnds) - 1) Then
		$iEnd = UBound($aWnds) - 1
	EndIf
	$Count = $iEnd - $iStart + 1
	If $Count < 1 Then
		Return SetError(1, 0, 0)
	EndIf
	$tWnds = DllStructCreate('hwnd[' & $Count & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = 1
	For $i = $iStart To $iEnd
		DLLStructSetData($tWnds, 1, $aWnds[$i], $Count)
		$Count += 1
	Next

	Local $Ret = DllCall('user32.dll', 'ushort', 'TileWindows', 'hwnd', $hParent, 'uint', $iFlags, 'ptr', DllStructGetPtr($tRECT), 'uint', $Count - 1, 'ptr', DllStructGetPtr($tWnds))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_TileWindows

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_TrackMouseEvent
; Description....: Posts messages when the mouse pointer leaves a window or hovers over a window for a specified amount of time.
; Syntax.........: _WinAPI_TrackMouseEvent ( $hWnd, $iFlags [, $iTime] )
; Parameters.....: $hWnd   - Handle to the window to track.
; Return values..: $iFlags - The services requested. This parameter can be a combination of the following values.
;
;                            $TME_CANCEL
;                            $TME_HOVER
;                            $TME_LEAVE
;                            $TME_NONCLIENT
;                            $TME_QUERY
;
;                  $iTime  - The hover time-out (if $TME_HOVER was specified in $Flags), in milliseconds. Can be (-1), which
;                            means to use the system default hover time-out.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Matt Diesel (Mat)
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ TrackMouseEvent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_TrackMouseEvent($hWnd, $iFlags, $iTime = -1)

	Local $tTME = DllStructCreate('dword;dword;hwnd;dword')

	DllStructSetData($tTME, 1, DllStructGetSize($tTME))
	DllStructSetData($tTME, 2, $iFlags)
	DllStructSetData($tTME, 3, $hWnd)
	DllStructSetData($tTME, 4, $iTime)

	Local $Ret = DllCall('user32.dll', 'int', 'TrackMouseEvent', 'ptr', DllStructGetPtr($tTME))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_TrackMouseEvent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnhookWinEvent
; Description....: Removes an event hook function.
; Syntax.........: _WinAPI_UnhookWinEvent ( $hEventHook )
; Parameters.....: $hEventHook - Handle to the event hook returned in the previous call to _WinAPI_SetWinEventHook().
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UnhookWinEvent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnhookWinEvent($hEventHook)

	Local $Ret = DllCall('user32.dll', 'int', 'UnhookWinEvent', 'ptr', $hEventHook)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnhookWinEvent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_TransparentBlt
; Description....: Performs a bit-block transfer of the color data corresponding to a rectangle of pixels.
; Syntax.........: _WinAPI_TransparentBlt ( $hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRGB )
; Parameters.....: $hDestDC     - Handle to the destination device context.
;                  $iXDest      - The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iYDest      - The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iWidthDest  - The width, in logical units, of the destination rectangle.
;                  $iHeightDest - The height, in logical units, of the destination rectangle.
;                  $hSrcDC      - Handle to the source device context.
;                  $iXSrc       - The x-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iYSrc       - The y-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iWidthSrc   - The width, in logical units, of the source rectangle.
;                  $iHeightSrc  - The height, in logical units, of the source rectangle.
;                  $iRGB        - The RGB color in the source bitmap to treat as transparent.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the source and destination rectangles are not the same size, the source bitmap is stretched to match the
;                  destination rectangle. When the _WinAPI_SetStretchBltMode() function is used, the stretching modes of
;                  $BLACKONWHITE and $WHITEONBLACK are converted to $COLORONCOLOR for the _WinAPI_TransparentBlt() function.
;
;                  This function supports all formats of source bitmaps. However, for 32 bpp bitmaps, it just copies the alpha
;                  value over. Use _WinAPI_AlphaBlend() to specify 32 bits-per-pixel bitmaps with transparency.
; Related........:
; Link...........: @@MsdnLink@@ GdiTransparentBlt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_TransparentBlt($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRGB)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GdiTransparentBlt', 'hwnd', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidthDest, 'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', __RGB($iRGB))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_TransparentBlt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnionRect
; Description....: Creates the union of two rectangles.
; Syntax.........: _WinAPI_UnionRect ( $tRECT1, $tRECT2 )
; Parameters.....: $tRECT1 - $tagRECT structure that contains the first source rectangle.
;                  $tRECT2 - $tagRECT structure that contains the second source rectangle.
; Return values..: Success - $tagRECT structure that contains the union of the $tRECT1 and $tRECT2 rectangles.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The union is the smallest rectangle that contains both source rectangles. The system ignores the
;                  dimensions of an empty rectangle that is, a rectangle in which all coordinates are set to zero, so that
;                  it has no height or no width.
; Related........:
; Link...........: @@MsdnLink@@ UnionRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnionRect($tRECT1, $tRECT2)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'UnionRect', 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tRECT1), 'ptr', DllStructGetPtr($tRECT2))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_UnionRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnionStruct
; Description....: Creates the structure of two structures.
; Syntax.........: _WinAPI_UnionStruct (ByRef $tStruct1, ByRef $tStruct2)
; Parameters.....: $tStruct1 - The structure that contains the first source data.
;                  $tStruct2 - The structure that contains the second source data.
; Return values..: Success   - "byte[n]" structure that contains the union data of the $tStruct1 and $tStruct2.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnionStruct(ByRef $tStruct1, ByRef $tStruct2)

	Local $Size1 = DllStructGetSize($tStruct1)
	Local $Size2 = DllStructGetSize($tStruct2)

	If (Not $Size1) Or (Not $Size2) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tData, $tResult, $Size, $Count = 1

	$tResult = DllStructCreate('byte[' & ($Size1 + $Size2) & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = 1 To 2
		$Size = Eval('Size' & $i)
		$tData = DllStructCreate('byte[' & $Size & ']', DllStructGetPtr(Eval('tStruct' & $i)))
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
		For $j = 1 To $Size
			DllStructSetData($tResult, 1, DllStructGetData($tData, 1, $j), $Count)
			If @error Then
				Return SetError(1, 0, 0)
			EndIf
			$Count += 1
		Next
	Next
	Return $tResult
EndFunc   ;==>_WinAPI_UnionStruct

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnloadKeyboardLayout
; Description....: Unloads an input locale identifier.
; Syntax.........: _WinAPI_UnloadKeyboardLayout ( $hLocale )
; Parameters.....: $hLocale - The input locale identifier to be unloaded.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_UnloadKeyboardLayout() cannot unload the system default input locale identifier if it is the only
;                  keyboard layout loaded. You must first load another input locale identifier before unloading the default input
;                  locale identifier.
; Related........:
; Link...........: @@MsdnLink@@ UnloadKeyboardLayout
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnloadKeyboardLayout($hLocale)

	Local $Ret = DllCall('user32.dll', 'int', 'UnloadKeyboardLayout', 'long', $hLocale)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnloadKeyboardLayout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnlockFile
; Description....: Unlocks a region in an open file.
; Syntax.........: _WinAPI_UnlockFile ( $hFile, $iOffset, $iLenght )
; Parameters.....: $hFile   - Handle to the file that contains a region locked with _WinAPI_LockFile() function.
;                  $iOffset - The starting byte offset in the file where the locked region begins.
;                  $iLenght - The length of the byte range to be unlocked.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Unlocking a region of a file releases a previously acquired lock on the file. The region to unlock must correspond
;                  exactly to an existing locked region. Two adjacent regions of a file cannot be locked separately and then unlocked
;                  using a single region that spans both locked regions.
; Related........:
; Link...........: @@MsdnLink@@ UnlockFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnlockFile($hFile, $iOffset, $iLenght)

	Local $Ret = DllCall('kernel32.dll', 'int', 'UnlockFile', 'ptr', $hFile, 'dword', _WinAPI_LoDWord($iOffset), 'dword', _WinAPI_HiDWord($iOffset), 'dword', _WinAPI_LoDWord($iLenght), 'dword', _WinAPI_HiDWord($iLenght))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnlockFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnmapViewOfFile
; Description....: Unmaps a mapped view of a file from the calling process's address space.
; Syntax.........: _WinAPI_UnmapViewOfFile ( $pAddress )
; Parameters.....: $pAddress - A pointer to the base address of the mapped view of a file that is to be unmapped. This value must be
;                              identical to the value returned by a previous call to the _WinAPI_MapViewOfFile() function.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Unmapping a mapped view of a file invalidates the range occupied by the view in the address space of the process
;                  and makes the range available for other allocations. It removes the working set entry for each unmapped virtual page
;                  that was part of the working set of the process and reduces the working set size of the process. It also
;                  decrements the share count of the corresponding physical page.
;
;                  Although an application may close the file handle used to create a file mapping object, the system holds the
;                  corresponding file open until the last view of the file is unmapped. Files for which the last view has not
;                  yet been unmapped are held open with no sharing restrictions.
;
;                  To minimize the risk of data loss in the event of a power failure or a system crash, you should explicitly flush
;                  modified pages using the _WinAPI_FlushViewOfFile() function.
; Related........:
; Link...........: @@MsdnLink@@ UnmapViewOfFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnmapViewOfFile($pAddress)

	Local $Ret = DllCall('kernel32.dll', 'int', 'UnmapViewOfFile', 'ptr', $pAddress)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnmapViewOfFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnregisterApplicationRestart
; Description....: Removes the active instance of an application from the restart list.
; Syntax.........: _WinAPI_UnregisterApplicationRestart ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: You do not need to call this function before exiting. You need to remove the registration only if you choose to
;                  not restart the application. For example, you could remove the registration if your application entered a corrupted
;                  state where a future restart would also fail. You must call _WinAPI_UnregisterApplicationRestart() before the
;                  application fails abnormally.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ UnregisterApplicationRestart
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnregisterApplicationRestart()

	Local $Ret = DllCall('kernel32.dll', 'uint', 'UnregisterApplicationRestart')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnregisterApplicationRestart

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnregisterClass
; Description....: Unregisters a window class, freeing the memory required for the class.
; Syntax.........: _WinAPI_UnregisterClass ( $sClass [, $hInstance] )
; Parameters.....: $sClass    - A null-terminated string or a class atom. If $sClass is a string, it specifies the window class
;                               name. This class name must have been registered by a previous call to the _WinAPI_RegisterClass()
;                               or _WinAPI_RegisterClassEx() function. If this parameter is an atom, it must be in the low-order
;                               word of $sClass; the high-order word must be zero.
;                  $hInstance - Handle to the instance of the module that created the class.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Before calling this function, an application must destroy all windows created with the specified class.
;                  All window classes that an application registers are unregistered when it terminates.
; Related........:
; Link...........: @@MsdnLink@@ UnregisterClass
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnregisterClass($sClass, $hInstance = 0)

	Local $TypeOfClass = 'ptr'

	If IsString($sClass) Then
		$TypeOfClass = 'wstr'
	EndIf

	Local $Ret = DllCall('user32.dll', 'int', 'UnregisterClassW', $TypeOfClass, $sClass, 'ptr', $hInstance)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnregisterClass

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnregisterHotKey
; Description....: Frees a hot key previously registered by the calling thread.
; Syntax.........: _WinAPI_UnregisterHotKey ( $hWnd, $ID )
; Parameters.....: $hWnd   - Handle to the window associated with the hot key to be freed. This parameter should be 0 if the
;                            hot key is not associated with a window.
;                  $ID     - Specifies the identifier of the hot key to be freed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UnregisterHotKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnregisterHotKey($hWnd, $ID)

	Local $Ret = DllCall('user32.dll', 'int', 'UnregisterHotKey', 'hwnd', $hWnd, 'int', $ID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnregisterHotKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnregisterPowerSettingNotification
; Description....: Unregisters the power setting notification.
; Syntax.........: _WinAPI_UnregisterPowerSettingNotification ( $hNotify )
; Parameters.....: $hNotify - Handle returned from the _WinAPI_RegisterPowerSettingNotification() function.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ UnregisterPowerSettingNotification
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnregisterPowerSettingNotification($hNotify)

	Local $Ret  = DllCall('user32.dll', 'int', 'UnregisterPowerSettingNotification', 'ptr', $hNotify)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnregisterPowerSettingNotification

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UpdateLayeredWindowEx
; Description....: Updates a bitmap translucency of a layered window.
; Syntax.........: _WinAPI_UpdateLayeredWindowEx ( $hWnd, $hBitmap [, $iOpacity [, $fDelete]] )
; Parameters.....: $hWnd     - Handle to a layered window. A layered window is created by specifying $WS_EX_LAYERED when its creating.
;                  $hBitmap  - Handle to the bitmap that will be set in the layered window.
;                  $iOpacity - The alpha transparency value to be used on the entire source bitmap.
;                  $fDelete  - Specifies whether delete the bitmap after updated the window, valid values:
;                  |TRUE     - Bitmap will be deleted if the function succeeds.
;                  |FALSE    - Don't delete, you must release the bitmap when you are finished using it. (Default)
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: For best drawing performance by the layered window and any underlying windows, the layered window should be
;                  as small as possible.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UpdateLayeredWindowEx($hWnd, $hBitmap, $iOpacity = 255, $fDelete = 0)

	Local $Ret, $tSIZE, $tPOINT, $tBLENDFUNCTION, $hDC, $hDestDC, $hDestSv

	$Ret = DllCall('user32.dll', 'hwnd', 'GetDC', 'hwnd', $hWnd)
	$hDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleDC', 'hwnd', $hDC)
	$hDestDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'SelectObject', 'hwnd', $hDestDC, 'ptr', $hBitmap)
	$hDestSv = $Ret[0]
	$tSIZE = _WinAPI_GetBitmapDimension($hBitmap)
	$tPOINT = DllStructCreate($tagPOINT)
	$tBLENDFUNCTION = DllStructCreate($tagBLENDFUNCTION)
	DllStructSetData($tBLENDFUNCTION, 'Alpha', $iOpacity)
	DllStructSetData($tBLENDFUNCTION, 'Format', 1)
	$Ret = DllCall('user32.dll', 'int', 'UpdateLayeredWindow', 'hwnd', $hWnd, 'hwnd', $hDC, 'ptr', 0, 'ptr', DllStructGetPtr($tSIZE), 'hwnd', $hDestDC, 'ptr', DllStructGetPtr($tPOINT), 'dword', 0, 'ptr', DllStructGetPtr($tBLENDFUNCTION), 'dword', 0x02)
	DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', $hWnd, 'hwnd', $hDC)
	DllCall('gdi32.dll', 'ptr', 'SelectObject', 'hwnd', $hDestDC, 'ptr', $hDestSv)
	DllCall('gdi32.dll', 'int', 'DeleteDC', 'hwnd', $hDestDC)
	If Not $Ret[0] Then
		Return SetError(1, 0, 0)
	EndIf
	If $fDelete Then
		_WinAPI_DeleteObject($hBitmap)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UpdateLayeredWindowEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UpdateResource
; Description....: Adds, deletes, or replaces a resource in a portable executable (PE) file.
; Syntax.........: _WinAPI_UpdateResource ( $hUpdate, $sType, $sName, $iLanguage, $pData, $iSize )
; Parameters.....: $hUpdate   - A module handle returned by the _WinAPI_BeginUpdateResource(), referencing the file to be updated.
;                  $sType     - The resource type to be updated. Alternatively, rather than a pointer, this parameter can be an
;                               integer value representing a predefined resource type. If the first character of the string is a
;                               pound sign (#), then the remaining characters represent a decimal number that specifies the integer
;                               identifier of the resource type. For example, the string "#258" represents the identifier 258.
;                               Also, you can use a predefined resource types ($RT_*).
;                  $sName     - The name of the resource to be updated. This parameter can be string or integer type (see above).
;                  $iLanguage - The language of the resource (LCID).
;                  $pData     - The resource data to be inserted into the file indicated by $hUpdate parameter. If the resource is
;                               one of the predefined types, the data must be valid and properly aligned. Note that this is the raw
;                               binary data, not the data provided by _WinAPI_LoadIcon(), _WinAPI_LoadString(), or other resource-
;                               specific load functions. All data containing strings or text must be in Unicode format. If $pData
;                               is 0 and $iSize is 0, the specified resource is deleted from the file indicated by $hUpdate.
;                  $iSize     - The size, in bytes, of the resource data at $pData.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: It is recommended that the resource file is not loaded before this function is called. However, if that file
;                  is already loaded, it will not cause an error to be returned.
;
;                  An application can use _WinAPI_UpdateResource() repeatedly to make changes to the resource data. Each call
;                  to _WinAPI_UpdateResource() contributes to an internal list of additions, deletions, and replacements but does
;                  not actually write the data to the file. The application must use the _WinAPI_EndUpdateResource() function to
;                  write the accumulated changes.
;
;                  If $pData is 0 and $iSize is 0, the specified resource is deleted from the file indicated by $hUpdate.
; Related........:
; Link...........: @@MsdnLink@@ UpdateResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UpdateResource($hUpdate, $sType, $sName, $iLanguage, $pData, $iSize)

	Local $TypeOfType = 'int', $TypeOfName = 'int'

	If IsString($sType) Then
		$TypeOfType = 'wstr'
	EndIf
	If IsString($sName) Then
		$TypeOfName = 'wstr'
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'UpdateResourceW', 'ptr', $hUpdate, $TypeOfType, $sType, $TypeOfName, $sName, 'ushort', $iLanguage, 'ptr', $pData, 'dword', $iSize)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UpdateResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlCreateFromPath
; Description....: Converts a Microsoft MS-DOS path to a canonicalized URL.
; Syntax.........: _WinAPI_UrlCreateFromPath ( $sPath )
; Parameters.....: $sPath  - The MS-DOS path.
; Return values..: Success - The URL.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UrlCreateFromPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlCreateFromPath($sPath)

	Local $tData = DllStructCreate('wchar[2048]')
	Local $Ret = DllCall('shlwapi.dll', 'uint', 'UrlCreateFromPathW', 'wstr', $sPath, 'ptr', DllStructGetPtr($tData), 'dword*', 2048, 'dword', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		Switch $Ret[0]
			Case 0, 1 ; S_OK, S_FALSE

			Case Else
				Return SetError(1, $Ret[0], '')
		EndSwitch
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_UrlCreateFromPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlEscape
; Description....: Converts characters in a URL that might be altered during transport across the Internet into their corresponding escape sequences.
; Syntax.........: _WinAPI_UrlEscape ( $sUrl [, $iFlags] )
; Parameters.....: $sUrl   - The URL.
;                  $iFlags - The flags that indicate which characters in the URL should be converted to their escape sequences
;                            (an escape sequence has the form "%xy"). It can be a combination of the following values.
;
;                            $URL_DONT_ESCAPE_EXTRA_INFO
;                            $URL_ESCAPE_SPACES_ONLY
;                            $URL_ESCAPE_PERCENT
;                            $URL_ESCAPE_SEGMENT_ONLY

;                            *Windows 7 or later
;
;                            $URL_ESCAPE_AS_UTF8
;
; Return values..: Success - The escaped URL.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UrlEscape
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlEscape($sUrl, $iFlags = 0)

	Local $tData = DllStructCreate('wchar[2048]')
	Local $Ret = DllCall('shlwapi.dll', 'uint', 'UrlEscapeW', 'wstr', $sUrl, 'ptr', DllStructGetPtr($tData), 'dword*', 2048, 'dword', $iFlags)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_UrlEscape

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlFixup
; Description....: Attempts to correct a URL whose protocol identifier is incorrect.
; Syntax.........: _WinAPI_UrlFixup ( $sUrl )
; Parameters.....: $sUrl   - The URL to be corrected.
; Return values..: Success - The corrected URL, or the original URL if no correction was needed.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UrlFixupW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlFixup($sUrl)

	Local $tData = DllStructCreate('wchar[2048]')
	Local $Ret = DllCall('shlwapi.dll', 'uint', 'UrlFixupW', 'wstr', $sUrl, 'ptr', DllStructGetPtr($tData), 'dword', 2048)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_UrlFixup

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlGetPart
; Description....: Retrieves a specified part from the URL.
; Syntax.........: _WinAPI_UrlGetPart ( $sUrl, $iPart )
; Parameters.....: $sUrl   - The URL.
;                  $iPart  - The part of the URL to retrieve. It can be one of the following values.
;
;                            $URL_PART_HOSTNAME
;                            $URL_PART_PASSWORD
;                            $URL_PART_PORT
;                            $URL_PART_QUERY
;                            $URL_PART_SCHEME
;                            $URL_PART_USERNAME
;
; Return values..: Success - The part of the URL.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UrlGetPart
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlGetPart($sUrl, $iPart)

	Local $tData = DllStructCreate('wchar[1024]')
	Local $Ret = DllCall('shlwapi.dll', 'uint', 'UrlGetPartW', 'wstr', $sUrl, 'ptr', DllStructGetPtr($tData), 'dword*', 1024, 'dword', $iPart, 'dword', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_UrlGetPart

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlIs
; Description....: Tests whether or not a URL is a specified type.
; Syntax.........: _WinAPI_UrlIs ( $sUrl [, $iType] )
; Parameters.....: $sUrl   - The URL.
;                  $iType  - The type of URL to be tested for. It can be one of the following values.
;
;                            $URLIS_APPLIABLE
;                            $URLIS_DIRECTORY
;                            $URLIS_FILEURL
;                            $URLIS_HASQUERY
;                            $URLIS_NOHISTORY
;                            $URLIS_OPAQUE
;                            $URLIS_URL
;
; Return values..: Success - 1 - The URL is the specified type.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UrlIs
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlIs($sUrl, $iType = 0)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'UrlIsW', 'wstr', $sUrl, 'uint', $iType)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_UrlIs

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlUnescape
; Description....: Converts escape sequences back into ordinary characters.
; Syntax.........: _WinAPI_UrlUnescape ( $sUrl [, $iFlags] )
; Parameters.....: $sUrl   - The URL.
;                  $iFlags - The flags that control which characters in the URL should be unescaped (an escape sequence has the form "%xy").
;                            It can be a combination of the following values.
;
;                            $URL_DONT_UNESCAPE_EXTRA_INFO
;
; Return values..: Success - The unescaped URL.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UrlUnescape
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlUnescape($sUrl, $iFlags = 0)

	Local $tData = DllStructCreate('wchar[2048]')
	Local $Ret = DllCall('shlwapi.dll', 'uint', 'UrlUnescapeW', 'wstr', $sUrl, 'ptr', DllStructGetPtr($tData), 'dword*', 2048, 'dword', $iFlags)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_UrlUnescape

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ValidateRect
; Description....: Removes a rectangle from the current update region of the specified window.
; Syntax.........: _WinAPI_ValidateRect ( $hWnd [, $tRECT] )
; Parameters.....: $hWnd   - Handle to the window whose update region is to be modified. If this parameter is 0, the system
;                            invalidates and redraws all windows and sends the WM_ERASEBKGND and WM_NCPAINT messages to the window
;                            procedure before the function returns.
;                  $tRECT  - $tagRECT structure that contains the client coordinates of the rectangle to be removed from the
;                            update region. If this parameter is 0, the entire client area is removed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ValidateRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ValidateRect($hWnd, $tRECT = 0)

	Local $Ret = DllCall('user32.dll', 'int', 'ValidateRect', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ValidateRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ValidateRgn
; Description....: Removes a region from the current update region of the specified window.
; Syntax.........: _WinAPI_ValidateRect ( $hWnd [, $hRgn] )
; Parameters.....: $hWnd   - Handle to the window whose update region is to be modified.
;                  $hRgn   - Handle to a region that defines the area to be removed from the update region. If this parameter is 0,
;                            the entire client area is removed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ValidateRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ValidateRgn($hWnd, $hRgn = 0)

	Local $Ret = DllCall('user32.dll', 'int', 'ValidateRgn', 'hwnd', $hWnd, 'ptr', $hRgn)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ValidateRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_VerQueryRoot
; Description....: Retrieves fixed (code page independent) version information from the specified file.
; Syntax.........: _WinAPI_VerQueryRoot ( $sFile )
; Parameters.....: $sFile  - The name of the file.
; Return values..: Success - $tagVS_FIXEDFILEINFO structure that contains the version information.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ VerQueryValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_VerQueryRoot($sFile)

	Local $tInfo = _WinAPI_GetFileVersionInfo($sFile)

	If Not IsDllStruct($tInfo) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('version.dll', 'int', 'VerQueryValueW', 'ptr', DllStructGetPtr($tInfo), 'wstr', '\', 'ptr*', 0, 'uint*', 0)

	If (@error) Or (Not $Ret[0]) Or (Not $Ret[4]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tData = DllStructCreate('byte[' & $Ret[4] & ']', $Ret[3])

	If Not IsDllStruct($tData) Then
		Return SetError(1, 0, 0)
	EndIf
	Return _WinAPI_CopyStruct($tData, $tagVS_FIXEDFILEINFO)
EndFunc   ;==>_WinAPI_VerQueryRoot

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_VerQueryValue
; Description....: Retrieves specified version information from the specified file.
; Syntax.........: _WinAPI_VerQueryValue ( $sFile [, $sValues] )
; Parameters.....: $sFile   - The name of the file.
;                  $sValues - The string containing the field names for which you want to get values. The names must be separated
;                             by a "|". For example, "name1|name2|...|namei". If some fields do not exist, the corresponding array
;                             elements is an empty string. If this parameter is not specified (empty string), uses the reserved
;                             names (12) in the following sequence.
;
;                             "Comments"
;                             "CompanyName"
;                             "FileDescription"
;                             "FileVersion'
;                             "InternalName"
;                             "LegalCopyright"
;                             "LegalTrademarks"
;                             "OriginalFilename"
;                             "ProductName"
;                             "ProductVersion"
;                             "PrivateBuild"
;                             "SpecialBuild"
;
; Return values..: Success  - The 2D array of the string values that specified by $sValues parameter for each language. The zeroth
;                             array element [0][0] contains the number of languages of the resource. The array dimension (i) equal
;                             to the number specified parameters + 1. The zeroth array element [n][0] contains the language
;                             identifier (LCID).
;
;                             [0][0] - Number of languages (n)
;                             [0][i] - Unused
;                             [1][0] - LCID
;                             [1][i] - Value
;                             [n][0] - LCID
;                             [n][i] - Value
;
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ VerQueryValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_VerQueryValue($sFile, $sValues = '')

	Local $tInfo = _WinAPI_GetFileVersionInfo($sFile)

	If Not IsDllStruct($tInfo) Then
		Return SetError(1, 0, 0)
	EndIf

	$sValues = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
	If Not $sValues Then
		$sValues = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
	EndIf

	Local $Ret, $Lenght, $LP, $tLang, $aValues = StringSplit($sValues, '|', 2), $pInfo = DllStructGetPtr($tInfo)
	Local $Result[1][UBound($aValues) + 1] = [[0]]

	$Ret = DllCall('version.dll', 'int', 'VerQueryValueW', 'ptr', $pInfo, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0, 'uint*', 0)
	If (@error) Or (Not $Ret[0]) Or (Not $Ret[4]) Then
		Return SetError(1, 0, 0)
	EndIf
	$Lenght = Floor($Ret[4] / 4)
	$tLang = DllStructCreate('dword[' & $Lenght & ']', $Ret[3])
	If Not IsDllStruct($tLang) Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = 1 To $Lenght
		$Result[0][0] += 1
		ReDim $Result[$Result[0][0] + 1][UBound($aValues) + 1]
		$Result[$Result[0][0]][0] = _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))
		$LP = Hex(_WinAPI_SwapDWord(DllStructGetData($tLang, 1, $i)), 8)
		For $j = 0 To UBound($aValues) - 1
			$Ret = DllCall('version.dll', 'int', 'VerQueryValueW', 'ptr', $pInfo, 'wstr', '\StringFileInfo\' & $LP & '\' & $aValues[$j], 'ptr*', 0, 'uint*', 0)
			If (Not @error) And ($Ret[0]) And ($Ret[4]) Then
				$Result[$Result[0][0]][$j + 1] = DllStructGetData(DllStructCreate('wchar[' & $Ret[4] & ']', $Ret[3]), 1)
			Else
				$Result[$Result[0][0]][$j + 1] = ''
			EndIf
		Next
	Next
	Return $Result
EndFunc   ;==>_WinAPI_VerQueryValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_WidenPath
; Description....: Redefines the current path as the area that would be painted if the path were stroked.
; Syntax.........: _WinAPI_WidenPath ( $hDC )
; Parameters.....: $hDC    - handle to a device context that contains a closed path.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The device context identified by the $hDC parameter must contain a closed path.
;
;                  The _WinAPI_WidenPath() function is successful only if the current pen has a width, in device units, of more than one.
;
;                  Any Bezier curves in the path are converted to sequences of straight lines approximating the widened curves.
;                  As such, no Bezier curves remain in the path after _WinAPI_WidenPath() is called.
; Related........:
; Link...........: @@MsdnLink@@ WidenPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_WidenPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'WidenPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_WidenPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_WindowFromDC
; Description....: Retrieves a handle to the window associated with the specified display device context (DC).
; Syntax.........: _WinAPI_WindowFromDC ( $hDC )
; Parameters.....: $hDC    - Handle to the device context from which a handle to the associated window is to be retrieved.
; Return values..: Success - Handle to the window associated with the specified DC. If no window is associated with the specified
;                            DC, the return value is 0.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ WindowFromDC
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_WindowFromDC($hDC)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'WindowFromDC', 'hwnd', $hDC)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_WindowFromDC

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_WinHelp
; Description....: Launches Microsoft Windows Help and passes additional data that indicates the nature of the help.
; Syntax.........: _WinAPI_WinHelp ( $hWnd, $iCommand [, $sPath [, $iData]] )
; Parameters.....: $hWnd     - Handle to the window requesting help. This function uses this handle to keep track of which
;                              applications have requested help. If the $iCommand parameter specifies $HELP_CONTEXTMENU or
;                              $HELP_WM_HELP, $hWnd identifies the control requesting help.
;                  $iCommand - The type of help requested. This parameter can be one of the following values.
;
;                              $HELP_COMMAND
;                              $HELP_CONTENTS
;                              $HELP_CONTEXT
;                              $HELP_CONTEXTMENU
;                              $HELP_CONTEXTPOPUP
;                              $HELP_FINDER
;                              $HELP_FORCEFILE
;                              $HELP_HELPONHELP
;                              $HELP_INDEX
;                              $HELP_KEY
;                              $HELP_MULTIKEY
;                              $HELP_PARTIALKEY
;                              $HELP_QUIT
;                              $HELP_SETCONTENTS
;                              $HELP_SETPOPUP_POS
;                              $HELP_SETWINPOS
;                              $HELP_TCARD (Can be combined with other values)
;                              $HELP_WM_HELP
;
;                  $sPath    - The path, if necessary, and the name of the Help file to display.
;                  $iData    - Additional data. The value used depends on the value of the $iCommand parameter.
;
;                              $HELP_COMMAND
;                              String that specifies the name of the Help macro(s) to run. If the string specifies multiple macro
;                              names, the names must be separated by semicolons. You must use the short form of the macro name
;                              for some macros because Windows Help does not support the long name.
;
;                              $HELP_CONTENTS
;                              Ignored; set to 0.
;
;                              $HELP_CONTEXT
;                              Contains the context identifier for the topic.
;
;                              $HELP_CONTEXTMENU
;                              Structure of a double word pairs ("dword[2], ..."). The first double word in each pair is the control
;                              identifier, and the second is the context identifier for the topic. The array must be terminated by
;                              a pair of zeros {0,0}. If you do not want to add Help to a particular control, set its context
;                              identifier to (-1).
;
;                              $HELP_CONTEXTPOPUP
;                              Contains the context identifier for a topic.
;
;                              $HELP_FINDER
;                              Ignored; set to 0.
;
;                              $HELP_FORCEFILE
;                              Ignored; set to 0.
;
;                              $HELP_HELPONHELP
;                              Ignored; set to 0.
;
;                              $HELP_INDEX
;                              Ignored; set to 0.
;
;                              $HELP_KEY
;                              Ther keyword string. Multiple keywords must be separated by semicolons.
;
;                              $HELP_MULTIKEY
;                              The MULTIKEYHELP structure that specifies a table footnote character and a keyword.
;
;                              $HELP_PARTIALKEY
;                              The keyword string. Multiple keywords must be separated by semicolons.
;
;                              $HELP_QUIT
;                              Ignored; set to 0.
;
;                              $HELP_SETCONTENTS
;                              Contains the context identifier for the Contents topic.
;
;                              $HELP_SETPOPUP_POS
;                              Contains the position data. The pop-up window is positioned as if the mouse cursor were at
;                              the specified point when the pop-up window was invoked.
;
;                              $HELP_SETWINPOS
;                              The HELPWININFO structure that specifies the size and position of either a primary or
;                              secondary Help window.
;
;                              $HELP_TCARD
;                              Depends on the command with which this command is combined.
;
;                              $HELP_WM_HELP
;                              Structure of a double word pairs ("dword[2], ..."). The first double word in each pair is the control
;                              identifier, and the second is the context identifier for the topic. The array must be terminated by
;                              a pair of zeros {0,0}. If you do not want to add Help to a particular control, set its context
;                              identifier to (-1).
;
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Before closing the window that requested help, the application must call WinHelp with the $iCommand parameter set to
;                  $HELP_QUIT. Until all applications have done this, Windows Help will not terminate. Note that calling Windows Help
;                  with the $HELP_QUIT command is not necessary if you used the $HELP_CONTEXTPOPUP command to start Windows Help.
; Related........:
; Link...........: @@MsdnLink@@ WinHelp
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_WinHelp($hWnd, $iCommand, $sPath = '', $iData = 0)

	Local $lData, $tData

	Select
		Case BitAND($iCommand, 0x0107)
			; $HELP_COMMAND, $HELP_KEY, $HELP_PARTIALKEY
			$tData = DllStructCreate('wchar[1024]')
			DllStructSetData($tData, 1, $iData)
			$lData = DllStructGetPtr($tData)
		Case BitAND($iCommand, 0x020F)
			; $HELP_CONTEXTMENU, $HELP_MULTIKEY, $HELP_SETWINPOS, $HELP_WM_HELP
			$lData = DllStructGetPtr($iData)
		Case BitAND($iCommand, 0x000F)
			; $HELP_CONTENTS, $HELP_FINDER, $HELP_FORCEFILE, $HELP_HELPONHELP, $HELP_INDEX, $HELP_QUIT
			$lData = 0
		Case Else
			$lData = $iData
	EndSelect

	Local $Ret = DllCall('user32.dll', 'int', 'WinHelpW', 'hwnd', $hWnd, 'wstr', $sPath, 'uint', $iCommand, 'lparam', $lData)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_WinHelp

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Wow64EnableWow64FsRedirection
; Description....: Enables or disables file system redirection for the calling thread.
; Syntax.........: _WinAPI_Wow64EnableWow64FsRedirection ( $fEnable )
; Parameters.....: $fEnable - Specifies whether enable or disable the WOW64 system folder redirection, valid values:
;                  |TRUE    - Enable.
;                  |FALSE   - Disable.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function is useful for 32-bit applications that want to gain access to the native system32 directory.
;                  By default, WOW64 file system redirection is enabled.
; Related........:
; Link...........: @@MsdnLink@@ Wow64EnableWow64FsRedirection
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Wow64EnableWow64FsRedirection($fEnable)

	Local $Ret = DllCall('kernel32.dll', 'int', 'Wow64EnableWow64FsRedirection', 'int', $fEnable)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_Wow64EnableWow64FsRedirection

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_WTSRegisterSessionNotification
; Description....: Registers the specified window to receive session change notifications.
; Syntax.........: _WinAPI_WTSRegisterSessionNotification ( $hWnd [, $iFlag] )
; Parameters.....: $hWnd   - Handle of the window to receive session change notifications.
;                  $iFlag  - The flag that specifies which session notifications are to be received. This parameter can be
;                            one of the following values.
;
;                            $NOTIFY_FOR_THIS_SESSION
;                            $NOTIFY_FOR_ALL_SESSIONS
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ WTSRegisterSessionNotification
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_WTSRegisterSessionNotification($hWnd, $iFlag = 0)

	If Not __DLL('wtsapi32.dll') Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('wtsapi32.dll', 'int', 'WTSRegisterSessionNotification', 'hwnd', $hWnd, 'dword', $iFlag)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_WTSRegisterSessionNotification

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_WTSUnRegisterSessionNotification
; Description....: Unregisters the specified window so that it receives no further session change notifications.
; Syntax.........: _WinAPI_WTSUnRegisterSessionNotification ( $hWnd )
; Parameters.....: $hWnd   - Handle of the window to be unregistered from receiving session notifications.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ WTSUnRegisterSessionNotification
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_WTSUnRegisterSessionNotification($hWnd)

	If Not __DLL('wtsapi32.dll') Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('wtsapi32.dll', 'int', 'WTSUnRegisterSessionNotification', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_WTSUnRegisterSessionNotification

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ZeroMemory
; Description....: Fills a block of memory with zeros.
; Syntax.........: _WinAPI_ZeroMemory ( $pDestination, $iLenght )
; Parameters.....: $pDestination - A pointer to the memory to be filled.
;                  $iLenght      - The number of bytes to be filled.
; Return values..: Success       - 1.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlZeroMemory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ZeroMemory($pDestination, $iLenght)
	DllCall('ntdll.dll', 'none', 'RtlZeroMemory', 'ptr', $pDestination, 'ulong_ptr', $iLenght)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ZeroMemory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ZwDelayExecution
; Description....: Enables or disables file system redirection for the calling thread.
; Syntax.........: _WinAPI_ZwDelayExecution ( $iMicroSeconds )
; Parameters.....: $iMicroSeconds - Specifies whether enable or disable the WOW64 system folder redirection, valid values:
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........:
; Related........:
; Link...........: @@MsdnLink@@ Wow64EnableWow64FsRedirection
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ZwDelayExecution($iMicroSeconds)

	Local $hStruct = DllStructCreate("int64 time;")
	;	If Not ($iMicroSecondsRaw) Then $iMicroSecondsRaw = 1
	DllStructSetData($hStruct, "time", -1 * ($iMicroSeconds * 10))
	;    DllStructSetData($hDll,"time",$iMicroSeconds)
	DllCall("ntdll.dll", "dword", "ZwDelayExecution", "int", 0, "ptr", DllStructGetPtr($hStruct))

EndFunc   ;==>_WinAPI_ZwDelayExecution

#EndRegion Public Functions

#Region Embedded DLL Functions

Func __AlphaProc()

	Static $pProc = Ptr(0)

	If Not $pProc Then
		If @AutoItX64 Then
			$pProc = __Init(Binary( _
					  '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' & _
						'48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883' & _
						'7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB' & _
						'034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B' & _
						'6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24' & _
						'287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080' & _
						'7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB' & _
						'034831C04883C438415F5DC3'))
		Else
			$pProc = __Init(Binary( _
					  '0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D' & _
						'1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407' & _
						'B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302' & _
						'83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00' & _
						'007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000'))
		EndIf
	EndIf
	Return $pProc
EndFunc   ;==>__AlphaProc

Func __ANDProc()

	Static $pProc = Ptr(0)

	If Not $pProc Then
		If @AutoItX64 Then
			$pProc = __Init(Binary( _
					  '0x48894C240848895424104C894424184C894C2420554157415648C7C009000000' & _
						'4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405' & _
						'4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405' & _
						'4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405' & _
						'4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405' & _
						'4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048' & _
						'21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000' & _
						'EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7' & _
						'44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100' & _
						'0048C74424380000000048C74424400000000048C744244800000000488BAC24' & _
						'A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B' & _
						'7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440' & _
						'4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24' & _
						'4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7' & _
						'442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C' & _
						'24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845' & _
						'0048FF4424604883442458F871B948C74424380000000048C744244000000000' & _
						'48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7' & _
						'D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C' & _
						'244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D' & _
						'184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24' & _
						'585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0' & _
						'010000004863C0EB034831C04883C470415E415F5DC3'))
		Else
			$pProc = __Init(Binary( _
					  '0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05' & _
						'B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24' & _
						'38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0' & _
						'EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000' & _
						'00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7' & _
						'042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000' & _
						'C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B' & _
						'3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480' & _
						'7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24' & _
						'0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000' & _
						'31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' & _
						'FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424' & _
						'0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3' & _
						'8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000' & _
						'31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' & _
						'FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8' & _
						'01000000EB0231C083C4205F5B5DC21000'))
		EndIf
	EndIf
	Return $pProc
EndFunc   ;==>__ANDProc

Func __TransparencyProc()

	Static $pProc = Ptr(0)

	If Not $pProc Then
		If @AutoItX64 Then
			$pProc = __Init(Binary( _
					  '0x48894C240848895424104C894424184C894C24205541574831C0505050505050' & _
						'4883EC284883BC24800000000074054831C0EB0748C7C0010000004821C07522' & _
						'488BAC248000000048837D180074054831C0EB0748C7C0010000004821C07502' & _
						'EB0948C7C001000000EB034831C04821C0740B4831C04863C0E93C0100004C63' & _
						'7C24784983FF647E0F48C7C0010000004863C0E9220100004C637C24784D21FF' & _
						'7D08C74424780000000048C74424280100000048C74424300000000048C74424' & _
						'3800000000488BAC24800000004C637D04488BAC2480000000486345084C0FAF' & _
						'F849C1E7024983C7FC4C3B7C24380F8C88000000488BAC24800000004C8B7D18' & _
						'4C037C24384983C7034C897C2440488B6C2440480FB64500505888442448807C' & _
						'244800744B4C0FB67C244848634424784C0FAFF84C89F848C7C1640000004899' & _
						'48F7F94989C74C89F850488B6C244858884500488B6C2440807D0000740948C7' & _
						'4424280000000048C7442430010000004883442438040F8149FFFFFF48837C24' & _
						'3000741148837C242800740948C7C001000000EB034831C04821C0740E48C7C0' & _
						'FFFFFFFF4863C0EB11EB0C48C7C0010000004863C0EB034831C04883C458415F' & _
						'5DC3'))
		Else
			$pProc = __Init(Binary( _
					  '0x555331C05050505050837C242800740431C0EB05B80100000021C075198B6C24' & _
						'28837D1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021' & _
						'C0740731C0E9E50000008B5C242483FB647E0AB801000000E9D20000008B5C24' & _
						'2421DB7D08C744242400000000C7042401000000C744240400000000C7442408' & _
						'000000008B6C24288B5D048B6C24280FAF5D08C1E30283C3FC3B5C24087C648B' & _
						'6C24288B5D14035C240883C303895C240C8B6C240C0FB6450088442410807C24' & _
						'100074380FB65C24100FAF5C242489D8B96400000099F7F989C3538B6C241058' & _
						'8845008B6C240C807D00007407C7042400000000C74424040100000083442408' & _
						'047181837C240400740D833C24007407B801000000EB0231C021C07409B8FFFF' & _
						'FFFFEB0BEB07B801000000EB0231C083C4145B5DC21000'))
		EndIf
	EndIf
	Return $pProc
EndFunc   ;==>__TransparencyProc

Func __XORProc()

	Static $pProc = Ptr(0)

	If Not $pProc Then
		If @AutoItX64 Then
			$pProc = __Init(Binary( _
					  '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' & _
						'48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074' & _
						'054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0' & _
						'4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C' & _
						'3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405' & _
						'4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C' & _
						'897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB' & _
						'034831C04883C438415F5DC3'))
		Else
			$pProc = __Init(Binary( _
					  '0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074' & _
						'0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB' & _
						'5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B' & _
						'6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303' & _
						'895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D' & _
						'C21000'))
		EndIf
	EndIf
	Return $pProc
EndFunc   ;==>__XORProc

#EndRegion Embedded DLL Functions

#Region Internal Functions

#Region Internal Functions
Func __AutoItFatalExit($iCode, $sText = '')
	If $sText Then
		_WinAPI_MsgBox(0x00040010, 'AutoIt', $sText)
	EndIf
	_WinAPI_FatalExit($iCode)
EndFunc   ;==>__AutoItFatalExit

Func __Binary($sPath)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetBinaryTypeW', 'wstr', $sPath, 'dword*', 0)

	If Not @error Then
		Return $Ret[2]
	Else
		Return 0
	EndIf
EndFunc   ;==>__Binary

Func __DlgSubclassProc($hWnd, $iMsg, $wParam, $lParam, $ID, $pData)

	#forceref $ID

	Switch $iMsg
		Case 0x004E ; WM_NOTIFY

			Local $tNMIA = DllStructCreate('hwnd;uint_ptr;' & __Iif(@AutoItX64, 'int;int', 'int') & ';int Item;int;uint;uint;uint;long;long;lparam;uint', $lParam)
			Local $hListView = DllStructGetData($tNMIA, 1)
			Local $nMsg = DllStructGetData($tNMIA, 3)
			Local $tParam = DllStructCreate('ptr;uint', $pData)
			Local $iDummy = DllStructGetData($tParam, 2)
			Local $hLV = DllStructGetData($tParam, 1)

			Switch $hListView
				Case $hLV
					Switch $nMsg
						Case -109 ; LVN_BEGINDRAG
							Return 0
						Case -114 ; LVN_ITEMACTIVATE
							If $iDummy Then
								GUICtrlSendToDummy($iDummy, DllStructGetData($tNMIA, 'Item'))
							EndIf
							Return 0
					EndSwitch
			EndSwitch
	EndSwitch
	Return _WinAPI_DefSubclassProc($hWnd, $iMsg, $wParam, $lParam)
EndFunc   ;==>__DlgSubclassProc

Func __DLL($sPath)
	If Not _WinAPI_GetModuleHandle($sPath) Then
		If Not _WinAPI_LoadLibrary($sPath) Then
			Return 0
		EndIf
	EndIf
	Return 1
EndFunc   ;==>__DLL

Func __EnumDefaultProc($pData, $lParam)

	#forceref $lParam

	Local $Lenght = _WinAPI_StrLen($pData)

	__Inc($__Data)
	If $Lenght Then
		$__Data[$__Data[0]] = DllStructGetData(DllStructCreate('wchar[' & ($Lenght + 1) & ']', $pData), 1)
	Else
		$__Data[$__Data[0]] = ''
	EndIf
	Return 1
EndFunc   ;==>__EnumDefaultProc

Func __EnumLocalesProc($pLocale)
	__Inc($__Data)
	$__Data[$__Data[0]] = Dec(DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pLocale) + 1) & ']', $pLocale), 1))
	Return 1
EndFunc   ;==>__EnumLocalesProc

Func __EnumPageFilesProc($iSize, $pInfo, $pFile)

	Local $tEPFI = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr', $pInfo)

	__Inc($__Data)
	$__Data[$__Data[0][0]][0] = DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pFile) + 1) & ']', $pFile), 1)
	For $i = 1 To 3
		$__Data[$__Data[0][0]][$i] = DllStructGetData($tEPFI, $i + 2) * $iSize
	Next
	Return 1
EndFunc   ;==>__EnumPageFilesProc

Func __EnumResLanguagesProc($hModule, $iType, $iName, $iLanguage, $lParam)

	#forceref $hModule, $iType, $iName, $lParam

	__Inc($__Data)
	$__Data[$__Data[0]] = $iLanguage
	Return 1
EndFunc   ;==>__EnumResLanguagesProc

Func __EnumResNamesProc($hModule, $iType, $iName, $lParam)

	#forceref $hModule, $iType, $lParam

	Local $Lenght = _WinAPI_StrLen($iName)

	__Inc($__Data)
	If $Lenght Then
		$__Data[$__Data[0]] = DllStructGetData(DllStructCreate('wchar[' & ($Lenght + 1) & ']', $iName), 1)
	Else
		$__Data[$__Data[0]] = Number($iName)
	EndIf
	Return 1
EndFunc   ;==>__EnumResNamesProc

Func __EnumResTypesProc($hModule, $iType, $lParam)

	#forceref $hModule, $lParam

	Local $Lenght = _WinAPI_StrLen($iType)

	__Inc($__Data)
	If $Lenght Then
		$__Data[$__Data[0]] = DllStructGetData(DllStructCreate('wchar[' & ($Lenght + 1) & ']', $iType), 1)
	Else
		$__Data[$__Data[0]] = Number($iType)
	EndIf
	Return 1
EndFunc   ;==>__EnumResTypesProc

Func __EnumSymbolsProc($pSymInfo, $iSymSize, $lParam)

;	Local $tSYMINFO = DllStructCreate('uint SizeOfStruct;uint TypeIndex;uint64 Reserved[2];uint Index;uint Size;uint64 ModBase;uint Flags;uint64 Value;uint64 Address;uint Register;uint Scope;uint Tag;uint NameLen;uint MaxNameLen;wchar Name[1]', $pSymInfo)
	Local $tSYMINFO = DllStructCreate('uint;uint;uint64[2];uint;uint;uint64;uint;uint64;uint64;uint;uint;uint;uint;uint;wchar[1]', $pSymInfo)
	Local $Lenght = DllStructGetData($tSYMINFO, 13)

	If ($Lenght) And (BitAND(DllStructGetData($tSYMINFO, 7), 0x00000600)) Then
		__Inc($__Data, 500)
		$__Data[$__Data[0][0]][0] = DllStructGetData($tSYMINFO, 9) - DllStructGetData($tSYMINFO, 6)
		$__Data[$__Data[0][0]][1] = DllStructGetData(DllStructCreate('wchar[' & ($Lenght + 1) & ']', DllStructGetPtr($tSYMINFO, 15)), 1)
	EndIf
	Return 1
EndFunc   ;==>__EnumSymbolsProc

Func __EnumWindowsProc($hWnd, $fVisible)
	If ($fVisible) And (Not _WinAPI_IsWindowVisible($hWnd)) Then
		Return 1
	EndIf
	__Inc($__Data)
	$__Data[$__Data[0][0]][0] = $hWnd
	$__Data[$__Data[0][0]][1] = _WinAPI_GetClassName($hWnd)
	Return 1
EndFunc   ;==>__EnumWindowsProc

Func __Hex($iValue, $sType)

	Local $Lenght

	Switch $sType
		Case 'BYTE', 'UBYTE', 'BOOLEAN'
			$Lenght = 2
		Case 'WORD', 'USHORT', 'short'
			$Lenght = 4
		Case 'BOOL', 'UINT', 'ULONG', 'DWORD', 'int', 'long'
			$Lenght = 8
		Case 'INT64', 'UINT64'
			$Lenght = 16
		Case 'INT_PTR', 'UINT_PTR', 'LONG_PTR', 'ULONG_PTR', 'DWORD_PTR', 'WPARAM', 'LPARAM', 'LRESULT'
			$Lenght = __Iif(@AutoItX64, 16, 8)
		Case Else
			$Lenght = 0
	EndSwitch
	If $Lenght Then
		Return '0x' & _WinAPI_Hex64($iValue, $Lenght)
	Else
		Return $iValue
	EndIf
EndFunc   ;==>__Hex

Func __Iif($fTest, $iTrue, $iFalse)
	If $fTest Then
		Return $iTrue
	Else
		Return $iFalse
	EndIf
EndFunc   ;==>__Iif

Func __Inc(ByRef $aData, $iIncrement = 100)
	If UBound($aData, 2) Then
		$aData[0][0] += 1
		If $aData[0][0] > UBound($aData) - 1 Then
			ReDim $aData[$aData[0][0] + $iIncrement][UBound($aData, 2)]
		EndIf
	Else
		$aData[0] += 1
		If $aData[0] > UBound($aData) - 1 Then
			ReDim $aData[$aData[0] + $iIncrement]
		EndIf
	EndIf
EndFunc   ;==>__Inc

Func __Init($bData)

	Local $tData, $Ret, $Lenght

	$Lenght = BinaryLen($bData)
	$Ret = DllCall('kernel32.dll', 'ptr', 'VirtualAlloc', 'ptr', 0, 'ulong_ptr', $Lenght, 'dword', 0x00001000, 'dword', 0x00000040)
	If (@error) Or (Not $Ret[0]) Then
		__AutoItFatalExit(1, 'Error allocating memory.')
	EndIf
	$tData = DllStructCreate('byte[' & $Lenght & "]", $Ret[0])
	DllStructSetData($tData, 1, $bData)
	Return $Ret[0]
EndFunc   ;==>__Init

Func __MD5($sData)

	Local $Ret, $hProv, $hHash, $tData, $Error = 1

	$hProv = DllCall('advapi32.dll', 'int', 'CryptAcquireContextW', 'ptr*', 0, 'ptr', 0, 'ptr', 0, 'dword', 3, 'dword', 0xF0000000)
	If (@error) Or (Not $hProv[0]) Then
		Return ''
	EndIf
	Do
		$hHash = DllCall('advapi32.dll', 'int', 'CryptCreateHash', 'ptr', $hProv[1], 'uint', 0x00008003, 'ptr', 0, 'dword', 0, 'ptr*', 0)
		If (@error) Or (Not $hProv[0]) Then
			$hHash = 0
			ExitLoop
		EndIf
		$hHash = $hHash[5]
		$tData = DllStructCreate('byte[' & BinaryLen($sData) & ']')
		DllStructSetData($tData, 1, $sData)
		$Ret = DllCall('advapi32.dll', 'int', 'CryptHashData', 'ptr', $hHash, 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData), 'dword', 1)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$tData = DllStructCreate('byte[16]')
		$Ret = DllCall('advapi32.dll', 'int', 'CryptGetHashParam', 'ptr', $hHash, 'dword', 2, 'ptr', DllStructGetPtr($tData), 'dword*', 16, 'dword', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	If $hHash Then
		DllCall('advapi32.dll', 'int', 'CryptDestroyHash', 'ptr', $hHash)
	EndIf
	If $Error Then
		Return ''
	EndIf
	Return StringTrimLeft(DllStructGetData($tData, 1), 2)
EndFunc   ;==>__MD5

Func __Quit()

	Local $pDll = DllCallbackGetPtr($__Dll)

	If $pDll Then
		_WinAPI_RemoveWindowSubclass($__Dlg, $pDll, 1000)
		DllCallbackFree($__Dll)
	EndIf
	$__Dll = 0
EndFunc   ;==>__Quit

Func __MakeCtrlCode($iDevType, $iFunction, $iMethod = 0, $iAccess = 0)
	Return BitOR(BitShift($iDevType, -16), BitShift($iAccess, -14), BitShift($iFunction, -2), $iMethod)
EndFunc   ;==>__MakeCtrlCode

Func __MemGlobalAlloc($iBytes, $iFlags = 0)
	Local $aResult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $iFlags, "ulong_ptr", $iBytes)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aResult[0]
EndFunc   ;==>__MemGlobalAlloc

Func __RGB($iColor)
	If $__RGB Then
		$iColor = _WinAPI_SwitchColor($iColor)
	EndIf
	Return $iColor
EndFunc   ;==>__RGB

Func __Def($iVer1, $iVal1, $iVer2, $iVal2, $iVer3 = Default, $iVal3 = Default, $iVer4 = Default, $iVal4 = Default)

	Local $Count = @NumParams / 2

	For $i = 1 To $Count
		If $__WINVER >= Eval('iVer' & $i) Then
			Return Eval('iVal' & $i)
		EndIf
	Next
	Return Eval('iVal' & $Count)
EndFunc   ;==>__Def

Func __Ver()

	Local $tOS, $Ret

	$tOS = DllStructCreate('dword[5];wchar[128]')
	DllStructSetData($tOS, 1, DllStructGetSize($tOS), 1)
	$Ret = DllCall('kernel32.dll', 'int', 'GetVersionExW', 'ptr', DllStructGetPtr($tOS))
	If (Not @error) And ($Ret[0]) Then
		Return BitOR(BitShift(DllStructGetData($tOS, 1, 2), -8), DllStructGetData($tOS, 1, 3))
	Else
		Return 0
	EndIf
EndFunc   ;==>__Ver

#EndRegion Internal Functions
